<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xgh-user.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="记录个人在平时学习的过程中的一些笔记、感受与遇到的坑,例如：java、计算机考研四件套等等。">
<meta property="og:type" content="website">
<meta property="og:title" content="_little-star_">
<meta property="og:url" content="http://xgh-user.github.io/page/2/index.html">
<meta property="og:site_name" content="_little-star_">
<meta property="og:description" content="记录个人在平时学习的过程中的一些笔记、感受与遇到的坑,例如：java、计算机考研四件套等等。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="_little-star_">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://xgh-user.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>_little-star_</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="_little-star_" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">_little-star_</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学习的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xgh-user.github.io/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_little-star_">
      <meta itemprop="description" content="记录个人在平时学习的过程中的一些笔记、感受与遇到的坑,例如：java、计算机考研四件套等等。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_little-star_">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">计算机网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-10 03:25:19" itemprop="dateCreated datePublished" datetime="2021-05-10T03:25:19+08:00">2021-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-18 10:59:14" itemprop="dateModified" datetime="2021-05-18T10:59:14+08:00">2021-05-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h2><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/31.png" alt="在这里插入图片描述"></p>
<hr>
<h3 id="1-1-1-、概念、组成、功能和分类"><a href="#1-1-1-、概念、组成、功能和分类" class="headerlink" title="1.1.1 、概念、组成、功能和分类"></a>1.1.1 、概念、组成、功能和分类</h3><ol>
<li><p>计算机网络概念：</p>
<p>是<strong>一个将分散的、具有独立功能的计算机系统，通过通信设备（交换机、路由器）与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统</strong>。</p>
<p>计算机网络是<strong>互连的、自治的计算机集合</strong>。</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/01.png" alt="image-20210402030633726"></p>
</li>
<li><p>计算机网络的功能</p>
<ol>
<li>数据通信（连通性）</li>
<li>资源共享（硬件、软件、数据，三大资源共享）</li>
<li>分布式处理（多台计算机各自承担同一工作任务的不同部分 如：Hadoop平台）</li>
<li>提高可靠性（替代机）</li>
<li>负载均衡</li>
</ol>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/02.png" alt="image-20210402031009538"></p>
</li>
<li><p>组成</p>
<ol>
<li><p>组成部分（硬件、软件、协议）</p>
<ol>
<li>硬件：主机（端系统），链路（双绞线、光纤），通信设备（路由器，交换机）</li>
<li>软件：QQ，微信等</li>
<li>协议</li>
</ol>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/03.png" alt="image-20210402031120533"></p>
</li>
<li><p>工作方式</p>
<ol>
<li>边缘部分：用户直接使用（C/S方式，P2P方式）</li>
<li>核心部分：为边缘部分服务（网络，路由器，交换机）</li>
</ol>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/04.png" alt="image-20210402031159369"></p>
</li>
<li><p>功能组成</p>
<ol>
<li><p>通信子网：实现数据通信(OSI上三层)</p>
</li>
<li><p>资源子网：实现资源共享/数据处理（OSI下三层）</p>
<blockquote>
<p>传输层：是资源子网和通信子网的接口</p>
</blockquote>
</li>
</ol>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/05.png" alt="image-20210402031240261"></p>
</li>
<li><p>计算机网络的分类</p>
<ol>
<li><p>按分布范围分</p>
<ul>
<li><p>广域网（WAN，交换技术）</p>
</li>
<li><p>城域网（MAN）</p>
</li>
<li><p>局域网（LAN，广播技术）</p>
</li>
<li><p>个人区域网（PAN）</p>
</li>
</ul>
</li>
<li><p>按使用者分</p>
<ul>
<li>公用网</li>
<li>专用网</li>
</ul>
</li>
<li><p>.按交换技术分</p>
<ul>
<li>电路交换</li>
<li>报文交换</li>
<li>分组交换</li>
</ul>
</li>
<li><p>按拓扑结构分</p>
<ul>
<li>总线型</li>
<li>星型</li>
<li>环形</li>
<li>网状型（常用于广域网）</li>
</ul>
</li>
<li><p>按照传输技术分</p>
<ul>
<li>广播式网络（共享公共通信信道）</li>
<li>点对点网络（使用分组存储转发和路由选择机制）</li>
</ul>
</li>
</ol>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/06.png" alt="image-20210402031749128"></p>
</li>
</ol>
</li>
</ol>
<p><strong>脑图：</strong></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/07.png" alt="在这里插入图片描述"></p>
<h3 id="1-1-2、-标准化工作及相关组织"><a href="#1-1-2、-标准化工作及相关组织" class="headerlink" title="1.1.2、 标准化工作及相关组织"></a>1.1.2、 标准化工作及相关组织</h3><ol>
<li><p>标准化工作</p>
<ol>
<li><p>标准的分类</p>
<ol>
<li><p>法定标准</p>
<p>由权威机构指定的正式的、合法的标准</p>
<p>OSI</p>
</li>
<li><p>事实标准</p>
<p>某些公司的产品在竞争中占据了主流，时间长了，这些产品中的协议和技术就成了标准</p>
<p>TCP/IP</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>RFC（Request For Comments）——因特网标准的形式</p>
</li>
</ol>
<p>RFC要上升为因特网正式标准的<strong>四个阶段</strong>：</p>
<ol>
<li><p>因特网草案（Internet Draft）</p>
<p> 这个阶段还不是RFC文档，只是一个构思</p>
</li>
<li><p>建议标准（Proposed Standard）</p>
<pre><code>- 从这个阶段开始成为RFC文档</code></pre>
</li>
<li><p>草案标准（Draft Standard）（现取消）</p>
<ul>
<li>IETF、IAB审核</li>
</ul>
</li>
<li><p>因特网标准（Internet Standard）</p>
</li>
<li><p>标准化工作的相关组织</p>
<ol>
<li><p>国际标准化组织ISO</p>
<p>OSI参考模型、HDLC协议</p>
</li>
<li><p>国际电信联盟ITU</p>
<p>制定通信规则</p>
</li>
<li><p>国际电气电子工程师协会IEEE</p>
<p>学术机构、IEEE802标准、5G</p>
</li>
<li><p>Internet工程任务组IETF</p>
<p>负责因特网相关标准的制定 RFC—XXXX</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/08.png" alt="image-20210405164611745"></p>
</li>
</ol>
</li>
</ol>
<p>脑图：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/09.png" alt="image-20210405164728541"></p>
<h3 id="1-1-3、-计算机网络的相关性能指标"><a href="#1-1-3、-计算机网络的相关性能指标" class="headerlink" title="1.1.3、 计算机网络的相关性能指标"></a>1.1.3、 计算机网络的相关性能指标</h3><ol>
<li><p>速率</p>
<p>即数据率或称数据传输率或比特率</p>
<p>连接在计算机网络上的主机在数字信道上传输数据位数的速率</p>
<p>补充：</p>
<p>​    速率的单位（千、兆、吉、太）</p>
<p>​    1Tb/s=10^3Gb/s=10^6Mb/s=10^9kb/s=10^12b/s</p>
<p>​    存储容量单位：</p>
<p>​    1Btye=8 bit 1TB/s=2^10 GB/s=2^20 MB/s=2^30 KB/s=2^40 B/s</p>
</li>
<li><p>带宽</p>
<p>原本指某个信号具有的频带宽度，即最高频率与最低频率之差，单位是赫兹（Hz）</p>
<p>在计算机网络中，带宽用来表示网络的通信线路传送数据的能力</p>
<p>通常是指单位时间内从网络的某一点到另一点所能通过的<strong>“最高数据率”</strong>。</p>
<p>单位与速率的单位相同。（比特每秒、b/s,kb/s,Mb/s,Gb/s）</p>
<p>可以理解为：<strong>网络设备所支持的最高速度</strong>，即：发送的速率</p>
</li>
<li><p>吞吐量</p>
<p>表示在单位时间内通过某个网络（信道、接口）的数据量。单位b/s，kb/s，Mb/s等</p>
<p>吞吐量受网络的<strong>带宽或网络的额定速率</strong>的限制</p>
<p><strong>所有的链路加一起</strong>才是本次网络的数据的真正吞吐量</p>
</li>
<li><p>时延</p>
<p>指数据（报文/分组/比特流）从网络（或链路）的一端传送到另一端所需时间。<br>也叫延迟或者迟延，单位是s</p>
<ol>
<li><p>发送时延/传输时延 = 数据长度/信道带宽（发送速率）</p>
<p>从发送分组的第一个比特算起，到该分组的最后一个比特发送完毕所需的时间。</p>
</li>
<li><p>传播时延 = 信道长度/电磁波在信道上的传播速率；<br>取决于电磁波传播速度和链路长度</p>
<p>此处注意：<strong>传输时延</strong>与<strong>传播时延</strong>的区别</p>
<ul>
<li>传输时延：发生在主机内部，一般是发生在网络适配器当中，发生在机器内部的发送器里面</li>
<li>传播时延：发生在机器外部，发送在信道上</li>
</ul>
</li>
<li><p>排队时延</p>
<p>等待输出/输入链路可用</p>
<p>在<strong>路由器的缓存空间</strong>那里</p>
</li>
<li><p>处理时延</p>
<ul>
<li>检错找出口</li>
</ul>
</li>
<li><p>时延抖动</p>
<p>时延的不均匀性</p>
</li>
</ol>
<p>注意：<strong>高速链路（提高发送速率/信号带宽）只是降低了发送时延，对传播时延和传播速率没有影响</strong></p>
</li>
<li><p>时延带宽积 = 传播时延 * 带宽</p>
<p>时延带宽积又称为比特位长度的链路长度</p>
<p>即：某段链路现在有多少比特，有“容量”的意思</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/10.png" alt="image-20210405173609630"></p>
</li>
<li><p>往返时延RTT</p>
<p>从<strong>发送发发送数据</strong>开始，到<strong>发送方收到接收方的确认</strong>（接收方收到数据后立即发送确认）总共经历的时延<strong>RTT越大，在收到确认之前，可以发送的数据越多</strong></p>
<p>RTT包括</p>
<ol>
<li>往返传播时延 = 传播时延 * 2</li>
<li>末端处理时间</li>
</ol>
<p><strong>注意：RTT不包括传输时延</strong></p>
</li>
<li><p>利用率</p>
<ul>
<li><p>信道利用率 = 有数据通过时间 / （有 + 无）数据通过的时间</p>
</li>
<li><p>网络利用率 = 信道利用率加权平均值</p>
</li>
<li><p><strong>利用率如果趋近于1，时延会急剧增大</strong></p>
<p>这些性能指标可以分为三类</p>
<ol>
<li>速率、带宽、吞吐率</li>
<li>时延、时延带宽积、往返时延RTT</li>
<li>利用率（利用率如果趋近于1，时延会急剧增大）</li>
</ol>
</li>
</ul>
</li>
</ol>
<p>脑图：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/11.png" alt="11"></p>
<h3 id="1-2-1、-分层结构、协议、接口、服务"><a href="#1-2-1、-分层结构、协议、接口、服务" class="headerlink" title="1.2.1、 分层结构、协议、接口、服务"></a>1.2.1、 分层结构、协议、接口、服务</h3><ol>
<li><p>为什么要分层？</p>
<p>发送文件前要完成的工作：</p>
<ol>
<li>发起通信的计算机必须将数据通信的通路进行激活。</li>
<li>要告诉网络如何识别目的主机。</li>
<li>发起通信的计算机要查明目的主机是否开机，并且与网络连接正常。</li>
<li>发起通信的计算机要弄清楚，对方计算机中文件管理程序是否已经做好准备工作。</li>
<li>确保差错和意外可以解决。</li>
<li>…….</li>
</ol>
<p>所以，在发送文件的过程中，会出现很多问题，需要把这些问题分成一个个小问题，然后解决</p>
</li>
<li><p>怎么分层</p>
<ul>
<li>实体、对等实体</li>
<li>对等实体之间才会有协议</li>
<li>上下层之间的接口</li>
<li>下层给上层提供服务</li>
</ul>
</li>
<li><p>分层的基本原则</p>
<ol>
<li>各层之间<strong>相互独立</strong>，每层只实现一种相对独立的功能</li>
<li>每层之间的<strong>界面自然清晰</strong>，易于理解，相互交流尽可能少</li>
<li>结构上可分隔开。每层都采用<strong>最合适的技术</strong>来实现</li>
<li>保持<strong>下层</strong>对<strong>上层</strong>的独立性，<strong>上层单向使用下层提供的服务</strong></li>
<li>整个分层结构应该促进标准化工作。</li>
</ol>
</li>
<li><p>正式认识分层结构</p>
<ol>
<li>实体：第n层中的活动元素称为<strong>n层实体</strong>。同一层的实体叫<strong>对等实体</strong>。</li>
<li>协议：为进行网络中的<strong>对等实体</strong>数据交换为建立的规则、标准或约定称为网络协议。【<strong>水平</strong>】<ul>
<li>语法：规定传输数据的格式</li>
<li>语义：规定所要完成的功能</li>
<li>同步：规定各种操作的顺序</li>
</ul>
</li>
<li>接口（访问服务点SAP）：上层使用下层服务的入口。</li>
<li>服务：下层为相邻上层提供的功能调用。【<strong>垂直</strong>】</li>
<li>SDU、PCI、PDU<ul>
<li>SDU服务数据单元：为完成用户所需要的功能而应传输的数据。</li>
<li>PCI协议控制信息：控制协议操作的信息。</li>
<li>PDU协议数据单元：对等层次之间传送的数据单位。</li>
<li>PDU=SDU+PCI</li>
</ul>
</li>
</ol>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/12.png" alt="image-20210405222724021"></p>
</li>
</ol>
<p>总结：</p>
<ul>
<li>网络体系结构是从<strong>功能</strong>上描述计算机网络结构。</li>
<li>计算机网络体系结构简称网络体系结构是<strong>分层结构</strong>。</li>
<li>每层遵循某个/些<strong>网络协议</strong>以完成本层功能。</li>
<li><strong>计算机网络体系结构</strong>是计算机网络的<strong>各层及其协议</strong>的集合。</li>
<li>第n层在向n+1层提供服务时，此服务<strong>不仅包含第n层本身的功能，还包含由下层服务提供的功能</strong>。</li>
<li>仅仅<strong>相邻层间有接口</strong>，且所提供服务的具体实现细节对上一层完全屏蔽。</li>
<li>体系结构是<strong>抽象</strong>的，而实现是指能运行的一些软件和硬件。</li>
</ul>
<p>脑图：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/13.png" alt="image-20210405223601395"></p>
<h3 id="1-2-2、-OSI参考模型"><a href="#1-2-2、-OSI参考模型" class="headerlink" title="1.2.2、 OSI参考模型"></a>1.2.2、 OSI参考模型</h3><ol>
<li><p>计算机网络分层结构</p>
<ul>
<li>7层OSI参考模型（法定标准）</li>
<li>4层TCP/IP参考模型（事实标准）</li>
<li>5层体系结构（主要是使我们学习计算机网络更加清晰，不是事实标准，也不是法定标准）</li>
</ul>
</li>
<li><p>OSI参考模型是怎么来的？<br>提出第一个网络体系结构：SNA（IBM公司）之后，很多公司和机构纷纷提出自己的网络体系结构：DEC公司的DNA，美国国防部的TCP/IP。为了支持异构网络系统的互联互通，国际标准化组织（ISO）于1984年提出开放系统互连（OSI）参考模型。但是，理论成功，市场失败。</p>
</li>
<li><p>OSI7层结构</p>
<ol>
<li>物理层、数据链路层、网络层、传输层、会话层、表示层、应用层<br>物、链、网、输、会、示、用<br>物联网淑慧试用</li>
<li>资源子网（数据处理）：上三层：会话层、表示层、应用层</li>
<li>通信子网（数据通信）：下三层：物理层、数据链路层、网络层</li>
</ol>
</li>
<li><p>OSI参考模型解释通信过程</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/14.png" alt="在这里插入图片描述"></p>
<p><strong>上四层</strong>实现的是<strong>端到端</strong>的通信<br><strong>下三层</strong>实现的是<strong>点到点</strong>的通信</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/15.png" alt="在这里插入图片描述"></p>
</li>
<li><p>各层功能与协议</p>
<ol>
<li><p>应用层<br>用户与网络的界面，所有能和用户交互产生网络流量的程序<br>典型应用层服务：</p>
<ul>
<li>文件传输（FTP)</li>
<li>电子邮件（SMTP）</li>
<li>万维网（HTTP）等</li>
</ul>
</li>
<li><p>表示层<br>用于处理在两个通信系统中交换信息的表示方式（语法和语义）</p>
<ul>
<li>功能1：数据格式变换（翻译官）</li>
<li>功能2：数据加密和解密</li>
<li>功能3：数据压缩和解压缩</li>
</ul>
<p>没有专门的协议，硬要说的话：主要协议有JPEG、ASCII</p>
</li>
<li><p>会话层<br>向表示层实体/用户进程提供<strong>建立连接</strong>并在连接上<strong>有序</strong>地<strong>传输</strong>数据<br>这是会话，也是<strong>建立同步</strong>（SYN）</p>
<ul>
<li>功能1：建立、管理、终止会话</li>
<li>功能2：使用校验点可以使会话在通信失效时，从校验点/同步点继续恢复通信，实现数据同步。（适用于传输大文件）<br>主要协议：ADSP、ASP</li>
</ul>
</li>
<li><p>传输层<br>负责两个不同主机中<strong>两个进程</strong>的通信，即<strong>端到端</strong>的通信。传输单位是报文段或用户数据报。（功能：可差流用）</p>
<ul>
<li>功能1：可靠传输、不可靠传输</li>
<li>功能2：差错控制</li>
<li>功能3：流量控制</li>
<li>功能4：复用分用<ul>
<li>复用：多个应用层进程可同时使用下面运输层的服务。</li>
<li>分用：运输层把收到的信息分别交付给上面应用层中相应的进程</li>
</ul>
</li>
</ul>
<p>主要协议：TCP、UDP</p>
</li>
<li><p>网络层（最重要）<br>主要任务是把<strong>分组</strong>从源端传到目的端，为分组交换网上的不同主机提供通信服务。</p>
<p>网络层传输单位是<strong>数据报</strong>。</p>
<p><strong>数据报过长时，会将数据报切割成一个个小的分组，再放到链路上传递</strong></p>
<ul>
<li>功能1：路由选择（最佳路径）</li>
<li>功能2：流量控制（协调发送端和接收端的速度）</li>
<li>功能3：差错控制（奇偶校验等）</li>
<li>功能4：拥塞控制<br>若所有结点都来不及接收分组，而要丢弃大量分组的话，网络就处于拥塞状态。因此要采取一定措施缓解这种拥塞。</li>
</ul>
<p>主要协议：IP、IPX、ICMP、IGMP、ARP、RARP、OSPF</p>
</li>
<li><p>数据链路层</p>
<p>主要任务是把网络层传下来的<strong>数据报组装成帧</strong></p>
<p>数据链路层/链路层的传输单位是<strong>帧</strong></p>
<ul>
<li>功能1：成帧（定义帧的开始和结束）</li>
<li>功能2：差错控制（帧错+位错）</li>
<li>功能3：流量控制</li>
<li>功能4：访问（接入）控制  <strong>控制对信道的访问</strong></li>
</ul>
<p>主要协议：SDLC、HDLC、PPP、STP</p>
</li>
<li><p>物理层</p>
<p>傻瓜层</p>
<p><strong>把比特流转成电信号的形式</strong>，然后放到链路上面进行传输，不需要对数据进行改动。<br>主要任务是在<strong>物理媒体</strong>上实现比特流的<strong>透明传输</strong>，传输单位是<strong>比特</strong>。<br>透明传输：指不管所传数据是什么样的比特组合，都应当能够在链路层上传送。</p>
<ul>
<li>功能1：定义接口特性</li>
<li>功能2：定义传输模式（单工、半双工、双工）</li>
<li>功能3：定义传输速率</li>
<li>功能4：比特同步</li>
<li>功能5：比特编码</li>
</ul>
<p>主要协议：Rj45、802.3</p>
</li>
</ol>
</li>
</ol>
<p>脑图：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/19.png" alt="image-20210405234108810"></p>
<h3 id="1-2-3、-TCP-IP参考模型和5层参考模型"><a href="#1-2-3、-TCP-IP参考模型和5层参考模型" class="headerlink" title="1.2.3、 TCP/IP参考模型和5层参考模型"></a>1.2.3、 TCP/IP参考模型和5层参考模型</h3><p>先有TCP/IP协议栈再有TCP/IP参考模型</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/16.png" alt="image-20210405233009957"></p>
<ol>
<li><p>OSI参考模型与TCP/IP参考模型相同点</p>
<ol>
<li>都分层</li>
<li>基于独立的协议栈的概念</li>
<li>都可以实现异构网络互联</li>
</ol>
</li>
<li><p>OSI参考模型与TCP/IP参考模型的不同点</p>
<ol>
<li><p>OSI定义三点：服务、协议、接口</p>
</li>
<li><p>OSI先出现，参考模型先于协议发明，不偏向特定协议</p>
</li>
<li><p>TCP/IP设计之初就考虑到<strong>异构网互联</strong>问题，<strong>将IP作为重要的层次</strong></p>
</li>
<li><p>OSI VS TCP/IP</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">OSI</th>
<th align="center">TCP/IP</th>
</tr>
</thead>
<tbody><tr>
<td align="center">网络层</td>
<td align="center">无连接+面向连接</td>
<td align="center">无连接</td>
</tr>
<tr>
<td align="center">传输层</td>
<td align="center">面向连接</td>
<td align="center">无连接+面向连接</td>
</tr>
</tbody></table>
<p>面向连接：分为三个阶段</p>
<ol>
<li>建立连接，发出一个建立连接的请求</li>
<li>连接成功之后，开始数据传输</li>
<li>数据传输完毕，释放连接</li>
</ol>
<p>无连接：直接进行数据传输</p>
</li>
<li><p>5层参考模型</p>
<p>综合了OSI和TCP/IP的优点</p>
<p>5层参考模型的分层及每层的功能：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/17.png" alt="在这里插入图片描述"></p>
<p>5层参考模型的数据封装与解封装过程：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/18.png" alt="在这里插入图片描述"></p>
</li>
</ol>
</li>
</ol>
<h3 id="1-3-第一章总结"><a href="#1-3-第一章总结" class="headerlink" title="1.3 第一章总结"></a>1.3 第一章总结</h3><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/25.png" alt="在这里插入图片描述"></p>
<h2 id="第二章-物理层"><a href="#第二章-物理层" class="headerlink" title="第二章 物理层"></a>第二章 物理层</h2><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/32.png" alt="在这里插入图片描述"></p>
<hr>
<p>第二章要学习的主要内容</p>
<ul>
<li>通信基础</li>
<li>两个公式lim（考研重点）</li>
<li>看图说话（数字信号的波形）</li>
<li>传输介质</li>
<li>物理层设备（中继器、集线器）</li>
</ul>
<h3 id="2-1-1、-物理层基本概念"><a href="#2-1-1、-物理层基本概念" class="headerlink" title="2.1.1、 物理层基本概念"></a>2.1.1、 物理层基本概念</h3><ol>
<li><p>物理层基本概念</p>
<p>物理层解决如何在连接各种计算机的传输媒体上<strong>传输数据比特流</strong>，而不是指具体的传输媒体（传输媒体可以看做是第0层，要与物理层分开看）</p>
<p>物理层的主要任务：<strong>确定与传输媒体接口有关的一些特性，定义标准</strong></p>
<p>物理层定义了哪些特性？</p>
<ul>
<li>机械特性<br>定义物理连接的特性，规定物理连接时所采用的的规格、接口形状、<strong>引线数目</strong>、<strong>引脚数量</strong>和排列情况</li>
<li>电气特性<br>规定传输二进制位时，线路上信号的<strong>电压范围</strong>、阻抗匹配、<strong>传输速率</strong>和<strong>距离限制</strong>等。</li>
<li>功能特性<br>指明某条线上出现的<strong>某一电平表示何种意义</strong>，接口部件的信号线的用途<br>比如：描述一个物理层接口引脚处于高电平时的含义。</li>
<li>规程特性<br>（过程特性）定义各条物理线路的<strong>工作规程和时序</strong>关系。</li>
</ul>
</li>
</ol>
<h3 id="2-1-2-、数据通信基础知识"><a href="#2-1-2-、数据通信基础知识" class="headerlink" title="2.1.2 、数据通信基础知识"></a>2.1.2 、数据通信基础知识</h3><p>典型的数据通信模型：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20.png" alt="在这里插入图片描述"></p>
<ol>
<li><p>数据通信相关术语</p>
<p>通信的目的是<strong>传送消息</strong></p>
<ul>
<li><p>数据：传送信息的实体，通常是有意义的符号序列。</p>
</li>
<li><p>信号：数据的电气/电磁的表现，是数据在传输过程中的<strong>存在形式</strong>。</p>
<ul>
<li><strong>数字信号</strong>：代表消息的参数取值是<strong>离散</strong>的</li>
<li><strong>模拟信号</strong>：代表消息的参数取值是<strong>连续</strong>的</li>
</ul>
</li>
<li><p>信源：产生和发送数据的源头</p>
</li>
<li><p>信宿：接收数据的终点</p>
</li>
<li><p>信道：信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条<strong>发送信道</strong>和一条<strong>接收信道</strong>.</p>
<p>信道分类</p>
<ul>
<li>按<strong>传输信号</strong>分：数字信道（传送数字信号）、模拟信道（传送模拟信号）</li>
<li>按<strong>传输介质</strong>分：无线信道、有线信道</li>
</ul>
</li>
</ul>
</li>
<li><p>三种通信方式</p>
<p>从通信双方信息的交互方式看，可以有三种基本方式</p>
<ul>
<li>单工通信<br>只有一个方向的通信而没有反方向的交互，仅需要<strong>一条</strong>信道</li>
<li>半双工通信<br>通信的双方都可以发送或接收信息，但任何一方都不能同时发送和接收，需要<strong>两条</strong>信道</li>
<li>全双工通信<br>通信双方可以同时发送和接受信息，也需要<strong>两条</strong>信道</li>
</ul>
</li>
<li><p>两种数据传输方式</p>
<p>数据在信道上的传送方式</p>
<ul>
<li>串行传输<br><strong>速度慢，费用低、适合远距离</strong></li>
<li>并行传输<br><strong>速度快、费用高、适合近距离</strong><br>用于<strong>计算机内部数据</strong>传输（打印机，扫描机）</li>
</ul>
</li>
</ol>
<h3 id="2-1-3-、码元、波特、速率、带宽"><a href="#2-1-3-、码元、波特、速率、带宽" class="headerlink" title="2.1.3 、码元、波特、速率、带宽"></a>2.1.3 、码元、波特、速率、带宽</h3><ol>
<li><p>码元<br>指用一个<strong>固定时长</strong>的<strong>信号波形</strong>（数字脉冲），代表<strong>不同离散数值的基本波形</strong>，是数字通信中数字信号的计量单位，<strong>这个时长内的信号称为k进制码元</strong>，而<strong>该时长称为码元宽度</strong>。当码元的离散状态有M个时（M&gt;2），此时码元为M进制码元。</p>
<p><strong>1码元可以携带多个比特的信息量</strong>。例如，在使用二进制编码时，只有两种不同的码元，一种代表0状态，另一种表示1状态。而四进制码元，一个码元可以携带2bit信息。（00/01/10/11）</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/21.png" alt="image-20210406001148097"></p>
</li>
<li><p>速率、波特</p>
<p>速率也叫数据率，是指数据的<strong>传输速率</strong>，表示单位时间内传输的数据量。可以用<strong>码元传输速率</strong>和<strong>信息传输速率</strong>表示。</p>
<ol>
<li><p>码元速率：（码元速率、波形速率、<strong>调制速率</strong>、<strong>符号速率</strong>等等）<br>它表示单位时间内数字通信系统所传输的码元个数（也可称为<strong>脉冲个数</strong>或<strong>信号变化的次数</strong>），单位是波特（Baud）。1波特表示数字通信系统每秒传输一个码元。这里的码元可以是多进制的，也可以是二进制的，但是<strong>码元速率与进制数无关</strong>。</p>
<p>即：<strong>1s传输了多少码元</strong></p>
</li>
<li><p>信息速率：<br>表示单位时间内数字通信系统传输的<strong>二进制码元个数</strong>（即比特数）<br>单位是比特/秒（b/s）</p>
<p>即：<strong>1s传输多少比特</strong></p>
<p>关系：</p>
<p>*<em>若一个码元携带n bit的信息量，则M Buad的码元传输速率所对应的信息传输速率为M</em>n bit/s**</p>
<p>即：*<em>信息传输速率 = n bit * 码元传输速率*</em></p>
<p>系统传输的是<strong>比特流</strong>，通常比较的的是<strong>信息传输速率</strong>。</p>
</li>
</ol>
</li>
<li><p>带宽<br>表示在单位时间内从网络中的<strong>某一点到另一点</strong>所能通过的“<strong>最高数据率</strong>”，常用来表示网络的通信线路所能传输数据的能力。单位是b/s。</p>
</li>
<li><p>相关习题：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/22.png" alt="image-20210406002432454"></p>
</li>
</ol>
<h3 id="2-1-4、-奈氏准则和香农定理"><a href="#2-1-4、-奈氏准则和香农定理" class="headerlink" title="2.1.4、 奈氏准则和香农定理"></a>2.1.4、 奈氏准则和香农定理</h3><ol>
<li><p>失真：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/23.png" alt="在这里插入图片描述"></p>
</li>
<li><p>影响失真的因素：</p>
<ol>
<li>码元传输速率（正相关）<br>速率越快，信号失真程度越严重</li>
<li>信号传输距离（正相关）<br>距离越远，衰减越久，干扰越久，对信号影响越大</li>
<li>噪声干扰（负相关）<br>噪声越多，信号失真程度越大</li>
<li>传输媒体质量（负相关）<br>传输媒体质量越差，越失真</li>
</ol>
</li>
<li><p>失真的一种现象——码间串扰</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%5C24.png" alt="在这里插入图片描述"></p>
<p>信道带宽：<strong>信道能通过的最高频率和最低频率之差</strong></p>
<p>上图的<strong>信道带宽</strong>是：3300Hz-300Hz=3000Hz</p>
<ol>
<li><p>速率过低为什么不能通过信道？</p>
<p>速度太低，信号在信道上非常容易衰减</p>
</li>
<li><p>速度过高为什么不能通过信道？</p>
<p>振动频率太快了，接收端在接收时区分不出来波形之间的差异（即：码间串扰）</p>
<p>码间串扰：<strong>接收端</strong>收到的信好波形<strong>失去了码元之间清晰界限</strong>的现象</p>
</li>
</ol>
</li>
<li><p>奈氏准则（奈奎斯特定理）</p>
<p>在理想低通（无噪声，带宽受限）条件下，为了避免码间串扰，<strong>极限码元传输速率为2W Baud</strong>，W是信道带宽，<strong>单位是Hz</strong>。<strong>在奈氏准则和香农定理中带宽的单位是Hz</strong>（不是bit/s）</p>
<p>理想低通信道下的极限传输率=2Wlog2V（b/s）<br>V：码元的种数/码元的离散电平数目</p>
<p>根据奈氏准则可以得到以下4条结论：</p>
<ol>
<li>在任何信道中，<strong>码元传输的速率是有上限的</strong>。若传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的完全正确识别成为不可能。</li>
<li>信道的<strong>频带越宽</strong>（即：能通过的信号高频分量越多），就可以用更高的速率进行码元的有效传输</li>
<li><strong>奈氏准则给出了码元传输速率的限制，但并没有对信息传输速率给出限制</strong></li>
<li>由于码元的传输速率受奈氏准则的制约，所以要<strong>提高数据的传输速率</strong>，就必须设法使每个码元能携带更多个比特的信息量，这就需要采用<strong>多元制的调制方法</strong>。</li>
</ol>
<p>例：在无噪声的情况下，若某通信链路的带宽为3kHz，采用4个相位，每个相位具有4种振幅的QAM调制技术，则该通信链路的最大数据传输率是多少?</p>
<p>分析：调相与调幅相结合</p>
<p>解：</p>
<pre><code> 信号有4 * 4=16种变化，则V=16；</code></pre>
<p>​     即：极限传输速率=2Wlog2（V）（b/s）= 2 * 3000 * log2（16）（b/s）= 24000（b/s）</p>
</li>
<li><p>香农定理</p>
<p><strong>噪声</strong>存在于所有的电子设备和通信系统中。由于噪声随机产生，它的瞬时值有时会很大，因此噪声会使接收端对码元的判决产生错误。但是<strong>噪声的影响是相对的，若信号较强，那么噪声影响相对较小</strong>。因此，信噪比就很重要。</p>
<p>信噪比 = <strong>信号</strong>的平均功率/<strong>噪声</strong>的平均功率，常记为S/N，并用分贝（dB）作为度量单位，即：<br>信噪比（dB）=10 * log10（S/N） </p>
<p>两者在数值上等价。</p>
<p>而往往信噪比的这个值会很大，所以一般取对数。取了对数这个严格来说就叫做声强级，取对数实际上获得了次方的值，进而得到了声音（信息）的强度。但是两个东西表示的是同一信息。声强级是为了方便读数理解而对信噪比进行的变换（类似科学记数法）</p>
<p>香农定理：</p>
<p>在<strong>带宽受限</strong>且<strong>有噪声</strong>的信道中，为了不产生误差，<strong>信息的数据传输速率</strong>有上限值。</p>
<p>信道的极限数据传输速率=W * log2（1+S/N） （b/s）</p>
<p>S：信道所传信号的平均功率</p>
<p>N：信道内的高斯噪声功率</p>
<p>S/N即：信噪比</p>
<p>W:带宽（Hz）</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/26.png" alt="image-20210406010014399"></p>
<p>根据香农定理可以得到以下5条结论：</p>
<ol>
<li>信道的<strong>带宽</strong>或信道中的<strong>信噪比</strong>越大，则信息的极限传输速率就<strong>越高</strong></li>
<li>对一定的传输带宽和一定的信噪比，信息传输速率的上限就确定了</li>
<li>只要信息的传输速率低于信道的极限传输速率，就一定能找到某种方法实现<strong>无差错传输</strong></li>
<li>香农定理得出的为极限信息传输速率，实际信道能达到的传输速率要比它低不少</li>
<li>从香农定理可以看出，若信道带宽W或信噪比S/N没有上限（不可能），那么信道的极限信息传输速率也就没有上限。</li>
</ol>
<p>例题：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/28.png" alt="image-20210406010235606"></p>
</li>
<li><p>奈氏准则和香农定理的联系与区别：</p>
<p>奈氏准则（内忧，码间串扰）香农定理（外患，外界噪声）<br>有时候既需要使用奈氏准则，也需要使用香农定理，这时，<strong>需要取两者中的最小值</strong></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/27.png" alt="image-20210406010414253"></p>
<p>例：二进制信号在信噪比为127∶1的4kHz信道上传输，最大的数据速率可达到多少?<br>解：</p>
<pre><code>由奈氏准则知：最大数据传输速率为=2 * W * log2（V）
                          =2 * 4000 * 1=8000（b/s）
有香农定理知：最大数据传输速率为=W * log2（1+S/N）
                          =4000 * log2（1+127）
                          =28000（b/s）
最大的数据传输率为8000（b/s）</code></pre>
</li>
</ol>
<h3 id="2-1-5-、编码与调制"><a href="#2-1-5-、编码与调制" class="headerlink" title="2.1.5 、编码与调制"></a>2.1.5 、编码与调制</h3><ol>
<li><p>基带信号与宽带信号</p>
<p>信道上传送的信号</p>
<ol>
<li>基带信号：将数字信号1和0直接用两种不同的电压表示，再送到<strong>数字信道</strong>上去传输（<strong>基带传输</strong>）<br>基带信号是<strong>来自信源</strong>的信号，就像计算机输出的代表各种文字或者图像文件的数据信号都属于基带信号。<br>基带信号就是发出的<strong>直接表达了要传输的信息的信号</strong>，比如我们说话的声波就是基带信号。</li>
<li>宽带信号：将基带信号进行调制后形成的频分复用模拟信号，再传到<strong>模拟信道</strong>上去传输（<strong>宽带传输</strong>）<br>把基带信号经过<strong>载波调制</strong>后，把信号的<strong>频率范围搬迁到较高的频段</strong>一遍在信道中传输（即：仅在一段频率范围内能够通过信道）<br>在传输距离较<strong>近</strong>时，计算机网络采用<strong>基带传输</strong>方式（近距离衰减小，从而信号内容不易发生变化）<br>在传输距离较<strong>远</strong>时，计算机网络采用<strong>宽带传输</strong>方式（近距离衰减大，即使信号变化大也能最后过滤出来基带信号）</li>
</ol>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/33.png" alt="image-20210407105303305"></p>
</li>
<li><p>编码与调制</p>
<p>数据–&gt;数字信号  编码</p>
<p>数据–&gt;模拟信号  调制</p>
<p>数字数据–数字发送器–&gt;数字信号   编码</p>
<p>数字数据–调制器–&gt;模拟信号      调制</p>
<p>模拟数据–PCM编码器–&gt;数字信号   编码</p>
<p>模拟数据–放大器调制器–&gt;模拟信号 调制</p>
</li>
<li><p>四种编码与调制方法</p>
<ol>
<li>数字数据编码为数字信号</li>
<li>数字数据调制为模拟信号</li>
<li>模拟数据编码为数字信号</li>
<li>模拟数据调制为模拟信号</li>
</ol>
</li>
<li><p>数字数据编码为数字信号</p>
<ol>
<li><p>非归零编码【NRZ】</p>
<p>编码方式：高1低0</p>
<p>编码容易实现，但没有检错功能，且无法判断一个码元的开始和结束，以至于收发双方难以保持同步。</p>
<p>发送端全1或0，接收端都不好识别，需要确定时间周期</p>
<p>不常用</p>
</li>
<li><p>曼彻斯特编码</p>
<p>综合归零编码、非归零编码、反向不归零编码的优缺点而形成的非常优秀的编码</p>
<p>它可以把时钟信号和数据都放在一块，不需要额外的信道传输时钟信号,就可以实现自己本身的同步，即：自同步<br>编码方式：</p>
<ul>
<li>将一个码元分成两个相同的间隔，前一个间隔为低电平后一个为高电平表示码元1；</li>
<li>码元0则正好相反。也可以采用相反的规定。</li>
</ul>
<p>该编码的特点是：在每一个码元的中间出现电平跳变，位于中间的跳变既作为时钟信号（用于同步），<br>又作为数据信号，但它所占的频带宽度是原始的基带宽度的两倍。每一个码元都被调成两个电平，所以数据传输速率只有调制速率的1/2。</p>
</li>
<li><p>差分曼彻斯特编码（常用于局域网传输）</p>
<p>编码方式：同1异0</p>
<p>其规则是：若码元为1，则前半个码元的电平与上一个码元的后半个码元的电平相同，若为0，则相反。</p>
<p>该编码的特点是：<br>在每个码元的中间，都有一次电平的跳转，可以实现自同步，且抗干扰性强于曼彻斯特编码（因为实现算法更复杂）</p>
</li>
<li><p>归零编码【RZ】</p>
<p>编码方式：信号电平在一个码元之内都要回复到零的方式</p>
<p>全零不容易识别</p>
<p>不常用</p>
</li>
<li><p>反向不归零编码【NRZI】</p>
<p>编码方式：信号电平翻转表示0，信号电平不变表示1</p>
<p>发送端全0，接收端容易识别，发送端全1，接收端不好识别</p>
</li>
<li><p>4B/5B编码</p>
<p>比特流中插入额外的比特以打破一连串的0或1，就是用5个比特来编码4个比特的数据，之后再传给接收方，因此称为4B/5B。编码效率为80%</p>
<p>只采用16种5位码对应16种不同的4位码，其他的16种5位码作为控制码（帧的开始或结束，线路的状态信息等）或保留。</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/34.png" alt="image-20210407110138680"></p>
</li>
</ol>
<p>前三种重点掌握，后三种了解即可</p>
</li>
<li><p>数字数据调制为模拟信号</p>
<p>数据调制技术：<br>在发送端将数字信号转化为模拟信号，而在接收端将模拟信号还原为数字信号，分别对应于调制解调器的调制和解调过程。</p>
<ul>
<li>2ASK 调幅<br>低电平0没有幅动，高电平1有幅动</li>
<li>2FSK 调频<br>低电平0低频，高电平1高频</li>
<li>2PSK 调相<br>0对应一种波形，1对应一种波形</li>
<li>QAM 调幅+调相<br>例如：某通信链路的波特率是1200Baud，采用4个相位，每个相位有4种振幅的QAM调制技术，则该链路的信息传输速率是多少?<br>解：<pre><code>信号有4 * 4 = 16种变化
信息传输速率 = W * log2（V）= 1200 * 4 = 4800（b/s）</code></pre>
</li>
</ul>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/29.png" alt="在这里插入图片描述"></p>
</li>
<li><p>模拟数据编码为数字信号</p>
<ol>
<li><p>计算机内部处理的是二进制数据，处理的都是<strong>数字音频</strong>，所以需要将模拟音频通过采样、量化转换成有限个数字表示的离散序列（即实现<strong>音频数字化</strong>）。</p>
</li>
<li><p>最典型的例子就是对音频信号进行编码的脉码调制（<strong>PCM脉码调制</strong>)，在计算机应用中，能够达到<strong>最高保真水平</strong>的就是PCM编码，被广泛用于素材保存及音乐欣赏，CD、DVD以及我们常见的WAV文件中均有应用。</p>
<p>它主要包括三步:抽样、量化、编码。</p>
<ol>
<li><p>抽样</p>
<p>对模拟信号周期性扫描，把时间上连续的信号变成离散的信号。</p>
<p>为了使所得的离散信号能够无失真地代表被抽样的模拟数据，要使用采样定理进行采样。</p>
<p>采样定理：（奈奎斯特采样定理）<br>f采样频率 &gt;= 2 * f信号最高频率<br>（最高分波形上至少采样两个点）</p>
</li>
<li><p>量化</p>
<p>把抽样取得的电平幅值按照一定的分级标度转化为对应的数字值，并取整数，这就把连续的电平幅值转换为离散的数字量。</p>
</li>
<li><p>编码</p>
<p>把量化的结果转换为与之对应的二进制编码</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%5C35.png" alt="image-20210407110815400"></p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>模拟数据调制为模拟信号<br>为了实现传输的有效性，可能需要较高的频率。这种调制方式还可以使用<strong>频分复用技术</strong>，充分利用带宽资源。在电话机和本地交换机所传输的信号是采用<strong>模拟信号传输模拟数据</strong>的方式；模拟的声音数据是加载到模拟的<strong>载波信号</strong>中传输的。</p>
</li>
</ol>
<p>脑图：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/30.png" alt="在这里插入图片描述"></p>
<h3 id="2-2-1、-物理层传输介质"><a href="#2-2-1、-物理层传输介质" class="headerlink" title="2.2.1、 物理层传输介质"></a>2.2.1、 物理层传输介质</h3><ol>
<li><p>传输介质及分类</p>
<ol>
<li><p>传输介质也称传输媒体/传输媒介，它就是数据传输系统中在发送设备和接收设备之间的物理通路</p>
</li>
<li><p><strong>传输媒体并不是物理层</strong></p>
<p>传输媒体在物理层的下面，因为物理层是体系结构的第一层，因此有时称传输媒体为0层。在传输媒体中传输的是信号，但传输媒体并不知道所传输的信号代表什么意思。但物理层规定了<strong>电气特性</strong>，因此能够识别所传送的比特流。</p>
</li>
<li><p>如果称物理层是傻瓜，那么传输媒体连傻瓜都不如</p>
</li>
<li><p>传输媒体分类</p>
<ol>
<li><p>导向性传输媒体</p>
<p>电磁波被导向沿着固体媒体（铜线/光纤）传播</p>
</li>
<li><p>非导向性传输媒体</p>
<p>自由空间，介质可以是空气、真空、海水等。</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>导向性传输介质</p>
<ol>
<li><p>双绞线：是古老、又最常用的传输介质，它由<strong>两根</strong>采用一定规则并排<strong>绞合</strong>的、相互绝缘的铜导线组成。</p>
<p>绞合可以减少相邻导线的电磁干扰。</p>
<p>为了进一步提高抗电磁干扰能力，可在双绞线的外面再加上一个由金属丝编织成的屏蔽层，这就是屏蔽双绞线（STP）</p>
<p>无屏蔽层的双绞线就称为非屏蔽双绞线（UTP）。</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/39.png" alt="image-20210409094235649"></p>
<p>特点：</p>
<ul>
<li>双绞线价格便宜，是最常用的传输介质之一，在局域网和传统电话网中普遍使用。</li>
<li>模拟传输和数字传输都可以使用双绞线，其通信距离一般为几公里到数十公里。</li>
<li>距离太远时，对于<strong>模拟传输</strong>，要用<strong>放大器放大衰减的信号</strong>;</li>
<li>对于<strong>数字传输</strong>，要用<strong>中继器将失真的信号整形</strong>。</li>
</ul>
</li>
<li><p>同轴电缆</p>
<p>同轴电缆由<strong>导体铜质芯线</strong>、<strong>绝缘层</strong>、<strong>网状编织屏蔽层</strong>和<strong>塑料外层</strong>构成。</p>
<p>按特性阻抗数值的不同，通常将同轴电缆分为两类:50欧姆同轴电缆和75欧姆同轴电缆。</p>
<p>其中，50欧姆同轴电缆主要用于传送基带数字信号，又称为<strong>基带同轴电缆</strong>，它在局域网中得到广泛应用;75欧姆同轴电缆主要用于传送宽带信号，又称为<strong>宽带同轴电缆</strong>，它主要用于有线电视系统。</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/40.png" alt="image-20210409094427395"></p>
<p>双绞线和同轴电缆的区别</p>
<p>由于外导体屏蔽层的作用，同轴电缆<strong>抗干扰特性</strong>比双绞线<strong>好</strong>，被广泛用于传输较高速率的数据，其<strong>传输距离更远</strong>，但<strong>价格</strong>较双绞线<strong>贵</strong>。</p>
</li>
<li><p>光纤</p>
<ol>
<li><p>光纤通信就是利用光导纤维（简称光纤）传递<strong>光脉冲</strong>来进行通信。有光脉冲表示1，无光脉冲表示O。</p>
<p>而可见光的频率大约是10^8MHz，因此光纤通信系统的<strong>带宽远远大</strong>于目前其他各种传输媒体的带宽。</p>
</li>
<li><p>光纤在发送端有光源，可以采用发光二极管或半导体激光器，它们在电脉冲作用下能产生出光脉冲，在接收端用光电二极管做成光检测器，在检测到光脉冲时可还原出电脉冲。</p>
</li>
<li><p>光纤主要由纤芯(实心的!)和包层构成，光波通过纤芯进行传导，包层较纤芯有较低的折射率。当光线从高折射率的介质射向低折射率的介质时，其折射角将大于入射角。因此，如果入射角足够大，就会出现全反射，即光线碰到包层时候就会折射回纤芯、这个过程不断重复，光也就沿着光纤传输下去。</p>
<p>超低损耗，传送超远距离</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/41.png" alt="image-20210409095419124"></p>
</li>
<li><p>分类</p>
<ol>
<li><p>多模光纤</p>
<p>传播过程会有损耗，传播过程中会受到噪声的影响，如果距离过远可能会出现较为严重的失真，适合近距离传输</p>
</li>
<li><p>单模光纤</p>
<p>单模与多模光纤的比较一根光缆少则只有一根光纤，多则包括十至数百根光纤</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/36.png" alt="在这里插入图片描述"></p>
</li>
</ol>
</li>
<li><p>光纤的特点</p>
<ol>
<li>传输损耗小，中继距离长，对远距离传输特别经济</li>
<li>抗雷电和电磁干扰性能好</li>
<li>无串音干扰，保密性好，也不易被窃听或截取数据</li>
<li>体积小，重量轻</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>非导向性传输介质</p>
<ol>
<li><p>无线电波</p>
<p>信号向<strong>所有方向</strong>传播</p>
<p>较强<strong>穿透能力</strong>，可传远距离，广泛用于通信领域（手机通信）</p>
</li>
<li><p>微波</p>
<p>信号固定方向传播</p>
<p>微波通信频率较高、频段范围宽，因此数据率很高</p>
<ol>
<li><p>地面微波接力通信</p>
<p>中继站</p>
</li>
<li><p>卫星通信</p>
<p>同步卫星起到了中继站的作用</p>
<ul>
<li>优点<ol>
<li>通信容量大</li>
<li>距离远</li>
<li>覆盖广</li>
<li>广播通信和多址通信</li>
</ol>
</li>
<li>缺点<ol>
<li>传播时延长（250-270ms）</li>
<li>受气候影响大（eg：强风、太阳黑子爆发）</li>
<li>误码率较高</li>
<li>成本高</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><p>红外线、激光</p>
<p>信号固定方向传播</p>
<p>把要传输的信号分别<strong>转换为各自的信号格式</strong>，即红外光信号和激光信号，再在空间中传播。<br>(微波不需要转换格式）</p>
</li>
</ol>
</li>
</ol>
<p>脑图：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/37.png" alt="在这里插入图片描述"></p>
<h3 id="2-2-2-、物理层设备"><a href="#2-2-2-、物理层设备" class="headerlink" title="2.2.2 、物理层设备"></a>2.2.2 、物理层设备</h3><ol>
<li><p>中继器</p>
<ol>
<li><p>诞生的背景：由于存在损耗，在线路上传输的信号功率会逐渐衰减，衰减到一定程度时将会造成信号失真。</p>
</li>
<li><p>中继器的功能：对信号进行<strong>再生和还原</strong>，对衰减的信号进行放大，保持与原数据相同，以增加信号传输的距离，延长网络的长度。</p>
</li>
</ol>
</li>
</ol>
<p>简而言之：<strong>再生数字信号</strong>。<br>   3. 中继器的两端：</p>
<pre><code>  1. 两端的网络部分是**网段**，而不是子网，适用于**完全相同的两类网络的互连**，且**两个网段速率要相同**。

  2. 中继器只将任何电缆段上的数据发送到另一段电缆上，它仅作用于信号的电气部分，并不管数据中是否有错误或不适于网段的数据。

  3. **两端可连相同的媒体，也可连不通的媒体**。

  4. 中继器两端的网段一定要是**同一个协议**。（**中继器不会存储转发**）</code></pre>
<ol start="4">
<li><p>5-4-3规则：网络标准中都对信号的延迟范围作了具体的规定，因而中继器只能在规定的范围内进行，否则会网络故障。</p>
<p>5个网段，4个网络设备，3个段可以连接计算机</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/42.png" alt="image-20210409164354784"></p>
</li>
<li><p>集线器（多口中继器）</p>
<ol>
<li><p>再生，放大信号</p>
</li>
<li><p>集线器的功能:对信号进行<strong>再生放大转发</strong>，对衰减的信号进行放大，接着转发到其他所有（除输入端口外）处于工作状态的端口上，以增加信号传输的距离，延长网络的长度。<strong>不具备信号的定向传送能力，是一个共享式设备</strong>。</p>
</li>
<li><p>星型拓扑（广播通信）</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/43.png" alt="image-20210409165035181"></p>
</li>
<li><p>集线器<strong>不能分割冲突域</strong>。当有超过两台主机同时发送数据给集线器就会发生信息碰撞，要等待随机一段时间之后在发送数据。当集线器连接的主机数目越来越多的时候，由于产生信息碰撞的概念变大，集线器的工作效率也会降低。连在集线器上的工作主机平分带宽。  </p>
</li>
</ol>
</li>
</ol>
<h3 id="2-3-、第二章总结"><a href="#2-3-、第二章总结" class="headerlink" title="2.3 、第二章总结"></a>2.3 、第二章总结</h3><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/38.png" alt="在这里插入图片描述"></p>
<h2 id="第三章-数据链路层"><a href="#第三章-数据链路层" class="headerlink" title="第三章 数据链路层"></a>第三章 数据链路层</h2><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/44.png" alt="在这里插入图片描述"></p>
<hr>
<p>第三章学习的主要内容是：</p>
<ol>
<li>链路层的功能</li>
<li>链路层的两种信道</li>
<li>局域网、广域网</li>
<li>链路层的设备</li>
</ol>
<h3 id="3-1-1、-数据链路层功能概述"><a href="#3-1-1、-数据链路层功能概述" class="headerlink" title="3.1.1、 数据链路层功能概述"></a>3.1.1、 数据链路层功能概述</h3><ol>
<li><p>数据链路层的研究思想：</p>
<p>想象数据是直接从发送端的数据链路层，经过中间系统<strong>水平发送</strong>到接收端的数据链路层</p>
</li>
<li><p>数据链路层的基本概念</p>
<ol>
<li><p>结点：主机、路由器</p>
</li>
<li><p>链路：网络中两个结点之间的<strong>物理通道</strong>，链路的传输介质主要有双绞线、光纤和微波。分为有线链路、无线链路。</p>
</li>
<li><p>数据链路：网络中两点之间的<strong>逻辑通道</strong>，把实际控制数据传输<strong>协议</strong>的硬件和软件加到链路上就构成了数据链路。</p>
</li>
<li><p>帧：链路层的协议数据单元，<strong>封装网络层的数据报</strong></p>
</li>
</ol>
<p>数据链路层负责通过一条链路从一个节点向另一个物理链路直接相邻的相邻结点传送数据报。</p>
</li>
<li><p>数据链路层功能概述</p>
<p>在物理层提供服务的基础之上向<strong>网络层提供服务</strong>，其最基本的服务是将源自网络层来的数据<strong>可靠</strong>地传输到相邻结点的目标机网络层。</p>
<p>其主要作用是<strong>加强物理层传输原始比特流的功能</strong>，将物理层提供的可能出错的物理连接改造成<strong>逻辑上无差错的数据链路</strong>，使之对网络层表现为一条无差错的链路。</p>
<ul>
<li>功能1：为网络层提供服务。<strong>无确认连接服务</strong>，<strong>有确认无连接服务</strong>，<strong>有确认面向连接服务</strong>。（有连接一定有确认！）<ul>
<li>无确认连接服务：通常用于实时通信或者误码率比较低的通信信道。源主机在发送数据的时候不用事先与目的主机建立好链路的连接，而且目的主机收到数据帧的时候也不用返回确认。如果数据帧丢失了数据链路层也不负责重发，而直接交给上一层处理。（不负责但很快）</li>
<li>有确认无连接服务：通常用于无线通信或者误码率比较高的通信信道。源主机在发送数据的时候不用事先与目的主机建立好链路的连接，但是目的主机收到数据帧的时候需要向源主机返回确认。如果源主机发现在规定时间内没有收到目的主机发送的确认信号，它就把刚才没有收到确认的这个数据帧重新发送，以此来提高数据链路层的可靠性。</li>
<li>有确认面向连接服务：源主机在发送数据的时事先与目的主机建立好链路的连接，目的主机收到数据帧的时也向源主机返回确认。源主机发现确认信号才能发送下一个。（最安全最可靠但速度也是最慢的）</li>
</ul>
</li>
<li>功能2：链路管理，即连接的建立、维持、释放（用于面向连接的服务）</li>
<li>功能3：组帧</li>
<li>功能4：流量控制，限制发送方</li>
<li>功能5：差错控制（帧错/位错）</li>
</ul>
</li>
</ol>
<h3 id="3-1-2、-封装成帧和透明传输"><a href="#3-1-2、-封装成帧和透明传输" class="headerlink" title="3.1.2、 封装成帧和透明传输"></a>3.1.2、 封装成帧和透明传输</h3><ol>
<li><p>封装成帧</p>
<ol>
<li><p>概念：</p>
<p>就是在一段数据的前后部分添加<strong>首部和尾部</strong>，这样就构成了一个帧。</p>
<p>接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。</p>
<p>首部和尾部包含许多的控制信息，他们的一个重要的作用：<strong>帧定界</strong>（确定帧的界限）</p>
</li>
<li><p>帧同步：<strong>接收方</strong>应当能从接收到的二进制比特流中区分出帧的起始和终止。</p>
</li>
<li><p>组帧的四种方法</p>
<ol>
<li>字符计数法</li>
<li>字符（节）填充法</li>
<li>零比特填充法</li>
<li>违规编码法</li>
</ol>
</li>
<li><p>示意图</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/45.png" alt="在这里插入图片描述"></p>
</li>
</ol>
</li>
<li><p>透明传输</p>
<p>指：不管所传数据是什么样的比特组合，都应当能够在链路上传送。</p>
<p>因此，链路层就“看不见”有什么妨碍数据传输的东西。当所传数据中的比特组合恰巧与某一个控制信息完全一样时，必须采取适当的措施，使接收方不会将这样的数据错误认为是某种控制信息，这样才能保证数据链路层的传输是透明的。</p>
</li>
<li><p>字符计数法（不常用）</p>
<p>帧首部使用一个计数字段（第一个字节，8位）来表明帧内字符数（字节数）。</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/47.png" alt="image-20210409182821894"></p>
<p>痛点：鸡蛋装在一个篮子里。</p>
<p>如果第一个字节（计数字段）是错误的，则后面的帧全部发生错误。这样接收方没有办法正确接收每一个帧。</p>
</li>
<li><p>字符填充法</p>
<p>当传送的帧是由文本文件组成时（文本文件的字符都是从键盘输入的，都是ASCII码），不管从键盘上输入什么字符都可以放在帧里面传过去，即<strong>透明传输</strong>。</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/48.png" alt="image-20210409182945627"></p>
<p>当传送的帧是由非ASCII码的文本文件组成时（二进制代码的程序或图像等），就采用<strong>字符填充法</strong>实现透明传输。</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/49.png" alt="image-20210409183020592"></p>
<p>字符填充法的示意图：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/46.png" alt="在这里插入图片描述"></p>
</li>
<li><p>零比特填充法</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/50.png" alt="image-20210409192047830"></p>
<p>   操作</p>
</li>
<li><p>在发送端，扫描整个信息字段（原始数据），只要连续5个1，就立即填入1个0</p>
<p>即：5”1”，1”0”</p>
</li>
<li><p>在信息字段前后都加上0111110，作为帧的边界</p>
</li>
<li><p>在接收端收到一个帧时，先找到标志字段确定边界，再用硬件对比特流进行扫描。</p>
<p>发现连续5个1时，就把后面的0删除。</p>
<p>保证了透明传输：在传送的比特流中可以传送任意比特组合，而不会引起对帧边界的判断错误。</p>
</li>
<li><p>违规编码法</p>
<p>对于曼彻斯特编码，可以使用高-高，低-低来定帧的起始和终止。</p>
<p>局域网的IEE802标准就采用了该方法。</p>
</li>
</ol>
<p>总结：</p>
<p>由于字节计数法中Count字段（第一个字节）的脆弱性（其值若有差错将导致灾难性后果）及字符填充实现上的复杂性和不兼容性，目前较普遍使用的帧同步法是<strong>比特填充</strong>和<strong>违规编码法</strong>。</p>
<h3 id="3-1-3-、差错控制（比特错，检错编码，纠错编码）"><a href="#3-1-3-、差错控制（比特错，检错编码，纠错编码）" class="headerlink" title="3.1.3 、差错控制（比特错，检错编码，纠错编码）"></a>3.1.3 、差错控制（比特错，检错编码，纠错编码）</h3><ol>
<li><p>差错从何而来？</p>
<p>概括来说，传输中的差错都是由于噪声引起的。</p>
<ol>
<li><p>全局性：由于线路本身<strong>电气特性</strong>所产生的的<strong>随机噪声</strong>（热噪声），是信道固有的，随机存在的。</p>
<p>解决办法：<strong>提高信噪比</strong>来减少或避免干扰。（<strong>对传感器下手</strong>）</p>
</li>
<li><p>局部性：外界特定的短暂原因所造成的<strong>冲击噪声</strong>，产生差错的主要原因。</p>
<p>解决办法：通常利用<strong>编码技术</strong>来解决。</p>
</li>
</ol>
</li>
<li><p>差错的分类</p>
<ol>
<li><p>位错：比特位出错，1变成0,0变成1</p>
</li>
<li><p>帧错：分为三种：丢失，重复，失序</p>
<p>例如：要传输三个帧[#1]-[#2]-[#3]，则：</p>
<ul>
<li>帧丢失：[#1]-[#3]</li>
<li>帧重复：[#1]-[#2]-[#2]-[#3]</li>
<li>帧失序：[#3]-[#2]-[#1]</li>
</ul>
<p>针对这些帧错误，会采用帧编号、确认重传机制等来进行帧的差错控制。</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/53.png" alt="image-20210409195542838"></p>
<p>这是过去OSI模型的观点，现在通信链路的质量大大提高，因为通信链路质量不好引起的差错概率越来越小。</p>
<p>现在的因特网会采用较为灵活的方法，针对不同的网络，我们会选择是否采用确认重传机制。</p>
</li>
</ol>
</li>
<li><p>链路层为网络层提供的服务：</p>
<ol>
<li>无确认无连接服务</li>
<li>有确认无连接服务</li>
<li>有确认面向连接服务</li>
</ol>
<p>若通信质量好，比如有线传输链路，链路层协议就不会采用确认和重传机制，而且也不要求链路层向网络层提供有效可靠传输的服务（即只有无确认无连接服务），如果发生差错，改错任务会交给上层协议(传输层)。</p>
<p>若通信质量差，比如无线传输链路，链路层协议就会采用确认和重传机制数据链路层就需要向上提供可靠传输的服务（即需要提供有确认无连接服务和有确认面向连接服务）</p>
</li>
<li><p>数据链路层的差错控制（比特错，帧错会在后面讲解）</p>
<p>差错控制：</p>
<ol>
<li>检错编码<ol>
<li>奇偶校验码</li>
<li>循环冗余码CRC</li>
</ol>
</li>
<li>纠错编码<ol>
<li>海明码</li>
</ol>
</li>
<li>数据链路层编码和物理层编码的区别<ul>
<li>数据链路层编码和物理层的<strong>数据编码与调制不同</strong>。</li>
<li><strong>物理层编码针对的是单个比特</strong>，解决传输过程中比特的同步等问题，如曼彻斯特编码。</li>
<li>而<strong>数据链路层的编码针对的是一组比特</strong>，它通过冗余码的技术实现一组二进制比特串在传输过程中是否出现了差错。</li>
</ul>
</li>
</ol>
</li>
<li><p>奇偶校验码</p>
<p>​    n-1位信息元，1位校验元</p>
<ol>
<li><p>奇校验码</p>
<p>信息元和校验元中，“1”的个数为奇数</p>
</li>
<li><p>偶校验码</p>
<p> 信息元和校验元中，“1”的个数为偶数</p>
</li>
</ol>
<p>奇偶校验码特点：只能检查出奇数个比特错误，检错能力为50%</p>
</li>
<li><p>CRC循环冗余码</p>
<ol>
<li><p>发送端最终发送的数据：要发送的数据+帧检验序列FCS</p>
<p>计算冗余码（FCS帧检验序列）</p>
<ol>
<li><p>第1步：加0  假设生成多项式G(x)的阶为r，则加r个0（多项式是n位，则阶是n-1位）</p>
<p>加0是为了不改变原发送数据，FSC帧检验直接跟在原发送数据的后面即可</p>
</li>
<li><p>第2步：模2除法。数据加0后除以多项式，余数就是冗余码FCS。</p>
<p>在除法过程中应该做减法的步骤，在模2除法中替换为异或</p>
</li>
</ol>
</li>
<li><p>接收端检错过程</p>
<p>把接收的每一帧都除以相同的除数（发送端的生成多项式），然后检查得到的除数R</p>
<ul>
<li>若R==0，判定这个帧没有差错，接受</li>
<li>若R!=0，判断这个帧有差错（无法确认到位），丢弃</li>
</ul>
</li>
<li><p>FCS的生成以及接收端CRC检验都是由硬件实现，处理很迅速，因此不会延误数据的传输。</p>
</li>
<li><p>在数据链路层仅仅使用循环冗余检验CRC差错检测技术，只能做到对帧的无比特差错接收，即“凡是接收端数据链路层接受的帧，我们都能以非常接近于1的概率认为这些帧在传输过程中没有产生差错”。</p>
<p>可以认为：“<strong>凡是接收端数据链路层接收的帧均无差错”</strong></p>
<p>接收端丢弃的帧虽然曾收到了，但是最终还是因为有差错被丢弃。</p>
</li>
<li><p>但是帧的无差错接受不是可靠传输，CRC循环冗余码只能检验出帧有错误并丢弃，但是不能对错误的帧进行校正。</p>
<p>可靠传输是指：数据链路层发送端发送什么，接收端就收到什么。</p>
</li>
</ol>
</li>
<li><p>海明码</p>
<ol>
<li><p>发现双比特错，纠正单比特错</p>
</li>
<li><p>工作原理：牵一发而动全身</p>
</li>
<li><p>工作流程</p>
<ol>
<li><p>确定校验码位数r</p>
<p>海明不等式：2^r &gt;= k+r+1  (r是冗余信息位，k为信息位)</p>
</li>
<li><p>确认校验码和数据的位置</p>
<p>校验码只能填在2的n次方的位置（包括第一个位置）</p>
<p>原码按顺序插入</p>
</li>
<li><p>求出校验码的值</p>
<p>首先将数据位从低位到高位按1，2，3…进行编号，然后将编号用二进制表示，记录二进制表示中的第n位为1的数据位，令这些数据位上的上的数据异或=0，则Pn即为所求这些数据位上包括Pn，则公式可以改进为：Pn=这些数据位除了Pn之外异或（原理：相同异或为零）</p>
<p>补充：异或的性质</p>
<ol>
<li><p>任意二进制数与0异或之后是本身</p>
</li>
<li><p>任意二进制数与1异或之后是取反</p>
</li>
<li><p>偶数个1异或是0（2 * k个1，即在1的基础上进行2 * k-1次取反操作），</p>
<p>奇数个1异或是1（2 * k+1个1，即在1的基础上进行2 * k次取反操作），</p>
<p>无论0有多少个</p>
</li>
</ol>
</li>
<li><p>检错并纠错</p>
<p>记录二进制表示中的第n位为1的数据位，求这些数据位上的上的数据异或，则Jn即为所求<br>J=JN…J1J2将J转换为十进制JT，即第JT位发生错误</p>
</li>
</ol>
</li>
<li><p>比如：D=101101</p>
<ol>
<li><p>第1步：先求出校验码的位数：2^4=16&gt;=4+6+1,所以校验码为4位</p>
</li>
<li><p>第2步：按位数分别给校验码、原码编号，原码一共有6位，即编号为：D6 D5 D4 D3 D2 D1</p>
<p>校验码一共有4位，即编号为P4 P3 P2 P1</p>
<p>校验码和原码的位置分配：D6   D5   P4   D4   D3   D2   P3   D1   P2   P1</p>
<p>​                            位置编号 10   9    8    7    6    5    4    3    2    1<br>​            位置二进制编码 1010 1001 1000 0111 0110 0101 0100 0011 0010 0001  </p>
</li>
<li><p>第3步：求P1，D5 D4 D2 D1 P1的位置编码的第一位是1，所以令D5 D4 D2 D1 P1的异或=0，求出P1</p>
<p>Pn的求法同理，先把能求的求出来，最后把之前不能求的再求出来</p>
<p>求得：P1=P2=P3=0，P4=1</p>
</li>
<li><p>第4步：求得海明码1011100100</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>脑图：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/51.png" alt="在这里插入图片描述"></p>
<h3 id="3-1-4-、流量控制与可靠传输机制"><a href="#3-1-4-、流量控制与可靠传输机制" class="headerlink" title="3.1.4 、流量控制与可靠传输机制"></a>3.1.4 、流量控制与可靠传输机制</h3><ol>
<li><p>数据链路层的流量控制</p>
<ol>
<li><strong>较高的发送速度</strong>和<strong>较低的接收能力</strong>的不匹配，会造成传输出错，因此流量控制也是数据链路层的一项重要工作</li>
<li>流量控制在<strong>传输层</strong>也有</li>
<li>链路层与传输层流量控制的区别：<ol>
<li><strong>数据链路层</strong>的流量控制是<strong>点对点</strong>的，而<strong>传输层</strong>的流量控制是<strong>端到端</strong>的。</li>
<li><strong>数据链路层</strong>流量控制的手段：<strong>接收方收不下就不回复确认</strong></li>
<li><strong>传输层</strong>流量控制手段：<strong>接收端给发送端一个窗口公告</strong></li>
</ol>
</li>
</ol>
</li>
<li><p>流量控制的方法</p>
<ol>
<li><p>停止等待协议（也可以算是一个特殊的滑动窗口协议，这种协议内发送和接收窗口都是1）</p>
<p>每发送完一个帧就停止发送，等待对方的确认，在收到确认后再发送下一个帧。</p>
<p>效率低</p>
<p>发送窗口大小=1，接收窗口大小=1;窗口大小固定</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/52.png" alt="在这里插入图片描述"></p>
</li>
<li><p>滑动窗口协议</p>
<ol>
<li><p>后退N帧协议（GBN）</p>
<p>发送窗口大小&gt;1，接收窗口大小=1;窗口大小固定</p>
</li>
<li><p>选择重传协议（SR）</p>
<p>发送窗口大小&gt;1，接收窗口大小&gt;1;窗口大小固定</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>可靠传输、滑动窗口、流量控制概念解析</p>
<ol>
<li>可靠传输：发送端发啥，接收端收啥</li>
<li>流量控制：控制发送速率，使接收方有足够的换种空间来接收每一帧。</li>
<li>滑动窗口是解决流量控制（收不下就不给确认，想发也发不了）和可靠传输（发送方自动重传）的方式</li>
</ol>
</li>
</ol>
<h4 id="3-1-4-1、-停止-等待协议"><a href="#3-1-4-1、-停止-等待协议" class="headerlink" title="3.1.4.1、 停止-等待协议"></a>3.1.4.1、 停止-等待协议</h4><ol>
<li><p>停止-等待协议究竟是哪一层？</p>
<p>在早期的计算机网络中，由于通信链路质量差，出现差错比较多，为了提高传输效率，数据链路层应该承担一部分可靠传输的任务，把停止-等待协议放在了数据链路层。</p>
<p>在现在的计算机网络中，通信链路质量大大提高，出现差错的情况很少，不用承担可靠传输的任务，提高了通信速度，降低了延迟。</p>
<p>把<strong>停止-等待协议放在了传输层</strong>，<strong>链路层则主要负责差错控制</strong>。</p>
</li>
<li><p>为什么要有停止-等待协议？</p>
<ol>
<li><p>除了<strong>比特出差错</strong>，底层信道还会出现丢包问题</p>
<p>丢包：物理线路故障、设备故障、病毒攻击、路由信息错误等原因会导致数据包的丢失<br>（数据包其实就是一个数据，在<strong>数据链路层叫帧</strong>，在<strong>网络层就叫IP数据报或者分组</strong>，在<strong>传输层也可以叫报文段</strong>）</p>
</li>
<li><p>为了解决丢包问题（可靠控制）和流量控制就出现了停止-等待协议</p>
</li>
</ol>
</li>
<li><p>研究停止等待协议的前提？</p>
<ol>
<li>虽然现在常用全双工通信方式，但为了讨论问题方便，仅考虑一方发送数据（发送方），一方接收数据（接收方）</li>
<li>因为是在讨论可靠传输的原理，所以并不考虑数据是在哪一层次上传送的</li>
<li>“停止-等待”就是每发送完一个分组就停止发送没等待对方确认，在收到确认后再发送下一个分组。</li>
</ol>
</li>
<li><p>停止等待协议有几种应用情况？</p>
<ol>
<li><p>无差错情况</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/57.png" alt="image-20210409211423472"></p>
</li>
<li><p>有差错情况</p>
<ol>
<li><p>数据帧丢失和检测到帧出错</p>
<ol>
<li><p>超时计时器：每发送一个帧就启动一个计时器</p>
</li>
<li><p>如果在计时器到期之前收到了确认帧，则计时器终止。</p>
<p>如果计时器到期了还没有收到确认帧，则发送方会重新发送没收到确认帧的数据帧</p>
</li>
<li><p>超时计时器设置的重传时间应当比帧传输的平均RTT（往返传播时延）更长一些</p>
</li>
<li><p>注意事项</p>
<ol>
<li>发送完一个帧后，必须保留它的副本。</li>
<li>数据帧和确认帧必须编号</li>
</ol>
</li>
</ol>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/58.png" alt="image-20210409211646062"></p>
</li>
<li><p>ACK丢失（确认帧丢失）</p>
<p>发送方超时计时器到期后没有收到确认帧，发送方重传数据帧</p>
<p>接收方收到了重复的数据帧，丢弃重复的数据帧，并重传确认帧</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/59.png" alt="image-20210409211747811"></p>
</li>
<li><p>ACK迟到（确认帧迟到）</p>
<p>超时还没收到确认帧则重传数据帧，接收方收到了重复的数据帧，并丢弃重复的数据帧</p>
<p>发送方之后在等待另一个确认帧时，收到了迟到的确认帧，会不对迟到的数据帧做处理</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/60.png" alt="image-20210409211901849"></p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>停止-等待协议性能分析</p>
<ol>
<li><p>优点：简单</p>
</li>
<li><p>缺点：信道利用率太低</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/61.png" alt="image-20210409212059380"></p>
<p>信道利用率：发送方在一个发送周期内，有效地发送数据所需要的时间占整个发送周期的比率信道利用率 = （L/C）/ T</p>
<ul>
<li>L：T内发送L比特数据</li>
<li>C：发送方数据传输率</li>
<li>T：发送周期，从发送数据开始，到收到第一个确认帧为止（一般包括发送时间和RTT，接收数据帧的时间可以忽略）</li>
</ul>
<p>信道吞吐率 = 信道利用率 * 发送方的发送速率</p>
</li>
</ol>
<p>例题：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/62.png" alt="image-20210409212300872"></p>
</li>
</ol>
<p>脑图：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/63.png" alt="image-20210409212332589"></p>
<h4 id="3-1-4-2-、后退N帧协议（GBN）"><a href="#3-1-4-2-、后退N帧协议（GBN）" class="headerlink" title="3.1.4.2 、后退N帧协议（GBN）"></a>3.1.4.2 、后退N帧协议（GBN）</h4><p>停止等待协议的弊端：信道利用率太低，太闲了。</p>
<p>采用流水线技术对停止-等待协议（一个数据帧跟着数据帧发送）进行改进。</p>
<p>使用流水线技术后：    </p>
<ol>
<li>必须增加数据帧序号的范围</li>
<li>发送方需要缓存多个分组</li>
</ol>
<p>所以出现了<strong>后退N帧协议（GBN）</strong>和<strong>选择重传协议（SR）</strong></p>
<ol>
<li><p>后退N帧协议中的滑动窗口</p>
<p>发送窗口：发送方维持一组连续的允许发送的帧的序号</p>
<p>接收窗口：接收方维持一组连续的允许接收帧的序号。</p>
<p>​    在后退N帧协议中，接收窗口只有一个</p>
<p>​    在选择重传协议中，接收窗口有多个</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/64.png" alt="image-20210409213121135"></p>
</li>
<li><p>后退N帧协议执行过程</p>
<ol>
<li><p>GBN发送方必须响应的三件事</p>
<ol>
<li><p>上层(网络层)的调用</p>
<p>上层要发送数据时，发送方先检查发送窗口是否已满，如果<strong>未满</strong>，则产生一个帧并将其发送；</p>
<p>如果窗口已满，发送方只需将数据返回给上层，暗示上层<strong>窗口已满</strong>。上层等一会再发送（实际实现中，发送方可以缓存这些数据，窗口不满时再发送帧。）</p>
</li>
<li><p>收到了一个ACK</p>
<p>GBN协议中，对n号帧的确认采用<strong>累计确认</strong>的方式，标明接收方已经收到n号帧和它之前的全部帧。</p>
<p>累计确认：例如：接收方返回了一个对于3号帧的确认帧，而数据帧的编号也是从0号开始的（0/1/2/3/4/….）。如果接收方将一个3号帧对应的确认帧给发送方。发送方就知道接收方已经接收到3号帧以及3号帧以前的所有的帧（0/1/2帧）。也就是说0到3号帧接收方已经完全接收了。这就是累积确认方式。</p>
<p>也就是说，在GBN协议当中，接收方不用对于每一个数据帧都逐个返回一个对应的确认帧。他可以隔一会在发送一个确认帧。它这个确认帧就是想告诉发送方：包括这个帧，以及这个帧以前的所有帧，它都已经全部正确接收了。</p>
</li>
<li><p>超时事件</p>
<p>协议的名字为后退N帧/回退N帧，来源于出现丢失和时延过长帧时发送方的行为。就像在停等协议中一样，定时器将再次用于恢复数据帧或确认帧的丢失。如果出现超时，发送方重传所有已发送但未被确认的帧。</p>
</li>
</ol>
</li>
<li><p>GBN接收方要做的事</p>
<p>如果正确收到n号帧，并且按序，那么接收方为n帧发送一个ACK，并将该帧中的数据部分交付给上层。</p>
<p>其余情况都丢弃帧，并为最近按序接收的帧重新发送ACK。接收方无需缓存任何失序帧，只需要维护一个信息: expectedseqnum(下一个按序接收的帧序号）。</p>
<p>即：接收方很专一，如果没有接收到对应帧的到来，后面的帧即使到了也会被丢弃</p>
</li>
<li><p>示意图</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/54.png" alt="在这里插入图片描述"></p>
</li>
</ol>
</li>
<li><p>滑动窗口长度可以无限长吗？</p>
<p>若采用n个比特对帧编号，那么发送窗口的尺寸WT,应满足：1 &lt;= W &lt;= 2^n-1。因为发送窗口尺寸过大，就会使得接收方无法区别新帧和旧帧（新帧与旧帧的帧编号相同）。</p>
</li>
<li><p>GBN协议重点总结</p>
<ol>
<li><strong>累计确认</strong>（偶尔捎带确认，接收方把确认帧放在了接收方要发给发送方的数据里）</li>
<li>接收方只按顺序接收帧，不按序无情丢弃</li>
<li>确认序列号最大的，按序到达的帧</li>
<li><strong>发送窗口最大为2^n-1，接收窗口大小为1</strong></li>
</ol>
<p>例题：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/65.png" alt="image-20210409215055723"></p>
</li>
<li><p>GBN协议性能分析</p>
<ol>
<li><p>优点：因连续发送数据帧而提高了信道利用率</p>
</li>
<li><p>缺点：在重传时，必须把原来已经正确传送的数据帧重传，使得传送效率降低</p>
<p>选择<strong>重传协议</strong>可以解决这个缺点</p>
</li>
</ol>
</li>
</ol>
<p>脑图：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/66.png" alt="image-20210409215131878"></p>
<h4 id="3-1-4-3-、选择重传协议（SR）"><a href="#3-1-4-3-、选择重传协议（SR）" class="headerlink" title="3.1.4.3 、选择重传协议（SR）"></a>3.1.4.3 、选择重传协议（SR）</h4><p>GBN协议的弊端：累计确认—&gt;批量重传。</p>
<p>可不可以只重传出错的帧？</p>
<p>解决办法：设置单个确认，同时加大接收窗口，设置接收缓存，缓存乱序到达的帧。</p>
<ol>
<li><p>选择重传协议中的滑动窗口示意图</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/55.png" alt="在这里插入图片描述"></p>
</li>
<li><p>SR发送方必须响应的三件事</p>
<ol>
<li><p>上层的调用</p>
<p>从上层收到数据后，SR发送方检查下一个可用于该帧的序号，如果序号位于发送窗口内，则发送数据帧;</p>
<p>否则就像GBN一样，要么<strong>将数据缓存</strong>，要么<strong>返回给上层</strong>之后再传输。</p>
</li>
<li><p>收到了一个ACK</p>
<p>如果<strong>收到ACK</strong>，加入该帧序号在窗口内，则SR发送方将那个被确认的帧标记为已接收。</p>
<p>如果该帧序号是窗口的下界（最左边第一个窗口对应的序号），则窗口向前移动到具有最小序号的未确认帧处。</p>
<p>如果窗口移动了并且有序号在窗白内的未发送帧，则发送这些帧。</p>
</li>
<li><p>超时事件</p>
<p>每一个帧都有自己的定时器，一个超时事件发生后<strong>只重传一个帧</strong>。</p>
<p>哪个帧的超时器超时，则重传哪个帧</p>
</li>
</ol>
</li>
<li><p>SR接收方要做的事情</p>
<ol>
<li><p>窗口内的帧来者不拒</p>
</li>
<li><p>SR接收方将确<strong>认一个正确接收的帧</strong>而<strong>不管其是否按序</strong>。</p>
<p>失序的帧将被<strong>缓存</strong>，并返回给发送方一个该帧的确认帧【<strong>收谁就确认谁</strong>】，直到失序前面所有帧（即序号更小的帧）皆被接收到为止，这时才可以将一批帧按序交付给上层，然后<strong>向前滑动窗口</strong>。</p>
</li>
<li><p>如果收到了窗口序号外（小于窗口下界）的帧，就返回一个ACK</p>
</li>
<li><p>其他情况就忽略该帧</p>
</li>
</ol>
</li>
<li><p>SR协议运行过程示意图</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/56.png" alt="在这里插入图片描述"></p>
</li>
<li><p>滑动窗口长度可以无限长吗？</p>
<ol>
<li><p>发送窗口大小最好等于接收窗口（大了会溢出，小了没意义）</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/67.png" alt="image-20210409223428612"></p>
</li>
<li><p>WTmax=WRmax=2^(n-1)</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/68.png" alt="image-20210409223645651"></p>
</li>
</ol>
</li>
<li><p>SR协议重点总结</p>
<ol>
<li>对数据帧逐一确认，收一个确认一个</li>
<li>只重传出错帧</li>
<li>接收方有缓存</li>
<li>WTmax=WRmax=2^(n-1)</li>
</ol>
</li>
</ol>
<p>例题:</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/69.png" alt="image-20210409223859479"></p>
<p>脑图：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/70.png" alt="image-20210409223919103"></p>
<h3 id="3-2-1-、信道划分介质访问控制"><a href="#3-2-1-、信道划分介质访问控制" class="headerlink" title="3.2.1 、信道划分介质访问控制"></a>3.2.1 、信道划分介质访问控制</h3><ol>
<li><p>传输数据使用的两种链路</p>
<ol>
<li><p>点对点链路</p>
<p>两个相邻节点通过一个链路相连，没有第三者。</p>
<p>应用：<strong>PPP协议</strong>，<strong>常用于广域网</strong>。</p>
</li>
<li><p>广播式链路</p>
<p>所有主机共享通信介质。</p>
<p>应用：早期的总线以太网、无线局域网，<strong>常用于局域网</strong></p>
<p>典型拓扑结构：总线型、星型（逻辑总线型）</p>
</li>
</ol>
</li>
<li><p>介质访问控制</p>
<p>介质访问控制的内容就是，采取一定的措施，使得两对界限之间的通信不会发生相互干扰的情况</p>
<p>介质访问控制分类</p>
<ol>
<li><p>静态划分信道，即信道划分介质访问控制（C!WTF）</p>
<ol>
<li>频分多路复用FDM（frequency）</li>
<li>时分多路复用TDM（time）</li>
<li>波分多路复用WDM（wave）</li>
<li>码分多路复用CDM（code）</li>
</ol>
</li>
<li><p>动态分配信道</p>
<ol>
<li><p>轮询访问介质访问控制</p>
<p>令牌传递协议</p>
</li>
<li><p>随机访问介质访问控制</p>
<ol>
<li>ALOHA协议</li>
<li>CSMA协议</li>
<li>CSMA/CD协议（重要）</li>
<li>CSMA/CA协议（重要）</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>信道划分介质访问控制</p>
<p>将使用介质的每个设备与来自同一信道上的其他设备的<strong>通信隔离开</strong>，把<strong>时域和频域资源</strong>合理地分配给网络上的设备</p>
<ol>
<li><p>多路复用技术</p>
<p>把多个信号组合放在一条物理信道上进行传输，使得多个计算机或终端设备<strong>共享信道资源</strong>，提高信道利用率</p>
<p>把一条广播信道，逻辑上分成几条用于两个节点之间通信的互不干扰的子信道，<strong>实际就是把广播信道转变为点对点信道</strong>。</p>
<p>图示：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/71.png" alt="在这里插入图片描述"></p>
</li>
<li><p>静态划分信道（信道划分介质访问控制）</p>
<ol>
<li><p>频分多路复用FDM</p>
<ol>
<li><p>概念：</p>
<p>用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</p>
<p><strong>频分复用的所有用户在同样的时间占用不同的带宽（频率带宽）资源。</strong></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/75.png" alt="image-20210410023214368"></p>
</li>
<li><p>优点：充分利用传输介质带宽，系统效率更高；由于技术比较成熟，实现也比较容易。</p>
</li>
</ol>
</li>
<li><p>时分多路复用TDM</p>
<ol>
<li><p>概念：</p>
<p>将时间划分为一段段等长的时分复用帧（TDM帧）。</p>
<p>每一个时分复用的用户在每一个TDM帧中占用<strong>固定序号的时隙</strong>，所有用户轮流占用信道。</p>
<p>TDM帧与数据链路层的帧不同，<strong>TDM帧是在物理层传送的比特流所划分的帧，标志一个周期</strong>(cpu的时间片轮转)。</p>
</li>
</ol>
<p>这一个周期对应的是在一个周期内可以发送多少个比特。</p>
<ol start="2">
<li><p>频分复用——“并行”</p>
<p>时分复用——“并发”</p>
</li>
<li><p>改进的时分复用——统计时分复用STDM(增加了信道的利用率)</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/72.png" alt="在这里插入图片描述"></p>
</li>
</ol>
</li>
<li><p>波分多路复用WDM</p>
<p>概念：波分多路复用就是<strong>光的频分多路复用</strong>，在一根光纤中传输多种不同波长（频率）的光信号，由于波长（频率)不同，所以各路光信号互不干扰，最后再用波长分解复用器将各路波长分解出来。</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/76.png" alt="image-20210410023757326"></p>
</li>
<li><p>码分多路复用CDM</p>
<p>注意：码分多址（CDMA）是码分复用的一种方式，注意与码分多路复用区分</p>
<ol>
<li><p>概念：<br>把1个比特分为多个码片/芯片（chip），每一个站点被指定一个唯一的m位（m位通常是128位或64位）的芯片序列发送1时，站点发送送芯片序列，发送0时发送芯片序列的反码（在芯片序列中，把0写成-1，正交的码片，CDM原理是利用向量正交为0）</p>
</li>
<li><p>如何不打架：多个站点同时发送数据的时候，要求各个站点芯片序列<strong>相互正交</strong>（<strong>规格内积化是0</strong>）</p>
<p>规格内积化：将对应的各位相乘，然后相加，最后在除于总的位数。</p>
</li>
<li><p>如何合并：各路数据在信道中被<strong>线性相加</strong>（对应的各个位进行相加）</p>
</li>
<li><p>如何分离：合并数据和原站（芯片序列 ）规格化内积</p>
</li>
</ol>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/77.png" alt="image-20210410024814953"></p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="3-2-2-、随机访问介质访问控制"><a href="#3-2-2-、随机访问介质访问控制" class="headerlink" title="3.2.2 、随机访问介质访问控制"></a>3.2.2 、随机访问介质访问控制</h3><p><strong>动态分配信道，也叫动态媒体接入控制/多点接入</strong>。</p>
<p>特点：信道<strong>并非</strong>在用户通信时<strong>固定</strong>分配给用户。</p>
<p>随机访问介质访问控制：所有用户可以随机发送信息，发送信息时占<strong>全部带宽</strong>。（不协调 =》冲突 =》 协议解决）</p>
<ul>
<li>ALOHA协议 不听就说</li>
<li>CSMA协议 先听再说</li>
<li>CSMA/CD协议（重要） 先听再说，边听边说</li>
<li>CSMA/CA协议（重要）</li>
</ul>
<h4 id="1、ALOHA协议"><a href="#1、ALOHA协议" class="headerlink" title="1、ALOHA协议"></a>1、ALOHA协议</h4><p>ALOHA协议（非重点）</p>
<ol>
<li><p>纯ALOHA协议</p>
<ol>
<li><p>思想：不监听信道，不按时间槽发送，随机重发。（想发就发）</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/78.png" alt="image-20210410025200886"></p>
<p>其中T0规定的是一个数据帧的长度。（一般一个数据帧的长度都是用比特来衡量，这里用T0衡量是什么意思呢？）T0指的是这样一个数据帧的发送时间。这里面的发送时间既包括传输时间，也包括传播时间。也就是一个数据帧从刚开始发送到发送成功为止的这样一段时间就叫做T0。</p>
</li>
<li><p>冲突如何检测？</p>
<p>如果发生冲突，接收方就会检测出差错，然后发送否定确认帧或者不发送确认帧，发送方在一定时间内收不到确认帧就判断冲突。</p>
</li>
<li><p>冲突如何解决？</p>
<p>超时后等一随机时间再重传。</p>
</li>
</ol>
</li>
<li><p>时隙ALOHA协议</p>
<p>思想：把时间分成若干个相同的时间片（T0，也可以叫做时间槽），所有用户的时间片开始时刻同步接入网络信道，若发生冲突，则必须等到下一个时间片开始时刻再发送。（控制想发就发的随意性）</p>
<p>主要特点：</p>
<ul>
<li>每一个站点在发送帧的时候，只能在一个时间片/时间槽的开始来发送</li>
<li>若站点当前想要发送数据帧，但是还没到一个时间片的开始，那么站点就会等待一个时间片的到来之后在进行发送</li>
<li>如果数据帧在发送过程中发生碰撞，那么这个结点就会在时隙结束之后，也就是经过一个T0之后，发送方发现了这样一个碰撞（接收方没有返回一个确认帧），发送方就判定数据在发送过程中发生了冲突。于是发送方进行超时重传。</li>
<li>发送方进行超时重传是依旧遵循之前的协议。在一个时隙（时间片）开始的时候来重传数据帧</li>
</ul>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/79.png" alt="image-20210410030015295"></p>
</li>
<li><p>关于ALOHA协要知道的事</p>
<ol>
<li>纯ALOHA比时隙ALOHA吞吐量更低，效率更低</li>
<li>纯ALOHA想发就发，时隙ALOHA只有在时间片段开始时才能发</li>
<li>不冲突概率=p(1-p)^2(N-1) = 1/2e，而时隙ALOHA只考虑一个时隙开始时，所以时隙ALOHA的效率是纯ALOHA效率的两倍</li>
</ol>
</li>
</ol>
<h4 id="2、CSMA协议"><a href="#2、CSMA协议" class="headerlink" title="2、CSMA协议"></a>2、CSMA协议</h4><ol>
<li><p>名词详解</p>
<p>载波监听多路访问协议CSMA（carrier sense multiple access）</p>
<ul>
<li><p>CS：载波侦听/监听，每一个站在发送数据之前要检测一下总线上是否有其他计算机在发送数据。</p>
<ul>
<li><p>如何监听？</p>
<p>当几个站同时在总线上发送数据时，总线上的信号<strong>电压摆动值</strong>将会增大（互相叠加)。当一个站检测到的信号电压摆动值超过一定门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞，即发生了冲突。</p>
</li>
</ul>
</li>
<li><p>MA：多点接入，表示许多计算以多点接入的方式连接在一根总线上</p>
</li>
</ul>
</li>
<li><p>协议思想：发送帧之前，监听信道</p>
<p>监听结果：</p>
<ol>
<li>信道空闲：发送完整数据帧</li>
<li>信道忙：推迟发送<ul>
<li>1-坚持CSMA</li>
<li>非坚持CSMA</li>
<li>P坚持CSMA</li>
</ul>
</li>
</ol>
</li>
<li><p>1-坚持CSMA</p>
<ul>
<li><p>坚持是指：对于监听信道<strong>忙</strong>之后的坚持。</p>
</li>
<li><p>1-坚持CSMA思想：</p>
<p>如果一个主机要发送信息，那么它先监听信道。</p>
<ul>
<li>监听结果空闲，则不必等待直接发送</li>
<li>监听结果为<strong>忙，则一直监听，直到空闲马上传输</strong></li>
<li>如果有冲突（一段时间内未收到肯定回复），则等待一个随机长的时间再监听（等待随机长的时间这一点与ALOHA协议类似，后同），重复上述过程。</li>
</ul>
</li>
<li><p>优点：只要媒体空闲，站点就马上发送，避免了媒体利用率的丢失</p>
</li>
<li><p>缺点：假如有两个或两个以上的站点有数据要发送，冲突就不可避免</p>
<p>比如这多个站点全部采用1-坚持CSMA，则一检测到信道空闲，就会同时发送信息，就会发生冲突。</p>
</li>
</ul>
</li>
<li><p>非坚持CSMA</p>
<ol>
<li><p>非坚持CSMA思想：</p>
<p>如果一个主机要发送信息，那么它先监听信道。</p>
<ul>
<li>监听结果空闲，则不必等待直接发送</li>
<li>监听结果为<strong>忙，则等待以后随机时间之后再进行监听</strong>。</li>
</ul>
</li>
<li><p>优点：采用随机的重发延迟时间，可以减少冲突发生的可能性</p>
</li>
<li><p>缺点：可能存在大家都在延迟等待过程中，使得媒体仍可能处于空闲状态，媒体使用率低。</p>
</li>
</ol>
</li>
<li><p>P-坚持CSMA</p>
<ol>
<li><p>P-坚持是指：对于<strong>监听信道空闲</strong>的处理。</p>
</li>
<li><p>P-坚持CSMA的思想</p>
<p>如果一个主机要发送信息，那么它先监听信道。</p>
<ul>
<li><strong>空闲则以p概率直接传输，不必等待;概率1-p等待到下一个时间槽再传输。</strong></li>
<li>忙则等待下一个时隙开始才监听，故叫做持续监听，重复上述过程</li>
</ul>
</li>
<li><p>优点：既能像非坚持算法那样减少冲突，又能像1-坚持算法那样减少媒体空闲时间。</p>
</li>
<li><p>缺点：发生冲突后还是要坚持把数据帧发送完，造成了浪费（这是所有CSMA的缺点，1-坚持、非坚持、P-坚持CSMA都有的缺点）</p>
</li>
</ol>
<p>三种CSMA的对比（注意P-坚持CSMA不太一样）：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/81.png" alt="image-20210410032318214"></p>
</li>
</ol>
<h4 id="3、CSMA-CD协议（重要）"><a href="#3、CSMA-CD协议（重要）" class="headerlink" title="3、CSMA/CD协议（重要）"></a>3、CSMA/CD协议（重要）</h4><ol>
<li><p>大体思想：边发送数据，边监听信道，如果发生冲突就停止发送数据</p>
</li>
<li><p>名词详解</p>
<p>载波监听多点接入/CD（也叫碰撞检测CSMA） （carrier sense multiple access with collision detection）</p>
<p>CS：载波侦听/监听，每一个站点在<strong>发送数据之前</strong>以及<strong>发送数据时</strong>都要检测一下总线上是否有其他计算机在发送数据。</p>
<p>与CSMA不同的是：CSMA/CD在发送数据时也会监听信道</p>
<p>MA：多点接入，表示许多计算机以多点接入的方式连接在一根总线上。=》 <strong>总线型网络</strong></p>
<p>CD：碰撞检测（冲突检测），“<strong>边发送边监听</strong>”，应用于适配器边发送数据，边检测信道上信号电压的变化情况，以便判断自己在发送数据时，其他站是否也在发送数据。</p>
<p>应用于：<strong>半双工网络</strong></p>
<p>主要应用于<strong>总线式以太网</strong></p>
</li>
<li><p>为什么先监听后发送还会产生冲突？</p>
<p>因为：电磁波在总线上总是以有限的速率传播的。</p>
<p>传播时延对载波监听的影响：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/82.png" alt="image-20210410032912095"></p>
<p>假设：单程端到端传播时延：t    最迟多久才能知道自己发送的数据没和别人碰撞？</p>
<p>最多是两倍的总线到端的传播时延（2 * t），即总线的端到端的往返传播时延（2 * t）</p>
<p>只要经过2 * t时间还没有检测到碰撞，就能肯定这次发送不会发生碰撞。</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/83.png" alt="image-20210410033340427"></p>
</li>
<li><p>如何确定碰撞后的重传时机？</p>
<p>如果检测到碰撞立即重发会导致恶性循环：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/84.png" alt="image-20210410033509456"></p>
<p>截断二进制指数规避算法</p>
<ol>
<li><p>确定基本退避（<strong>推迟</strong>）时间为争用期2t</p>
</li>
<li><p>定义参数k,它等于<strong>重传次数</strong>，但k不超过10，即k=min[重传次数，10]。</p>
<ul>
<li>当重传次数不超过10时，k等于重传次数；</li>
<li>当重传次数大于10时，k就不再增大而一直等于10。</li>
</ul>
</li>
<li><p>从离散的整数集合[0,1,…,2^k-1]中随机取出一个数r，重传所需要退避的时间就是<strong>r倍的基本退避时间</strong>，即2 * r * t。</p>
</li>
<li><p>当重传达<strong>16次</strong>（最大重传次数）仍不能成功时，说明网络太拥挤，认为此帧永远无法正确发出，抛弃此帧并向高层报告出错。</p>
<p>截断二进制指数规避算法使用示例</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/73.png" alt="在这里插入图片描述"></p>
</li>
</ol>
<p>例题：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/85.png" alt="image-20210410034142801"></p>
</li>
<li><p>最小帧长问题：</p>
<p>A站发了一个很短的帧，但是发生了碰撞，不过帧在发送完毕后才检测出发生碰撞，没法停止发送。为了使CSMA/CD协议有意义，要定义一个最小帧长。</p>
<p><strong>帧的传输时延至少要两倍于信号在总线中的传播时延</strong></p>
<p>帧的传输时延 = 帧长（bit）/ 数据传输率 &gt;= 2 * 总线传播时延</p>
<p>即：最小帧长 = 2 * 总线传播时延 * 数据传输速率 = 2 * t * 数据传输速率</p>
<p>补充：以太网规定最短帧长为<strong>64B</strong>，凡是长度小于64B的都是由于冲突而异常终止的无效帧。因此，以太网为了达到这个最小帧长，对于一个比较短的帧，它会对它进行一个<strong>填充</strong>操作，使它的帧长大于等于64B，然后才能将它放到链路上进行发送。</p>
<p>脑图：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/86.png" alt="image-20210410034655978"></p>
</li>
</ol>
<h4 id="4、CSMA-CA协议（重要）"><a href="#4、CSMA-CA协议（重要）" class="headerlink" title="4、CSMA/CA协议（重要）"></a>4、CSMA/CA协议（重要）</h4><p>CA：对碰撞的避免</p>
<p>CD：对碰撞的检测</p>
<ol>
<li><p>名词解释</p>
<ol>
<li><p>载波监听多点接入/CA（碰撞避免CSMA，不能检测碰撞）（carrier sense multiple access with collision avoidance）</p>
</li>
<li><p>为什么要有CSMA/CA？</p>
<p>主要是因为：CA主要应用于<strong>无线局域网</strong></p>
<ol>
<li><p>在无线局域网中无法使用CD协议，不能做到360度全面检测碰撞</p>
<ul>
<li>CD主要应用于总线式以太网</li>
</ul>
</li>
<li><p>隐蔽站问题，当A和C都检测不到信号，认为信道空闲时，同时向终端B发送数据帧，就会发生冲突。</p>
<p>C相对于A就是隐蔽站</p>
</li>
</ol>
</li>
<li><p>有礼貌的CSMA/CA：不光是先听后发，在听了之后，发送数据之前会等一小段时间。</p>
</li>
</ol>
</li>
<li><p>CSMA/CA工作原理</p>
<p>发送数据之前，先检测信道是否空闲。</p>
<p>若空闲则发出RTS（request to send），RTS包括发射端的地址、接收端的地址、下一份数据将持续发送的时间等信息；RTS可发可不发，<strong>发RTS是为了解决隐蔽站的问题</strong>。</p>
<p>若信道忙，则等待。接收端收到RTS后，将响应CTS（clear to send）</p>
<p>RTS和CTS就是用来解决隐蔽站的问题：</p>
<ul>
<li><p>发送端收到CTS后，开始发送数据帧（同时开始预约信道：发送方告知其他站点自己要传多久数据）</p>
</li>
<li><p>接收端收到数据帧后，将用CRC（CRC循环冗余检验）来检验数据是否正确，正确则响应ACK帧</p>
</li>
<li><p>发送方收到ACK就可以进行下一个数据帧的发送，若没有则一直重传至规定重发次数为止</p>
<p>（这里跟CD协议一样，采用二进制指数退避算法来确定随机的推迟时间。）</p>
</li>
</ul>
</li>
<li><p>三个机制实现碰撞避免</p>
<ol>
<li>预约信道</li>
<li>ACK帧</li>
<li>RTS/CTS帧（可选，主要是解决隐蔽站的问题）</li>
</ol>
</li>
<li><p>CD和CA协议的比较</p>
<ul>
<li><p>相同点：</p>
<p>CD和CA机制都从属于CDMA的思路，其核心就是<strong>先听再说</strong>。</p>
<p>换言之，两个在接入信道前都要进行监听。当发现信道空闲后，才能进行接入。</p>
</li>
<li><p>不同点：</p>
<ol>
<li>传输介质不同<ul>
<li>CD用于总线式以太网【有线】</li>
<li>CA用于无线局域网【无线】</li>
</ul>
</li>
<li>载波检测方式不同<ul>
<li>应传输介质不同，CD和CA的检测方式也不同。</li>
<li>CD通过电缆中电压的变化来检测，当数据发生碰撞时，电缆中的电压就会随着发生变化；</li>
<li>CA采用能量检测（ED）、载波检测（CS）和能量载波检测三种检测信道空闲的方式。</li>
<li><strong>CSMA/CD检测冲突</strong>，<strong>CSMA/CA避免冲突</strong>，两者出现冲突后都会进行<strong>有上限的重传。</strong></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="3-2-3-、轮询访问介质访问控制"><a href="#3-2-3-、轮询访问介质访问控制" class="headerlink" title="3.2.3 、轮询访问介质访问控制"></a>3.2.3 、轮询访问介质访问控制</h3><p>信道划分介质访问控制（MAC Multiple Access Control）协议：</p>
<ul>
<li>基于多路复用技术划分资源</li>
<li>网络负载重时，共享信道效率高，且公平</li>
<li>网络负载轻时：共享信道效率低</li>
</ul>
<p>随机访问MAC协议：</p>
<ul>
<li>用户根据意愿随机发送信息，发送信息时可独占信道带宽</li>
<li>网络负载重时，产生冲突开销</li>
<li>网络负载轻时，共享信道效率高，单个结点可利用信道全部带宽</li>
</ul>
<p>轮询访问MAC协议/轮流协议/轮转访问MAC协议：</p>
<p>综合信道划分介质访问控制协议和随机访问MAC协议，既不产生冲突，也要发送时占用全部带宽</p>
<ul>
<li><p>轮询协议</p>
<p>主结点轮流“邀请”从属结点发送数据</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504145458454-1620111300402.png" alt="image-20210504145458454"></p>
<p>问题：</p>
<ol>
<li>轮询开销</li>
<li>靠后结点有等待延迟</li>
<li>单点故障：主结点发生故障</li>
</ol>
</li>
<li><p>令牌传递协议（重要）</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504145553598-1620111355000.png" alt="image-20210504145553598"></p>
</li>
</ul>
<p>主机</p>
<p>TCU（转发器）</p>
<p>令牌：一个特殊格式的MAC控制帧，不含任何信息</p>
<p>控制信道的使用，确保同一时刻只有一个结点独占信道。</p>
<p>每一个结点都可以在一定的时间内（令牌持有时间内）获得发送数据的权利，并不是无限制地持有令牌</p>
<p>问题：</p>
<ol>
<li>令牌开销</li>
<li>等待延迟</li>
<li>单点故障（一个主机宕机后，线路故障）</li>
</ol>
<p>通常应用于令牌环网（物理星型拓扑，逻辑环形拓扑）</p>
<p>采用令牌传送方式的网络常用于负载较重、通信量较大的网络中。</p>
<p>介质访问控制总结：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504150943372-1620112185046.png" alt="image-20210504150943372"></p>
<h3 id="3-3-1-、局域网基本概念和体系结构"><a href="#3-3-1-、局域网基本概念和体系结构" class="headerlink" title="3.3.1 、局域网基本概念和体系结构"></a>3.3.1 、局域网基本概念和体系结构</h3><p>局域网（LAN，Local Area Network）</p>
<ol>
<li><p>概念：是指某一区域内由多台计算机互连成的计算机组，使用广播信道</p>
</li>
<li><p>特点</p>
<ol>
<li>覆盖地理范围小，只在一个相对独立的局部范围内联，如一座或集中的建筑群内。</li>
<li>使用专门铺设的传输介质（双绞线、同轴电缆）进行联网，数据传输速率高（10Mb/s-10Gb/s）</li>
<li>通信延迟时间短，误码率低，可靠性高</li>
<li>各站点为平等关系，共享传输信道</li>
<li>多采用分布式控制和广播式通信，能进行广播和组播</li>
</ol>
</li>
<li><p>决定局域网的主要要素为：<strong>网络拓扑</strong>，<strong>传播介质</strong>与<strong>介质访问控制方法</strong></p>
<ol>
<li><p>局域网的网络拓扑</p>
<ol>
<li><p>星型拓扑</p>
<p>中心节点是控制中心，任意两个节点间的通信最多只需两步，传输速度快，并且网络构形简单、建网容易、便于控制和管理。但这种网络系统，网络可靠性低，网络共享能力差，<strong>有单点故障问题</strong>。</p>
</li>
<li><p>总线型拓扑（常用）</p>
<p>网络可靠性高、网络节点间响应速度快、共享资源能力强、设备投入量少、成本低、安装使用方便，当某个工作站节点出现故障时，对整个网络系统影响小。</p>
</li>
<li><p>环形拓扑</p>
<p>系统中通信设备和线路比较节省。<strong>有单点故障问题</strong>；由于环路是封闭的，所以不便于扩充，系统响应延时长，且信息传输效率相对较低。</p>
</li>
<li><p>树形拓扑</p>
<p>易于拓展，易于隔离故障，也<strong>容易有单点故障。</strong></p>
</li>
</ol>
</li>
<li><p>局域网传输介质</p>
<ol>
<li>有线局域网 常用介质：双绞线、同轴电缆、光纤</li>
<li>无线局域网 常用介质：电磁波</li>
</ol>
</li>
<li><p>局域网介质访问控制方法</p>
<ol>
<li><p>CSMA/CD 常用于<strong>总线型局域网</strong>，也用于<strong>树型网络</strong></p>
</li>
<li><p>令牌总线常用于<strong>总线型局域网</strong>，也用于<strong>树型网络</strong></p>
<p>   它是把<strong>总线型或树型网络中的各个工作站按一定顺序如按接口地址大小排列形成一个逻辑环</strong>。只有令牌持有者才能控制总线，才有发送信息的权力。</p>
</li>
<li><p>令牌环 用于环形局域网，如<strong>令牌环网</strong></p>
<ul>
<li><strong>逻辑拓扑：环型</strong>（逻辑拓扑主要受通信思想的制约）</li>
<li><strong>物理拓扑：星型</strong>（物理拓扑主要受限制的制约）</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><p>局域网的分类</p>
<ol>
<li><p>以太网</p>
<p> 以太网是应用最广泛的局域网，包括标准以太网（10Mbps）、快速以太网（100Mbps）、千兆以太网（1000Mbps）和10G以太网，它们都符合IEEE 802.3系列标准规范。</p>
<p>逻辑拓扑总线型，物理拓扑是星型或拓展星型。使用CSMA/CD</p>
</li>
<li><p>令牌环网</p>
<p>造价高，不是很实用，已是明日黄花</p>
<p>物理拓扑星型，逻辑拓扑环型</p>
</li>
<li><p>FDDI网（Fiber Distributed Data Interface）（了解）</p>
<p>用的很少</p>
<p>物理双环拓扑，逻辑环型拓扑</p>
</li>
<li><p>ATM网（Asynchronous Transfer Mode）（了解）</p>
<p>较新型的单元交换技术，使用53字节固定长度的单元进行交换</p>
</li>
<li><p>无线局域网（Wireless Local Area Network，WLAN）</p>
<p>采用IEEE 802.11标准</p>
</li>
</ol>
</li>
<li><p>IEEE 802标准</p>
<p>IEEE802系列标准是IEEE802LAN/MAN标准委员会制定的局域网、城域网技术标准（1980年2月成立）其中最广泛使用的有以太网、令牌环网、无线局域网。这一系列标准中的每一个子标准都由委员会中的一个专门工作组负责。</p>
<ol>
<li><p><strong>IEEE802.3标准</strong></p>
<p><strong>以太网</strong>介质访问控制协议及物理层技术规范</p>
</li>
<li><p><strong>IEEE802.5标准</strong></p>
<p><strong>令牌环网</strong>的介质访问控制协议及物理层技术规范</p>
</li>
<li><p><strong>IEEE802.8标准</strong></p>
<p>光纤技术咨询组，提供有关光纤联网的技术咨询（<strong>FDDI网</strong>）</p>
</li>
<li><p><strong>IEEE802.11</strong></p>
<p><strong>无线局域网（WLAN）</strong>的介质访问控制协议及物理层技术规范</p>
</li>
</ol>
</li>
<li><p>MAC子层和LLC子层</p>
<p>IEEE802标准所描述的局域网参考模型只对应OSI参考模型的<strong>数据链路层和物理层</strong>，它将数据链路层划分为<strong>逻辑链路层LLC子层</strong>、<strong>介质访问控制MAC子层</strong>。</p>
<ol>
<li><p>LLC负责识别网络层协议，然后对它们进行封装。LLC报头告诉数据链路层一旦帧被接收到时，应当对数据包做何处理。</p>
<p>为网络层提供服务:无确认无连接、面向连接、带确认无连接、高速传送。</p>
</li>
<li><p>MAC子层的主要功能包括数据帧的封装/卸装，帧的寻址和识别，帧的接收与发送，链路的管理，帧的差错控制等。</p>
<p>MAC子层的存在屏蔽了不同物理链路种类的差异性。</p>
</li>
</ol>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504150742911-1620112064581.png" alt="image-20210504150742911"></p>
</li>
</ol>
<p>脑图</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504150832973-1620112114455.png" alt="image-20210504150832973"></p>
<h3 id="3-3-2、以太网概述"><a href="#3-3-2、以太网概述" class="headerlink" title="3.3.2、以太网概述"></a>3.3.2、以太网概述</h3><ol>
<li><p>概念</p>
<p>以太网(Ethernet)指的是由Xerox公司创建并由Xerox、Intel和DEC公司联合开发的基带总线局域网规范，是当今现有局域网采用的最通用的通信协议标准。<strong>以太网络使用CSMA/CD（载波监听多路访问及冲突检测）技术</strong>。</p>
</li>
<li><p>以太网在局域网各种技术中占<strong>统治地位</strong></p>
<ol>
<li>造价低廉（以太网网卡不到100块）</li>
<li>是应用最广泛的局域网技术</li>
<li>比令牌环网、ATM网便宜，简单</li>
<li>满足网络速率的要求，10Mbps-10Gbps</li>
</ol>
</li>
<li><p>以太网的两个标准</p>
<ol>
<li>DIX Ethernet V2：第一个局域网产品（以太网）规约。</li>
<li>IEEE802.3：IEEE802委员会802.3工作组制定的第一个IEEE的以太网标准</li>
</ol>
<p>这两个标准的区别不大，只是在帧的格式上有两个字节的差异，<br>因此只要满足两个标准中的一个都叫以太网，以太网也叫802.3局域网</p>
</li>
<li><p>以太网提供无连接、不可靠的服务</p>
<ul>
<li>无连接：发送方和接收方之间无“握手过程”。</li>
<li>不可靠：<ul>
<li>不对发送方的数据帧编号，</li>
<li>接收方不向发送方进行确认，</li>
<li>差错帧直接丢弃，</li>
<li>差错纠正由高层负责。</li>
</ul>
</li>
</ul>
<p><strong>以太网只实现无差错接受，不实现可靠传输</strong>。</p>
</li>
<li><p>以太网传输介质和拓扑结构的发展</p>
<ul>
<li>传输介质：粗同轴电缆–&gt;细同轴电缆–&gt;双绞线+集线器</li>
<li>物理拓扑：总线型–&gt;星型<ul>
<li>使用集线器的以太网在逻辑上仍是一个总线网，各站共享逻辑上的总线，使用的还是CSMA/CD协议</li>
</ul>
</li>
<li>以太网拓扑：逻辑上总线型，物理上星型</li>
</ul>
</li>
<li><p>10BASE-T以太网</p>
<ul>
<li>10BASE-T是传送基带信号的<strong>双绞线</strong>以太网，T表示采用双绞线，现10BASE-T采用的是无屏蔽双绞线(UTP），<strong>传输速率是10Mb/s</strong>。</li>
<li><strong>物理上采用星型拓扑、逻辑上总线型，每段双绞线最长100m</strong></li>
<li>采用<strong>曼彻斯特编码</strong></li>
<li>采用<strong>CSMA/CD</strong>介质访问控制</li>
</ul>
</li>
<li><p>适配器与MAC地址</p>
<ul>
<li>计算机与外界有局域网的连接是通过<strong>通信适配器</strong>的。<ul>
<li>网络接口板</li>
<li>网络接口卡NIC（network interface card），现在不再使用网卡</li>
<li>适配器上装有处理器和存储器（包括RAM和ROM）</li>
<li><strong>ROM上有计算机硬件地址MAC地址</strong></li>
</ul>
</li>
<li>在局域网中，<strong>硬件地址又称为物理地址</strong>，或<strong>MAC地址</strong>。【实际上是<strong>标识符</strong>】</li>
<li>MAC地址：每个适配器由全球唯一的二进制地址，前24位代表厂家（有IEEE规定），后24位厂家自己指定。常用<strong>6个十六进制数</strong>表示。即：这个是12个16进制数决定，前六位是厂家，后六位是各个网络制造商自己规定的。如02-60-8c-e4-b1-21</li>
</ul>
</li>
<li><p>以太网MAC帧</p>
<ul>
<li><p>最常用的MAC帧是<strong>以太网V2的格式</strong></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20200919000153735.png" alt="img"></p>
<ul>
<li>目的地址有三种情况<ul>
<li>单播地址，一个专有的MAC地址。传播给固定主机</li>
<li>广播地址：8B的前导码全”1”（二进制）,或者全”F”（十六进制）。会发生给所有主机</li>
<li>多播地址</li>
</ul>
</li>
</ul>
</li>
<li><p>与IEE 802.3的区别：</p>
<ol>
<li>第三个字段是长度/类型</li>
<li>当长度/类型字段值小于0x0600时，数据字段必须装入LLC子层。</li>
</ol>
</li>
</ul>
</li>
<li><p>高速以太网    </p>
<ol>
<li><p>100BASE-T以太网</p>
<ul>
<li><p>在<strong>双绞线</strong>上传送<strong>100Mb/s基带信号</strong>的<strong>星型拓扑以太网</strong>，仍使用IEEE802.3的<strong>CSMA/CD</strong>协议。</p>
</li>
<li><p>支持全双工和半双工，可在<strong>全双工方式下工作而无冲突</strong>（不使用CSMA/CD协议）。</p>
<ul>
<li><p>全双工（<strong>交换机可以隔离冲突域</strong>，每一个交换机的端口都是一个冲突域，一个主机在一个冲突域当中不存在冲突）</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504153357428-1620113639265.png" alt="image-20210504153357428"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>吉比特以太网</p>
<ul>
<li>在<strong>光纤或双绞线</strong>上传送<strong>1Gb/s信号</strong>。</li>
<li><strong>支持全双工和半双工，可在全双工方式下工作而无冲突</strong>。</li>
</ul>
</li>
<li><p>10吉比特</p>
<ul>
<li>10吉比特以太网在<strong>光纤</strong>上传送<strong>10Gb/s信号</strong>。</li>
<li>只支持全双工，无争用问题</li>
</ul>
</li>
</ol>
</li>
</ol>
<p>脑图</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504153615323-1620113777239.png" alt="image-20210504153615323"></p>
<h3 id="3-3-3、无线局域网"><a href="#3-3-3、无线局域网" class="headerlink" title="3.3.3、无线局域网"></a>3.3.3、无线局域网</h3><p>IEEE802.11是无线局与通信用的标准，它是由IEEE所定义的无线通信的标准</p>
<p>wifi是WLAN的一种应用，WLAN可以比较大。</p>
<p>802.11的MAC帧头格式</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504153957809.png" alt="image-20210504153957809"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504154046849.png" alt="image-20210504154046849"></p>
<p>总结一下：</p>
<ul>
<li>IBSS就是一个服务集内的移动站点不通过基站的直接通信</li>
<li>To AP 就是服务集内的移动站点向基站的通信</li>
<li>From AP 就是服务集内基站向移动站的通信</li>
<li>WDS就是不同服务集内的两个移动站之间的通信（漫游）</li>
</ul>
<p>无线局域网的分类：</p>
<ol>
<li><p><strong>有固定基础设施</strong>无线局域网</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504154529596.png" alt="image-20210504154529596"></p>
</li>
<li><p>无固定基础设施无线局域网的自组织网络</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504154658400.png" alt="image-20210504154658400"></p>
</li>
</ol>
<h3 id="3-3-4、PPP协议和HDLC协议"><a href="#3-3-4、PPP协议和HDLC协议" class="headerlink" title="3.3.4、PPP协议和HDLC协议"></a>3.3.4、PPP协议和HDLC协议</h3><p>广域网（WAN，Wide Area Network）通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个城市或国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络。</p>
<p>广域网的通信子网主要使用<strong>分组交换</strong>技术。广域网的通信子网可以利用公用分组交换网、卫星通信网和无线分组交换网，它将分布在不同地区的<strong>局域网或计算机系统</strong>互连起来，达到<strong>资源共享</strong>的目的。如因特网(Internet)是世界范围内最大的广域网。</p>
<p><strong>广域网强调资源共享，局域网强调数据传输</strong></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504154840374.png" alt="image-20210504154840374"></p>
<ol>
<li><p>PPP协议：</p>
<ol>
<li><p>点对点协议PPP（Point-to-Point Protocol）是目前使用最广泛的数据链路层协议，用户使用拨号电话接入因特网时一般都是用PPP协议</p>
<ul>
<li><strong>只支持全双工链路</strong></li>
</ul>
</li>
<li><p>PPP协议应满足的要求：</p>
<ul>
<li><strong>简单</strong> 对于链路层的帧，无需纠错，无需序号，无需流量传输</li>
<li><strong>封装成帧</strong> 帧定界符</li>
<li><strong>透明传输</strong> 与帧定界符一样比特组合的数据应该如何处理：<strong>异步线路用字节填充</strong>，<strong>同步线路用比特填充</strong></li>
<li><strong>多种网络层协议</strong> 封装的IP数据报可以采用多种协议</li>
<li><strong>多种类型链路</strong> 串行/并行，异步/同步，光/电</li>
<li><strong>差错检测</strong> 错就丢弃</li>
<li><strong>检测连接状态</strong> 链路是否正常</li>
<li><strong>最大传送单元</strong> 数据部分最大长度MTU(<strong>默认不超过1500B</strong>)</li>
<li><strong>网络层地址协商</strong> 知道通信双方的网络层地址</li>
<li><strong>数据压缩协商</strong></li>
</ul>
</li>
<li><p>PPP协议无需满足的要求：（纠流编多）</p>
<ul>
<li><strong>纠错</strong></li>
<li><strong>流量控制</strong></li>
<li><strong>对帧编序号</strong></li>
<li><strong>不支持多点线路</strong></li>
</ul>
</li>
<li><p>PPP协议的三个组成部分：</p>
<ol>
<li>一个将IP数据报封装到串行链路（同步串行/异步串行）的方法 </li>
<li>链路控制协议LCP：建立并维护数据链路连接。（物理连接）<ul>
<li>应用：身份验证</li>
</ul>
</li>
<li>网络控制协议NCP：PPP可支持多种网络层协议，每个不同的网络层协议都要一个相应的NCP来配置，为网络层协议建立和配置逻辑连接（逻辑连接）</li>
</ol>
</li>
<li><p>PPP协议的状态图</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20200919000226542.png" alt="img"></p>
</li>
<li><p>PPP协议的帧格式</p>
<ul>
<li><p>帧格式是什么东西?</p>
</li>
<li><p>还有MAC帧格式（以字节为单位）（7E\7D）</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20200919000236673.png" alt="img"></p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>HDLC协议</p>
<p>高级数据链路控制（High-Level Data Link Control或简称HDLC)，是一个在同步网上传输数据、<strong>面向比特</strong>的数据链路层协议，它是由国际标准化组织(<strong>ISO</strong>)根据IBM公司的SDLC(SynchronousData Link Control)协议扩展开发而成的。</p>
<p>数据报文可透明传输，用于实现透明传输的“0比特插入法”易于硬件实现</p>
<p><strong>采用全双工通信</strong></p>
<p><strong>所有帧采用CRC检验，对信息帧进行顺序编号</strong>，<strong>可防止漏收或重份，传输可靠性高</strong>。</p>
<p>HDLC的站：<strong>主站</strong>、<strong>从站</strong>、<strong>复合站</strong></p>
<ol>
<li>主站的主要功能是发送命令(包括数据信息)帧、接收响应帧，并负责对整个链路的控制系统的初启、流程的控制、差错检测或恢复等。</li>
<li>从站的主要功能是接收由主站发来的命令帧，向主站发送响应帧，并且配合主站参与差错恢复等链路控制。</li>
<li>复合站的主要功能是既能发送，又能接收命令帧和响应帧，并且负责整个链路的控制。</li>
</ol>
<p>HDLC的三种数据操作方式：</p>
<ol>
<li><p>正常响应方式</p>
<p>从站发送消息要经过主站的同意，主站命令从站发送数据，从站才可以发送数据</p>
</li>
<li><p>异步平衡方式</p>
<p>每一个复合站都可以对其他站的数据传输，每个站都是平等的地位</p>
</li>
<li><p>异步响应方式</p>
<p>从站可以不经过主站的同意就进行数据的传输</p>
</li>
</ol>
<p>HDLC的帧格式：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504160825465.png" alt="image-20210504160825465"></p>
<p>对于地址A：取决于当前选择的数据操作方式</p>
<ul>
<li>正常响应方式/异步响应方式：从站的地址</li>
<li>异步平衡方式：对应站（应答站），也就是对方的地址</li>
</ul>
<p>对于控制C：决定了HDLC帧的类型（无奸细）</p>
<ul>
<li><strong>信息帧(I)**：</strong>第1位为0<strong>，用来</strong>传输数据信息<strong>，或使用捎带技术</strong>对数据进行确认**;</li>
<li><strong>监督帧(S)**：</strong>10**, 用于<strong>流量控制和差错控制</strong>，执行<strong>对信息帧的确认、请求重发和请求暂停发送</strong>等功能</li>
<li><strong>无编号帧(U)**：</strong>11**, 用于提供对<strong>链路的建立、拆除</strong>等多种控制功能。</li>
</ul>
</li>
<li><p>PPP协议 &amp; HDLC协议</p>
<p>相同点：</p>
<ul>
<li>HDLC、PPP<strong>只支持全双工链路</strong></li>
<li>都可以实现差错检测，但不纠正差错</li>
<li>都可以<strong>实现透明传输</strong><ul>
<li>关于透明传输的一点小差别：<ul>
<li>PPP协议既可以实现0比特填充的比特型的填充方法，也可以实现字节填充的方法</li>
<li>HDLC协议只能实现0比特填充的比特型的填充方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>区别：</p>
<table>
<thead>
<tr>
<th>PPP协议</th>
<th>面向字节</th>
<th>2B协议字段</th>
<th>无序号和确认机制</th>
<th>不可靠</th>
</tr>
</thead>
<tbody><tr>
<td><strong>HDLC协议</strong></td>
<td><strong>面向比特</strong></td>
<td><strong>没有</strong></td>
<td><strong>有编号和确认机制</strong></td>
<td><strong>可靠</strong></td>
</tr>
</tbody></table>
</li>
</ol>
<p>   <img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504162250883.png" alt="image-20210504162250883"></p>
<p>脑图</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504162337180.png" alt="image-20210504162337180"></p>
<h3 id="3-4-1、链路层设备"><a href="#3-4-1、链路层设备" class="headerlink" title="3.4.1、链路层设备"></a>3.4.1、链路层设备</h3><h4 id="3-4-1-1、物理层扩展以太网"><a href="#3-4-1-1、物理层扩展以太网" class="headerlink" title="3.4.1.1、物理层扩展以太网"></a>3.4.1.1、物理层扩展以太网</h4><p>采用光纤的方式</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504162926611.png" alt="image-20210504162926611"></p>
<p>采用集线器的方式</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504163113104.png" alt="image-20210504163113104"></p>
<p>可以扩展以太网，但是集线器会无脑将一个设备的所有消息转发到集线器所连的所有设备，故会将所连接的<strong>所有设备</strong>变成一个大的冲突域，同时只能有两台设备进行通信，且设备越多，冲突越多。由此诞生了网桥</p>
<h4 id="3-4-1-2、数据链路层扩展以太网"><a href="#3-4-1-2、数据链路层扩展以太网" class="headerlink" title="3.4.1.2、数据链路层扩展以太网"></a>3.4.1.2、数据链路层扩展以太网</h4><p>采用网桥的方式：</p>
<p>网桥根据<strong>MAC帧</strong>的目的地址对帧进行<strong>转发</strong>和<strong>过滤</strong>。当网桥收到一个帧时，并不向所有接口转发此帧，而是先检查此帧的目的MAC地址，然后再确定将该帧转发到哪一个接口，或者是把它丢弃(即过滤)。</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504163354054.png" alt="image-20210504163354054"></p>
<p>网桥优点：</p>
<ul>
<li>过滤通信量，增大吞吐量。</li>
<li>扩大了物理范围。</li>
<li>提高了可靠性。</li>
<li>可互连不同物理层、不同MAC子层和不同速率的以太网。</li>
</ul>
<p>网桥的分类：</p>
<ul>
<li><p>透明网桥：“透明”指以太网上的站点并不知道所发送的帧将经过哪几个网桥，是一种即插即用设备——自学习。</p>
<ul>
<li><p>关于自学习</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504164127428.png" alt="image-20210504164127428"></p>
</li>
</ul>
</li>
<li><p>源路由网桥：在发送帧时，把详细的最佳路由信息( 路由最少/时间最短)放在帧的首部中。</p>
<p>方法：源站以广播方式向欲通信的目的站发送一个<strong>发现帧</strong>。</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504164759387.png" alt="image-20210504164759387"></p>
</li>
</ul>
<p>采用交换机的方法</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504165249409.png" alt="image-20210504165249409"></p>
<p>以太网交换机的两种交换方式：</p>
<ul>
<li>直通式交换机：查完目的地址(6B) 就立刻转发。<ul>
<li>优点：延迟小</li>
<li>缺点：可靠性低，无法支持具有不同速率的端口的交换。</li>
</ul>
</li>
<li>存储转发式交换机（常用）：将帧放入高速缓存，并检查否正确，正确则转发，错误则丢弃。<ul>
<li>优点：<strong>可靠性高，可以支持具有不同速率的端口的交换</strong>。</li>
<li>缺点：延迟大</li>
</ul>
</li>
</ul>
<p>冲突域 VS 广播域</p>
<ul>
<li>冲突域：在同一个冲突域中的每一个节点都能收到所有被发送的帧。简单的说就是<strong>同一时间内只能有一台设备发送信息的范围</strong>。</li>
<li>广播域：网络中能接收任一设备发出的广播帧的所有设备的集合。简单的说<strong>如果站点发出一个广播信号，所有能接收收到这个信号的设备范围称为一个广播域</strong>。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>能否隔离冲突域</th>
<th>能否隔离广播域</th>
</tr>
</thead>
<tbody><tr>
<td>物理层设备[傻瓜]<br>(中继器、集线器)</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>链路层设备[路人]<br>(网桥、交换机)</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>网络层设备[大佬]<br>(路由器)</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<p>相关例题：（广播域看路由器，冲突域：交换机每一个接口就是一个冲突域）</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504170220974.png" alt="image-20210504170220974"></p>
<p>脑图：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504170343115.png" alt="image-20210504170343115"></p>
<h3 id="3-5、第三章总结"><a href="#3-5、第三章总结" class="headerlink" title="3.5、第三章总结"></a>3.5、第三章总结</h3><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210504170510895.png" alt="image-20210504170510895"></p>
<h2 id="第四章-网络层"><a href="#第四章-网络层" class="headerlink" title="第四章 网络层"></a>第四章 网络层</h2><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2020070417434323.jpg" alt="img"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20200704174405272.jpg" alt="img"></p>
<h3 id="4-1、网络层的任务与功能"><a href="#4-1、网络层的任务与功能" class="headerlink" title="4.1、网络层的任务与功能"></a>4.1、网络层的任务与功能</h3><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505155309690.png" alt="image-20210505155309690"></p>
<h3 id="4-2、数据交换方式"><a href="#4-2、数据交换方式" class="headerlink" title="4.2、数据交换方式"></a>4.2、数据交换方式</h3><h4 id="1、网络的“掌中宝”——路由器"><a href="#1、网络的“掌中宝”——路由器" class="headerlink" title="1、网络的“掌中宝”——路由器"></a>1、网络的“掌中宝”——路由器</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505155454971.png" alt="image-20210505155454971"></p>
<h4 id="2、为什么要数据交换"><a href="#2、为什么要数据交换" class="headerlink" title="2、为什么要数据交换"></a>2、为什么要数据交换</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505155727387.png" alt="image-20210505155727387"></p>
<h4 id="3、数据交换的方式"><a href="#3、数据交换的方式" class="headerlink" title="3、数据交换的方式"></a>3、数据交换的方式</h4><p>数据交换可分为三种方式：</p>
<ul>
<li>电路交换</li>
<li>报文交换</li>
<li>分组交换<ul>
<li>数据报方式</li>
<li>虚电路方式</li>
</ul>
</li>
</ul>
<h4 id="4、电路交换"><a href="#4、电路交换" class="headerlink" title="4、电路交换"></a>4、电路交换</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505160852979.png" alt="image-20210505160852979"></p>
<h4 id="5、报文交换"><a href="#5、报文交换" class="headerlink" title="5、报文交换"></a>5、报文交换</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%5Cimage-20210517160352740.png" alt="image-20210517160352740"></p>
<h4 id="6、分组交换"><a href="#6、分组交换" class="headerlink" title="6、分组交换"></a>6、分组交换</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505161751869.png" alt="image-20210505161751869"></p>
<h4 id="7、报文交换-amp-分组交换"><a href="#7、报文交换-amp-分组交换" class="headerlink" title="7、报文交换 &amp; 分组交换"></a>7、报文交换 &amp; 分组交换</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505162605543.png" alt="image-20210505162605543"></p>
<h4 id="8、三种数据交换方式比较总结"><a href="#8、三种数据交换方式比较总结" class="headerlink" title="8、三种数据交换方式比较总结"></a>8、三种数据交换方式比较总结</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505162837182.png" alt="image-20210505162837182"></p>
<h4 id="9、数据报方式-amp-虚电路方式"><a href="#9、数据报方式-amp-虚电路方式" class="headerlink" title="9、数据报方式&amp;虚电路方式"></a>9、数据报方式&amp;虚电路方式</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505163608737.png" alt="image-20210505163608737"></p>
<h4 id="10、几种传输单元名词辨析"><a href="#10、几种传输单元名词辨析" class="headerlink" title="10、几种传输单元名词辨析"></a>10、几种传输单元名词辨析</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505164202246.png" alt="image-20210505164202246"></p>
<h4 id="11、数据报-应用于因特网"><a href="#11、数据报-应用于因特网" class="headerlink" title="11、数据报(应用于因特网)"></a>11、数据报(应用于因特网)</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505164423826.png" alt="image-20210505164423826"></p>
<h4 id="12、虚电路"><a href="#12、虚电路" class="headerlink" title="12、虚电路"></a>12、虚电路</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505164740761.png" alt="image-20210505164740761"></p>
<h4 id="13、数据报-amp-虚电路"><a href="#13、数据报-amp-虚电路" class="headerlink" title="13、数据报 &amp; 虚电路"></a>13、数据报 &amp; 虚电路</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505164918003.png" alt="image-20210505164918003"></p>
<h3 id="4-3-1、IP数据报格式"><a href="#4-3-1、IP数据报格式" class="headerlink" title="4.3.1、IP数据报格式"></a>4.3.1、IP数据报格式</h3><h4 id="1、TCP-IP协议栈"><a href="#1、TCP-IP协议栈" class="headerlink" title="1、TCP/IP协议栈"></a>1、TCP/IP协议栈</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505165458233.png" alt="image-20210505165458233"></p>
<h4 id="2、IP数据报格式"><a href="#2、IP数据报格式" class="headerlink" title="2、IP数据报格式"></a>2、IP数据报格式</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505165620439.png" alt="image-20210505165620439"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505171044015.png" alt="image-20210505171044015"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210517165201436.png" alt="image-20210517165201436"></p>
<h3 id="4-3-2、IP数据报分片"><a href="#4-3-2、IP数据报分片" class="headerlink" title="4.3.2、IP数据报分片"></a>4.3.2、IP数据报分片</h3><h4 id="1、最大传送单元MTU"><a href="#1、最大传送单元MTU" class="headerlink" title="1、最大传送单元MTU"></a>1、最大传送单元MTU</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505171323581.png" alt="image-20210505171323581"></p>
<h4 id="2、IP数据报格式——分片相关"><a href="#2、IP数据报格式——分片相关" class="headerlink" title="2、IP数据报格式——分片相关"></a>2、IP数据报格式——分片相关</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505171749113.png" alt="image-20210505171749113"></p>
<h4 id="3、IP数据报分片例题"><a href="#3、IP数据报分片例题" class="headerlink" title="3、IP数据报分片例题"></a>3、IP数据报分片例题</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505172207007.png" alt="image-20210505172207007"></p>
<h4 id="4、IP数据报格式——相关单位-一种八片首饰"><a href="#4、IP数据报格式——相关单位-一种八片首饰" class="headerlink" title="4、IP数据报格式——相关单位(一种八片首饰)"></a>4、IP数据报格式——相关单位(一种八片首饰)</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505172335655.png" alt="image-20210505172335655"></p>
<h3 id="4-3-3、IPv4地址"><a href="#4-3-3、IPv4地址" class="headerlink" title="4.3.3、IPv4地址"></a>4.3.3、IPv4地址</h3><h4 id="1、IP地址"><a href="#1、IP地址" class="headerlink" title="1、IP地址"></a>1、IP地址</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505172546692.png" alt="image-20210505172546692"></p>
<h4 id="2、IP编址的历史阶段"><a href="#2、IP编址的历史阶段" class="headerlink" title="2、IP编址的历史阶段"></a>2、IP编址的历史阶段</h4><ul>
<li>分类的IP地址</li>
<li>子网的划分</li>
<li>构成超网(无分类编址方法)</li>
</ul>
<h4 id="3、分类的IP地址"><a href="#3、分类的IP地址" class="headerlink" title="3、分类的IP地址"></a>3、分类的IP地址</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505172901070.png" alt="image-20210505172901070"></p>
<h5 id="1、互联网中的IP地址："><a href="#1、互联网中的IP地址：" class="headerlink" title="1、互联网中的IP地址："></a>1、互联网中的IP地址：</h5><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505173055123.png" alt="image-20210505173055123"></p>
<h5 id="2、分类的IP地址："><a href="#2、分类的IP地址：" class="headerlink" title="2、分类的IP地址："></a>2、分类的IP地址：</h5><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505173438999.png" alt="image-20210505173438999"></p>
<h5 id="3、特殊IP地址"><a href="#3、特殊IP地址" class="headerlink" title="3、特殊IP地址"></a>3、特殊IP地址</h5><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505173834400.png" alt="image-20210505173834400"></p>
<h5 id="4、私有IP地址"><a href="#4、私有IP地址" class="headerlink" title="4、私有IP地址"></a>4、私有IP地址</h5><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505174001052.png" alt="image-20210505174001052"></p>
<h5 id="5、分类IP使用个数"><a href="#5、分类IP使用个数" class="headerlink" title="5、分类IP使用个数"></a>5、分类IP使用个数</h5><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505192925617.png" alt="image-20210505192925617"></p>
<h3 id="4-3-4、网络地址转换NAT"><a href="#4-3-4、网络地址转换NAT" class="headerlink" title="4.3.4、网络地址转换NAT"></a>4.3.4、网络地址转换NAT</h3><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505193330114.png" alt="image-20210505193330114"></p>
<p>网络地址转换NAT：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505193808509.png" alt="image-20210505193808509"></p>
<h3 id="4-3-5、子网划分和子网掩码"><a href="#4-3-5、子网划分和子网掩码" class="headerlink" title="4.3.5、子网划分和子网掩码"></a>4.3.5、子网划分和子网掩码</h3><h4 id="1、子网划分"><a href="#1、子网划分" class="headerlink" title="1、子网划分"></a>1、子网划分</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505194037834.png" alt="image-20210505194037834"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505194204411.png" alt="image-20210505194204411"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505194311386.png" alt="image-20210505194311386"></p>
<h4 id="2、子网掩码"><a href="#2、子网掩码" class="headerlink" title="2、子网掩码"></a>2、子网掩码</h4><p>子网掩码：是为了区分网段的 掩码和主机号与主机号比较来判断属不属于该网段</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505194758394.png" alt="image-20210505194758394"></p>
<p>相关习题：</p>
<p>习题1：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505195105282.png" alt="image-20210505195105282"></p>
<p>习题2：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505200049573.png" alt="image-20210505200049573"></p>
<h4 id="3、使用子网时分组的转发"><a href="#3、使用子网时分组的转发" class="headerlink" title="3、使用子网时分组的转发"></a>3、使用子网时分组的转发</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505200430899.png" alt="image-20210505200430899"></p>
<h3 id="4-3-6、无分类编址CIDR"><a href="#4-3-6、无分类编址CIDR" class="headerlink" title="4.3.6、无分类编址CIDR"></a>4.3.6、无分类编址CIDR</h3><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505201051592.png" alt="image-20210505201051592"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505201235591.png" alt="image-20210505201235591"></p>
<h4 id="构成超网"><a href="#构成超网" class="headerlink" title="构成超网"></a>构成超网</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505201651932.png" alt="image-20210505201651932"></p>
<h4 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505202925728.png" alt="image-20210505202925728"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505203331296.png" alt="image-20210505203331296"></p>
<h3 id="4-3-7、ARP协议"><a href="#4-3-7、ARP协议" class="headerlink" title="4.3.7、ARP协议"></a>4.3.7、ARP协议</h3><h4 id="1、发送数据的过程"><a href="#1、发送数据的过程" class="headerlink" title="1、发送数据的过程"></a>1、发送数据的过程</h4><p>IP1向IP3发送数据：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505203902705.png" alt="image-20210505203902705"></p>
<p>IP1向IP5发送数据：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505212537717.png" alt="image-20210505212537717"></p>
<h4 id="2、ARP协议"><a href="#2、ARP协议" class="headerlink" title="2、ARP协议"></a>2、ARP协议</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505212854516.png" alt="image-20210505212854516"></p>
<p>ARP地址的相关习题</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505213228348.png" alt="image-20210505213228348"></p>
<h3 id="4-3-8、DHCP协议"><a href="#4-3-8、DHCP协议" class="headerlink" title="4.3.8、DHCP协议"></a>4.3.8、DHCP协议</h3><h4 id="1、主机如何获得IP地址"><a href="#1、主机如何获得IP地址" class="headerlink" title="1、主机如何获得IP地址?"></a>1、主机如何获得IP地址?</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505223656891.png" alt="image-20210505223656891"></p>
<h4 id="2、DHCP协议"><a href="#2、DHCP协议" class="headerlink" title="2、DHCP协议"></a>2、DHCP协议</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505224535421.png" alt="image-20210505224535421"></p>
<h3 id="4-3-9、ICMP协议"><a href="#4-3-9、ICMP协议" class="headerlink" title="4.3.9、ICMP协议"></a>4.3.9、ICMP协议</h3><h4 id="1、ICMP协议作用"><a href="#1、ICMP协议作用" class="headerlink" title="1、ICMP协议作用"></a>1、ICMP协议作用</h4><p>为了更有效地转发IP数据报和提高交付成功的机会</p>
<h4 id="2、网际控制报文协议ICMP"><a href="#2、网际控制报文协议ICMP" class="headerlink" title="2、网际控制报文协议ICMP"></a>2、网际控制报文协议ICMP</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505225626767.png" alt="image-20210505225626767"></p>
<h4 id="3、ICMP差错报告报文-5种"><a href="#3、ICMP差错报告报文-5种" class="headerlink" title="3、ICMP差错报告报文(5种)"></a>3、ICMP差错报告报文(5种)</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505225923078.png" alt="image-20210505225923078"></p>
<h4 id="4、ICMP差错报告报文数据字段"><a href="#4、ICMP差错报告报文数据字段" class="headerlink" title="4、ICMP差错报告报文数据字段"></a>4、ICMP差错报告报文数据字段</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505230122748.png" alt="image-20210505230122748"></p>
<h4 id="5、不应发送ICMP差错报文的情况"><a href="#5、不应发送ICMP差错报文的情况" class="headerlink" title="5、不应发送ICMP差错报文的情况"></a>5、不应发送ICMP差错报文的情况</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505230238989.png" alt="image-20210505230238989"></p>
<h4 id="6、ICMP询问报文"><a href="#6、ICMP询问报文" class="headerlink" title="6、ICMP询问报文"></a>6、ICMP询问报文</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505230910474.png" alt="image-20210505230910474"></p>
<h4 id="7、ICMP的应用"><a href="#7、ICMP的应用" class="headerlink" title="7、ICMP的应用"></a>7、ICMP的应用</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505231645689.png" alt="image-20210505231645689"></p>
<h3 id="4-4、IPv6"><a href="#4-4、IPv6" class="headerlink" title="4.4、IPv6"></a>4.4、IPv6</h3><h4 id="1、为什么有IPv6"><a href="#1、为什么有IPv6" class="headerlink" title="1、为什么有IPv6"></a>1、为什么有IPv6</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505232136621.png" alt="image-20210505232136621"></p>
<h4 id="2、IPv6数据报格式"><a href="#2、IPv6数据报格式" class="headerlink" title="2、IPv6数据报格式"></a>2、IPv6数据报格式</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505233127480.png" alt="image-20210505233127480"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505233806463.png" alt="image-20210505233806463"></p>
<h4 id="3、IPv6-VS-IPv4"><a href="#3、IPv6-VS-IPv4" class="headerlink" title="3、IPv6  VS IPv4"></a>3、IPv6  VS IPv4</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505234147607.png" alt="image-20210505234147607"></p>
<h4 id="4、IPv6地址表示形式"><a href="#4、IPv6地址表示形式" class="headerlink" title="4、IPv6地址表示形式"></a>4、IPv6地址表示形式</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505234335367.png" alt="image-20210505234335367"></p>
<h4 id="5、IPv6基本地址类型"><a href="#5、IPv6基本地址类型" class="headerlink" title="5、IPv6基本地址类型"></a>5、IPv6基本地址类型</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505234545274.png" alt="image-20210505234545274"></p>
<h4 id="6、IPv6向IPv4过渡的策略"><a href="#6、IPv6向IPv4过渡的策略" class="headerlink" title="6、IPv6向IPv4过渡的策略"></a>6、IPv6向IPv4过渡的策略</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505234827815.png" alt="image-20210505234827815"></p>
<h4 id="7、脑图"><a href="#7、脑图" class="headerlink" title="7、脑图"></a>7、脑图</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210505234924693.png" alt="image-20210505234924693"></p>
<h3 id="4-5、路由算法及路由协议"><a href="#4-5、路由算法及路由协议" class="headerlink" title="4.5、路由算法及路由协议"></a>4.5、路由算法及路由协议</h3><h4 id="1、路由算法"><a href="#1、路由算法" class="headerlink" title="1、路由算法"></a>1、路由算法</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506000134403.png" alt="image-20210506000134403"></p>
<h4 id="2、路由算法的分类"><a href="#2、路由算法的分类" class="headerlink" title="2、路由算法的分类"></a>2、路由算法的分类</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506000028662.png" alt="image-20210506000028662"></p>
<h4 id="3、分层次的路由选择协议"><a href="#3、分层次的路由选择协议" class="headerlink" title="3、分层次的路由选择协议"></a>3、分层次的路由选择协议</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506000422048.png" alt="image-20210506000422048"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506000456424.png" alt="image-20210506000456424"></p>
<h3 id="4-6-1、RIP协议与距离向量算法"><a href="#4-6-1、RIP协议与距离向量算法" class="headerlink" title="4.6.1、RIP协议与距离向量算法"></a>4.6.1、RIP协议与距离向量算法</h3><h4 id="1、RIP协议"><a href="#1、RIP协议" class="headerlink" title="1、RIP协议"></a>1、RIP协议</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506000832013.png" alt="image-20210506000832013"></p>
<h4 id="2、RIP协议和谁交换-多久交换一次-交换什么"><a href="#2、RIP协议和谁交换-多久交换一次-交换什么" class="headerlink" title="2、RIP协议和谁交换?多久交换一次? 交换什么?"></a>2、RIP协议和谁交换?多久交换一次? 交换什么?</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506001325532.png" alt="image-20210506001325532"></p>
<h4 id="3、距离向量算法"><a href="#3、距离向量算法" class="headerlink" title="3、距离向量算法"></a>3、距离向量算法</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506001614574.png" alt="image-20210506001614574"></p>
<p>相关例题：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506001913695.png" alt="image-20210506001913695"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506002345004.png" alt="image-20210506002345004"></p>
<h4 id="4、RIP协议的报文格式"><a href="#4、RIP协议的报文格式" class="headerlink" title="4、RIP协议的报文格式"></a>4、RIP协议的报文格式</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506002716945.png" alt="image-20210506002716945"></p>
<h4 id="5、RIP协议好消息传得快，坏消息传得慢"><a href="#5、RIP协议好消息传得快，坏消息传得慢" class="headerlink" title="5、RIP协议好消息传得快，坏消息传得慢"></a>5、RIP协议好消息传得快，坏消息传得慢</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506002829463.png" alt="image-20210506002829463"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506002927178.png" alt="image-20210506002927178"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506003058016.png" alt="image-20210506003058016"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506003123096.png" alt="image-20210506003123096"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506003157668.png" alt="image-20210506003157668"></p>
<h4 id="脑图"><a href="#脑图" class="headerlink" title="脑图"></a>脑图</h4><p>补充下，RIP与距离向量算法不一样：因数据报服务在分组转发时，每个分组独立选择路由转发，从而引出了路由选择协议。RIP叫路由信息协议。为了找出RIP的最短距离引出了距离向量算法。</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506003352720.png" alt="image-20210506003352720"></p>
<h3 id="4-6-2、OSPF协议与链路状态算法"><a href="#4-6-2、OSPF协议与链路状态算法" class="headerlink" title="4.6.2、OSPF协议与链路状态算法"></a>4.6.2、OSPF协议与链路状态算法</h3><h4 id="1、OSPF协议"><a href="#1、OSPF协议" class="headerlink" title="1、OSPF协议"></a>1、OSPF协议</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506003646135.png" alt="image-20210506003646135"></p>
<h4 id="2、链路状态路由算法"><a href="#2、链路状态路由算法" class="headerlink" title="2、链路状态路由算法"></a>2、链路状态路由算法</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506004006614.png" alt="image-20210506004006614"></p>
<h4 id="3、OSPF的区域"><a href="#3、OSPF的区域" class="headerlink" title="3、OSPF的区域"></a>3、OSPF的区域</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506004158704.png" alt="image-20210506004158704"></p>
<h4 id="4、OSPF分组"><a href="#4、OSPF分组" class="headerlink" title="4、OSPF分组"></a>4、OSPF分组</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506004522231.png" alt="image-20210506004522231"></p>
<h4 id="5、OSPF其他特点"><a href="#5、OSPF其他特点" class="headerlink" title="5、OSPF其他特点"></a>5、OSPF其他特点</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506004650863.png" alt="image-20210506004650863"></p>
<h3 id="4-6-3、BGP协议"><a href="#4-6-3、BGP协议" class="headerlink" title="4.6.3、BGP协议"></a>4.6.3、BGP协议</h3><h4 id="1、BGP协议"><a href="#1、BGP协议" class="headerlink" title="1、BGP协议"></a>1、BGP协议</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506004817609.png" alt="image-20210506004817609"></p>
<h4 id="2、BGP协议交换信息的过程"><a href="#2、BGP协议交换信息的过程" class="headerlink" title="2、BGP协议交换信息的过程"></a>2、BGP协议交换信息的过程</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506005743562.png" alt="image-20210506005743562"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506005824214.png" alt="image-20210506005824214"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506005844401.png" alt="image-20210506005844401"></p>
<h4 id="3、BGP协议报文格式"><a href="#3、BGP协议报文格式" class="headerlink" title="3、BGP协议报文格式"></a>3、BGP协议报文格式</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506005948843.png" alt="image-20210506005948843"></p>
<h4 id="4、BGP协议特点"><a href="#4、BGP协议特点" class="headerlink" title="4、BGP协议特点"></a>4、BGP协议特点</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506010034467.png" alt="image-20210506010034467"></p>
<h4 id="5、BGP-4的四种报文"><a href="#5、BGP-4的四种报文" class="headerlink" title="5、BGP-4的四种报文"></a>5、BGP-4的四种报文</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506010126542.png" alt="image-20210506010126542"></p>
<h4 id="6、三种路由协议比较"><a href="#6、三种路由协议比较" class="headerlink" title="6、三种路由协议比较"></a>6、三种路由协议比较</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506010314753.png" alt="image-20210506010314753"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506010353924.png" alt="image-20210506010353924"></p>
<h3 id="4-7、IP组播"><a href="#4-7、IP组播" class="headerlink" title="4.7、IP组播"></a>4.7、IP组播</h3><h4 id="1、IP数据报的三种传输方式"><a href="#1、IP数据报的三种传输方式" class="headerlink" title="1、IP数据报的三种传输方式"></a>1、IP数据报的三种传输方式</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506010805488.png" alt="image-20210506010805488"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506010910591.png" alt="image-20210506010910591"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506011014041.png" alt="image-20210506011014041"></p>
<h4 id="2、IP组播地址"><a href="#2、IP组播地址" class="headerlink" title="2、IP组播地址"></a>2、IP组播地址</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506011327598.png" alt="image-20210506011327598"></p>
<h4 id="3、硬件组播"><a href="#3、硬件组播" class="headerlink" title="3、硬件组播"></a>3、硬件组播</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506012222229.png" alt="image-20210506012222229"></p>
<h4 id="4、IGMP协议与组播路由选择协议"><a href="#4、IGMP协议与组播路由选择协议" class="headerlink" title="4、IGMP协议与组播路由选择协议"></a>4、IGMP协议与组播路由选择协议</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506012400642.png" alt="image-20210506012400642"></p>
<h4 id="5、网际组管理协议IGMP"><a href="#5、网际组管理协议IGMP" class="headerlink" title="5、网际组管理协议IGMP"></a>5、网际组管理协议IGMP</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506012545893.png" alt="image-20210506012545893"></p>
<p><strong>ICMP和IGMP都使用IP数据报传递报文</strong>。</p>
<h4 id="6、IGMP工作的两个阶段"><a href="#6、IGMP工作的两个阶段" class="headerlink" title="6、IGMP工作的两个阶段"></a>6、IGMP工作的两个阶段</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506012720613.png" alt="image-20210506012720613"></p>
<h4 id="7、组播路由选择协议"><a href="#7、组播路由选择协议" class="headerlink" title="7、组播路由选择协议"></a>7、组播路由选择协议</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506012924832.png" alt="image-20210506012924832"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506013034949.png" alt="image-20210506013034949"></p>
<p>组播路由选择协议常使用的三种算法：</p>
<ul>
<li>基于链路状态的路由选择</li>
<li>基于距离-向量的路由选择</li>
<li>协议无关的组播(稀疏/密集)</li>
</ul>
<h4 id="8、脑图"><a href="#8、脑图" class="headerlink" title="8、脑图"></a>8、脑图</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506013212541.png" alt="image-20210506013212541"></p>
<h3 id="4-8、移动IP"><a href="#4-8、移动IP" class="headerlink" title="4.8、移动IP"></a>4.8、移动IP</h3><h4 id="1、移动IP相关术语"><a href="#1、移动IP相关术语" class="headerlink" title="1、移动IP相关术语"></a>1、移动IP相关术语</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506013719153.png" alt="image-20210506013719153"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506013851391.png" alt="image-20210506013851391"></p>
<h4 id="2、移动IP通信过程"><a href="#2、移动IP通信过程" class="headerlink" title="2、移动IP通信过程"></a>2、移动IP通信过程</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506014144890.png" alt="image-20210506014144890"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506014312720.png" alt="image-20210506014312720"></p>
<h3 id="4-9、网络层设备"><a href="#4-9、网络层设备" class="headerlink" title="4.9、网络层设备"></a>4.9、网络层设备</h3><h4 id="1、路由器"><a href="#1、路由器" class="headerlink" title="1、路由器"></a>1、路由器</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506014602052.png" alt="image-20210506014602052"></p>
<h4 id="2、输入端口对线路上收到的分组的处理"><a href="#2、输入端口对线路上收到的分组的处理" class="headerlink" title="2、输入端口对线路上收到的分组的处理"></a>2、输入端口对线路上收到的分组的处理</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506014713942.png" alt="image-20210506014713942"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506014800212.png" alt="image-20210506014800212"></p>
<h4 id="3、三层设备的区别"><a href="#3、三层设备的区别" class="headerlink" title="3、三层设备的区别"></a>3、三层设备的区别</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506014928456.png" alt="image-20210506014928456"></p>
<h4 id="4、路由表与路由转发"><a href="#4、路由表与路由转发" class="headerlink" title="4、路由表与路由转发"></a>4、路由表与路由转发</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506015046620.png" alt="image-20210506015046620"></p>
<h3 id="4-10、网络层总结"><a href="#4-10、网络层总结" class="headerlink" title="4.10、网络层总结"></a>4.10、网络层总结</h3><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506015143791.png" alt="image-20210506015143791"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506015239776.png" alt="image-20210506015239776"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506015254927.png" alt="image-20210506015254927"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506015310030.png" alt="image-20210506015310030"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506015341546.png" alt="image-20210506015341546"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506015440181.png" alt="image-20210506015440181"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506015614088.png" alt="image-20210506015550548"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506015658610.png" alt="image-20210506015658610"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506015721592.png" alt="image-20210506015721592"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506015734462.png" alt="image-20210506015734462"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210506015810700.png" alt="image-20210506015810700"></p>
<h2 id="第五章-传输层"><a href="#第五章-传输层" class="headerlink" title="第五章 传输层"></a>第五章 传输层</h2><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2020070417445825.jpg" alt="在这里插入图片描述"></p>
<h3 id="5-1、传输层概述"><a href="#5-1、传输层概述" class="headerlink" title="5.1、传输层概述"></a>5.1、传输层概述</h3><h4 id="1、什么是传输层"><a href="#1、什么是传输层" class="headerlink" title="1、什么是传输层"></a>1、什么是传输层</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509091650713.png" alt="image-20210509091650713"></p>
<h4 id="2、传输层的两个协议"><a href="#2、传输层的两个协议" class="headerlink" title="2、传输层的两个协议"></a>2、传输层的两个协议</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509130716955.png" alt="image-20210509130716955"></p>
<h4 id="3、传输层的寻址与端口"><a href="#3、传输层的寻址与端口" class="headerlink" title="3、传输层的寻址与端口"></a>3、传输层的寻址与端口</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509131021768.png" alt="image-20210509131021768"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509131114772.png" alt="image-20210509131114772"></p>
<h3 id="5-2、UDP协议"><a href="#5-2、UDP协议" class="headerlink" title="5.2、UDP协议"></a>5.2、UDP协议</h3><h4 id="1、用户数据报协议UDP概述"><a href="#1、用户数据报协议UDP概述" class="headerlink" title="1、用户数据报协议UDP概述"></a>1、用户数据报协议UDP概述</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509131452260.png" alt="image-20210509131452260"></p>
<h4 id="2、UDP首部格式"><a href="#2、UDP首部格式" class="headerlink" title="2、UDP首部格式"></a>2、UDP首部格式</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509131719115.png" alt="image-20210509131719115"></p>
<h4 id="3、UDP校验"><a href="#3、UDP校验" class="headerlink" title="3、UDP校验"></a>3、UDP校验</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509131902697.png" alt="image-20210509131902697"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509132143163.png" alt="image-20210509132143163"></p>
<h3 id="5-3-1、TCP协议特点和TCP报文段格式"><a href="#5-3-1、TCP协议特点和TCP报文段格式" class="headerlink" title="5.3.1、TCP协议特点和TCP报文段格式"></a>5.3.1、TCP协议特点和TCP报文段格式</h3><h4 id="1、TCP协议的特点"><a href="#1、TCP协议的特点" class="headerlink" title="1、TCP协议的特点"></a>1、TCP协议的特点</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509132448448.png" alt="image-20210509132448448"></p>
<h4 id="2、TCP协议的特点-amp-TCP报文段首部格式"><a href="#2、TCP协议的特点-amp-TCP报文段首部格式" class="headerlink" title="2、TCP协议的特点 &amp; TCP报文段首部格式"></a>2、TCP协议的特点 &amp; TCP报文段首部格式</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509133753564.png" alt="image-20210509133753564"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509132848748.png" alt="image-20210509132848748"></p>
<p>TCP首部——序号：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509133439721.png" alt="image-20210509133439721"></p>
<p>TCP首部——确认号</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509133333378.png" alt="image-20210509133333378"></p>
<p>相关控制位：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509135329970.png" alt="image-20210509135329970"></p>
<p>TCP首部控制位——紧急位URG</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509134247734.png" alt="image-20210509134247734"></p>
<p>TCP首部控制位——推送位PSH</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509134713094.png" alt="image-20210509134713094"></p>
<p>TCP首部——窗口</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509135449995.png" alt="image-20210509135449995"></p>
<p>TCP首部——紧急指针</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509135608155.png" alt="image-20210509135608155"></p>
<h3 id="5-3-2、TCP连接管理"><a href="#5-3-2、TCP连接管理" class="headerlink" title="5.3.2、TCP连接管理"></a>5.3.2、TCP连接管理</h3><h4 id="1、TCP连接管理"><a href="#1、TCP连接管理" class="headerlink" title="1、TCP连接管理"></a>1、TCP连接管理</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509135759910.png" alt="image-20210509135759910"></p>
<h4 id="2、TCP的连接建立"><a href="#2、TCP的连接建立" class="headerlink" title="2、TCP的连接建立"></a>2、TCP的连接建立</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509140112306.png" alt="image-20210509140112306"></p>
<h4 id="3、SYN洪泛攻击"><a href="#3、SYN洪泛攻击" class="headerlink" title="3、SYN洪泛攻击"></a>3、SYN洪泛攻击</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509143604587.png" alt="image-20210509143604587"></p>
<h4 id="4、TCP的连接释放"><a href="#4、TCP的连接释放" class="headerlink" title="4、TCP的连接释放"></a>4、TCP的连接释放</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509143655748.png" alt="image-20210509143655748"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509144000502.png" alt="image-20210509144000502"></p>
<h3 id="5-3-3、TCP可靠传输"><a href="#5-3-3、TCP可靠传输" class="headerlink" title="5.3.3、TCP可靠传输"></a>5.3.3、TCP可靠传输</h3><h4 id="1、TCP可靠传输"><a href="#1、TCP可靠传输" class="headerlink" title="1、TCP可靠传输"></a>1、TCP可靠传输</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509144114911.png" alt="image-20210509144114911"></p>
<h4 id="2、序号"><a href="#2、序号" class="headerlink" title="2、序号"></a>2、序号</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509144335882.png" alt="image-20210509144335882"></p>
<h4 id="3、确认"><a href="#3、确认" class="headerlink" title="3、确认"></a>3、确认</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509144702310.png" alt="image-20210509144702310"></p>
<h4 id="4、重传"><a href="#4、重传" class="headerlink" title="4、重传"></a>4、重传</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509144948012.png" alt="image-20210509144948012"> </p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509145112616.png" alt="image-20210509145112616"></p>
<h4 id="5-3-4、TCP流量控制"><a href="#5-3-4、TCP流量控制" class="headerlink" title="5.3.4、TCP流量控制"></a>5.3.4、TCP流量控制</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509145413434.png" alt="image-20210509145413434"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509150152054.png" alt="image-20210509150152054"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509150246065.png" alt="image-20210509150246065"></p>
<h3 id="5-3-5、TCP拥塞控制"><a href="#5-3-5、TCP拥塞控制" class="headerlink" title="5.3.5、TCP拥塞控制"></a>5.3.5、TCP拥塞控制</h3><h4 id="1、TCP拥塞控制"><a href="#1、TCP拥塞控制" class="headerlink" title="1、TCP拥塞控制"></a>1、TCP拥塞控制</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509150503776.png" alt="image-20210509150503776"></p>
<h4 id="2、拥塞控制四种算法"><a href="#2、拥塞控制四种算法" class="headerlink" title="2、拥塞控制四种算法"></a>2、拥塞控制四种算法</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509150710651.png" alt="image-20210509150710651"></p>
<h4 id="3、拥塞控制四种算法——慢开始和拥塞避免"><a href="#3、拥塞控制四种算法——慢开始和拥塞避免" class="headerlink" title="3、拥塞控制四种算法——慢开始和拥塞避免"></a>3、拥塞控制四种算法——慢开始和拥塞避免</h4><p>传输轮次：</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509151158840.png" alt="image-20210509151158840"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509151631221.png" alt="image-20210509151631221"></p>
<h4 id="4、拥塞控制四种算法——快重传和快恢复"><a href="#4、拥塞控制四种算法——快重传和快恢复" class="headerlink" title="4、拥塞控制四种算法——快重传和快恢复"></a>4、拥塞控制四种算法——快重传和快恢复</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509152156033.png" alt="image-20210509152156033"></p>
<h3 id="5-4、传输层总结"><a href="#5-4、传输层总结" class="headerlink" title="5.4、传输层总结"></a>5.4、传输层总结</h3><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509152240332.png" alt="image-20210509152240332"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509152327273.png" alt="image-20210509152327273"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210509152352593.png" alt="image-20210509152352593"></p>
<h2 id="第六章-应用层"><a href="#第六章-应用层" class="headerlink" title="第六章 应用层"></a>第六章 应用层</h2><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20200704174557419.jpg" alt="img"></p>
<h3 id="6-1、网络应用模型"><a href="#6-1、网络应用模型" class="headerlink" title="6.1、网络应用模型"></a>6.1、网络应用模型</h3><h4 id="1、应用层概述"><a href="#1、应用层概述" class="headerlink" title="1、应用层概述"></a>1、应用层概述</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510103902295.png" alt="image-20210510103902295"></p>
<h4 id="2、网络应用模型"><a href="#2、网络应用模型" class="headerlink" title="2、网络应用模型"></a>2、网络应用模型</h4><h5 id="1、客户-服务器模型-Client-Server"><a href="#1、客户-服务器模型-Client-Server" class="headerlink" title="1、客户/服务器模型(Client/Server)"></a>1、客户/服务器模型(Client/Server)</h5><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510104239979.png" alt="image-20210510104239979"></p>
<h5 id="2、P2P模型-Peer-to-peer"><a href="#2、P2P模型-Peer-to-peer" class="headerlink" title="2、P2P模型(Peer-to-peer )"></a>2、P2P模型(Peer-to-peer )</h5><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510104646313.png" alt="image-20210510104646313"></p>
<h3 id="6-2、域名解析（DNS）系统"><a href="#6-2、域名解析（DNS）系统" class="headerlink" title="6.2、域名解析（DNS）系统"></a>6.2、域名解析（DNS）系统</h3><h4 id="1、DNS系统"><a href="#1、DNS系统" class="headerlink" title="1、DNS系统"></a>1、DNS系统</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510104903931.png" alt="image-20210510104903931"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510105032397.png" alt="image-20210510105032397"></p>
<h4 id="2、域名"><a href="#2、域名" class="headerlink" title="2、域名"></a>2、域名</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510105410771.png" alt="image-20210510105410771"></p>
<p>域名树</p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510105508640.png" alt="image-20210510105508640"></p>
<h4 id="3、域名服务器"><a href="#3、域名服务器" class="headerlink" title="3、域名服务器"></a>3、域名服务器</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510105950375.png" alt="image-20210510105950375"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510110153218.png" alt="image-20210510110153218"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510110230680.png" alt="image-20210510110230680"></p>
<h4 id="4、域名解析过程"><a href="#4、域名解析过程" class="headerlink" title="4、域名解析过程"></a>4、域名解析过程</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510110758844.png" alt="image-20210510110758844"></p>
<h3 id="6-3、文件传输协议FTP"><a href="#6-3、文件传输协议FTP" class="headerlink" title="6.3、文件传输协议FTP"></a>6.3、文件传输协议FTP</h3><h4 id="1、文件传送协议"><a href="#1、文件传送协议" class="headerlink" title="1、文件传送协议"></a>1、文件传送协议</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510111014038.png" alt="image-20210510111014038"></p>
<h4 id="2、FTP服务器和客户端"><a href="#2、FTP服务器和客户端" class="headerlink" title="2、FTP服务器和客户端"></a>2、FTP服务器和客户端</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510111137982.png" alt="image-20210510111137982"></p>
<h4 id="3、FTP工作原理"><a href="#3、FTP工作原理" class="headerlink" title="3、FTP工作原理"></a>3、FTP工作原理</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510111724834.png" alt="image-20210510111724834"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510112854765.png" alt="image-20210510112854765"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510111833815.png" alt="image-20210510111833815"></p>
<h3 id="6-4、电子邮件"><a href="#6-4、电子邮件" class="headerlink" title="6.4、电子邮件"></a>6.4、电子邮件</h3><h4 id="1、电子邮件系统概述——电子邮件的的信息格式"><a href="#1、电子邮件系统概述——电子邮件的的信息格式" class="headerlink" title="1、电子邮件系统概述——电子邮件的的信息格式"></a>1、电子邮件系统概述——电子邮件的的信息格式</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510114256285.png" alt="image-20210510114256285"></p>
<h4 id="2、电子邮件系统概述——组成结构"><a href="#2、电子邮件系统概述——组成结构" class="headerlink" title="2、电子邮件系统概述——组成结构"></a>2、电子邮件系统概述——组成结构</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510114344542.png" alt="image-20210510114344542"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510114417744.png" alt="image-20210510114417744"></p>
<h4 id="3、简单邮件传送协议SMTP"><a href="#3、简单邮件传送协议SMTP" class="headerlink" title="3、简单邮件传送协议SMTP"></a>3、简单邮件传送协议SMTP</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510114439779.png" alt="image-20210510114439779"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510114512955.png" alt="image-20210510114512955"></p>
<h4 id="4、MIME"><a href="#4、MIME" class="headerlink" title="4、MIME"></a>4、MIME</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510114546291.png" alt="image-20210510114546291"></p>
<h4 id="5、邮局协议POP3"><a href="#5、邮局协议POP3" class="headerlink" title="5、邮局协议POP3"></a>5、邮局协议POP3</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510114622467.png" alt="image-20210510114622467"></p>
<h4 id="6、网际报文存取协议IMAP"><a href="#6、网际报文存取协议IMAP" class="headerlink" title="6、网际报文存取协议IMAP"></a>6、网际报文存取协议IMAP</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510114808711.png" alt="image-20210510114808711"></p>
<h4 id="7、基于万维网的电子邮件"><a href="#7、基于万维网的电子邮件" class="headerlink" title="7、基于万维网的电子邮件"></a>7、基于万维网的电子邮件</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510114701163.png" alt="image-20210510114701163"></p>
<h4 id="脑图-1"><a href="#脑图-1" class="headerlink" title="脑图"></a>脑图</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510114720692.png" alt="image-20210510114720692"></p>
<h3 id="6-5、万维网和HTTP协议"><a href="#6-5、万维网和HTTP协议" class="headerlink" title="6.5、万维网和HTTP协议"></a>6.5、万维网和HTTP协议</h3><h4 id="1、万维网概述"><a href="#1、万维网概述" class="headerlink" title="1、万维网概述"></a>1、万维网概述</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510115838121.png" alt="image-20210510115838121"></p>
<h4 id="2、超文本传输协议HTTP"><a href="#2、超文本传输协议HTTP" class="headerlink" title="2、超文本传输协议HTTP"></a>2、超文本传输协议HTTP</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510115923321.png" alt="image-20210510115923321"></p>
<h4 id="3、HTTP协议的特点"><a href="#3、HTTP协议的特点" class="headerlink" title="3、HTTP协议的特点"></a>3、HTTP协议的特点</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510120008065.png" alt="image-20210510120008065"></p>
<h4 id="4、HTTP协议的连接方式"><a href="#4、HTTP协议的连接方式" class="headerlink" title="4、HTTP协议的连接方式"></a>4、HTTP协议的连接方式</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510120102536.png" alt="image-20210510120102536"></p>
<h4 id="5、超文本传输协议HTTP——报文结构"><a href="#5、超文本传输协议HTTP——报文结构" class="headerlink" title="5、超文本传输协议HTTP——报文结构"></a>5、超文本传输协议HTTP——报文结构</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510123648179.png" alt="image-20210510123648179"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510123711370.png" alt="image-20210510123711370"></p>
<p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210510123757619.png" alt="image-20210510123757619"></p>
<p>参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/inv1796915552/article/details/108597883">计算机网络（2019 王道考研）</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gl620321/article/details/107126941">计算机网络思维导图</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xgh-user.github.io/2021/04/19/VUE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_little-star_">
      <meta itemprop="description" content="记录个人在平时学习的过程中的一些笔记、感受与遇到的坑,例如：java、计算机考研四件套等等。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_little-star_">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/19/VUE/" class="post-title-link" itemprop="url">Vue</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-19 03:10:19 / 修改时间：03:31:53" itemprop="dateCreated datePublished" datetime="2021-04-19T03:10:19+08:00">2021-04-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">前端学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><p><a target="_blank" rel="noopener" href="https://cn.vuejs.org/">Vue官网</a></p>
<h2 id="一、邂逅Vuejs"><a href="#一、邂逅Vuejs" class="headerlink" title="一、邂逅Vuejs"></a>一、邂逅Vuejs</h2><h3 id="1、遇见Vuejs"><a href="#1、遇见Vuejs" class="headerlink" title="1、遇见Vuejs"></a>1、遇见Vuejs</h3><h4 id="1、认识Vuejs"><a href="#1、认识Vuejs" class="headerlink" title="1、认识Vuejs"></a>1、认识Vuejs</h4><ul>
<li><p>Vue (读Vue (读音 /vjuː/，类似于 <strong>view</strong>)音 /vjuː/，类似于 <strong>view</strong>)</p>
</li>
<li><p>Vue是一个渐进式的框架，渐进式的框架：</p>
<ul>
<li>渐进式意味着你可以将Vue作为你应用的一部分嵌入其中，带来更丰富的交互体验。</li>
<li>如果你希望将更多的业务逻辑使用Vue实现，那么Vue的核心库以及其生态系统。比如Core+Vue-router+Vuex，也可以满足你各种各样的需求。</li>
</ul>
</li>
<li><p>与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/single-file-components.html">现代化的工具链</a>以及各种<a target="_blank" rel="noopener" href="https://github.com/vuejs/awesome-vue#libraries--plugins">支持类库</a>结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p>
</li>
</ul>
<h4 id="2、Vue的特点和Web开发中常见的高级功能"><a href="#2、Vue的特点和Web开发中常见的高级功能" class="headerlink" title="2、Vue的特点和Web开发中常见的高级功能"></a>2、Vue的特点和Web开发中常见的高级功能</h4><ul>
<li>解耦视图和数据</li>
<li>可复用的组件</li>
<li>前端路由技术</li>
<li>状态管理</li>
<li>虚拟DOM</li>
</ul>
<h3 id="2、安装Vuejs"><a href="#2、安装Vuejs" class="headerlink" title="2、安装Vuejs"></a>2、安装Vuejs</h3><p><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/installation.html">安装</a></p>
<h4 id="1、方式一：下载和引入"><a href="#1、方式一：下载和引入" class="headerlink" title="1、方式一：下载和引入"></a>1、方式一：下载和引入</h4><p>在<a target="_blank" rel="noopener" href="https://cn.vuejs.org/">官网</a>上直接下载vue.js文件引入到项目（本地）中，其中有<a target="_blank" rel="noopener" href="https://vuejs.org/js/vue.js">开发环境</a>与<a target="_blank" rel="noopener" href="https://vuejs.org/js/vue.min.js">生产环境</a>。</p>
<p>注意：</p>
<p>在下载时不能直接点击，直接点击的话你将看到vue.js的源码。应该右键选中<code>从链接另存文件</code>。</p>
<p><img src="/2021/04/19/VUE/01.png" alt="image-20210320014752045"></p>
<p>其中</p>
<ul>
<li><p>开发环境用在开发的时候，其中的代码包含了有帮助的命令行警告，方便程序员查看源代码，但相对的文件比较大。</p>
</li>
<li><p>生产环境用在发布产品的时候，其中的代码都是经过压缩的，优化了尺寸和速度，文件也比较小，方便用户下载，但代码的可读性极差。</p>
</li>
</ul>
<p>一句话总结：开发环境面向的是程序员，生产环境面向的是用户。</p>
<h4 id="2、方式二：直接CDN引入"><a href="#2、方式二：直接CDN引入" class="headerlink" title="2、方式二：直接CDN引入"></a>2、方式二：直接CDN引入</h4><p>你可以在你的项目中直接CDN（外部）引入：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--如果你使用原生 ES Modules，这里也有一个兼容 ES Module 的构建文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;https://cdn.jsdelivr.net/npm/vue@2.6.12/dist/vue.esm.browser.js&#x27;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3、方式三：NPM安装"><a href="#3、方式三：NPM安装" class="headerlink" title="3、方式三：NPM安装"></a>3、方式三：NPM安装</h4><p>在用 Vue 构建大型应用时推荐使用 NPM 安装[<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/installation.html#footnote-1">1]</a>。NPM 能很好地和诸如 <a target="_blank" rel="noopener" href="https://webpack.js.org/">webpack</a> 或 <a target="_blank" rel="noopener" href="http://browserify.org/">Browserify</a> 模块打包器配合使用。同时 Vue 也提供配套工具来开发<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/single-file-components.html">单文件组件</a>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 最新稳定版</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install vue</span></span><br></pre></td></tr></table></figure>

<h3 id="3、第一个Vuejs程序"><a href="#3、第一个Vuejs程序" class="headerlink" title="3、第一个Vuejs程序"></a>3、第一个Vuejs程序</h3><p><img src="/2021/04/19/VUE/02.png" alt="image-20210320015424885"></p>
<h4 id="1、代码的执行"><a href="#1、代码的执行" class="headerlink" title="1、代码的执行"></a>1、代码的执行</h4><ol>
<li>阅读JavaScript代码，程序发现创建了一个Vue对象；</li>
<li>创建Vue对象的时候，传入了一些options：{}<ul>
<li>{}中包含了el属性：该属性决定了这个Vue对象挂载到哪一个元素上，很明显，我们这里是挂载到了id为app的元素上；</li>
<li>{}中包含了data属性：该属性中通常会存储一些数据：<ul>
<li>这些数据可以是我们直接定义出来的，比如像上面代码这样</li>
<li>也可能是来自网络，从服务器加载的</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="2、浏览器执行代码的流程"><a href="#2、浏览器执行代码的流程" class="headerlink" title="2、浏览器执行代码的流程"></a>2、浏览器执行代码的流程</h4><ol>
<li>执行到10~13行代码显然出对应的HTML；</li>
<li>执行第16行代码创建Vue实例，并且对原HTML进行解析和修改</li>
</ol>
<h4 id="3、响应式"><a href="#3、响应式" class="headerlink" title="3、响应式"></a>3、响应式</h4><p>Vue代码是可以实现响应式的。在浏览器里进入开发者模式<code>F12</code>中的<code>console</code>。在里面修改代码可以实现浏览器的内容也随着修改而响应着改变。</p>
<p><img src="/2021/04/19/VUE/03.png" alt="image-20210320020223661"></p>
<h3 id="4、Vue与JavaScript-（两种编程范式）"><a href="#4、Vue与JavaScript-（两种编程范式）" class="headerlink" title="4、Vue与JavaScript （两种编程范式）"></a>4、Vue与JavaScript （两种编程范式）</h3><ul>
<li><p>命令式编程（JavaScript ）</p>
<p>命令式编程的主要思想是关注计算机执行的步骤，即一步一步告诉计算机先做什么再做什么。</p>
<p>优点：数据和界面完全分离，不需要js创建页面元素等操作</p>
</li>
</ul>
<ul>
<li><p>声明式编程（Vuejs）</p>
<p>声明式编程是以数据结构的形式来表达程序执行的逻辑。它的主要思想是告诉计算机应该做什么，但不指定具体要怎么做。</p>
<p>优点：当数据发生改变时界面自动发生改变（响应式）</p>
</li>
</ul>
<h3 id="5、Vue的MVVM"><a href="#5、Vue的MVVM" class="headerlink" title="5、Vue的MVVM"></a>5、Vue的MVVM</h3><h4 id="1、是什么MVVM"><a href="#1、是什么MVVM" class="headerlink" title="1、是什么MVVM"></a>1、是什么MVVM</h4><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MVVM">维基百科官方解释</a>：</p>
<p><strong>MVVM</strong>（<strong>Model–view–viewmodel</strong>）是一种软件<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F">架构模式</a>。</p>
<p>MVVM有助于将<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2">图形用户界面</a>的开发与<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91">业务逻辑</a>或<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%89%8D%E7%AB%AF%E5%92%8C%E5%90%8E%E7%AB%AF">后端</a>逻辑（<em>数据模型</em>）的开发<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB">分离</a>开来，这是通过<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BD%AE%E6%A0%87%E8%AF%AD%E8%A8%80">置标语言</a>或GUI代码实现的。MVVM的<em>视图模型</em>是一个值转换器，[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MVVM#cite_note-MVVM-eliminates-valueconverters-1">1]</a> 这意味着视图模型负责从模型中暴露（转换）<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">数据对象</a>，以便轻松管理和呈现对象。在这方面，视图模型比视图做得更多，并且处理大部分视图的显示逻辑。[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MVVM#cite_note-MVVM-eliminates-valueconverters-1">1]</a> 视图模型可以实现<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F">中介者模式</a>，组织对视图所支持的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%94%A8%E4%BE%8B">用例</a>集的后端逻辑的访问。</p>
<p><img src="/2021/04/19/VUE/184.png" alt="image-20210402232753389"></p>
<h4 id="2、Vue的MVVM"><a href="#2、Vue的MVVM" class="headerlink" title="2、Vue的MVVM"></a>2、Vue的MVVM</h4><p><img src="/2021/04/19/VUE/04.png" alt="image-20210320022023488"></p>
<ul>
<li>View层：<ul>
<li>视图层</li>
<li>在前端开发中，通常就是DOM层</li>
<li>主要的作用是给用户展示各种信息</li>
</ul>
</li>
<li>Model层：<ul>
<li>数据层</li>
<li>数据可能是我们固定的死数据，但更多的是来自我们服务器，从网络上请求下来的数据</li>
</ul>
</li>
<li>VueModel层：<ul>
<li>视图模型层</li>
<li>视图模型层是View和Model沟通的桥梁</li>
<li>一方面它实现了Data Binding，也就是数据绑定，将Model的改变实时的反应到View中</li>
<li>另一方面它实现了DOM Listener，也就是DOM监听，当DOM发生一些事件(点击、滚动、touch等)时，可以监听到，并在需要的情况下改变对应的Data</li>
</ul>
</li>
</ul>
<h4 id="3、计数器的MVVM示例"><a href="#3、计数器的MVVM示例" class="headerlink" title="3、计数器的MVVM示例"></a>3、计数器的MVVM示例</h4><p>计数器：点击 <code>+</code> 计数器+1，点击 <code>-</code>  计数器 -1</p>
<p>在Vue对象中</p>
<ul>
<li>新属性：methods。该属性用于在Vue对象中定义方法。</li>
<li>新的指令：@click, 该指令用于监听某个元素的点击事件，并且需要指定当发生点击时，执行的方法(方法通常是methods中定义的方法)</li>
</ul>
<p><img src="/2021/04/19/VUE/05.png" alt="image-20210320022244195"></p>
<p><img src="/2021/04/19/VUE/06.png" alt="image-20210320022417139"></p>
<p>计数器中就有严格的MVVM思想：</p>
<ul>
<li>View依然是我们的DOM</li>
<li>Model就是我们我们抽离出来的obj</li>
<li>ViewModel就是我们创建的Vue对象实例</li>
</ul>
<p><img src="/2021/04/19/VUE/07.png" alt="01-计数器的MVVM"></p>
<p>它们之间如何工作呢？</p>
<ol>
<li>首先ViewModel通过Data Binding让obj中的数据实时的在DOM中显示。</li>
<li>其次ViewModel通过DOM Listener来监听DOM事件，并且通过methods中的操作，来改变obj中的数据。</li>
</ol>
<p>有了Vue帮助我们完成VueModel层的任务，在后续的开发，我们就可以专注于数据的处理，以及DOM的编写工作了。</p>
<h3 id="6、创建Vue实例传入的options"><a href="#6、创建Vue实例传入的options" class="headerlink" title="6、创建Vue实例传入的options"></a>6、创建Vue实例传入的options</h3><p>在创建Vue实例的时候，传入了一个对象options。那么，这个options中可以包含哪些选项呢？<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E6%95%B0%E6%8D%AE">详细解析</a></p>
<ul>
<li><p>el：</p>
<p>传入类型：string | HTMLElement</p>
<p>作用：决定之后Vue实例会管理哪一个DOM，挂载要管理的元素</p>
<p>限制：只在用 <code>new</code> 创建实例时生效</p>
</li>
<li><p>data：</p>
<p>类型：Object | Function （组件当中data必须是一个函数）</p>
<p>作用：Vue实例对应的数据对象</p>
<p>限制：组件的定义只接受 <code>function</code></p>
</li>
<li><p>methods：</p>
<p>类型：{ [key: string]: Function }</p>
<p>作用：定义属于Vue的一些方法，可以在其他地方调用，也可以在指令中使用。</p>
</li>
<li><p>components：</p>
<p>类型：<code>Object</code></p>
<p>详细：包含 Vue 实例可用组件的哈希表。</p>
</li>
<li><p>computed：</p>
<p>类型：<code>&#123; [key: string]: Function | &#123; get: Function, set: Function &#125; &#125;</code></p>
<p>详细：</p>
<p>计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。</p>
<p>注意如果你为一个计算属性使用了箭头函数，则 <code>this</code> 不会指向这个组件的实例，不过你仍然可以将其实例作为函数的第一个参数来访问。</p>
<p>计算属性的结果会被缓存，除非依赖的响应式 property 变化才会重新计算。注意，如果某个依赖 (比如非响应式 property) 在该实例范畴之外，则计算属性是<strong>不会</strong>被更新的。</p>
</li>
<li><p>生命周期函数：</p>
<p>所有的生命周期钩子<code>hook</code>自动绑定 <code>this</code> 上下文到实例中，因此你可以访问数据，对 property 和方法进行运算。（粗体表示常用）</p>
<ul>
<li><p>beforeCreate：</p>
<p>类型：<code>Function</code></p>
<p>详细：</p>
<p>在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。</p>
</li>
<li><p><strong>created</strong>：</p>
<p>类型：<code>Function</code></p>
<p>详细：</p>
<p>在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，property 和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，<code>$el</code> property 目前尚不可用。</p>
</li>
<li><p>beforeMount：</p>
<p>类型：<code>Function</code></p>
<p>详细：</p>
<p>在挂载开始之前被调用：相关的 <code>render</code> 函数首次被调用。</p>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
</li>
<li><p><strong>mounted</strong>：</p>
<p>类型：<code>Function</code></p>
<p>详细：</p>
<p>实例被挂载后调用，这时 <code>el</code> 被新创建的 <code>vm.$el</code> 替换了。如果根实例挂载到了一个文档内的元素上，当 <code>mounted</code> 被调用时 <code>vm.$el</code> 也在文档内。</p>
<p>注意 <code>mounted</code> <strong>不会</strong>保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 <code>mounted</code> 内部使用 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#vm-nextTick">vm.$nextTick</a></p>
</li>
<li><p>beforeUpdate：</p>
<p>类型：<code>Function</code></p>
<p>详细：</p>
<p>数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。</p>
<p><strong>该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。</strong></p>
</li>
<li><p>updated：</p>
<p>类型：<code>Function</code></p>
<p>详细：</p>
<p>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</p>
<p>当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#computed">计算属性</a>或 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#watch">watcher</a> 取而代之。</p>
<p>注意 <code>updated</code> <strong>不会</strong>保证所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以在 <code>updated</code> 里使用 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#vm-nextTick">vm.$nextTick</a></p>
</li>
<li><p><strong>activated</strong>：</p>
<p>类型：<code>Function</code></p>
<p>详细：</p>
<p>被 keep-alive 缓存的组件激活时调用。</p>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
</li>
<li><p>deactivated：</p>
<p>类型：<code>Function</code></p>
<p>详细：</p>
<p>被 keep-alive 缓存的组件停用时调用。</p>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
</li>
<li><p>beforeDestroy：</p>
<p>类型：<code>Function</code></p>
<p>详细：</p>
<p>实例销毁之前调用。在这一步，实例仍然完全可用。</p>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
</li>
<li><p>destroyed：</p>
<p>类型：<code>Function</code></p>
<p>详细：</p>
<p>实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。</p>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
</li>
<li><p>errorCaptured：</p>
<blockquote>
<p>2.5.0+ 新增(<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#errorCaptured">具体查看</a>)</p>
</blockquote>
<p>类型：<code>(err: Error, vm: Component, info: string) =&gt; ?boolean</code></p>
<p>详细：</p>
<p>当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 <code>false</code> 以阻止该错误继续向上传播。</p>
</li>
</ul>
</li>
</ul>
<h3 id="7、Vue的生命周期"><a href="#7、Vue的生命周期" class="headerlink" title="7、Vue的生命周期"></a>7、Vue的生命周期</h3><p>以下图来自<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/instance.html">官网</a></p>
<p><img src="/2021/04/19/VUE/08.png" alt="Vue 实例生命周期"></p>
<img src="/2021/04/19/VUE/09.png" alt="image-20210320025609038" style="zoom: 200%;">

<p>简化：</p>
<p><img src="/2021/04/19/VUE/10.png" alt="image-20210320025717195"></p>
<h3 id="8、ES6补充"><a href="#8、ES6补充" class="headerlink" title="8、ES6补充"></a>8、ES6补充</h3><h4 id="1、let-var"><a href="#1、let-var" class="headerlink" title="1、let/var"></a>1、let/var</h4><p>事实上var的设计可以看成JavaScript语言设计上的错误. 但是这种错误多半不能修复和移除, 以为需要向后兼容。于是，大概十年前，Brendan Eich就决定修复这个问题, 于是他添加了一个新的关键字: let。</p>
<p>我们可以将let看成更完美的var</p>
<h5 id="1、块级作用域"><a href="#1、块级作用域" class="headerlink" title="1、块级作用域"></a>1、<strong>块级作用域</strong></h5><ul>
<li>JS中使用var来声明一个变量时, 变量的作用域主要是和函数的定义有关</li>
<li>针对于其他块定义来说是没有作用域的，比如if/for等，这在我们开发中往往会引起一些问题。</li>
</ul>
<p>我们可以通过ES6与ES5的不同来显示<strong>块级作用域</strong>的作用：</p>
<ul>
<li><p>ES5中的var是没有块级作用域的(if/for)，var只有在function中才有块级作用域。</p>
<p>ES5之前因为if和for都没有块级作用域的概念，所以在很多时候，我们都必须借助于function的作用域来解决应用外面变量的问题。</p>
</li>
<li><p>ES6中的let是由块级作用的(if/for)</p>
</li>
</ul>
<h5 id="2、没有块级作用域引起的问题"><a href="#2、没有块级作用域引起的问题" class="headerlink" title="2、没有块级作用域引起的问题"></a>2、没有块级作用域引起的问题</h5><p>for的块级：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var btns = document.getElementsByTagName(&#x27;button&#x27;);</span><br><span class="line"> for (var i=0; i<span class="tag">&lt;<span class="name">btns.length;</span> <span class="attr">i</span>++) &#123;</span></span><br><span class="line"><span class="tag">     <span class="attr">btns</span>[<span class="attr">i</span>]<span class="attr">.addEventListener</span>(&#x27;<span class="attr">click</span>&#x27;, <span class="attr">function</span> () &#123;</span></span><br><span class="line"><span class="tag">       <span class="attr">console.log</span>(&#x27;第&#x27; + <span class="attr">i</span> + &#x27;个按钮被点击&#x27;);</span></span><br><span class="line"><span class="tag">     &#125;)</span></span><br><span class="line"><span class="tag"> &#125;</span></span><br></pre></td></tr></table></figure>

<p>效果：无论点击哪个按钮，日志打印的都是<code>第5个按钮被点击</code></p>
<p><img src="/2021/04/19/VUE/19.png" alt="image-20210320220031829"></p>
<p>说明：由于var没有块级作用域，被var定义的<code>i</code>会随着<code>i++</code>的改变而改变。function里面的<code>i</code>受到for循环的<code>i++</code>的影响，被改变成了<code>5</code>，所以输出的都是<code>第5个按钮被点击</code></p>
<h5 id="3、解决方法："><a href="#3、解决方法：" class="headerlink" title="3、解决方法："></a>3、解决方法：</h5><ol>
<li><p>用闭包可以解决问题。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var btns = document.getElementsByTagName(&#x27;button&#x27;);</span><br><span class="line">  for (var i=0; i<span class="tag">&lt;<span class="name">btns.length;</span> <span class="attr">i</span>++) &#123;</span></span><br><span class="line"><span class="tag">    (<span class="attr">function</span> (<span class="attr">num</span>) &#123; // <span class="attr">0</span></span></span><br><span class="line"><span class="tag">      <span class="attr">btns</span>[<span class="attr">i</span>]<span class="attr">.addEventListener</span>(&#x27;<span class="attr">click</span>&#x27;, <span class="attr">function</span> () &#123;</span></span><br><span class="line"><span class="tag">        <span class="attr">console.log</span>(&#x27;第&#x27; + <span class="attr">num</span> + &#x27;个按钮被点击&#x27;);</span></span><br><span class="line"><span class="tag">      &#125;)</span></span><br><span class="line"><span class="tag">    &#125;)(<span class="attr">i</span>)</span></span><br><span class="line"><span class="tag">  &#125;</span></span><br></pre></td></tr></table></figure>

<p>为什么闭包可以解决问题：函数是一个作用域。</p>
</li>
<li><p>用ES6的let</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const btns = document.getElementsByTagName(&#x27;button&#x27;)</span><br><span class="line">for (let i = 0; i <span class="tag">&lt; <span class="attr">btns.length</span>; <span class="attr">i</span>++) &#123;</span></span><br><span class="line"><span class="tag">  <span class="attr">btns</span>[<span class="attr">i</span>]<span class="attr">.addEventListener</span>(&#x27;<span class="attr">click</span>&#x27;, <span class="attr">function</span> () &#123;</span></span><br><span class="line"><span class="tag">    <span class="attr">console.log</span>(&#x27;第&#x27; + <span class="attr">i</span> + &#x27;个按钮被点击&#x27;);</span></span><br><span class="line"><span class="tag">  &#125;)</span></span><br><span class="line"><span class="tag">&#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="2、const"><a href="#2、const" class="headerlink" title="2、const"></a>2、const</h3><ul>
<li>在很多语言中已经存在, 比如C/C++中, 主要的作用是将某个变量修饰为常量。</li>
<li>在JavaScript中也是如此, 使用const修饰的标识符为常量, 不可以再次赋值。</li>
</ul>
<p>什么时候使用：</p>
<p>当我们修饰的标识符<strong>不会被再次赋值</strong>时, 就可以使用const来<strong>保证数据的安全性</strong>。</p>
<p><strong>建议:</strong></p>
<p><strong>在ES6开发中,优先使用const, 只有需要改变某一个标识符的时候才使用let。</strong></p>
<p>使用const时要注意的点（以下代码为错误展示）：</p>
<ul>
<li><p>一旦给const修饰的标识符被赋值之后, 不能修改</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const name = &#x27;why&#x27;;</span><br><span class="line">name = &#x27;abc&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在使用const定义标识符,必须进行赋值</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>常量的含义是指向的对象不能修改, 但是可以改变对象内部的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; &#123;</span><br><span class="line">    name: &#39;why&#39;,</span><br><span class="line">    age: 18,</span><br><span class="line">    height: 1.88</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; const修饰的标识符被赋值之后, 不能修改</span><br><span class="line">  &#x2F;&#x2F; obj &#x3D; &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 但是可以改变对象内部的属性</span><br><span class="line">  obj.name &#x3D; &#39;kobe&#39;;</span><br><span class="line">  obj.age &#x3D; 40;</span><br><span class="line">  obj.height &#x3D; 1.87;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3、对象增强写法"><a href="#3、对象增强写法" class="headerlink" title="3、对象增强写法"></a>3、<strong>对象增强写法</strong></h3><p>ES6中，对<strong>对象字面量</strong>进行了很多增强。</p>
<p>属性初始化简写和方法的简写：</p>
<ul>
<li><p>属性初始化</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// ES5的写法</span><br><span class="line">const obj = &#123;</span><br><span class="line">  name: name,</span><br><span class="line">  age: age,</span><br><span class="line">  height: height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ES6的写法</span><br><span class="line">const obj = &#123;</span><br><span class="line">  name,</span><br><span class="line">  age,</span><br><span class="line">  height,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法的简写</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// ES5的写法</span><br><span class="line">const obj = &#123;</span><br><span class="line">  run: function () &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  eat: function () &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// ES6的写法</span><br><span class="line">const obj = &#123;</span><br><span class="line">  run() &#123;</span><br><span class="line">  </span><br><span class="line">  &#125;,</span><br><span class="line">  eat() &#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="二、Vue基础语法"><a href="#二、Vue基础语法" class="headerlink" title="二、Vue基础语法"></a>二、Vue基础语法</h2><h3 id="1、语法糖"><a href="#1、语法糖" class="headerlink" title="1、语法糖"></a>1、语法糖</h3><p>指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。</p>
<p>语法糖对程序员来说是友好的，但对机器本身却不怎么好。语法糖越甜，编译成的二进制也就越麻烦，出错的时候也会带来更多的麻烦。程序员要做的不是尽力避免错误，而是聚焦在快速发现并改正错误。真正以快速方式轻易解决错误，“快速的失败”远胜过“预防错误”。</p>
<p>Vue中常用的语法糖：</p>
<ul>
<li><code>v-bind</code>：<code>:</code></li>
<li><code>v-on</code>：<code>@</code></li>
<li><code>v-once</code>：<code>.once</code></li>
</ul>
<h3 id="2、插值语法"><a href="#2、插值语法" class="headerlink" title="2、插值语法"></a>2、插值语法</h3><h4 id="1、mustache语法"><a href="#1、mustache语法" class="headerlink" title="1、mustache语法"></a>1、mustache语法</h4><p>Mustache（胡子/胡须）是一款「logic-less（轻逻辑）」的前端模板引擎，它原本是基于 javascript 实现的，但是因为轻量易用，所以经过拓展目前支持更多的平台，如 java，.NET，PHP，C++ 等。Mustache 主要用于在表现和数据相分离的前端技术架构中，根据数据生成特定的动态内容，这些内容在网页中指的是HTML结构，而在小程序中则是WXML结构。在前后端分离的技术架构下面，前端模板引擎是一种可以被考虑的技术选型，随着重型框架（AngularJS、ReactJS、Vue）的流行，前端的模板技术已经成为了某种形式上的标配，Mustache 的价值在于其稳定和经典</p>
<p>主页：<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/janl/mustache.js/">https://github.com/janl/mustache.js/</a></p>
<p>文档：<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://mustache.github.io/mustache.5.html">https://mustache.github.io/mustache.5.html</a></p>
<p>项目主页：<a target="_blank" rel="noopener" href="http://mustache.github.io/">http://mustache.github.io/</a></p>
<p>Handlebars：基于 Mustache 的模板引擎：<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://handlebarsjs.com/">http://handlebarsjs.com/</a></p>
<p>对于Vue简单来说："{{}}"（双大括号）不仅仅可以直接写变量,也可以写简单的表达式

更多的Mustache功能参考：https://www.jianshu.com/p/7f1cecdc27e1

我们可以像下面这样来使用，并且数据是响应式的：

![image-20210320030738172](VUE/11.png)

#### 2、v-once

在某些情况下，我们可能不希望界面随意的跟随改变，这个时候，我们就可以使用一个Vue的指令：v-once

v-once：

- 该指令后面不需要跟任何表达式(比如v-for后面是由跟表达式的)
- p该指令表示元素和组件(组件后面才会学习)只渲染一次，不会随着数据的改变而改变。

代码：

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-once</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好啊&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

效果：

![image-20210320032116662](VUE/12.png)

#### 3、v-html

某些情况下，我们从服务器请求到的数据本身就是一个HTML代码。如果我们直接通过"{{}}"来输出，会将HTML代码也一起输出。但是我们可能希望的是按照HTML格式进行解析，并且显示对应的内容。这个时候，我们就可以使用一个Vue的指令：v-html</p>
<p>v-html：</p>
<ul>
<li>该指令后面往往会跟上一个string类型</li>
<li>会将string的html解析出来并且进行渲染</li>
</ul>
<p>代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;url&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-html</span>=<span class="string">&quot;url&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好啊&#x27;</span>,</span></span><br><span class="line"><span class="handlebars"><span class="xml">      url: &#x27;<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span>&gt;</span>百度一下<span class="tag">&lt;/<span class="name">a</span>&gt;</span>&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<h4 id="4、v-text（不常用）"><a href="#4、v-text（不常用）" class="headerlink" title="4、v-text（不常用）"></a><img src="/2021/04/19/VUE/13.png" alt="image-20210320032430169">4、v-text（不常用）</h4><p>nv-text作用和Mustache比较相似：都是用于将数据显示在界面中</p>
<p>nv-text</p>
<ul>
<li>通常情况下，接受一个string类型</li>
</ul>
<p>代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;, 李银河!<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-text</span>=<span class="string">&quot;message&quot;</span>&gt;</span>, 李银河!<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好啊&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="/2021/04/19/VUE/14.png" alt="image-20210320032749380"></p>
<h4 id="5、v-pre"><a href="#5、v-pre" class="headerlink" title="5、v-pre"></a>5、v-pre</h4><p>v-pre用于跳过这个元素和它子元素的编译过程，用于显示原本的Mustache语法。</p>
<p>比如下面的代码：</p>
<ul>
<li>第一个h2元素中的内容会被编译解析出来对应的内容</li>
<li>第二个h2元素中会直接显示</li>
</ul>
<p>代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-pre</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;Hello World&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="/2021/04/19/VUE/15.png" alt="image-20210320032946332"></p>
<h4 id="6、v-cloak"><a href="#6、v-cloak" class="headerlink" title="6、v-cloak"></a>6、v-cloak</h4><p>在某些情况下，我们浏览器可能会直接显然出未编译的Mustache标签（加载过慢）。</p>
<p>v-cloak</p>
<ul>
<li>存在期限：在vue解析之前存在，在vue解析之后消失。</li>
<li>该指令后面不需要跟任何表达式</li>
</ul>
<p>cloak：斗篷（起遮挡作用）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-attr">[v-cloak]</span> &#123;</span></span><br><span class="line">      display: none;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span> <span class="attr">v-cloak</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 在vue解析之前, div中有一个属性v-cloak</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 在vue解析之后, div中没有一个属性v-cloak</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">      data: &#123;</span><br><span class="line"><span class="javascript">        message: <span class="string">&#x27;你好啊&#x27;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<ul>
<li>在没加v-cloak之前，浏览器先显示，过1s后显示“你好啊”</li>
<li>在加了v-cloak之后，浏览器先显示空白，过1s后显示“你好啊”</li>
</ul>
<h3 id="3、绑定属性（v-bind）"><a href="#3、绑定属性（v-bind）" class="headerlink" title="3、绑定属性（v-bind）"></a>3、绑定属性（v-bind）</h3><h4 id="1、v-bind基础"><a href="#1、v-bind基础" class="headerlink" title="1、v-bind基础"></a>1、v-bind基础</h4><p>前面的插值指令主要作用是将值插入到我们<strong>模板的内容</strong>当中。但是，除了内容需要动态来决定外，某些属性我们也希望动态来绑定。</p>
<ul>
<li>比如动态绑定a元素中网站的链接href</li>
<li>比如动态绑定img元素的src属性</li>
<li>动态绑定一些类、样式</li>
</ul>
<p>v-bind指令：</p>
<ul>
<li>作用：绑定一个或多个属性值，或者向另一个组件传递props值</li>
<li>缩写：<code>:</code></li>
<li>预期：any (with argument) | Object (without argument)</li>
<li>参数：attrOrProp (optional)</li>
</ul>
<p>通过Vue实例中的data绑定元素的src和href：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 错误的做法: 这里不可以使用mustache语法--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--&lt;img src=&quot;&#123;&#123;imgURL&#125;&#125;&quot; alt=&quot;&quot;&gt;--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 正确的做法: 使用v-bind指令 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">&quot;imgURL&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;aHref&quot;</span>&gt;</span>百度一下<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--&lt;h2&gt;&#123;&#123;&#125;&#125;&lt;/h2&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--语法糖的写法--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;imgURL&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;aHref&quot;</span>&gt;</span>百度一下<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      imgURL: <span class="string">&#x27;https://vuejs.org/images/log.png&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      aHref: <span class="string">&#x27;https://vuejs.org&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2、v-bind绑定class"><a href="#2、v-bind绑定class" class="headerlink" title="2、v-bind绑定class"></a>2、v-bind绑定class</h4><p>很多时候，我们希望动态的来切换class：</p>
<ul>
<li>当数据为某个状态时，字体显示红色。</li>
<li>当数据另一个状态时，字体显示黑色。</li>
</ul>
<h5 id="1、绑定方式：对象语法"><a href="#1、绑定方式：对象语法" class="headerlink" title="1、绑定方式：对象语法"></a>1、绑定方式：对象语法</h5><p>对象语法的含义是:class后面跟的是一个对象。</p>
<p>语法：v-bind:class=’{类名: boolean,类名: boolean}’</p>
<p>eg：v-bind:class=”{类名1: true, 类名2: boolean}</p>
<p>对象语法有下面这些用法：</p>
<ul>
<li><p>直接通过{}绑定一个类：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;&#x27;active&#x27;: isActive&#125;&quot;</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过判断，传入多个值：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;&#x27;active&#x27;: isActive, &#x27;line&#x27;: isLine&#125;&quot;</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>和普通的类同时存在，并不冲突</p>
<p>注：如果isActive和isLine都为true，那么会有title/active/line三个class</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;&#x27;active&#x27;: isActive, &#x27;line&#x27;: isLine&#125;&quot;</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果过于复杂，可以放在一个methods或者<code>computed</code>中</p>
<p>注：classes是一个<code>计算属性</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;classes&quot;</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      isActive: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">      isLine: <span class="literal">true</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line"><span class="javascript">      classes: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;<span class="attr">active</span>: <span class="built_in">this</span>.isActive, <span class="attr">line</span>: <span class="built_in">this</span>.isLine&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="2、绑定方式：数组语法"><a href="#2、绑定方式：数组语法" class="headerlink" title="2、绑定方式：数组语法"></a>2、绑定方式：数组语法</h5><p>数组语法的含义是:class后面跟的是一个数组。</p>
<p>数组语法有下面这些用法：</p>
<ul>
<li><p>直接通过{}绑定一个类：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">&quot;[&#x27;active&#x27;,&#x27;line&#x27;]&quot;</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>和普通的类同时存在，并不冲突</p>
<p>注：会有title/active/line三个class</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span> <span class="attr">:class</span>=<span class="string">“[‘active’,</span> &#x27;<span class="attr">line</span>&#x27;]&quot;&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果过于复杂，可以放在一个methods或者computed中</p>
<p>注：classes是一个<code>计算属性</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;getClasses()&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      active: <span class="string">&#x27;aaaaaa&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      line: <span class="string">&#x27;bbbbbbb&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      getClasses: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> [<span class="built_in">this</span>.active, <span class="built_in">this</span>.line]</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="3、v-bind绑定style"><a href="#3、v-bind绑定style" class="headerlink" title="3、v-bind绑定style"></a>3、v-bind绑定style</h4><p>我们可以利用v-bind:style来绑定一些CSS内联样式。</p>
<p>在写CSS属性名的时候，比如font-size</p>
<ul>
<li>我们可以使用驼峰式 (camelCase) fontSize </li>
<li>或短横线分隔 (kebab-case，记得用单引号括起来) ‘font-size’</li>
</ul>
<h5 id="1、绑定方式：对象语法-1"><a href="#1、绑定方式：对象语法-1" class="headerlink" title="1、绑定方式：对象语法"></a>1、绑定方式：对象语法</h5><p>style后面跟的是一个对象类型</p>
<ul>
<li>对象的key是<code>CSS属性名称</code></li>
<li>对象的value是具体赋的值，值可以来自于data中的属性</li>
<li>如果过于复杂，可以放在一个methods或者<code>computed</code>中</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.title</span> &#123;</span></span><br><span class="line">      font-size: 50px;</span><br><span class="line">      color: red;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--&lt;h2 :style=&quot;&#123;key(属性名): value(属性值)&#125;&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--&#x27;50px&#x27;必须加上单引号, 否则是当做一个变量去解析--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:style</span>=<span class="string">&quot;&#123;fontSize: &#x27;50px&#x27;&#125;&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--finalSize当成一个变量使用--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--&lt;h2 :style=&quot;&#123;fontSize: finalSize&#125;&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:style</span>=<span class="string">&quot;&#123;fontSize: finalSize + &#x27;px&#x27;, backgroundColor: finalColor&#125;&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:style</span>=<span class="string">&quot;getStyles()&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好啊&#x27;</span>,</span></span><br><span class="line">      finalSize: 100,</span><br><span class="line"><span class="javascript">      finalColor: <span class="string">&#x27;red&#x27;</span>,</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      getStyles: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;<span class="attr">fontSize</span>: <span class="built_in">this</span>.finalSize + <span class="string">&#x27;px&#x27;</span>, <span class="attr">backgroundColor</span>: <span class="built_in">this</span>.finalColor&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="2、绑定方式：数组语法-1"><a href="#2、绑定方式：数组语法-1" class="headerlink" title="2、绑定方式：数组语法"></a>2、绑定方式：数组语法</h5><p>style后面跟的是一个数组类型</p>
<ul>
<li>多个值以<code>,</code>分割即可</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:style</span>=<span class="string">&quot;[baseStyle, baseStyle1]&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好啊&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      baseStyle: &#123;<span class="attr">backgroundColor</span>: <span class="string">&#x27;red&#x27;</span>&#125;,</span></span><br><span class="line"><span class="javascript">      baseStyle1: &#123;<span class="attr">fontSize</span>: <span class="string">&#x27;100px&#x27;</span>&#125;,</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4、计算属性（computed）"><a href="#4、计算属性（computed）" class="headerlink" title="4、计算属性（computed）"></a>4、计算属性（computed）</h3><h4 id="1、是什么计算属性"><a href="#1、是什么计算属性" class="headerlink" title="1、是什么计算属性"></a>1、是什么计算属性</h4><p>在模板中可以直接通过插值语法显示一些data中的数据。但是在某些情况，我们可能需要对数据进行一些转化后再显示，或者需要将多个数据结合起来进行显示：</p>
<ul>
<li><p>比如我们有firstName和lastName两个变量，我们需要显示完整的名称：</p>
<ul>
<li> </li>
<li>undefined undefined
</li>
</ul>
</li>
<li><p>但是如果多个地方都需要显示完整的名称，我们就需要写多个</p>
 。代码臃肿

</li>
</ul>
<p>我们可以将上面的代码换成计算属性：写在实例Vue的computed选项中的。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;firstName + &#x27; &#x27; + lastName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;getFullName()&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      firstName: <span class="string">&#x27;Lebron&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      lastName: <span class="string">&#x27;James&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="comment">// computed: 计算属性()</span></span></span><br><span class="line">    computed: &#123;</span><br><span class="line"><span class="javascript">      fullName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">getFullName</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2、计算属性："><a href="#2、计算属性：" class="headerlink" title="2、计算属性："></a>2、计算属性：</h4><ul>
<li><p>解决代码臃肿</p>
</li>
<li><p>可以进行一些更加复杂的操作</p>
<p><img src="/2021/04/19/VUE/16.png" alt="image-20210320150614370"></p>
</li>
<li><p>计算属性会进行缓存，如果多次使用时，计算属性只会调用一次。</p>
</li>
</ul>
<h4 id="3、计算属性的setter和getter"><a href="#3、计算属性的setter和getter" class="headerlink" title="3、计算属性的setter和getter"></a>3、计算属性的setter和getter</h4><p>每个计算属性都包含一个getter和一个setter</p>
<ul>
<li><p>在上面的例子中，我们只是使用getter来读取。</p>
</li>
<li><p>在某些情况下，你也可以提供一个setter方法（不常用）。</p>
<p>由于一般我们不希望有人能任意修改我们的计算属性的值，所以一般省略setter方法。而计算属性的getter就能简写成：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 简写前（如果有setter方法）：</span><br><span class="line">computed: &#123;</span><br><span class="line">	  fullName: &#123;</span><br><span class="line">		get() &#123;</span><br><span class="line">		  console.log(&#x27;---调用了fullName的get&#x27;);</span><br><span class="line">		  return this.firstName + &#x27; &#x27; + this.lastName</span><br><span class="line">		&#125;</span><br><span class="line">	  &#125;,</span><br><span class="line">		set(newValue) &#123;</span><br><span class="line">		  console.log(&#x27;---调用了fullName的get&#x27;);</span><br><span class="line">		  const names = newValue.split(&#x27; &#x27;);</span><br><span class="line">		  this.firstName = names[0];</span><br><span class="line">		  this.lastName = names[1];</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 简写后：</span><br><span class="line">computed: &#123;</span><br><span class="line">      fullName: function () &#123;</span><br><span class="line">        return this.firstName + &#x27; &#x27; + this.lastName</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="4、methods与computed"><a href="#4、methods与computed" class="headerlink" title="4、methods与computed"></a>4、methods与computed</h4><p>methods和computed看起来都可以实现我们的功能，那么为什么还要多一个计算属性这个东西呢？</p>
<p>原因：计算属性会进行缓存，如果多次使用时，计算属性只会调用一次。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--1.直接拼接: 语法过于繁琐--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--2.通过定义methods--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--&lt;h2&gt;&#123;&#123;getFullName()&#125;&#125;&lt;/h2&gt;--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--&lt;h2&gt;&#123;&#123;getFullName()&#125;&#125;&lt;/h2&gt;--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--&lt;h2&gt;&#123;&#123;getFullName()&#125;&#125;&lt;/h2&gt;--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--&lt;h2&gt;&#123;&#123;getFullName()&#125;&#125;&lt;/h2&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--3.通过computed--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// angular -&gt; google</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// TypeScript(microsoft) -&gt; ts(类型检测)</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// flow(facebook) -&gt;</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      firstName: <span class="string">&#x27;Kobe&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      lastName: <span class="string">&#x27;Bryant&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      getFullName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;getFullName&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line"><span class="javascript">      fullName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;fullName&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<ul>
<li><p>当使用computed时：由于有缓存，浏览器只执行了一次。</p>
<p><img src="/2021/04/19/VUE/17.png" alt="image-20210320153300912"></p>
</li>
<li><p>当使用methods时：没有缓存，浏览器执行多次，加重了浏览器的负担。</p>
<p><img src="/2021/04/19/VUE/18.png" alt="image-20210320153616146"></p>
</li>
</ul>
<h3 id="5、事件监听（v-on）"><a href="#5、事件监听（v-on）" class="headerlink" title="5、事件监听（v-on）"></a>5、事件监听（v-on）</h3><p>在前端开发中，我们需要经常和用于交互。</p>
<p>这个时候，我们就必须监听用户发生的时间，比如点击、拖拽、键盘事件等等</p>
<p>在Vue中如何监听事件呢？使用v-on指令</p>
<p>v-on：</p>
<ul>
<li><strong>作用</strong>：绑定事件监听器</li>
<li><strong>缩写</strong>（语法糖）：@</li>
<li><strong>预期</strong>：Function | Inline Statement | Object</li>
<li><strong>参数</strong>：event</li>
</ul>
<h4 id="1、v-on基础"><a href="#1、v-on基础" class="headerlink" title="1、v-on基础"></a>1、v-on基础</h4><ul>
<li><p>一般v-on后面加上<code>:</code>，然后加上<code>动作</code>如点击（click）、拖拽、键盘事件（keyup/keydown）等等。</p>
</li>
<li><p>若v-on监听的事件简单，可以在v-on后面直接实现</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;counter++&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>若v-on监听的事件复杂，就需要将事件的实现抽取成一个方法</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">      increment() &#123;</span><br><span class="line">        this.counter++</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="2、v-on参数"><a href="#2、v-on参数" class="headerlink" title="2、v-on参数"></a>2、v-on参数</h4><p>当通过methods中定义方法，以供@click调用时，需要<strong>注意参数问题</strong>：</p>
<ul>
<li><p>如果该方法不需要额外参数，那么方法后的()可以不添加。</p>
<p>但是注意：如果方法本身中有一个参数，那么会默认将原生事件event参数传递进去。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1.事件调用的方法没有参数--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--1.1函数后添加()--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btn1Click()&quot;</span>&gt;</span>按钮1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--1.1函数后不添加()--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btn1Click&quot;</span>&gt;</span>按钮1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">      btn1Click() &#123;</span><br><span class="line">        console.log(&quot;btn1Click&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--2.在事件定义时, 写方法时省略了小括号, 但是方法本身是需要一个参数的, 这个时候, Vue会默认将浏览器生产的event事件对象作为参数传入到方法--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--2.1函数后没添加()--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btn2Click&quot;</span>&gt;</span>按钮2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--2.2函数需要参数,()里传入参数--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;button @click=&quot;btn2Click(123)&quot;&gt;按钮2&lt;/button&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--2.3如果函数需要参数,但是没有传入, 那么函数的形参为undefined--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;button @click=&quot;btn2Click()&quot;&gt;按钮2&lt;/button&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">      btn2Click(event) &#123;</span><br><span class="line">        console.log(&#x27;--------&#x27;, event);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.1的效果：</p>
<p><img src="/2021/04/19/VUE/20.png" alt="image-20210320232959026"></p>
<p>2.3的效果：</p>
<p><img src="/2021/04/19/VUE/21.png" alt="image-20210320233429354"></p>
</li>
<li><p>如果需要同时传入某个参数，同时需要event时，可以通过$event传入事件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--3.方法定义时, 我们需要event对象, 同时又需要其他参数--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--3.1在调用函数时, 如何手动的获取到浏览器参数的event对象: $event--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btn3Click(&#x27;abc&#x27;, $event)&quot;</span>&gt;</span>按钮3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--3.2在调用函数时，若event没有加$，那么浏览器将默认将event当成一个变量，若event在app实例里没有定义的话，浏览器会找不到该变量而报错并且返回undefined--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btn3Click(&#x27;abc&#x27;, event)&quot;</span>&gt;</span>按钮3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--3.3在调用函数时，若函数没传入参数，那么浏览器将默认将浏览器参数的event放入第一个参数中，又因为第二个参数没有传值，浏览器会将其变为undefined--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btn3Click&quot;</span>&gt;</span>按钮3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">      btn3Click(abc, event) &#123;</span><br><span class="line">        console.log(&#x27;++++++++&#x27;, abc, event);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.1的效果：</p>
<p><img src="/2021/04/19/VUE/22.png" alt="image-20210320234009069"></p>
<p>3.2的效果：</p>
<p><img src="/2021/04/19/VUE/23.png" alt="image-20210320235528249"></p>
<p>3.3的效果：</p>
<p><img src="/2021/04/19/VUE/24.png" alt="image-20210320235715797"></p>
</li>
</ul>
<h4 id="3、v-on修饰符"><a href="#3、v-on修饰符" class="headerlink" title="3、v-on修饰符"></a>3、v-on修饰符</h4><p>在某些情况下，我们拿到event的目的可能是进行一些事件处理。Vue提供了修饰符来帮助我们方便的处理一些事件：</p>
<ul>
<li>.stop - 调用 event.stopPropagation()。</li>
<li>.prevent - 调用 event.preventDefault()。</li>
<li>.{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调。</li>
<li>.native - 监听组件根元素的原生事件。</li>
<li>.once - 只触发一次回调。</li>
</ul>
<p><img src="/2021/04/19/VUE/25.png" alt="image-20210321000423484"></p>
<p>更多修饰符参考<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/events.html#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6">官网的事件修饰符</a>，以下来自官网。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">&quot;onSubmit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.capture</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 点击事件将只会触发一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.once</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 而不会等待 `onScroll` 完成  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:scroll.passive</span>=<span class="string">&quot;onScroll&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.enter</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.page-down</span>=<span class="string">&quot;onPageDown&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="6、条件判断"><a href="#6、条件判断" class="headerlink" title="6、条件判断"></a>6、条件判断</h3><h4 id="1、v-if、v-else-if、v-else"><a href="#1、v-if、v-else-if、v-else" class="headerlink" title="1、v-if、v-else-if、v-else"></a>1、v-if、v-else-if、v-else</h4><ul>
<li><p>这三个指令与JavaScript的条件语句if、else、else if类似。</p>
</li>
<li><p>Vue的条件指令可以根据表达式的值在DOM中渲染或销毁元素或组件。</p>
</li>
</ul>
<p>简单的案例演示：</p>
<p><img src="/2021/04/19/VUE/26.png" alt="image-20210321004504280"></p>
<p><img src="/2021/04/19/VUE/27.png" alt="image-20210321005848254"></p>
<p>v-if的原理：</p>
<ul>
<li><p>v-if后面的条件为false时，对应的元素以及其子元素不会渲染。</p>
</li>
<li><p>也就是根本没有不会有对应的标签出现在DOM中。</p>
</li>
</ul>
<h4 id="2、一个简单的小案例（用户登陆方式切换）"><a href="#2、一个简单的小案例（用户登陆方式切换）" class="headerlink" title="2、一个简单的小案例（用户登陆方式切换）"></a>2、一个简单的小案例（用户登陆方式切换）</h4><p>用户再登录时，可以切换使用用户账号登录还是邮箱地址登录。类似如下情景：</p>
<p><img src="/2021/04/19/VUE/28.png" alt="image-20210321013857218"></p>
<p>代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;isUser&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>用户账号<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;用户账号&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;email&quot;</span>&gt;</span>用户邮箱<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;email&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;用户邮箱&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;isUser = !isUser&quot;</span>&gt;</span>切换类型<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      isUser: <span class="literal">true</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="1、问题"><a href="#1、问题" class="headerlink" title="1、问题"></a>1、问题</h5><p>以上案例会有一个小问题：如果我们在有输入内容的情况下，切换了类型，我们会发现文字依然显示之前的输入的内容。</p>
<p>为什么呢？按道理讲，我们在一个input输入的内容（value），在切换到另外一个input元素后应该消失，因为在另一个input元素中，我们并没有输入内容。</p>
<h5 id="2、问题解答"><a href="#2、问题解答" class="headerlink" title="2、问题解答"></a>2、问题解答</h5><ul>
<li>这是因为Vue在进行渲染时，不会直接渲染在浏览器上面，Vue会在其之间构建一个虚拟NOM，Vue会先渲染在虚拟DOM上面，然后在渲染在浏览器上。而出于性能考虑，当出现两个只存在一个（if -else）的时候，会尽可能的复用已经存在的元素，而不是重新创建新的元素。</li>
<li>在上面的案例中，Vue内部会发现原来（if）的input元素不再使用，直接作为else中的input来使用了。此时并不会重新构建一个input，并且改变的只有与之前input不同的内容（如for、id、placeholder等等），所以文本里面的内容不会改变。</li>
</ul>
<h5 id="3、解决方案"><a href="#3、解决方案" class="headerlink" title="3、解决方案"></a>3、解决方案</h5><p>如果我们不希望Vue出现类似重复利用的问题，可以给对应的input添加key</p>
<p>并且需要我们保证key的值不同。（若key的值相同的话还是会继承文本内容）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;isUser&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>用户账号<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;用户账号&quot;</span> <span class="attr">key</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;email&quot;</span>&gt;</span>用户邮箱<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;email&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;用户邮箱&quot;</span> <span class="attr">key</span>=<span class="string">&quot;email&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3、v-show"><a href="#3、v-show" class="headerlink" title="3、v-show"></a>3、<strong>v-show</strong></h4><p>v-show的用法和v-if非常相似，也用于决定一个元素是否渲染</p>
<p><strong>v-if和v-show对比：</strong></p>
<ul>
<li>v-if: 当条件为false时, 包含v-if指令的元素, 根本就不会存在dom中</li>
<li>v-show: 当条件为false时, v-show只是给我们的元素添加一个行内样式: display: none</li>
</ul>
<p>v-if和v-show都可以决定一个元素是否渲染，<strong>开发中如何选择</strong>呢：</p>
<ul>
<li>当需要在显示与隐藏之间切换很频繁时，使用v-show</li>
<li>当只有一次切换时，通过使用v-if</li>
</ul>
<h3 id="7、循环遍历（v-for）"><a href="#7、循环遍历（v-for）" class="headerlink" title="7、循环遍历（v-for）"></a>7、循环遍历（v-for）</h3><h4 id="1、v-for遍历数组"><a href="#1、v-for遍历数组" class="headerlink" title="1、v-for遍历数组"></a>1、v-for遍历数组</h4><p>当我们有一组数据需要进行渲染时，我们就可以使用v-for来完成</p>
<ul>
<li><p>v-for的语法类似于JavaScript中的for循环。</p>
</li>
<li><p>格式如下：item in items的形式。</p>
</li>
<li><p>如果在遍历的过程中不需要使用索引值</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in names&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果在遍历的过程中，我们需要拿到元素在数组中的索引值</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in names&quot;</span>&gt;</span></span><br><span class="line">      // 使遍历从1开始</span><br><span class="line">      &#123;&#123;index+1&#125;&#125;.&#123;&#123;item&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="2、v-for遍历对象"><a href="#2、v-for遍历对象" class="headerlink" title="2、v-for遍历对象"></a>2、v-for遍历对象</h4><p>当有一对象需要我们对其里面的数据进行渲染时，我们就可以使用v-for来完成</p>
<ul>
<li><p>在遍历对象的过程中, 如果只是获取一个值, 那么获取到的是value</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in info&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      info: &#123;</span><br><span class="line"><span class="javascript">        name: <span class="string">&#x27;why&#x27;</span>,</span></span><br><span class="line">        age: 18,</span><br><span class="line">        height: 1.88</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<ul>
<li>why</li>
<li>18</li>
<li>1.88</li>
</ul>
</li>
<li><p>获取key和value 格式: (value, key)</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, key) in info&quot;</span>&gt;</span>&#123;&#123;value&#125;&#125;-&#123;&#123;key&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      info: &#123;</span><br><span class="line"><span class="javascript">        name: <span class="string">&#x27;why&#x27;</span>,</span></span><br><span class="line">        age: 18,</span><br><span class="line">        height: 1.88</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<ul>
<li>why-name</li>
<li>18-age</li>
<li>1.88-height</li>
</ul>
</li>
<li><p>获取key和value和index 格式: (value, key, index)</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, key, index) in info&quot;</span>&gt;</span>&#123;&#123;value&#125;&#125;-&#123;&#123;key&#125;&#125;-&#123;&#123;index + 1&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      info: &#123;</span><br><span class="line"><span class="javascript">        name: <span class="string">&#x27;why&#x27;</span>,</span></span><br><span class="line">        age: 18,</span><br><span class="line">        height: 1.88</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<ul>
<li>why-name-1</li>
<li>18-age-2</li>
<li>1.88-height-3</li>
</ul>
</li>
</ul>
<h4 id="3、v-for的组件的key属性"><a href="#3、v-for的组件的key属性" class="headerlink" title="3、v-for的组件的key属性"></a>3、v-for的组件的key属性</h4><p>官方推荐我们在使用v-for时，给对应的元素或组件添加上一个:key属性。</p>
<p>为什么需要这个key属性呢？</p>
<ul>
<li><p>这个其实和Vue的虚拟DOM的Diff算法有关系</p>
</li>
<li><p>我们借用<a href="https://link.zhihu.com/?target=https://calendar.perfplanet.com/2013/diff/">React’s</a><a href="https://link.zhihu.com/?target=https://calendar.perfplanet.com/2013/diff/"> diff algorithm</a>中的一张图来简单说明一下：</p>
<p><img src="/2021/04/19/VUE/29.png" alt="image-20210321153710582"></p>
</li>
<li><p>当某一层有很多相同的节点时，也就是列表节点时，我们希望插入一个新的节点</p>
<ul>
<li>我们希望可以在B和C之间加一个F，Diff算法默认执行起来是这样的</li>
<li>即把C更新成F，D更新成C，E更新成D，最后再插入E</li>
</ul>
</li>
<li><p>这样做会使程序的执行效率变低，所以可以用<code>key</code>这个属性来给每个节点做一个唯一标识</p>
<ul>
<li>Diff算法就可以正确的识别此节点</li>
<li>找到正确的位置区插入新的节点</li>
</ul>
</li>
<li><p><strong>key的作用主要是为了高效的更新虚拟DOM</strong></p>
</li>
</ul>
<h4 id="4、检测数组更新（响应式）"><a href="#4、检测数组更新（响应式）" class="headerlink" title="4、检测数组更新（响应式）"></a>4、检测数组更新（响应式）</h4><p>因为Vue是响应式的，所以当数据发生变化时，Vue会自动检测数据变化，视图会发生对应的更新。</p>
<p>Vue中包含了一组观察数组编译的方法，使用它们改变数组也会触发视图的更新：</p>
<ul>
<li><p>push()：在数组末尾添加一个或多个元素</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">      letters: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.letters.push(&#x27;aaa&#x27;)</span><br><span class="line">this.letters.push(&#x27;aaaa&#x27;, &#x27;bbbb&#x27;, &#x27;cccc&#x27;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>pop()：删除数组中的最后一个元素</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">      letters: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.letters.pop();</span><br></pre></td></tr></table></figure>
</li>
<li><p>shift()：删除数组中的第一个元素</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">      letters: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.letters.shift();</span><br></pre></td></tr></table></figure>
</li>
<li><p>unshift()：在数组最前面添加一个或多个元素</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">      letters: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.letters.unshift()</span><br><span class="line">this.letters.unshift(&#x27;aaa&#x27;, &#x27;bbb&#x27;, &#x27;ccc&#x27;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>splice(start,index,…items)：删除元素/插入元素/替换元素</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">      letters: [&#x27;a&#x27;, &#x27;d&#x27;, &#x27;c&#x27;, &#x27;b&#x27;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除元素: 第二个参数传入你要删除几个元素(如果没有传,就删除后面所有的元素)</span><br><span class="line">this.letters.splice(1, 3)</span><br><span class="line">this.letters.splice(1)</span><br><span class="line"></span><br><span class="line">// 替换元素: 第二个参数, 表示我们要替换几个元素, 后面是用于替换前面的元素</span><br><span class="line">this.letters.splice(1, 3, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;l&#x27;, &#x27;x&#x27;)</span><br><span class="line"></span><br><span class="line">// 插入元素: 第二个参数, 传入0, 并且后面跟上要插入的元素</span><br><span class="line">this.letters.splice(1, 0, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>sort()：对数组进行排序。（参数可以添加排序的规则的方法）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">      letters: [&#x27;a&#x27;, &#x27;d&#x27;, &#x27;c&#x27;, &#x27;b&#x27;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.letters.sort()</span><br></pre></td></tr></table></figure>
</li>
<li><p>reverse()：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">      letters: [&#x27;a&#x27;, &#x27;d&#x27;, &#x27;c&#x27;, &#x27;b&#x27;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.letters.reverse()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>注意：通过<code>索引值</code>修改数组中的元素不能做到响应式</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">      letters: [&#x27;a&#x27;, &#x27;d&#x27;, &#x27;c&#x27;, &#x27;b&#x27;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.letters[0] = &#x27;bbbbbb&#x27;;</span><br></pre></td></tr></table></figure>

<p>此时可以通过splice方法或Vue的set方法的方式来修改以达到响应式的目的</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// splice方法</span><br><span class="line">this.letters.splice(0, 1, &#x27;bbbbbb&#x27;)</span><br><span class="line"></span><br><span class="line">// Vue的set(要修改的对象, 索引值, 修改后的值)</span><br><span class="line">Vue.set(this.letters, 0, &#x27;bbbbbb&#x27;)</span><br></pre></td></tr></table></figure>

<h4 id="5、作业：（v-for-v-bind-v-on-当前索引方法的应用）"><a href="#5、作业：（v-for-v-bind-v-on-当前索引方法的应用）" class="headerlink" title="5、作业：（v-for + v-bind + v-on + 当前索引方法的应用）"></a>5、作业：（v-for + v-bind + v-on + 当前索引方法的应用）</h4><p>需求：有一电影列表，点击哪一部影片，哪一部影片就表现为红色。</p>
<p>代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>homework<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.active</span>&#123;</span></span><br><span class="line">      color: red;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(movie,index) in movies&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:class</span>=<span class="string">&quot;&#123;active: currentIndex === index&#125;&quot;</span></span></span><br><span class="line"><span class="tag">        @<span class="attr">click</span>=<span class="string">&quot;isClick(index)&quot;</span>&gt;</span></span><br><span class="line">      &#123;&#123;index&#125;&#125;.&#123;&#123;movie&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      movies: [<span class="string">&#x27;海贼王&#x27;</span>,<span class="string">&#x27;火影忍者&#x27;</span>,<span class="string">&#x27;进击的巨人&#x27;</span>,<span class="string">&#x27;妖精的尾巴&#x27;</span>],</span></span><br><span class="line">      currentIndex: -1</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      isClick: <span class="function"><span class="keyword">function</span> (<span class="params">index</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.currentIndex = index</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="6、高阶函数filter-map-reduce"><a href="#6、高阶函数filter-map-reduce" class="headerlink" title="6、高阶函数filter|map|reduce"></a>6、高阶函数filter|map|reduce</h4><h5 id="1、filter：过滤作用"><a href="#1、filter：过滤作用" class="headerlink" title="1、filter：过滤作用"></a>1、filter：过滤作用</h5><p>filter函数的参数是一个回调函数，返回值为一个数组：</p>
<ul>
<li>回调函数的参数为循环遍历的值n</li>
<li>回调函数有一个要求: 必须返回一个boolean值<ul>
<li>true: 当返回true时, 函数内部会自动将这次回调的n加入到新的数组中</li>
<li>false：当返回false时, 函数内部会过滤掉这次的n</li>
</ul>
</li>
</ul>
<p>使用：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const nums = [10, 20, 111, 222, 444, 40, 50]</span><br><span class="line"></span><br><span class="line">// newNums = [10,20,40,50]</span><br><span class="line">let newNums = nums.filter(function (n) &#123;</span><br><span class="line">  return n <span class="tag">&lt; <span class="attr">100</span></span></span><br><span class="line"><span class="tag">&#125;)</span></span><br></pre></td></tr></table></figure>

<h5 id="2、map：映射作用"><a href="#2、map：映射作用" class="headerlink" title="2、map：映射作用"></a>2、map：映射作用</h5><p>map函数的参数是一个回调函数，返回值为一个数组：</p>
<ul>
<li>回调函数的参数为循环遍历的值n</li>
<li>可以在回调函数内对数组的值进行操作，map会帮操作完的值映射到一个新的数组</li>
</ul>
<p>使用：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// newNums = [10,20,40,50]</span><br><span class="line">// new2Nums = [20,40,80,100]</span><br><span class="line">let new2Nums = newNums.map(function (n) &#123; // 20</span><br><span class="line">  return n * 2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="3、reduce：作用对数组中所有的内容进行汇总"><a href="#3、reduce：作用对数组中所有的内容进行汇总" class="headerlink" title="3、reduce：作用对数组中所有的内容进行汇总"></a>3、reduce：作用对数组中所有的内容进行汇总</h5><p>map函数的参数是一个回调函数，和一个初始值</p>
<ul>
<li>回调函数有两个参数（previousValue，start）<ul>
<li>previousValue：数组当前值的前一个值</li>
<li>start：数组当前值</li>
</ul>
</li>
<li>初始值为数组一开始值（第一个元素，index=0）的前一个值</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// new2Nums = [20,40,80,100]</span><br><span class="line">// total = 240</span><br><span class="line">let total = new2Nums.reduce(function (preValue, n) &#123;</span><br><span class="line">  return preValue + n</span><br><span class="line">&#125;, 0)</span><br></pre></td></tr></table></figure>

<h5 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h5><p>需求：筛选出数组nums里所有小于100的值，然后就值乘以2再相加。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const nums = [10, 20, 111, 222, 444, 40, 50]</span><br><span class="line"></span><br><span class="line">let total = nums.filter(function (n) &#123;</span><br><span class="line">  return n <span class="tag">&lt; <span class="attr">100</span></span></span><br><span class="line"><span class="tag">&#125;)<span class="attr">.map</span>(<span class="attr">function</span> (<span class="attr">n</span>) &#123;</span></span><br><span class="line"><span class="tag">  <span class="attr">return</span> <span class="attr">n</span> * <span class="attr">2</span></span></span><br><span class="line"><span class="tag">&#125;)<span class="attr">.reduce</span>(<span class="attr">function</span> (<span class="attr">prevValue</span>, <span class="attr">n</span>) &#123;</span></span><br><span class="line"><span class="tag">  <span class="attr">return</span> <span class="attr">prevValue</span> + <span class="attr">n</span></span></span><br><span class="line"><span class="tag">&#125;, <span class="attr">0</span>)</span></span><br></pre></td></tr></table></figure>

<p>以上三个高阶函数的回调函数都可以用箭头函数表示。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let total = nums.filter(n =&gt; n <span class="tag">&lt; <span class="attr">100</span>)<span class="attr">.map</span>(<span class="attr">n</span> =&gt;</span> n * 2).reduce((pre, n) =&gt; pre + n)</span><br></pre></td></tr></table></figure>

<h3 id="8、表单绑定（v-mode）"><a href="#8、表单绑定（v-mode）" class="headerlink" title="8、表单绑定（v-mode）"></a>8、表单绑定（v-mode）</h3><h4 id="1、v-mode基础"><a href="#1、v-mode基础" class="headerlink" title="1、v-mode基础"></a>1、v-mode基础</h4><p>表单控件在实际开发中是非常常见的。特别是对于用户信息的提交，需要大量的表单。</p>
<p>Vue中使用v-model指令来实现表单元素和数据的双向绑定。</p>
<p>案例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123;message&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;Hello Vue&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/19/VUE/30.png" alt="image-20210321210459660"></p>
<p>案例的解析：</p>
<p>当我们在输入框输入内容时，因为input中的v-model绑定了message，所以会实时将输入的内容传递给message，message发生改变。当message发生改变时，因为上面我们使用Mustache语法，将message的值插入到DOM中，所以DOM会发生响应的改变。所以，通过v-model实现了双向的绑定。</p>
<p>当然，我们也可以将v-model用于textarea元素。</p>
<h4 id="2、v-mode的原理"><a href="#2、v-mode的原理" class="headerlink" title="2、v-mode的原理"></a>2、v-mode的原理</h4><p>v-model其实是一个语法糖，它的背后本质上是包含两个操作：</p>
<ul>
<li>v-bind绑定一个value属性</li>
<li>v-on指令给当前元素绑定input事件</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--等同与--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;message&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;valueChange&quot;</span>&gt;</span></span><br><span class="line">methods: &#123;</span><br><span class="line">      valueChange(event) &#123;</span><br><span class="line">        this.message = event.target.value;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">&lt;!--也等同与--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;message&quot;</span> <span class="attr">v-on:input</span>=<span class="string">&quot;message = $event.target.value&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3、v-mode：radio"><a href="#3、v-mode：radio" class="headerlink" title="3、v-mode：radio"></a>3、v-mode：radio</h4><p>当存在多个单选框时，v-mode可用于将单选框的值和与之对应变量进行双向绑定。</p>
<p>其中一个label与一个input组合，label里面的for与input里面的id一一对应，实现用户点击文字就可以选中对应的单选框。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;male&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;male&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;sex&quot;</span>&gt;</span>男</span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;female&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;female&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;sex&quot;</span>&gt;</span>女</span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>您选择的性别是: &#123;&#123;sex&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      sex: <span class="string">&#x27;女&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="4、v-mode：checkbox"><a href="#4、v-mode：checkbox" class="headerlink" title="4、v-mode：checkbox"></a>4、v-mode：checkbox</h4><p>checkbox复选框分为两种情况：单个勾选框和多个勾选框</p>
<ul>
<li><p>单个勾选框：</p>
<ul>
<li><p>v-model即为布尔值</p>
</li>
<li><p>此时input的value并不影响v-model的值</p>
</li>
<li><p>常用于让用户点击<code>同意协议</code>后才能点击<code>下一步</code>的业务场景</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;licence&quot;</span>&gt;</span>--&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;licence&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;isAgree&quot;</span>&gt;</span>同意协议</span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>您选择的是: &#123;&#123;isAgree&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">:disabled</span>=<span class="string">&quot;!isAgree&quot;</span>&gt;</span>下一步<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      isAgree: <span class="literal">false</span>,</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>多个复选框</p>
<ul>
<li><p>当是多个复选框时，因为可以选中多个，所以对应的data中属性是一个数组</p>
</li>
<li><p>当选中某一个时，就会将input的value添加到数组中</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;篮球&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobbies&quot;</span>&gt;</span>篮球</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;足球&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobbies&quot;</span>&gt;</span>足球</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;乒乓球&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobbies&quot;</span>&gt;</span>乒乓球</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;羽毛球&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobbies&quot;</span>&gt;</span>羽毛球</span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>您的爱好是: &#123;&#123;hobbies&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--label中的:for与input的:id对应--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">v-for</span>=<span class="string">&quot;item in originHobbies&quot;</span> <span class="attr">:for</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;item&quot;</span> <span class="attr">:id</span>=<span class="string">&quot;item&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobbies&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      hobbies: [],</span><br><span class="line"><span class="javascript">      originHobbies: [<span class="string">&#x27;篮球&#x27;</span>, <span class="string">&#x27;足球&#x27;</span>, <span class="string">&#x27;乒乓球&#x27;</span>, <span class="string">&#x27;羽毛球&#x27;</span>, <span class="string">&#x27;台球&#x27;</span>, <span class="string">&#x27;高尔夫球&#x27;</span>]</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="5、v-mode：select"><a href="#5、v-mode：select" class="headerlink" title="5、v-mode：select"></a>5、v-mode：select</h4><p>select也分单选和多选两种情况：</p>
<ul>
<li><p>单选：只能选中一个值：</p>
<ul>
<li><p>v-model绑定的是一个值</p>
</li>
<li><p>当我们选中option中的一个时，会将它对应的value赋值到mySelect中</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;abc&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;fruit&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;苹果&quot;</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;香蕉&quot;</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;榴莲&quot;</span>&gt;</span>榴莲<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;葡萄&quot;</span>&gt;</span>葡萄<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>您选择的水果是: &#123;&#123;fruit&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      <span class="comment">// 默认香蕉</span></span></span><br><span class="line"><span class="javascript">      fruit: <span class="string">&#x27;香蕉&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>多选：可以选中多个值（属性加上multiple）：</p>
<ul>
<li><p>v-model绑定的是一个数组</p>
</li>
<li><p>当选中多个值时，就会将选中的option对应的value添加到数组mySelects中</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;abc&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;fruits&quot;</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;苹果&quot;</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;香蕉&quot;</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;榴莲&quot;</span>&gt;</span>榴莲<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;葡萄&quot;</span>&gt;</span>葡萄<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>您选择的水果是: &#123;&#123;fruits&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      fruits: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="6、值绑定"><a href="#6、值绑定" class="headerlink" title="6、值绑定"></a>6、值绑定</h4><p>动态的给value赋值而已。我们前面的value中的值，都是在定义input的时候直接给定的（写死），但是真实开发中，这些input的值可能是从网络获取或定义在data中的。所以我们可以通过v-bind:value动态的给value绑定值（其实就是v-bind在input中的应用）</p>
<h4 id="7、修饰符"><a href="#7、修饰符" class="headerlink" title="7、修饰符"></a>7、修饰符</h4><h5 id="1、lazy修饰符"><a href="#1、lazy修饰符" class="headerlink" title="1、lazy修饰符"></a>1、lazy修饰符</h5><p>默认情况下，v-model默认是在input事件中同步输入框的数据的。也就是说，一旦有数据发生改变对应的data中的数据就会自动发生改变。</p>
<p>lazy修饰符可以让数据在失去焦点或者回车时才会更新。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model.lazy</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;Hello Vue&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<ul>
<li>聚焦时：</li>
</ul>
<p><img src="/2021/04/19/VUE/31.png" alt="image-20210321214116893"></p>
<ul>
<li>失焦时：</li>
</ul>
<p><img src="/2021/04/19/VUE/32.png" alt="image-20210321214156460"></p>
<h5 id="2、number修饰符"><a href="#2、number修饰符" class="headerlink" title="2、number修饰符"></a>2、number修饰符</h5><p>默认情况下，在输入框中无论我们输入的是字母还是数字，都会被当做字符串类型进行处理。但是如果我们希望处理的是数字类型，那么最好直接将内容当做数字处理。</p>
<p>number修饰符可以让在输入框中输入的内容自动转成数字类型</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">v-model.number</span>=<span class="string">&quot;age&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;age&#125;&#125;-&#123;&#123;typeof age&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      age: 18</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<ul>
<li><p>没加number：</p>
<p><img src="/2021/04/19/VUE/33.png" alt="image-20210321214845631"></p>
</li>
<li><p>加上number：</p>
<p><img src="/2021/04/19/VUE/34.png" alt="image-20210321214942404"></p>
</li>
</ul>
<h4 id="3、trim修饰符"><a href="#3、trim修饰符" class="headerlink" title="3、trim修饰符"></a>3、trim修饰符</h4><p>如果输入的内容首尾有很多空格，通常我们希望将其去除，trim修饰符可以过滤内容左右两边的空格（浏览器会格式化显示时帮忙去掉多余的空格，但在代码里空格依旧存在，trim修饰符可以过滤内容左右两边的空格）。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model.trim</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>您输入的名字:&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      name: <span class="string">&#x27;&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<ul>
<li><p>没加trim：</p>
<p><img src="/2021/04/19/VUE/36.png" alt="image-20210321215801147"></p>
</li>
<li><p>加上trim</p>
<p><img src="/2021/04/19/VUE/35.png" alt="image-20210321215539094"></p>
</li>
</ul>
<h2 id="三、组件化开发"><a href="#三、组件化开发" class="headerlink" title="三、组件化开发"></a>三、组件化开发</h2><h3 id="1、什么是组件化"><a href="#1、什么是组件化" class="headerlink" title="1、什么是组件化"></a>1、什么是组件化</h3><p>如果我们将一个页面中所有的处理逻辑全部放在一起，处理起来就会变得非常复杂，而且不利于后续的管理以及扩展。但如果，我们讲一个页面拆分成一个个小的功能块，每个功能块完成属于自己这部分独立的功能，那么之后整个页面的管理和维护就变得非常容易了。</p>
<p>如图：</p>
<ul>
<li>我们将一个完整的页面分成很多个组件。</li>
<li>每个组件都用于实现页面的一个功能块。</li>
<li>而每一个组件又可以进行细分。</li>
</ul>
<p><img src="/2021/04/19/VUE/37.png" alt="image-20210321224044742"></p>
<h3 id="2、Vue组件化思想"><a href="#2、Vue组件化思想" class="headerlink" title="2、Vue组件化思想"></a>2、Vue组件化思想</h3><p>组件化是Vue.js中的重要思想。它提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用。任何的应用都会被抽象成一颗组件树。</p>
<p><img src="/2021/04/19/VUE/38.png" alt="image-20210321224237074"></p>
<p>组件化思想的应用：</p>
<ul>
<li>有了组件化的思想，我们在之后的开发中就要充分的利用它。</li>
<li>尽可能的将页面拆分成一个个小的、可复用的组件。</li>
<li>这样让我们的代码更加方便组织和管理，并且扩展性也更强。</li>
</ul>
<p>注意：每一个组件都有独属于自己的data、<code>methods</code>、<code>computed</code>、<code>components</code>、<code>template</code>等等。其中<code>app</code>可以看成所有组件的<strong>根组件（root）。</strong>但要注意，app也只能调用自己的<code>儿子</code>组件，不能去跨辈调用<code>孙子</code>组件。</p>
<h3 id="3、注册组件"><a href="#3、注册组件" class="headerlink" title="3、注册组件"></a>3、注册组件</h3><p>组件的使用分成三个步骤：</p>
<ol>
<li>创建组件构造器</li>
<li>注册组件</li>
<li>使用组件：组件只能在注册过的实例里使用，否则Vue因没有进行管理不会加载组件。</li>
</ol>
<p>注意：字符串的表达除了有<code>&#39;&#39;</code>（单引号）、<code>&quot;&quot;</code>（双引号）以外，还有<code>``</code>（尖引号）。尖引号可以实现字符串的跨行。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--3.使用组件--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">my-cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">my-cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">my-cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">my-cpn</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">my-cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">my-cpn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--以下没有在app实例里使用，Vue没有进行管理不会加载组件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">my-cpn</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 1.创建组件构造器对象</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> cpnC = Vue.extend(&#123;</span></span><br><span class="line">    template: `</span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>组件标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是组件中的一个段落内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`</span></span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 2.注册组件</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 参数1：组件的名称，参数2：组件构造器对象的名称</span></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&#x27;my-cpn&#x27;</span>, cpnC)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好啊&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="注册组件步骤解析"><a href="#注册组件步骤解析" class="headerlink" title="注册组件步骤解析"></a>注册组件步骤解析</h4><ol>
<li><p>Vue.extend()：</p>
<ol>
<li>调用Vue.extend()创建的是一个组件构造器；</li>
<li>通常在创建组件构造器时，传入template代表我们自定义组件的模板；</li>
<li>该模板就是在使用到组件的地方，要显示的HTML代码；</li>
<li>事实上，这种写法在Vue2.x的文档中几乎已经看不到了，它会直接使用下面我们会讲到的语法糖，但是在很多资料还是会提到这种方式，而且这种方式是学习后面方式的基础</li>
</ol>
</li>
<li><p>Vue.component()：</p>
<ol>
<li>调用Vue.component()是将刚才的组件构造器注册为一个组件，并且给它起一个组件的标签名称；</li>
<li>所以需要传递两个参数：<ol>
<li>注册组件的标签名</li>
<li>组件构造器</li>
</ol>
</li>
</ol>
</li>
<li><p>组件必须挂载在某个Vue实例下，否则它不会生效：</p>
<ol>
<li><p>我们来看下面我使用了三次<my-cpn></my-cpn></p>
</li>
<li><p>而第三次其实并没有生效：</p>
<p><img src="/2021/04/19/VUE/39.png" alt="image-20210322023308247"></p>
</li>
</ol>
</li>
</ol>
<h3 id="4、全局组件和局部组件"><a href="#4、全局组件和局部组件" class="headerlink" title="4、全局组件和局部组件"></a>4、全局组件和局部组件</h3><p>当我们通过<strong>调用Vue.component()注册组件</strong>时，组件的注册是<strong>全局的</strong>。</p>
<p><strong>这意味着该组件可以在任意Vue示例下使用。</strong></p>
<p><img src="/2021/04/19/VUE/40.png" alt="image-20210322023704676"></p>
<p>如果我们注册的组件是挂载在某个实例中, 那么就是一个局部组件</p>
<p><img src="/2021/04/19/VUE/41.png" alt="image-20210322023725407"></p>
<h3 id="5、父组件和子组件"><a href="#5、父组件和子组件" class="headerlink" title="5、父组件和子组件"></a>5、父组件和子组件</h3><p>在前面我们看到了组件树：组件和组件之间存在层级关系。而其中一种非常重要的关系就是父子组件的关系</p>
<p>我们来看通过代码如何组成的这种层级关系：</p>
<p><img src="/2021/04/19/VUE/42.png" alt="image-20210322024427807"></p>
<p>父子组件错误用法：以子标签的形式在Vue实例中使用</p>
<ul>
<li>因为当子组件注册到父组件的components时，Vue会编译好父组件的模块</li>
<li>该模板的内容已经决定了父组件将要渲染的HTML（相当于父组件中已经有了子组件中的内容了）</li>
<li><child-cpn></child-cpn>是只能在父组件中被识别的。</li>
<li>类似这种用法，<child-cpn></child-cpn>是会被浏览器忽略的。</li>
</ul>
<h3 id="6、注册组件语法糖"><a href="#6、注册组件语法糖" class="headerlink" title="6、注册组件语法糖"></a>6、注册组件语法糖</h3><p>在上面注册组件的方式，可能会有些繁琐。Vue为了简化这个过程，提供了注册的语法糖。</p>
<p>主要是省去了调用Vue.extend()的步骤，而是可以直接使用一个对象来代替。</p>
<p>语法糖注册全局组件和局部组件：</p>
<ul>
<li><p>全局组件的语法糖：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn1</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">Vue.component(<span class="string">&#x27;cpn1&#x27;</span>, &#123;</span></span><br><span class="line">    template: `</span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题1<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容, 哈哈哈哈<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">    `</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>局部组件的语法糖：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn2</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 注册局部组件的语法糖</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    components: &#123;</span><br><span class="line"><span class="javascript">      <span class="string">&#x27;cpn2&#x27;</span>: &#123;</span></span><br><span class="line">        template: `</span><br><span class="line"><span class="handlebars"><span class="xml">          <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容, 呵呵呵<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">   		 `</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="7、模板的分离写法"><a href="#7、模板的分离写法" class="headerlink" title="7、模板的分离写法"></a>7、模板的分离写法</h3><p>以上代码虽然通过语法糖简化了Vue组件的注册过程，但还有一个地方的写法比较麻烦，就是template模块写法。如果我们能将其中的HTML分离出来写，然后挂载到对应的组件上，必然结构会变得非常清晰。</p>
<p>Vue提供了两种方案来定义HTML模块内容：</p>
<ul>
<li><p>使用<script>标签：添加类型：text/x-template；用id的值来建立组件与模板之间的关系</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--script标签, 注意:类型必须是text/x-template--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/x-template&quot;</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span>--&gt;</span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">	<span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">	<span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容,哈哈哈<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="comment">// 注册一个全局组件</span></span></span><br><span class="line"><span class="javascript">Vue.component(<span class="string">&#x27;cpn&#x27;</span>, &#123;</span></span><br><span class="line"><span class="javascript">	template: <span class="string">&#x27;#cpn&#x27;</span></span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<template>标签：用id的值来建立组件与模板之间的关系</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--template标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容,呵呵呵<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="comment">// 注册一个全局组件</span></span></span><br><span class="line"><span class="javascript">Vue.component(<span class="string">&#x27;cpn&#x27;</span>, &#123;</span></span><br><span class="line"><span class="javascript">	template: <span class="string">&#x27;#cpn&#x27;</span></span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意：组件模板必须要有一个根。</strong>可以是<div></div></p>
</li>
</ul>
<h3 id="8、组件的数据存放"><a href="#8、组件的数据存放" class="headerlink" title="8、组件的数据存放"></a>8、组件的数据存放</h3><h4 id="1、组件可以访问Vue实例数据吗？"><a href="#1、组件可以访问Vue实例数据吗？" class="headerlink" title="1、组件可以访问Vue实例数据吗？"></a>1、组件可以访问Vue实例数据吗？</h4><p>组件是一个单独功能模块的封装：这个模块有属于自己的HTML模板，也应该有属性自己的数据data。</p>
<p>组件中的数据是保存在哪里呢？顶层的Vue实例中吗？我们先来测试一下，组件中能不能直接访问Vue实例中的data。</p>
<p><img src="VUE/43.png" alt="image-20210322131356074"></p>
<p>我们发现不能访问，而且即使可以访问，<strong>如果将所有的数据都放在Vue实例中，Vue实例就会变的非常臃肿</strong>。</p>
<p><strong>结论：Vue组件应该有自己保存数据的地方。</strong></p>
<h4 id="2、组件自己的数据存放"><a href="#2、组件自己的数据存放" class="headerlink" title="2、组件自己的数据存放"></a>2、组件自己的数据存放</h4><p>组件对象也有一个data属性(也可以有methods等属性)</p>
<ul>
<li><p>只是这个data属性<strong>必须是一个函数</strong></p>
</li>
<li><p>而且这个函数<strong>返回一个对象，对象内部保存着数据</strong></p>
<p><img src="VUE/45.png" alt="image-20210322132158055"></p>
</li>
</ul>
<p>为什么data属性在组件中一定要是一个函数？</p>
<ul>
<li><p>首先，如果不是一个函数，Vue直接就会报错（直接原因Vue不允许）</p>
</li>
<li><p>其次，原因是在于Vue让每个组件对象<strong>都返回一个新的实例</strong>（存储地址不同），因为如果是同一个对象的，组件在多次使用后会相互影响。</p>
</li>
<li><p>组件是可复用的vue实例，一个组件被创建好之后，就可能被用在各个地方，而组件不管被复用了多少次，组件中的data数据都应该是相互隔离，互不影响的</p>
</li>
<li><p>data返回一个实例所以每个counter都存在自己的实例的堆里面，如果直接返回一个data对象那么3个都共用一个堆会一起改变。</p>
<p><img src="VUE/46.png" alt="image-20210322132442881"></p>
</li>
</ul>
<h3 id="9、父子组件的通信"><a href="#9、父子组件的通信" class="headerlink" title="9、父子组件的通信"></a>9、父子组件的通信</h3><p>因为子组件是不能引用父组件或者Vue实例的数据的。但是，在开发中，往往一些数据确实需要从上层传递到下层：</p>
<ul>
<li>比如在一个页面中，我们从服务器请求到了很多的数据。</li>
<li>其中一部分数据，并非是我们整个页面的大组件来展示的，而是需要下面的子组件进行展示。</li>
<li>这个时候，并不会让子组件再次发送一个网络请求，而是直接让**大组件(父组件)将数据传递给小组件(子组件)**。</li>
</ul>
<p>那么父子组件间如何通信呢？Vue官方提到</p>
<ul>
<li>通过props向子组件传递数据</li>
<li>通过事件向父组件发送消息</li>
</ul>
<p><img src="VUE/47.png" alt="image-20210322183204442"></p>
<h4 id="1、父级向子级传递数据"><a href="#1、父级向子级传递数据" class="headerlink" title="1、父级向子级传递数据"></a>1、父级向子级传递数据</h4><p>在组件中，使用选项props来声明需要从父级接收到的数据。</p>
<p>props写在子组件中，使用子组件时使用props的属性，对应属性的值填父组件的变量，即可通过props中的属性获取父组件的变量值。</p>
<p>父组件模板通过<code>:</code>也就是<code>v-on:</code>来绑定父组件向子组件传递的数据的名称。</p>
<p>props的值有两种方式：</p>
<ul>
<li><p>方式一：字符串数组，数组中的字符串就是传递时的名称。</p>
</li>
<li><p>方式二：对象，对象可以设置：</p>
<ul>
<li><p>传递时的类型：type，type既可以是基本数据类型，也可以是数组，或者自定义的一些对象。若props有可能的好几种，也可以写成数组的形式。[String,Arrary]</p>
</li>
<li><p>默认值：default，给props提供一些默认值。</p>
<p>注意：但props的类型为数组或对象时，不能直接设置默认值，而是必须从一个工厂函数中获取。</p>
</li>
<li><p>必传值：required，required是一个Boolean值。表示传过来的是否一定需要传入props</p>
</li>
<li><p>验证：validator，为一个函数，其参数为一个值，传入值必须与设置字符串其中之一匹配。返回值是一个Boolean值：true则匹配成功，false则匹配失败。</p>
</li>
</ul>
</li>
<li><p>其中当需要对<strong>props进行类型等验证时</strong>，就需要对象写法了。验证支持的数据类型（其中<code>null</code>可以匹配所有类型）：</p>
<ul>
<li><p>String</p>
</li>
<li><p>Number</p>
</li>
<li><p>Boolean</p>
</li>
<li><p>Array</p>
</li>
<li><p>Object</p>
</li>
<li><p>Date</p>
</li>
<li><p>Function</p>
</li>
<li><p>Symbol</p>
</li>
<li><p>当我们有自定义构造函数时，验证也支持自定义的类型</p>
<p><img src="VUE/48.png" alt="image-20210322192825268"></p>
</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--父组件模板--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span> <span class="attr">:cmessage</span>=<span class="string">&quot;message&quot;</span> <span class="attr">:cmovies</span>=<span class="string">&quot;movies&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--子组件模板--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in cmovies&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;cmessage&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 父传子: props</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 子组件</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> cpn = &#123;</span></span><br><span class="line"><span class="javascript">    template: <span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 方式一：字符串数组，数组中的字符串就是传递时的名称</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// props: [&#x27;cmovies&#x27;, &#x27;cmessage&#x27;],</span></span></span><br><span class="line">      </span><br><span class="line"><span class="javascript">    <span class="comment">// 方式二：对象，对象可以设置传递时的类型，也可以设置默认值等。</span></span></span><br><span class="line">    props: &#123;</span><br><span class="line"><span class="javascript">      <span class="comment">// 1.类型限制</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// cmovies: Array,</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// cmessage: String,</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// 2.提供一些默认值, 以及必传值</span></span></span><br><span class="line">      cmessage: &#123;</span><br><span class="line"><span class="javascript">        type: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">        <span class="keyword">default</span>: <span class="string">&#x27;aaaaaaaa&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        required: <span class="literal">true</span></span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="comment">// 类型是对象或者数组时, 默认值必须是一个函数</span></span></span><br><span class="line">      cmovies: &#123;</span><br><span class="line"><span class="javascript">        type: <span class="built_in">Array</span>,</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">default</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> []</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;&#125;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="javascript">  <span class="comment">// 2.父组件</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好啊&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      movies: [<span class="string">&#x27;海王&#x27;</span>, <span class="string">&#x27;海贼王&#x27;</span>, <span class="string">&#x27;海尔兄弟&#x27;</span>]</span></span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      cpn</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2、子级向父级传递数据"><a href="#2、子级向父级传递数据" class="headerlink" title="2、子级向父级传递数据"></a>2、子级向父级传递数据</h4><p>我们需要使用<strong>自定义事件</strong>来完成子级向父级的数据传递。<code>@</code>(v-on)不仅仅可以用于监听DOM事件，也可以用于监听组件间的自定义事件。所有可以用<code>@</code> + <code>$emit()</code>自定义事件来完成子级向父级的数据传递。</p>
<p>自定义事件的流程：</p>
<ul>
<li>在子组件中，通过$emit()来触发事件。<ul>
<li>参数一：自定义事件的标签（注意不要用驼峰）</li>
<li>参数二：事件的对象</li>
</ul>
</li>
<li>在父组件中，通过v-on来监听子组件事件。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--父组件模板--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span> @<span class="attr">item-click</span>=<span class="string">&quot;cpnClick&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--子组件模板--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-for</span>=<span class="string">&quot;item in categories&quot;</span></span></span><br><span class="line"><span class="tag">            @<span class="attr">click</span>=<span class="string">&quot;btnClick(item)&quot;</span>&gt;</span></span><br><span class="line">      &#123;&#123;item.name&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 1.子组件</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> cpn = &#123;</span></span><br><span class="line"><span class="javascript">    template: <span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line">        categories: [</span><br><span class="line"><span class="javascript">          &#123;<span class="attr">id</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;热门推荐&#x27;</span>&#125;,</span></span><br><span class="line"><span class="javascript">          &#123;<span class="attr">id</span>: <span class="string">&#x27;bbb&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;手机数码&#x27;</span>&#125;,</span></span><br><span class="line"><span class="javascript">          &#123;<span class="attr">id</span>: <span class="string">&#x27;ccc&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;家用家电&#x27;</span>&#125;,</span></span><br><span class="line"><span class="javascript">          &#123;<span class="attr">id</span>: <span class="string">&#x27;ddd&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;电脑办公&#x27;</span>&#125;,</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">btnClick</span>(<span class="params">item</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// $emit发射事件: 自定义事件</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 参数一：自定义事件的标签（注意不要用驼峰）</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 参数二：事件的对象</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$emit(<span class="string">&#x27;item-click&#x27;</span>, item)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 2.父组件</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好啊&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      cpn</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">cpnClick</span>(<span class="params">item</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;cpnClick&#x27;</span>, item);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3、标签驼峰问题"><a href="#3、标签驼峰问题" class="headerlink" title="3、标签驼峰问题"></a>3、标签驼峰问题</h4><p>在html的自定义标签的时候，最好不要用驼峰的写法，其实不是Vue不支持驼峰。而是在HTML属性不支持大写，即浏览器会将cInfo会自动解析成cinfo。由于浏览器解析后的标签名与代码的标签名对不上，会导致渲染失败。若需要分隔单词的时候，不要写成驼峰，而是推荐写成 “<strong><code>小写单词</code> + <code>-</code> + <code>小写单词</code></strong>“ 的方式。如：childMyMessage -&gt; child-my-message</p>
<h4 id="4、案例（父传子、子传父、在之间实现功能、数据流）"><a href="#4、案例（父传子、子传父、在之间实现功能、数据流）" class="headerlink" title="4、案例（父传子、子传父、在之间实现功能、数据流）"></a>4、案例（父传子、子传父、在之间实现功能、数据流）</h4><p>需求以及注意的点：</p>
<ol>
<li><p>父为app，子为cpn。</p>
</li>
<li><p>父组件里面有两个值1/0，父组件通过props向子组件传递这两个值</p>
</li>
<li><p>在子组件的两个值对应添加相应的输入框input，并将各自input与值用<code>v-mode</code>进行双向绑定。希望在改变输入框的值的时候，双向绑定到子组件的值，去修改子组件的值。</p>
<p>存在的问题：由于子组件的值是由父组件的值传递过来的，但你去修改子组件的值时会同时影响改变父组件的值。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span> <span class="attr">:number1</span> = <span class="string">&quot;num1&quot;</span> <span class="attr">:number2</span> = <span class="string">&quot;num2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;number1&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;number1&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;number1&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;number1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;number2&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;number2&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;number2&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;number2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      num1: 1,</span><br><span class="line">      num2: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      cpn: &#123;</span><br><span class="line"><span class="javascript">        template: <span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line">        props: &#123;</span><br><span class="line"><span class="javascript">          number1: <span class="built_in">Number</span>,</span></span><br><span class="line"><span class="javascript">          number2: <span class="built_in">Number</span></span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="VUE/49.png" alt="image-20210322222858177"></p>
<p>注意：虽然以上代码实现了功能（改变子组件的值，但同时改变了父组件的值），但是浏览器却报错：避免直接改变属性，因为每当父组件重新渲染时，该值将被覆盖。所以应当让父组件来将其进行重写。</p>
<p>相反，它让我们使用基于属性值的data或computed去改变绑定的值。</p>
<p>其实：Vue建议我们最好不要通过修改子组件的值，从而去修改父组件的值。这样会引起很多问题。</p>
<ul>
<li>可以这样理解：父亲传过来的参数，我既使不满意但我也不能改变，于是自己搞个数据默认值为父亲传过来的参数，这样既可以改变数值，又没有改变父亲的参数。</li>
<li>从父组件传过来的值放在props绑定的组件变量里，而组件变量的值deepcopy了一份到data里，v-model绑定的是data数据，不影响props。</li>
</ul>
<p>修改的代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;number1&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;dnumber1&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;number2&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;dnumber2&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        dnumber1: this.number1,</span><br><span class="line">        dnumber2: this.number2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="VUE/50.png" alt="image-20210322235953981"></p>
</li>
<li><p>将子组件改变的值重新传回父组件。（也就是调试改变props里的值）。</p>
<ol>
<li><p>将v-mode转换为用v-on与v-bind来表示。v-bind绑定value,v-on监听输入事件，并将其抽离成一个方法。</p>
</li>
<li><p>并在那方法里实现$emit()方法来与父组件传递数据。</p>
</li>
<li><p>$emit()方法传入自定义事件num1change()和子组件data里的值</p>
</li>
<li><p>在父组件的methods里实现自定义事件num1change()，用来修改父组件data里的值，因为父组件的data里的值被修改，父组件向子组件传递的props里的值也被改变。</p>
</li>
<li><p>向浏览器进行渲染</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span> <span class="attr">:number1</span> = <span class="string">&quot;num1&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">:number2</span> = <span class="string">&quot;num2&quot;</span></span></span><br><span class="line"><span class="tag">       @<span class="attr">num1change</span> = <span class="string">&quot;num1change&quot;</span></span></span><br><span class="line"><span class="tag">       @<span class="attr">num2change</span> = <span class="string">&quot;num2change&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>props: &#123;&#123;number1&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>data: &#123;&#123;dnumber1&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;number1&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--      &lt;input type=&quot;text&quot; id=&quot;number1&quot; v-model=&quot;dnumber1&quot;&gt;--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;number1&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;dnumber1&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;num1Input&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>props: &#123;&#123;number2&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>data: &#123;&#123;dnumber2&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;number2&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--      &lt;input type=&quot;text&quot; id=&quot;number2&quot; v-model=&quot;dnumber2&quot;&gt;--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;number2&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;dnumber2&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;num2Input&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      num1: 1,</span><br><span class="line">      num2: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">num1change</span>(<span class="params">value</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.num1 = value</span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">num2change</span>(<span class="params">value</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.num2 = value</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      cpn: &#123;</span><br><span class="line"><span class="javascript">        template: <span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line">        props: &#123;</span><br><span class="line"><span class="javascript">          number1: <span class="built_in">Number</span>,</span></span><br><span class="line"><span class="javascript">          number2: <span class="built_in">Number</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">            dnumber1: <span class="built_in">this</span>.number1,</span></span><br><span class="line"><span class="javascript">            dnumber2: <span class="built_in">this</span>.number2</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="javascript">          <span class="function"><span class="title">num1Input</span>(<span class="params">event</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 1.将input中的value赋值到dnumber中</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.dnumber1 = event.target.value;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 2.为了让父组件可以修改值, 发出一个事件</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.$emit(<span class="string">&quot;num1change&quot;</span>,<span class="built_in">this</span>.dnumber1)</span></span><br><span class="line"></span><br><span class="line">          &#125;,</span><br><span class="line"><span class="javascript">          <span class="function"><span class="title">num2Input</span>(<span class="params">event</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.dnumber2 = event.target.value;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.$emit(<span class="string">&quot;num2change&quot;</span>,<span class="built_in">this</span>.dnumber2)</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="VUE/51.png" alt="image-20210323011007374"></p>
</li>
<li><p>注意：以上报错是因为传入的数据默认为字符串（String）类型，二代码里的值的类型是Number类型。两者类型不同而报错。可以将浏览器传来的value进行类型转换就行。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">      num1change(value) &#123;</span><br><span class="line">        this.num1 = parseFloat(value)</span><br><span class="line">      &#125;,</span><br><span class="line">      num2change(value) &#123;</span><br><span class="line">        this.num2 = parseFloat(value)</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="VUE/52.png" alt="image-20210323012409525"></p>
</li>
</ol>
</li>
<li><p>在下面的值为上面的值的100倍，在上面的值为下面的值的1/100倍.</p>
<p>实现：在numxInput函数里添加业务需求就行</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">          num1Input(event) &#123;</span><br><span class="line">            // 1.将input中的value赋值到dnumber中</span><br><span class="line">            this.dnumber1 = event.target.value;</span><br><span class="line">            // 2.为了让父组件可以修改值, 发出一个事件</span><br><span class="line">            this.$emit(&quot;num1change&quot;,this.dnumber1);</span><br><span class="line">            // 3.同时修饰dnumber2的值</span><br><span class="line">            this.dnumber2 = this.dnumber1 * 100</span><br><span class="line"></span><br><span class="line">          &#125;,</span><br><span class="line">          num2Input(event) &#123;</span><br><span class="line">            this.dnumber2 = event.target.value;</span><br><span class="line">            this.$emit(&quot;num2change&quot;,this.dnumber2)</span><br><span class="line">            this.dnumber1 = this.dnumber2 / 100</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="VUE/53.png" alt="image-20210323013317559"></p>
<p>出现问题：</p>
<p>当上面值修改时，下面只有data里的值变成了上面值的100倍，而props里的值并没有改变。</p>
<p>解决方法：</p>
<p>在实现业务修改data的值后，再把data里的值通过自定义事件的方式（$erim）传递给父组件，父组件改变后在去改变子组件props里的值。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">          num1Input(event) &#123;</span><br><span class="line">            // 1.将input中的value赋值到dnumber中</span><br><span class="line">            this.dnumber1 = event.target.value;</span><br><span class="line">            // 2.为了让父组件可以修改值, 发出一个事件</span><br><span class="line">            this.$emit(&quot;num1change&quot;,this.dnumber1);</span><br><span class="line">            // 3.同时修饰dnumber2的值</span><br><span class="line">            this.dnumber2 = this.dnumber1 * 100;</span><br><span class="line">            this.$emit(&quot;num2change&quot;,this.dnumber2)</span><br><span class="line">          &#125;,</span><br><span class="line">          num2Input(event) &#123;</span><br><span class="line">            this.dnumber2 = event.target.value;</span><br><span class="line">            this.$emit(&quot;num2change&quot;,this.dnumber2)</span><br><span class="line">            this.dnumber1 = this.dnumber2 / 100;</span><br><span class="line">            this.$emit(&quot;num1change&quot;,this.dnumber1)</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="VUE/54.png" alt="image-20210323014120094"></p>
</li>
</ol>
<p>以上程序完整代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span> <span class="attr">:number1</span> = <span class="string">&quot;num1&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">:number2</span> = <span class="string">&quot;num2&quot;</span></span></span><br><span class="line"><span class="tag">       @<span class="attr">num1change</span> = <span class="string">&quot;num1change&quot;</span></span></span><br><span class="line"><span class="tag">       @<span class="attr">num2change</span> = <span class="string">&quot;num2change&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>props: &#123;&#123;number1&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>data: &#123;&#123;dnumber1&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;number1&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--      &lt;input type=&quot;text&quot; id=&quot;number1&quot; v-model=&quot;dnumber1&quot;&gt;--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;number1&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;dnumber1&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;num1Input&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>props: &#123;&#123;number2&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>data: &#123;&#123;dnumber2&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;number2&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--      &lt;input type=&quot;text&quot; id=&quot;number2&quot; v-model=&quot;dnumber2&quot;&gt;--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;number2&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;dnumber2&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;num2Input&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      num1: 1,</span><br><span class="line">      num2: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">num1change</span>(<span class="params">value</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.num1 = <span class="built_in">parseFloat</span>(value)</span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">num2change</span>(<span class="params">value</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.num2 = <span class="built_in">parseFloat</span>(value)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      cpn: &#123;</span><br><span class="line"><span class="javascript">        template: <span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line">        props: &#123;</span><br><span class="line"><span class="javascript">          number1: <span class="built_in">Number</span>,</span></span><br><span class="line"><span class="javascript">          number2: <span class="built_in">Number</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">            dnumber1: <span class="built_in">this</span>.number1,</span></span><br><span class="line"><span class="javascript">            dnumber2: <span class="built_in">this</span>.number2</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="javascript">          <span class="function"><span class="title">num1Input</span>(<span class="params">event</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 1.将input中的value赋值到dnumber中</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.dnumber1 = event.target.value;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 2.为了让父组件可以修改值, 发出一个事件</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.$emit(<span class="string">&quot;num1change&quot;</span>,<span class="built_in">this</span>.dnumber1);</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 3.同时修饰dnumber2的值</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.dnumber2 = <span class="built_in">this</span>.dnumber1 * <span class="number">100</span>;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.$emit(<span class="string">&quot;num2change&quot;</span>,<span class="built_in">this</span>.dnumber2)</span></span><br><span class="line">          &#125;,</span><br><span class="line"><span class="javascript">          <span class="function"><span class="title">num2Input</span>(<span class="params">event</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.dnumber2 = event.target.value;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.$emit(<span class="string">&quot;num2change&quot;</span>,<span class="built_in">this</span>.dnumber2)</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.dnumber1 = <span class="built_in">this</span>.dnumber2 / <span class="number">100</span>;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.$emit(<span class="string">&quot;num1change&quot;</span>,<span class="built_in">this</span>.dnumber1)</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>将以上代码执行流程总结成一张图如下：</p>
<p><img src="VUE/58.png"></p>
<p>我们也可以用watch属性 + v-mode来实现以上需求：</p>
<p>watch属性：里面可以写一些函数用来监听组件内某一属性的改变。</p>
<p>里面函数的参数：</p>
<ul>
<li>newValue（常用）：变化的新值</li>
<li>oldValue（不常用）：变化前的值</li>
</ul>
<p>代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span> <span class="attr">:number1</span>=<span class="string">&quot;num1&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">:number2</span>=<span class="string">&quot;num2&quot;</span></span></span><br><span class="line"><span class="tag">       @<span class="attr">num1change</span>=<span class="string">&quot;num1change&quot;</span></span></span><br><span class="line"><span class="tag">       @<span class="attr">num2change</span>=<span class="string">&quot;num2change&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>props:&#123;&#123;number1&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>data:&#123;&#123;dnumber1&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;dnumber1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>props:&#123;&#123;number2&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>data:&#123;&#123;dnumber2&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;dnumber2&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      num1: 1,</span><br><span class="line">      num2: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">num1change</span>(<span class="params">value</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.num1 = <span class="built_in">parseFloat</span>(value)</span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">num2change</span>(<span class="params">value</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.num2 = <span class="built_in">parseFloat</span>(value)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      cpn: &#123;</span><br><span class="line"><span class="javascript">        template: <span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line">        props: &#123;</span><br><span class="line"><span class="javascript">          number1: <span class="built_in">Number</span>,</span></span><br><span class="line"><span class="javascript">          number2: <span class="built_in">Number</span>,</span></span><br><span class="line"><span class="javascript">          name: <span class="string">&#x27;&#x27;</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">            dnumber1: <span class="built_in">this</span>.number1,</span></span><br><span class="line"><span class="javascript">            dnumber2: <span class="built_in">this</span>.number2</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        watch: &#123;</span><br><span class="line"><span class="javascript">          <span class="function"><span class="title">dnumber1</span>(<span class="params">newValue</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.dnumber2 = newValue * <span class="number">100</span>;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.$emit(<span class="string">&#x27;num1change&#x27;</span>, newValue);</span></span><br><span class="line">          &#125;,</span><br><span class="line"><span class="javascript">          <span class="function"><span class="title">dnumber2</span>(<span class="params">newValue</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.number1 = newValue / <span class="number">100</span>;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.$emit(<span class="string">&#x27;num2change&#x27;</span>, newValue);</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="10、父子组件的访问"><a href="#10、父子组件的访问" class="headerlink" title="10、父子组件的访问"></a>10、父子组件的访问</h3><p>有时候我们需要父组件直接访问子组件，子组件直接访问父组件，或者是子组件访问跟组件。</p>
<ul>
<li>父组件访问子组件：使用<code>$children</code>或<code>$refs</code></li>
<li>子组件访问父组件：使用<code>$parent</code>或<code>$root</code></li>
</ul>
<h4 id="1、父组件直接访问子组件"><a href="#1、父组件直接访问子组件" class="headerlink" title="1、父组件直接访问子组件"></a>1、父组件直接访问子组件</h4><h5 id="1、-children（不常用）"><a href="#1、-children（不常用）" class="headerlink" title="1、$children（不常用）"></a>1、$children（不常用）</h5><p>this.$children是一个数组类型，它包含所有子组件对象。我们可以通过一个遍历，取出所有子组件的数值data、方法methods、计算属性computed等等。<img src="VUE/55.png" alt="image-20210323014719042"></p>
<p>$children的缺陷：</p>
<ul>
<li>通过$children访问子组件时，是一个数组类型，访问其中的子组件必须通过索引值。</li>
<li>但是当子组件过多，我们需要拿到其中一个时，往往不能确定它的索引值，甚至还可能会发生变化（其他组件的插入删除等等）。</li>
<li>有时候，我们想明确获取其中一个特定的组件，这个时候就可以使用$refs</li>
</ul>
<h5 id="2、-refs（常用）"><a href="#2、-refs（常用）" class="headerlink" title="2、$refs（常用）"></a>2、$refs（常用）</h5><p>$refs的使用：</p>
<ul>
<li><code>$refs</code>和<code>ref</code>指令通常是一起使用的。</li>
<li>首先，我们<strong>通过ref给某一个子组件绑定一个特定的ID</strong>。</li>
<li>其次，通过<code>this.$refs.ID</code>就可以访问到该组件了。</li>
</ul>
<p><img src="VUE/56.png" alt="image-20210323015200643"></p>
<h4 id="2、子组件访问父组件"><a href="#2、子组件访问父组件" class="headerlink" title="2、子组件访问父组件"></a>2、子组件访问父组件</h4><h5 id="1、-parent（不常用）"><a href="#1、-parent（不常用）" class="headerlink" title="1、$parent（不常用）"></a>1、$parent（不常用）</h5><p>注意事项：</p>
<ul>
<li>尽管在Vue开发中，我们允许通过$parent来访问父组件，但是在真实开发中尽量不要这样做。</li>
<li>子组件应该尽量避免直接访问父组件的数据，因为这样<strong>耦合度太高</strong>了。</li>
<li><strong>如果我们将子组件放在另外一个组件之内，很可能该父组件没有对应的属性，往往会引起问题</strong>。</li>
<li>另外，更不好做的是通过$parent直接修改父组件的状态，那么父组件中的状态将变得飘忽不定，很不利于我的调试和维护。</li>
</ul>
<p><img src="VUE/57.png" alt="image-20210323015429354"></p>
<h5 id="2、-root（不常用）"><a href="#2、-root（不常用）" class="headerlink" title="2、$root（不常用）"></a>2、$root（不常用）</h5><p>我们可以通过$root访问到根组件，也就是app。但实际上我们在开发过程中也很少用这个$root.因为在root组件里什么都没有，非常简单。它只有一些非常重要的东西，比如：路由、Vuex。所以我们一般不访问根组件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(this.$root.message);</span><br></pre></td></tr></table></figure>

<h3 id="11、插槽slot"><a href="#11、插槽slot" class="headerlink" title="11、插槽slot"></a>11、插槽slot</h3><h4 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h4><p>组件的插槽：</p>
<ul>
<li>组件的插槽也是为了让我们封装的组件<strong>更加具有扩展性</strong>。</li>
<li>让使用者可以决定组件内部的一些内容到底展示什么。</li>
</ul>
<p>组件插槽的例子：移动网站中的导航栏。</p>
<p>移动开发中，几乎每个页面都有导航栏。导航栏我们必然会封装成一个插件，比如nav-bar组件。一旦有了这个组件，我们就可以在多个页面中复用了。但是每个页面的导航栏是不一样，它们也很多<strong>区别</strong>，但是也有很多<strong>共性</strong>。</p>
<ul>
<li>如果，我们每一个单独去封装一个组件，显然不合适：比如每个页面都返回，这部分内容我们就要重复去封装（<strong>共性</strong>）。</li>
<li>如果我们封装成一个，好像也不合理：有些左侧是菜单，有些是返回，有些中间是搜索，有些是文字等等，每一个组件又不一样（<strong>区别</strong>）。</li>
</ul>
<p>那么该如何封装合适呢？抽取共性，保留不同</p>
<ul>
<li>最好的封装方式就是将<strong>共性抽取到组件中</strong>，将<strong>区别暴露为插槽（slot）</strong>。</li>
<li>一旦我们预留了插槽，就可以让使用者根据自己的需求，决定插槽中插入什么内容。</li>
<li>是搜索框，还是文字，还是菜单。由调用者自己来决定。</li>
</ul>
<h4 id="2、slot的基本使用"><a href="#2、slot的基本使用" class="headerlink" title="2、slot的基本使用"></a>2、slot的基本使用</h4><ul>
<li><p>在子组件中，使用特殊的元素<slot>就可以为子组件开启一个插槽。</p>
</li>
<li><p>该插槽插入什么内容取决于父组件如何使用。</p>
</li>
<li><p>我们也可以为插槽设置默认值，当父组件没有使用该插槽的时候，插槽显示的就是默认值。</p>
<p>插槽的默认值 <slot>button</slot></p>
</li>
<li><p>如果父组件有多个值, 同时放入到组件的插槽进行替换时, 这多个值会一起作为替换元素。</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--插槽显示默认值--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--插槽显示父组件修改的样式--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>哈哈哈<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;<span class="name">i</span>&gt;</span>呵呵呵<span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">&lt;!--插槽显示父组件的多个值，多个值一起作为插槽的替换元素--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span>&gt;</span>呵呵呵<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是div元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是p元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--插槽显示默认值--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是组件, 哈哈哈<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好啊&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      cpn: &#123;</span><br><span class="line"><span class="javascript">        template: <span class="string">&#x27;#cpn&#x27;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2、具名插槽（多个插槽）"><a href="#2、具名插槽（多个插槽）" class="headerlink" title="2、具名插槽（多个插槽）"></a>2、具名插槽（多个插槽）</h4><p>当子组件的功能复杂时，子组件的插槽可能并非是一个。</p>
<ul>
<li>比如我们封装一个导航栏的子组件，可能就需要三个插槽，分别代表左边、中间、右边。</li>
<li>那么，外面在给插槽插入内容时，如何区分插入的是哪一个呢？</li>
<li>这个时候，我们就需要给插槽起一个名字。这就是具名插槽。</li>
</ul>
<p>那么如何使用具名插槽呢？</p>
<ul>
<li><p>只要在子组件的template中给slot元素一个name属性即可</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&#x27;myslot&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后在父组件使用子组件插槽的时候用slot属性并赋予将要操作的插槽的name即可。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">slot</span>=<span class="string">&quot;mysolt&quot;</span>&gt;</span>返回<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">&quot;center&quot;</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">slot</span>=<span class="string">&quot;left&quot;</span>&gt;</span>返回<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>左边<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>中间<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>右边<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好啊&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      cpn: &#123;</span><br><span class="line"><span class="javascript">        template: <span class="string">&#x27;#cpn&#x27;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3、编译作用域"><a href="#3、编译作用域" class="headerlink" title="3、编译作用域"></a>3、编译作用域</h4><p>官方给出了一条准则：</p>
<ul>
<li><strong>父组件模板的所有东西都会在父级作用域内编译；</strong></li>
<li><strong>子组件模板的所有东西都会在子级作用域内编译。</strong></li>
</ul>
<p>即：在父组件模板使用的数据内容来自于父组件自己本身，而不会从自己绑定的子组件里面拿数据内容。在子组件模板里面使用的数据内容与来自子组件本身，不会从自己的父组件里面拿数据内容。</p>
<p>示例：</p>
<p><img src="VUE/59.png" alt="image-20210323220612323"></p>
<p>以上的代码是否最终是可以渲染出来的：</p>
<ul>
<li><my-cpn v-show="isShow"></my-cpn>中，我们使用了isShow属性。</li>
<li>isShow属性包含在组件中，也包含在Vue实例中。</li>
</ul>
<p>答案：最终可以渲染出来，也就是使用的是Vue实例的属性。</p>
<ul>
<li>我们在使用<my-cpn v-show="isShow"></my-cpn>的时候，<strong>整个组件的使用过程是相当于在父组件</strong>（父组件模板）中出现的。</li>
<li>那么他的作用域就是父组件，使用的属性也是属于父组件的属性。</li>
<li>因此，isShow使用的是Vue实例中的属性，而不是子组件的属性。</li>
</ul>
<h4 id="4、作用域插槽"><a href="#4、作用域插槽" class="headerlink" title="4、作用域插槽"></a>4、作用域插槽</h4><p>有时，父组件使用插槽的时候需要用到子组件里面的内容，又因为父子组件都有自己的编译作用域。父组件不能拿到子组件的内容。所以才出现了作用域插槽。</p>
<p>有一句话总结：父组件替换插槽的标签，但是内容由子组件来提供。</p>
<p>使用作用域插槽：</p>
<p>父组件：</p>
<ul>
<li><p>在父组件使用子组件<cpn></p>
</li>
<li><p>在<cpn>里面使用<template>标签，在<template>里有一个属性：</p>
<ul>
<li><p>v-solt：作用域插槽，格式：</p>
<p><strong>v-slot :+ 插槽名称 + = + 组件内部绑定作用域值的映射。</strong></p>
</li>
</ul>
<p>注意：在<cpn>里不是一定要使用<template>标签。在Vue2.6版本以后就可以使用其他标签了，如<div>、<span>等等，但是为了兼容Vue2.6以前的版本，我们一般会使用<template></p>
</li>
<li><p>然后在<template>里面完成自己的业务</p>
</li>
</ul>
<p>子组件：</p>
<ul>
<li><p>在子组件模板里使用<slot>插槽，里面有几个属性：</p>
<ul>
<li><p>name：实现具名插槽</p>
</li>
<li><p>v-bind(<code>:</code>)：与子组件的值进行绑定。</p>
<p>如：:user=”user”  :message=”message”  :data=”data”</p>
</li>
</ul>
</li>
<li><p>在子组件内部要定义好在子组件模板插槽里与之绑定的数据。</p>
</li>
</ul>
<p>通过以上父子组件两步设置就可以完成：父组件使用子组件的插槽时可以拿到子组件的数据内容。</p>
<p>需求：</p>
<ul>
<li>子组件中包括一组数据，比如：pLanguages: [‘JavaScript’, ‘Python’, ‘Swift’, ‘Go’, ‘C++’]</li>
<li>需要在多个界面进行展示：<ul>
<li>某些界面是以列表形式展示的</li>
<li>某些界面要用<code>-</code>进行分隔</li>
<li>某些界面要用<code>*</code>进行分隔</li>
</ul>
</li>
</ul>
<p>代码实现：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--目的是获取子组件中的pLanguages--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:cpn</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--&lt;span v-for=&quot;item in slot.data&quot;&gt; - &#123;&#123;item&#125;&#125;&lt;/span&gt;--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;slotProps.data.join(&#x27; - &#x27;)&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--目的是获取子组件中的pLanguages--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:cpn</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--&lt;span v-for=&quot;item in slot.data&quot;&gt; - &#123;&#123;item&#125;&#125;&lt;/span&gt;--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;slotProps.data.join(&#x27; * &#x27;)&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;cpn&quot;</span> <span class="attr">:data</span>=<span class="string">&quot;pLanguages&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in pLanguages&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好啊&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      cpn: &#123;</span><br><span class="line"><span class="javascript">        template: <span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">            pLanguages: [<span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;C++&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;C#&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;Go&#x27;</span>, <span class="string">&#x27;Swift&#x27;</span>]</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="VUE/60.png" alt="image-20210324003729089"></p>
<h2 id="四、前端模块化"><a href="#四、前端模块化" class="headerlink" title="四、前端模块化"></a>四、前端模块化</h2><h3 id="1、为什么需要模块化"><a href="#1、为什么需要模块化" class="headerlink" title="1、为什么需要模块化"></a>1、为什么需要模块化</h3><p>在网页开发的早期，js制作作为一种脚本语言，做一些简单的表单验证或动画实现等，那个时候代码还是很少的，可以直接将代码写在<script>标签中。</p>
<p>但随着ajax异步请求的出现，慢慢形成了前后端的分离：</p>
<ul>
<li><p>客户端需要完成的事情越来越多，代码量也是与日俱增。</p>
</li>
<li><p>为了应对代码量的剧增，我们通常会将代码组织在多个js文件中，进行维护</p>
</li>
<li><p>但是这种维护方式，依然不能避免一些灾难性的问题：</p>
<ul>
<li><p>全局变量同名问题</p>
<p><img src="VUE/61.png" alt="image-20210324102745837"></p>
</li>
<li><p>对js文件的依赖顺序几乎是强制性的(对js文件导入的顺序不同，所得到的结果也是不同的)</p>
</li>
<li><p>但是当js文件过多，比如有几十个的时候，弄清楚它们的顺序是一件比较同时的事情。</p>
</li>
<li><p>而且即使你弄清楚顺序了，也不能避免上面出现的这种尴尬问题的发生。</p>
</li>
</ul>
</li>
</ul>
<p>随着重名问题的出现，也随之出现了解决方法：</p>
<p>使用<strong>匿名函数</strong>来解决方面的重名问题（闭包）。因为函数是有自己的作用域的。重名的变量或者方法都只有在对应的函数里面才有效。将一个个重名的全局变量变成一个个局部变量。</p>
<p><img src="VUE/62.png" alt="image-20210324103304290"></p>
<p>但随之而来又出现了新的问题：程序的代码复用性大大的下降。因为定义的变量都是局部变量，只有在自己匿名函数的内部使用，不能在其他js文件里引用。</p>
<p>所以，模块化思想就出现了。我们可以使用一个模块作为出口，将我们需要的局部变量与方法暴露出来。外部的js文件就可以通过这个模块去调用匿名函数里面的变量与方法。</p>
<p>那么怎么是匿名函数模块化呢？</p>
<p>匿名函数：</p>
<ul>
<li>在匿名函数内部，定义一个对象；</li>
<li>给对象添加各种需要暴露到外面的属性和方法(不需要暴露的直接定义即可)；</li>
<li>最后将这个对象返回，并且在外面使用了一个MoudleA接受。</li>
</ul>
<p>调用方（某js文件）：</p>
<ul>
<li>只需要使用属于自己模块的属性和方法即可</li>
</ul>
<p><img src="VUE/63.png" alt="image-20210324104648346"></p>
<p>这就是模块最基础的封装。但前端模块化开发到今天，已经有了很多既有的规范，以及对应的实现方案。常见的模块化规范：</p>
<ul>
<li>CommonJS：在Nodejs里使用（了解）</li>
<li>ES6的Modules（主要学习）</li>
<li>AMD</li>
<li>CMD</li>
</ul>
<h3 id="2、CommonJS"><a href="#2、CommonJS" class="headerlink" title="2、CommonJS"></a>2、CommonJS</h3><p>CommonJS模块化有两个核心：导出和导入</p>
<p>CommonJS的导出：</p>
<p><img src="VUE/64.png" alt="image-20210324105207224"></p>
<p>CommonJS的导入：</p>
<p><img src="VUE/65.png" alt="image-20210324105241377"></p>
<h3 id="3、ES6的Modules"><a href="#3、ES6的Modules" class="headerlink" title="3、ES6的Modules"></a>3、ES6的Modules</h3><h4 id="1、ES6的Modules的导出：export"><a href="#1、ES6的Modules的导出：export" class="headerlink" title="1、ES6的Modules的导出：export"></a>1、ES6的Modules的导出：export</h4><h5 id="1、export导出变量"><a href="#1、export导出变量" class="headerlink" title="1、export导出变量"></a>1、export导出变量</h5><ul>
<li><p>导出方式一：先定义好变量，在将需要导出的变量一起导出</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flag = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> message = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.先定义好变量，在将需要导出的变量一起导出</span></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  flag, message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>导出方式二：在定义变量的同时导出</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.在定义变量的同时导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> num1 = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> height = <span class="number">1.88</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="2、export导出函数或者类"><a href="#2、export导出函数或者类" class="headerlink" title="2、export导出函数或者类"></a>2、export导出函数或者类</h5><ul>
<li><p>导出方式三：导出函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.导出函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 * num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>导出方式四：导出类</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4.导出类</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;在奔跑&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="3、export-default"><a href="#3、export-default" class="headerlink" title="3、export default"></a>3、export default</h5><p>某些情况下，一个模块中包含某个的功能，我们并不希望给这个功能命名，而且让导入者可以自己来命名。这个时候就可以使用export default。</p>
<p><strong>需要注意</strong>：<strong>export default在同一个模块中，不允许同时存在多个。</strong></p>
<ul>
<li><p>导出方式五：export default为一个变量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> address = <span class="string">&#x27;北京市&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> address</span><br></pre></td></tr></table></figure>
</li>
<li><p>导出方式六：export default为一个方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">argument</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(argument);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="2、ES6的Modules的导入：import"><a href="#2、ES6的Modules的导入：import" class="headerlink" title="2、ES6的Modules的导入：import"></a>2、ES6的Modules的导入：import</h4><p>我们使用**<code>export</code><strong>指令导出了模块对外提供的接口，下面我们就可以通过</strong><code>import</code>**命令来加载对应的这个模块了。</p>
<p>关于import的使用：</p>
<ol>
<li><p>首先，我们需要在HTML代码中<strong>引入两个js文件</strong>，并且<strong>类型需要设置为module</strong>。</p>
<p><img src="VUE/67.png" alt="image-20210324111327722"></p>
</li>
<li><p>import指令用于导入模块中的内容。以下为导入的几种形式（对应上面的方式一到六）：</p>
<ol>
<li><p>导入的{}中定义的变量（对应方式一）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;flag, message&#125; <span class="keyword">from</span> <span class="string">&quot;./aaa.js&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;小明是天才, 哈哈哈&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接导入export定义的变量（对应方式二）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;num1, height&#125; <span class="keyword">from</span> <span class="string">&quot;./aaa.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num1);</span><br><span class="line"><span class="built_in">console</span>.log(height);</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入 export的function（对应方式三）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mul&#125; <span class="keyword">from</span> <span class="string">&quot;./aaa.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(mul(<span class="number">30</span>, <span class="number">50</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入 export的class（对应方式四）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mul, Person&#125; <span class="keyword">from</span> <span class="string">&quot;./aaa.js&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.run()</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入 export default中的内容（变量）（对应方式五）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> addr <span class="keyword">from</span> <span class="string">&quot;./aaa.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(addr);</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入 export default中的内容（方法）（对应方式六）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> todo <span class="keyword">from</span> <span class="string">&quot;./aaa.js&quot;</span>;</span><br><span class="line">todo(<span class="string">&#x27;你好啊&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>统一全部导入：</p>
<p>我们希望某个模块中所有的信息都导入，一个个导入显然有些麻烦</p>
<p>通过<code>*</code>可以导入模块中所有的export变量</p>
<p>但是通常情况下我们需要给<code>*</code>用<code>as</code><strong>起一个别名</strong>，方便后续的使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import &#123;flag, num, num1, height, Person, mul, sum&#125; from &quot;./aaa.js&quot;;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> aaa <span class="keyword">from</span> <span class="string">&#x27;./aaa.js&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(aaa.flag);</span><br><span class="line"><span class="built_in">console</span>.log(aaa.height);</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
<h2 id="五、webpack"><a href="#五、webpack" class="headerlink" title="五、webpack"></a>五、webpack</h2><h3 id="1、什么是webpack？"><a href="#1、什么是webpack？" class="headerlink" title="1、什么是webpack？"></a>1、什么是webpack？</h3><p>官方解释：</p>
<ul>
<li>At its core, <strong>webpack</strong> is a <em>static module bundler</em> for modern JavaScript applications. </li>
<li>从本质上来讲，webpack是一个现代的JavaScript应用的静态<strong>模块打包</strong>工具。</li>
</ul>
<p><img src="VUE/68.png" alt="image-20210325215829591"></p>
<p>我们从两个点来解释上面这句话：<strong>模块</strong> 和 <strong>打包</strong></p>
<ul>
<li><p>模块：</p>
<p>前端模块化的必要性之前已经提及，而且也提到了目前使用前端模块化的一些方案：AMD、CMD、CommonJS、ES6。</p>
<p>但在ES6之前，我们要想进行模块化开发，就必须借助于其他的工具，让我们可以进行模块化开发并且在通过模块化开发完成了项目后，还需要处理模块间的各种依赖，并且将其进行整合打包。</p>
<p>而webpack其中一个核心就是让我们可能进行模块化开发，并且会帮助我们处理模块间的依赖关系。而且不仅仅是JavaScript文件，我们的CSS、图片、json文件，以及一些less、scss、stylus文件等等在webpack中都可以被当做模块来使用。</p>
</li>
<li><p>打包：</p>
<p>理解了webpack可以帮助我们进行模块化，并且处理模块间的各种复杂关系后，打包的概念就非常好理解了。</p>
<p>webpack的打包就是将webpack中的各种资源模块进行打包合并成一个或多个包(Bundle)。并且在打包的过程中，还可以对资源进行处理，比如压缩图片，将scss转成css，将ES6语法转成ES5语法，将TypeScript转成JavaScript等等操作。</p>
<p>也就是说，开发的时候你可以使用AMD、CMD、CommonJS、ES6等模块化方案进行编码开发，发布到浏览器的时候可以通过webpack打包成一个浏览器能够识别的（如ES5）代码文件。然后再将这个代码文件部署到服务器。</p>
<p>但是打包的操作似乎<code>grunt</code>/<code>gulp</code>/<code>rollup</code>(Vue的源码就是用rollup构建的)也可以帮助我们完成。为什么要用webpack呢？</p>
</li>
</ul>
<h3 id="2、webpack和grunt-gulp的对比"><a href="#2、webpack和grunt-gulp的对比" class="headerlink" title="2、webpack和grunt/gulp的对比"></a>2、webpack和grunt/gulp的对比</h3><h4 id="1、grunt-gulp"><a href="#1、grunt-gulp" class="headerlink" title="1、grunt/gulp"></a>1、grunt/gulp</h4><p><strong>grunt/gulp的核心是Task（任务）</strong></p>
<p>我们可以配置一系列的task，并且定义task要处理的事务（例如ES6、ts转化，图片压缩，scss转成css）。之后让grunt/gulp来依次执行这些task，而且让整个流程自动化。所以grunt/gulp也被称为<strong>前端自动化任务管理工具</strong>。</p>
<p>一个gulp的task：</p>
<ul>
<li>下面的task就是将src下面的所有js文件转成ES5的语法。</li>
<li>并且最终输出到dist文件夹中。</li>
</ul>
<p><img src="VUE/69.png" alt="image-20210325221756978"></p>
<p>什么时候用grunt/gulp？什么时候用webpack？</p>
<ul>
<li>如果你的工程模块依赖非常简单，甚至是没有用到模块化的概念。</li>
<li>只需要进行简单的合并、压缩，就使用grunt/gulp即可。</li>
<li>但是如果整个项目使用了模块化管理，而且相互依赖非常强，我们就可以使用更加强大的webpack了。</li>
</ul>
<h4 id="2、grunt-gulp和webpack有什么不同呢？"><a href="#2、grunt-gulp和webpack有什么不同呢？" class="headerlink" title="2、grunt/gulp和webpack有什么不同呢？"></a>2、grunt/gulp和webpack有什么不同呢？</h4><ul>
<li>grunt/gulp更加强调的是<strong>前端流程的自动化</strong>，模块化不是它的核心。</li>
<li>webpack更加强调<strong>模块化开发管理</strong>，而文件压缩合并、预处理等功能，是他附带的功能。</li>
</ul>
<h3 id="3、webpack的安装"><a href="#3、webpack的安装" class="headerlink" title="3、webpack的安装"></a>3、webpack的安装</h3><ol>
<li><p>安装webpack首先需要安装Node.js，Node.js自带了软件包管理工具npm</p>
<p>查看自己的node版本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>

<p>查看自己的npm版本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure>

<p>webpack和node和npm的关系：</p>
<p><img src="VUE/77.png" alt="webpack和node和npm的关系"></p>
</li>
<li><p>全局安装webpack（<strong>全局的webpack</strong>）（少用）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// -g进行全局安装（默认安装最新版本）</span><br><span class="line">npm install webpack -g</span><br><span class="line"></span><br><span class="line">// 也可以通过@+版本号进行具体版本的安装</span><br><span class="line">npm install webpack@3.6.0 -g </span><br></pre></td></tr></table></figure>

<p><strong>局部安装webpack</strong>（常用）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd 对应目录</span><br><span class="line">// 可以通过@+版本号安装该模块需要的webpack版本</span><br><span class="line">// --save-dev`是开发时依赖，项目打包后不需要继续使用的</span><br><span class="line">npm install webpack --save-dev</span><br></pre></td></tr></table></figure>

<p>为什么全局安装后，还需要局部安装呢？</p>
<ul>
<li>全局安装：在终端直接执行webpack命令，使用的全局安装的webpack</li>
<li>局部安装：当在package.json中定义了scripts时，其中包含了webpack命令，那么使用的是局部webpack。</li>
</ul>
<p>开发时依赖与运行时依赖（<a target="_blank" rel="noopener" href="https://docs.npmjs.com/cli/v7/configuring-npm/package-json">npm的5种依赖种类</a>）</p>
<ul>
<li><p>开发时依赖（package.json中的devDependencies）：</p>
<p>开发中所使用的的依赖，<strong>线上生产环境上并不需要他们</strong>，npm官方文档将它定义为开发中所使用的外部的测试或者文档框架。目的是为了减少在安装依赖时node_modules的体积，提升安装依赖的速度，节省线上及其的硬盘资源以及部署上线的时间。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install/i xxx -D/--save-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行时依赖（package.json中的dependencies）：</p>
<p>这是npm最基本的依赖，写在一个简单的对象中，将依赖程序包映射到版本范围。比较常用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install/i xxx@version -S/--save</span><br></pre></td></tr></table></figure>

<p>如果不指定版本号version，则默认安装最新版本</p>
</li>
</ul>
</li>
</ol>
<h3 id="4、使用webpack进行开发"><a href="#4、使用webpack进行开发" class="headerlink" title="4、使用webpack进行开发"></a>4、使用webpack进行开发</h3><h4 id="1、webpack基础"><a href="#1、webpack基础" class="headerlink" title="1、webpack基础"></a>1、webpack基础</h4><ol>
<li><p>我们创建如下文件和文件夹：</p>
<ul>
<li><p>index.html：浏览器打开展示的首页html</p>
</li>
<li><p>dist文件夹：用于存放之后打包的文件</p>
</li>
<li><p>src文件夹：用于存放我们写的源文件</p>
</li>
<li><p>js文件夹：用于存放我们写的js文件</p>
<ul>
<li><p>main.js：项目的入口文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.使用commonjs的模块化规范进行导入</span></span><br><span class="line"><span class="keyword">const</span> &#123;add, mul,dec&#125; = <span class="built_in">require</span>(<span class="string">&#x27;./mathUtils.js&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"><span class="built_in">console</span>.log(mul(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"><span class="built_in">console</span>.log(dec(<span class="number">30</span>, <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.使用ES6的模块化的规范进行导入</span></span><br><span class="line"><span class="keyword">import</span> &#123;name, age, height&#125; <span class="keyword">from</span> <span class="string">&quot;./info&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line"><span class="built_in">console</span>.log(age);</span><br><span class="line"><span class="built_in">console</span>.log(height);</span><br></pre></td></tr></table></figure>
</li>
<li><p>mathUtils.js：定义了一些数学工具函数，可以在其他地方引用，并且使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 乘法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 * num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dec</span>(<span class="params">num1,num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 - num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用CommonJS进行导出</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  add,</span><br><span class="line">  mul,</span><br><span class="line">  dec</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>info.js：定义了一些属性，可以在其他地方引用，并且使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用ES6的模块化的规范进行导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&#x27;why&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> height = <span class="number">1.88</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>package.json：通过npm init生成的，npm包管理的文件（下面会提）</p>
</li>
</ul>
</li>
<li><p>现在的js文件中使用了模块化的方式进行开发，但是他们并不可以直接使用。</p>
<ul>
<li>因为如果直接在index.html引入这两个js文件，浏览器并不识别其中的模块化代码</li>
<li>另外，在真实项目中当有许多这样的js文件时，我们一个个引用非常麻烦，并且后期非常不方便对它们进行管理</li>
</ul>
</li>
<li><p>所以我们应使用webpack工具，对多个js文件进行打包。</p>
<ul>
<li>webpack就是一个模块化的打包工具，所以它支持我们代码中写模块化，可以对模块化的代码进行处理。</li>
<li>另外，如果在处理完所有模块之间的关系后，将多个js打包到一个js文件中，引入时就变得非常方便了。</li>
<li>而且，在打包的时候也不用将所有的js文件进行打包，只选择有导入其他模块（js文件）的主js文件（main.js）进行打包即可。因为webpack会自动处理模块间的依赖，它会根据依赖找到相关联的js文件，然后webpack会将主js文件（main.js）与之相关联的文件一起打包。如以上代码只需打包main.js文件即可。</li>
</ul>
</li>
<li><p>在终端进到项目的目录，使用webpack的指令进行打包（webpack 3.6.0版本）。将src下的main.js打包到dist下的bundle.js文件（自动生成）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack ./src/main.js ./dist/bundle.js</span><br></pre></td></tr></table></figure>

<p><img src="VUE/70.png" alt="image-20210325233912009"></p>
</li>
<li><p>打包后会在dist文件下，生成一个bundle.js文件</p>
<ul>
<li><p>文件内容有些复杂，这里暂时先不看，后续再进行分析</p>
</li>
<li><p>bundle.js文件，是webpack处理了项目直接文件依赖后生成的一个js文件，我们只需要将这个js文件在index.html中引入即可</p>
<p><img src="VUE/71.png" alt="image-20210325234101665"></p>
</li>
</ul>
</li>
<li><p>bundle.js：核心方法：__webpack_require__（用来就将ES6解析成ES5）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******/</span> (<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>) </span>&#123; <span class="comment">// webpackBootstrap</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// The module cache</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="keyword">var</span> installedModules = &#123;&#125;;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// The require function</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="comment">// Check if module is in cache</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="function"><span class="title">if</span>(<span class="params">installedModules[moduleId]</span>)</span> &#123;</span><br><span class="line"><span class="comment">/******/</span> 			<span class="keyword">return</span> installedModules[moduleId].exports;</span><br><span class="line"><span class="comment">/******/</span> 		&#125;</span><br><span class="line"><span class="comment">/******/</span> 		<span class="comment">// Create a new module (and put it into the cache)</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="keyword">var</span> <span class="built_in">module</span> = installedModules[moduleId] = &#123;</span><br><span class="line"><span class="comment">/******/</span> 			i: moduleId,</span><br><span class="line"><span class="comment">/******/</span> 			l: <span class="literal">false</span>,</span><br><span class="line"><span class="comment">/******/</span> 			<span class="built_in">exports</span>: &#123;&#125;</span><br><span class="line"><span class="comment">/******/</span> 		&#125;;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="comment">// Execute the module function</span></span><br><span class="line"><span class="comment">/******/</span> 		modules[moduleId].call(<span class="built_in">module</span>.exports, <span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="comment">// Flag the module as loaded</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="built_in">module</span>.l = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="comment">// Return the exports of the module</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line"><span class="comment">/******/</span> 	&#125;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// expose the modules object (__webpack_modules__)</span></span><br><span class="line"><span class="comment">/******/</span> 	__webpack_require__.m = modules;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// expose the module cache</span></span><br><span class="line"><span class="comment">/******/</span> 	__webpack_require__.c = installedModules;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// define getter function for harmony exports</span></span><br><span class="line"><span class="comment">/******/</span> 	__webpack_require__.d = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">exports</span>, name, getter</span>) </span>&#123;</span><br><span class="line"><span class="comment">/******/</span> 		<span class="function"><span class="title">if</span>(<span class="params">!__webpack_require__.o(<span class="built_in">exports</span>, name)</span>)</span> &#123;</span><br><span class="line"><span class="comment">/******/</span> 			<span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, name, &#123;</span><br><span class="line"><span class="comment">/******/</span> 				configurable: <span class="literal">false</span>,</span><br><span class="line"><span class="comment">/******/</span> 				enumerable: <span class="literal">true</span>,</span><br><span class="line"><span class="comment">/******/</span> 				get: getter</span><br><span class="line"><span class="comment">/******/</span> 			&#125;);</span><br><span class="line"><span class="comment">/******/</span> 		&#125;</span><br><span class="line"><span class="comment">/******/</span> 	&#125;;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// getDefaultExport function for compatibility with non-harmony modules</span></span><br><span class="line"><span class="comment">/******/</span> 	__webpack_require__.n = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line"><span class="comment">/******/</span> 		<span class="keyword">var</span> getter = <span class="built_in">module</span> &amp;&amp; <span class="built_in">module</span>.__esModule ?</span><br><span class="line"><span class="comment">/******/</span> 			<span class="function"><span class="keyword">function</span> <span class="title">getDefault</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">module</span>[<span class="string">&#x27;default&#x27;</span>]; &#125; :</span><br><span class="line"><span class="comment">/******/</span> 			<span class="function"><span class="keyword">function</span> <span class="title">getModuleExports</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">module</span>; &#125;;</span><br><span class="line"><span class="comment">/******/</span> 		__webpack_require__.d(getter, <span class="string">&#x27;a&#x27;</span>, getter);</span><br><span class="line"><span class="comment">/******/</span> 		<span class="keyword">return</span> getter;</span><br><span class="line"><span class="comment">/******/</span> 	&#125;;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// Object.prototype.hasOwnProperty.call</span></span><br><span class="line"><span class="comment">/******/</span> 	__webpack_require__.o = <span class="function"><span class="keyword">function</span>(<span class="params">object, property</span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.hasOwnProperty.call(object, property); &#125;;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// __webpack_public_path__</span></span><br><span class="line"><span class="comment">/******/</span> 	__webpack_require__.p = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// Load entry module and return exports</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="keyword">return</span> __webpack_require__(__webpack_require__.s = <span class="number">0</span>);</span><br><span class="line"><span class="comment">/******/</span> &#125;)</span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="comment">/******/</span> ([</span><br><span class="line"><span class="comment">/* 0 */</span></span><br><span class="line"><span class="comment">/***/</span> (<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(__webpack_exports__, <span class="string">&quot;__esModule&quot;</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="comment">/* harmony import */</span> <span class="keyword">var</span> __WEBPACK_IMPORTED_MODULE_0__info__ = __webpack_require__(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1.使用commonjs的模块化规范</span></span><br><span class="line"><span class="keyword">const</span> &#123;add, mul,dec&#125; = __webpack_require__(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"><span class="built_in">console</span>.log(mul(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"><span class="built_in">console</span>.log(dec(<span class="number">30</span>, <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.使用ES6的模块化的规范</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(__WEBPACK_IMPORTED_MODULE_0__info__[<span class="string">&quot;c&quot;</span> <span class="comment">/* name */</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(__WEBPACK_IMPORTED_MODULE_0__info__[<span class="string">&quot;a&quot;</span> <span class="comment">/* age */</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(__WEBPACK_IMPORTED_MODULE_0__info__[<span class="string">&quot;b&quot;</span> <span class="comment">/* height */</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/***/</span> &#125;),</span><br><span class="line"><span class="comment">/* 1 */</span></span><br><span class="line"><span class="comment">/***/</span> (<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, <span class="built_in">exports</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 * num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dec</span>(<span class="params">num1,num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 - num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  add,</span><br><span class="line">  mul,</span><br><span class="line">  dec</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***/</span> &#125;),</span><br><span class="line"><span class="comment">/* 2 */</span></span><br><span class="line"><span class="comment">/***/</span> (<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;why&#x27;</span>;</span><br><span class="line"><span class="comment">/* harmony export (immutable) */</span> __webpack_exports__[<span class="string">&quot;c&quot;</span>] = name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="comment">/* harmony export (immutable) */</span> __webpack_exports__[<span class="string">&quot;a&quot;</span>] = age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> height = <span class="number">1.88</span>;</span><br><span class="line"><span class="comment">/* harmony export (immutable) */</span> __webpack_exports__[<span class="string">&quot;b&quot;</span>] = height;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***/</span> &#125;)</span><br><span class="line"><span class="comment">/******/</span> ]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果：</p>
<p><img src="VUE/72.png" alt="image-20210325234538965"></p>
</li>
</ol>
<h4 id="2、webpack的配置"><a href="#2、webpack的配置" class="headerlink" title="2、webpack的配置"></a>2、webpack的配置</h4><p>如果每次使用webpack的命令都需要写上入口和出口作为参数，就非常麻烦，有没有一种方法可以将这两个参数写到配置中，在运行时，直接读取呢？</p>
<p>当然可以，就是创建一个**<code>webpack.config.js</code>**文件。文件名字不能修改。在里面设置路径、出口与入口。</p>
<ul>
<li>入口：项目打包的文件</li>
<li>出口：项目要打包到哪里</li>
<li>路径：用来确定出口的位置。注意路径必须是绝对路径，但是又不能写死，所以需要我们动态获取路径。通过Nodejs的<code>path</code>模块进行路径的动态获取。</li>
</ul>
<p>如何获取Nodejs的<code>path</code>模块？安装步骤：</p>
<ol>
<li><p>在终端输入</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure>

<p>当项目需要使用到Nodejs的东西的时候，就需要我们初始化npm。</p>
<p>npm初始化过程：</p>
<ul>
<li>package name：给包起一个名称（排除中文与一些特殊符号）</li>
<li>version：版本号</li>
<li>description：描述（可不填）</li>
<li>entry point：index.js（在webpack用不上）</li>
<li>test command：测试命令</li>
<li>git repository：git仓库</li>
<li>keywords：密码</li>
<li>author：作者</li>
<li>license：协议（如果为开源就需要设置）</li>
</ul>
<p>一旦初始化就会生成一个**<code>package.json</code>**的文件：任何一个项目，如果想单独依赖Nodejs环境的话，一般情况下，都需要一个package.json文件。这个文件是用来告知当前项目的一些信息的。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;meetwebpack&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;webpack&quot;</span>: <span class="string">&quot;^3.6.0&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一些命令：</p>
<ul>
<li>npm install：若项目有依赖一些模块的话，他会根据你在package.json里所有的依赖，帮助我们在当前文件夹下安装一些东西。</li>
</ul>
</li>
<li><p>然后在**<code>webpack.config.js</code>**文件里的路径处使用path的resolve函数。</p>
<p>resolve函数：用于对两个路径进行拼接</p>
<p>而绝对路径的拼接还需要一个全局变量：__dirname：保存当前文件所在的路径。</p>
</li>
</ol>
<p><strong>webpack.config.js</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&#x27;./src/main.js&#x27;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    filename: <span class="string">&#x27;bundle.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后就可以直接使用<code>webpack</code>对项目进行打包。</p>
<p>但是当项目越来越复杂的时候，即不止一个webpack.config.js，还存在production.comfig.js等等文件的时候。执行webpack的时候，还得加上具体的js文件。这是还可以通过将webpack命令统一映射到一个命令上，如<code>npm run build</code>。那么怎么设置映射呢？</p>
<p>在package.json里对scripts（脚本）设置自己的执行脚本：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack&quot;</span></span><br><span class="line">  	&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>package.json中的scripts的脚本在执行时，会按照一定的顺序寻找命令对应的位置。</p>
<ol>
<li>首先，会寻找本地的node_modules/.bin路径中对应的命令</li>
<li>如果没有找到，会去全局的环境变量中寻找。<ul>
<li>在这里全局的环境变量指的是当时我们安装的全局webpack。</li>
<li>而本地的node_modules/.bin路径指的是我们在当前项目安装的局部webpack。</li>
<li>上文有提：<code>webpack</code>命令执行的全局的webpack，因为它是在终端命令的；而npm run build命令执行的是局部的webpack，因为它是根据scripts的脚本执行的，找的是本地的webpack。<strong>而在大项目中，每个子项目往往依赖特定的webpack版本，很少去使用全局的webpack，全局的版本可能很这个项目的webpack版本不一致，导出打包出现问题</strong>。（反正全局的webpack的版本太高而出现bug）<strong>所以通常一个项目，都有自己局部的webpack</strong>。而我们也要使用局部webpack的方式**<code>node_modules/.bin/webpack</code>**进行局部打包。但是我们可以通过映射的方式简化命令，这也是我们要设置映射，使用 npm run bulid 而不使用webpack的一大原因。</li>
</ul>
</li>
</ol>
<h3 id="5、webpack其他文件的转化（Loader）"><a href="#5、webpack其他文件的转化（Loader）" class="headerlink" title="5、webpack其他文件的转化（Loader）"></a>5、webpack其他文件的转化（Loader）</h3><p>webpack用来做什么呢？</p>
<ul>
<li>在我们之前的实例中，我们主要是用webpack来处理我们写的js代码，并且webpack会自动处理js之间相关的依赖。</li>
<li>但是，在开发中我们不仅仅有基本的js代码处理，我们也需要加载css、图片，也包括一些高级的将ES6转成ES5代码，将TypeScript转成ES5代码，将scss、less转成css，将.jsx、.vue文件转成js文件等等。</li>
<li>对于webpack本身的能力来说，对于这些转化是不支持的。</li>
<li>所以，就需要给webpack扩展对应的loader。</li>
<li>loader是webpack中一个非常核心的概念</li>
</ul>
<p>loader使用过程：</p>
<ol>
<li>通过npm安装需要使用的loader</li>
<li>在webpack.config.js中的module关键字下进行配置</li>
</ol>
<p>大部分loader我们都可以在<a target="_blank" rel="noopener" href="https://webpack.docschina.org/loaders/">webpack的官网</a>中找到，并且学习对应的用法。</p>
<h4 id="1、CSS文件"><a href="#1、CSS文件" class="headerlink" title="1、CSS文件"></a>1、CSS文件</h4><p>项目开发过程中，我们必然需要添加很多的样式，而样式我们往往写到一个单独的文件中。在src目录中，创建一个css文件，在该文件夹下写我们css的一些代码。</p>
<p>但是这个时候，我们写的.css文件中的样式并不会生效：</p>
<ul>
<li>我们压根就没有引用它</li>
<li>webpack也不可能找到它，因为我们只有一个入口，webpack会从入口开始查找其他依赖的文件</li>
</ul>
<p>所以需要我们在入口js文件里引用需要的css文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依赖css文件</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./css/normal.css&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>重新打包，会出现如下错误：</p>
<p><img src="VUE/73.png" alt="image-20210326013352060"></p>
<p>这个错误告诉我们：加载normal.css文件必须有对应的loader。</p>
<p>在<a target="_blank" rel="noopener" href="https://webpack.docschina.org/loaders/">webpack的官方</a>中，我们可以找到如下关于样式的loader使用方法：</p>
<p><img src="VUE/75.png" alt="image-20210326013640249"></p>
<ul>
<li><p>按照官方先安装css-loader</p>
</li>
<li><p>按照官方配置webpack.config.js文件（暂时不配置style-loader看情况）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&#x27;./src/main.js&#x27;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    filename: <span class="string">&#x27;bundle.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 正则表达式 \.对.进行转义，$为结束标志</span></span><br><span class="line">        <span class="comment">// 匹配.css文件</span></span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [ <span class="string">&#x27;css-loader&#x27;</span> ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>重新打包项目，运行index.html，你会发现样式并没有生效。原因：</p>
<ul>
<li>css-loader只负责加载css文件，但是并不负责将css具体样式嵌入到文档中</li>
<li>这个时候，我们还需要一个style-loader帮助我们处理。</li>
</ul>
<p>安装style-loader：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev style-loader</span><br></pre></td></tr></table></figure>

<p>在webpack.config.js配置：</p>
<p><strong>注意：style-loader需要放在css-loader的前面。</strong>（官网也是这么配置的）</p>
<p>疑惑：不对吧？按照我们的逻辑，在处理css文件过程中，应该是css-loader先加载css文件，再由style-loader来进行进一步的处理，为什么会将style-loader放在前面呢？</p>
<p>答案：这次<strong>因为webpack在读取使用的loader的过程中，是按照从右向左的顺序读取的</strong>。否则打包报错：</p>
<p><img src="VUE/76.png" alt="image-20210326015106671"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// css-loader只负责将css文件进行加载</span></span><br><span class="line">        <span class="comment">// style-loader负责将样式添加到DOM中</span></span><br><span class="line">        <span class="comment">// 使用多个loader时, 是从右向左</span></span><br><span class="line">        use: [ <span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span> ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、less文件"><a href="#2、less文件" class="headerlink" title="2、less文件"></a>2、less文件</h4><p>如果我们希望在项目中使用less、scss、stylus来写样式，与css一样，webpack并不可以帮助我们处理。需要我们添加对应的loader。（以less为例，scss与stylus一样）</p>
<p>先创建一个less文件，依然放在css文件夹中。在less文件夹里编写我们的less代码。并在main.js里面依赖less文件，然后对项目进行打包（报错）：</p>
<p><img src="VUE/78.png" alt="image-20210326015525314"></p>
<p>继续在官方中查找，我们会找到less-loader相关的使用说明</p>
<p><img src="VUE/79.png" alt="image-20210326015729535"></p>
<ol>
<li><p>首先，还是需要安装对应的loader</p>
<p>注意：我们这里还安装了less，因为webpack会使用<strong>less对less文件进行编译解析</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install less less-loader --save-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>其次，修改对应的配置文件webpack.config.js</p>
<p>添加一个rules选项，用于处理.less文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// css-loader只负责将css文件进行加载</span></span><br><span class="line">        <span class="comment">// style-loader负责将样式添加到DOM中</span></span><br><span class="line">        <span class="comment">// 使用多个loader时, 是从右向左</span></span><br><span class="line">        use: [ <span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span> ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [&#123;</span><br><span class="line">          loader: <span class="string">&quot;style-loader&quot;</span>, <span class="comment">// creates style nodes from JS strings</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">          loader: <span class="string">&quot;css-loader&quot;</span> <span class="comment">// translates CSS into CommonJS</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">          loader: <span class="string">&quot;less-loader&quot;</span>, <span class="comment">// compiles Less to CSS</span></span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="3、图片文件处理"><a href="#3、图片文件处理" class="headerlink" title="3、图片文件处理"></a>3、图片文件处理</h4><h5 id="1、url-loader与file-loader"><a href="#1、url-loader与file-loader" class="headerlink" title="1、url-loader与file-loader"></a>1、url-loader与file-loader</h5><ol>
<li><p>首先，我们在项目中加入两张图片：</p>
<ul>
<li>一张较小的图片test.jpg(小于13kb)，一张较大的图片timg.jpeg(大于13kb)</li>
<li>待会儿我们会针对这两张图片进行不同的处理</li>
</ul>
</li>
<li><p>将这两张图片放在src文件夹下的img文件夹里</p>
</li>
<li><p>先考虑在css样式中引用图片的情况，所以我更改了normal.css中的样式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="comment">/*background-color: red;*/</span></span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&quot;../img/test.jpg&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果我们现在直接打包，会出现如下问题</p>
<p><img src="VUE/80.png" alt="image-20210326021448341"></p>
</li>
<li><p>图片处理，我们使用url-loader来处理（在webpack5之后有改变，<a target="_blank" rel="noopener" href="https://webpack.docschina.org/guides/asset-modules/">详情</a>）</p>
</li>
<li><p>依然先安装url-loader</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install url-loader --save-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>在webpack.config.js配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif|jpeg)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              <span class="comment">// 当加载的图片, 小于limit时, 会将图片编译成base64字符串形式.</span></span><br><span class="line">              <span class="comment">// 当加载的图片, 大于limit时, 需要使用file-loader模块进行加载.</span></span><br><span class="line">              limit: <span class="number">13000</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>再次打包，运行index.html，就会发现我们的背景图片选出了出来。</p>
<ul>
<li><p>而仔细观察，你会发现背景图是通过base64显示出来的</p>
<p><img src="VUE/81.png" alt="image-20210326022233777"></p>
</li>
<li><p>OK，这就是limit属性的作用，当图片小于13kb时，对图片进行base64编码</p>
</li>
</ul>
</li>
<li><p>那么问题来了，如果大于13kb呢？我们将background的图片改成test02.jpg</p>
<ul>
<li><p>这次因为大于8kb的图片，会通过file-loader进行处理，但是我们的项目中并没有file-loader</p>
<p><img src="VUE/82.png" alt="image-20210326022436695"></p>
</li>
</ul>
</li>
<li><p>所以，我们需要安装file-loader</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install file-loader --save-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>在webpack.config.js配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif)$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>将项目重新打包，运行index.html，发现图片并未显示出来，控制台报404错误。</p>
</li>
</ol>
<p><img src="VUE/83.png"></p>
<p>原因：</p>
<ul>
<li><p>因为之前使用url-loader加载图片时是通过base64进行的，不需要单独一个文件来存储。</p>
</li>
<li><p>而现在使用的file-loader加载图片是将其看成一个完整的图片，就需要对它进行打包到dist文件夹里面，并对其进行重新命名（以哈希方式，防止重复）。</p>
</li>
<li><p>以后发布时连同bundle.js一起发布到服务器。所以打开dist文件夹下多了一个图片文件：</p>
<p><img src="VUE/84.png" alt="image-20210326024243736"></p>
</li>
<li><p>当浏览器加载图片的时候加载的是dist里打包的hash的图片文件，而不是我们开发时用的src/img下的图片。</p>
</li>
<li><p>控制台报404找不到浏览器需要加载的图片是因为浏览器是在index.html当前路径下查找图片的：</p>
<p><img src="VUE/85.png" alt="image-20210326024731783"></p>
</li>
<li><p>而我们的图片是在dist文件夹下面的，所以需要我们把路径改成dist/32f5576… .jpg</p>
</li>
<li><p>但我们不能改变css里面的代码，不能把它写死，应该让他在使用路径自动加上dist这个文件夹，所以我们需要对webpack.config.js的output属性进行修改，添加一个publicPath属性：值为<code>&#39;dist/&#39;</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    filename: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">    publicPath: <span class="string">&#x27;dist/&#x27;</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>设置以后，以后只要用到url的时候，就会在url前面添加dist/</p>
</li>
</ul>
<p>将项目重新打包，运行index.html。发现图片加载成功。</p>
<p><strong>注意：开发时我们可以使用这种方式，但在之后，我们项目发布服务器的时候是要将index.html文件打包进dist文件夹里面的，此时图片就在index.html的当前路径下，不需要在路径前面添加dist/，所以当项目发布的时候需要将publicPath属性删除。</strong></p>
<h5 id="2、修改dist图片文件名称"><a href="#2、修改dist图片文件名称" class="headerlink" title="2、修改dist图片文件名称"></a>2、<strong>修改dist图片文件名称</strong></h5><p>我们发现webpack自动帮助我们在dist文件夹里生成一个非常长的名字的图片。</p>
<ul>
<li>这是一个32位hash值，目的是防止名字重复</li>
<li>但是，真实开发中，我们可能对打包的图片名字有一定的要求</li>
<li>比如，将所有的图片放在一个文件夹img中，跟上<strong>图片原来的名称</strong>，同时也要防止重复，所以也需要进行<strong>hash</strong>方式（其中ext是为了保存后缀名 ext = extension）：img/name.hash:8.ext</li>
</ul>
<p>所以，我们可以在options中添加上如下选项：</p>
<ul>
<li>img：文件要打包到的文件夹</li>
<li>name：获取图片原来的名字，放在该位置</li>
<li>hash:8：为了防止图片名称冲突，依然使用hash，但是我们只保留8位</li>
<li>ext：使用图片原来的扩展名</li>
</ul>
<p>对webpack.config.js进行修改：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif|jpeg)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              <span class="comment">// 当加载的图片, 小于limit时, 会将图片编译成base64字符串形式.</span></span><br><span class="line">              <span class="comment">// 当加载的图片, 大于limit时, 需要使用file-loader模块进行加载.</span></span><br><span class="line">              limit: <span class="number">13000</span>,</span><br><span class="line">              name: <span class="string">&#x27;img/[name].[hash:8].[ext]&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>注意：**name、hash、ext要用中括号<code>[]</code>**，webpack会把<code>[]</code>里的值当成一个变量</p>
<ul>
<li>如果有些中括号<code>[]</code>,webpack在读取配置的时候会根据原有变量对应的值对<code>[]</code>里的内容进行替换</li>
<li>如果没有中括号<code>[]</code>,webpack会将其统一命名成name.png</li>
</ul>
<p>将项目进行打包后，发现配置成功：</p>
<p><img src="VUE/86.png" alt="image-20210326031643907"></p>
<h4 id="4、ES6语法处理（babel）"><a href="#4、ES6语法处理（babel）" class="headerlink" title="4、ES6语法处理（babel）"></a>4、ES6语法处理（babel）</h4><p>如果你仔细阅读webpack打包的js文件，发现写的ES6语法并没有转成ES5，那么就意味着可能一些对ES6还不支持的浏览器没有办法很好的运行我们的代码。</p>
<p>如果希望将ES6的语法转成ES5，那么就需要使用babel。而在webpack中，我们直接使用babel对应的loader就可以了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-loader@7 babel-core babel-preset-es2015</span><br></pre></td></tr></table></figure>

<p>配置webpack.config.js文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="comment">// exclude: 排除</span></span><br><span class="line">        <span class="comment">// include: 包含</span></span><br><span class="line">        exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            presets: [<span class="string">&#x27;es2015&#x27;</span>]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、webpack配置vue"><a href="#6、webpack配置vue" class="headerlink" title="6、webpack配置vue"></a>6、webpack配置vue</h3><p>后续项目中，我们会使用Vuejs进行开发，而且会以特殊的文件来组织vue的组件。所以，需要我们在我们的webpack环境中集成Vuejs。</p>
<p>现在，我们希望在项目中使用Vuejs，那么必然需要对其有依赖，所以需要先进行安装</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue --save</span><br></pre></td></tr></table></figure>

<p><strong>注意：因为我们后续是在实际项目中也会使用vue的，所以并不是开发时依赖</strong></p>
<p>在main.js引入vue</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5.使用Vue进行开发</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">      message: <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在index.html里挂载app：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123;message&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>打包运行index.html，控制台报错：</p>
<p><img src="VUE/87.png" alt="image-20210326033342069"></p>
<p>原因：</p>
<ul>
<li><p>Vue在构建最终的发布版本的时候，它构建了两类版本：</p>
<ul>
<li><p>runtime-only：</p>
<p>代码中不允许有任何template（app算vue实例的template），因为该版本内没有包含对template编译解析的代码（only只包含运行，不包含编译）。</p>
</li>
<li><p>runtime-compiler：</p>
<p>代码中允许有template，因为该版本中有compiler可以用于编译template</p>
</li>
</ul>
</li>
</ul>
<p>解决方法：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/installation.html#%E5%AF%B9%E4%B8%8D%E5%90%8C%E6%9E%84%E5%BB%BA%E7%89%88%E6%9C%AC%E7%9A%84%E8%A7%A3%E9%87%8A">Vue不同版本构建</a></p>
<p>修改webpack的配置，添加如下内容即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">    <span class="comment">// alias: 别名</span></span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">&#x27;vue$&#x27;</span>: <span class="string">&#x27;vue/dist/vue.esm.js&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="VUE/88.png" alt="image-20210326034650420"></p>
<h3 id="7、Vue的正确格式（el与template区别）"><a href="#7、Vue的正确格式（el与template区别）" class="headerlink" title="7、Vue的正确格式（el与template区别）"></a>7、Vue的正确格式（el与template区别）</h3><p>正常运行之后，我们来考虑另外一个问题：</p>
<ul>
<li>如果我们希望将data中的数据显示在界面中，就必须是修改index.html</li>
<li>如果我们后面自定义了组件，也必须修改index.html来使用组件</li>
<li>但是html模板在之后的开发中，我并不希望手动的来频繁修改。</li>
</ul>
<p>SPA（single page web application）:单页面复用。只有一个index.html。多页面我们也可以通过单页面实现（通过路由跳转vue-router（前端路由））。所以一般我们不改index.html里的东西，只用于挂载vue实例和导入主js文件（到时候插件帮我们将index.html导入到dist文件夹的是会自动生成，不需要我们手动写）。</p>
<ol>
<li><p>修改index.html</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./dist/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在main.js了删除Vue实例前面的变量app，将之前写在index.html里面的vue实例的模板通过template搬到Vue实例中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5.使用Vue进行开发</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  template:  <span class="string">`</span></span><br><span class="line"><span class="string">      &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">        &lt;button @click=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;</span></span><br><span class="line"><span class="string">        &lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">&#x27;Hello Webpack&#x27;</span>,</span><br><span class="line">      name: <span class="string">&#x27;coderwhy&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">btnClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>el与template的区别</strong>：</p>
<ul>
<li>在我们之前的学习中，我们知道el用于指定Vue要管理的DOM，可以帮助解析其中的指令、事件监听等等</li>
<li>而如果Vue实例中同时指定了template，那么<strong>template模板的内容会替换掉挂载的对应el的模板</strong>。</li>
<li>这样做的好处：之后我们就不需要在以后的开发中再次操作index.html，只需要在template中写入对应的标签即可。</li>
</ul>
<p>但是，书写template模块非常麻烦臃肿怎么办呢？</p>
<p>最终会将template模板中的内容进行抽离，会分成三部分书写：template、script、style，结构变得非常清晰</p>
</li>
<li><p>将vue实例的内容抽取成一个组件，在vue实例中使用抽取的组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5.使用Vue进行开发</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = &#123;</span><br><span class="line">  template:  <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;button @click=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">&#x27;Hello Webpack&#x27;</span>,</span><br><span class="line">      name: <span class="string">&#x27;coderwhy&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">btnClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  template: <span class="string">&#x27;&lt;App/&gt;&#x27;</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    App</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>将抽取出去的App组件当成一个对象，在src下创建一个vue文件夹，在该文件夹下创建app.js：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  template:  <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;button @click=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">&#x27;Hello Webpack&#x27;</span>,</span><br><span class="line">      name: <span class="string">&#x27;coderwhy&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">btnClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在main.js进行导入</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./vue/app&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>但是存在一个问题：app.js里模板与js代码没有分离。</p>
<p>解决方法：在src/vue文件夹下创建App.vue文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2 class&#x3D;&quot;title&quot;&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;btnClick&quot;&gt;按钮&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;App&quot;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        message: &#39;Hello Webpack&#39;,</span><br><span class="line">        name: &#39;coderwhy&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      btnClick() &#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  .title &#123;</span><br><span class="line">    color: green;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>在main.js里引入：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5.使用Vue进行开发</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">// import App from &#x27;./vue/app&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./vue/App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  template: <span class="string">&#x27;&lt;App/&gt;&#x27;</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    App</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>打包运行报错：没有对应的loader。</p>
</li>
<li><p>安装vue-loader和vue-template-compiler</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-loader vue-template-compiler --save-dev</span><br></pre></td></tr></table></figure>

<p>修改webpack.config.js的配置文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;vue-loader&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但依旧存在问题：缺少插件。在vue-loader14开始，如果要使用vue-loader，还必须另外给它配置个插件。</p>
<p>解决方法：降低版本，在package.json里进行修改</p>
<p>其中：<code>^</code>大于等于，表示在13 &lt; vue-loader &lt; 14在这中间安装一个版本。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;vue-loader&quot;: &quot;^13.0.0&quot;,</span><br></pre></td></tr></table></figure>

<p>在终端执行命令<code>npm install</code>重新安装</p>
</li>
<li><p>在vue编写其他组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;我是cpn组件的标题&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;p&gt;我是cpn组件的内容, 哈哈哈&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;Cpn&quot;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        name: &#39;CPN组件的name&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>在App.vue里使用Cpn.vue组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2 class&#x3D;&quot;title&quot;&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;btnClick&quot;&gt;按钮&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;Cpn&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Cpn from &#39;.&#x2F;Cpn.vue&#39;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;App&quot;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      Cpn</span><br><span class="line">    &#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        message: &#39;Hello Webpack&#39;,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      btnClick() &#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  .title &#123;</span><br><span class="line">    color: green;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>若你在导入Cpn.vue的时候想要省略掉.vue的话，就需要修改webpack.config.js文件：在resolve里添加属性extensions，值为要省略的扩展名。如[‘.js’, ‘.css’, ‘.vue’]</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">    <span class="comment">// alias: 别名</span></span><br><span class="line">    extensions: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.css&#x27;</span>, <span class="string">&#x27;.vue&#x27;</span>],</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">&#x27;vue$&#x27;</span>: <span class="string">&#x27;vue/dist/vue.esm.js&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后在App.vue里引入的时候就能省略扩展名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Cpn from &#39;.&#x2F;Cpn&#39;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="8、插件（plugin）"><a href="#8、插件（plugin）" class="headerlink" title="8、插件（plugin）"></a>8、插件（plugin）</h3><h4 id="1、插件（plugin）是什么"><a href="#1、插件（plugin）是什么" class="headerlink" title="1、插件（plugin）是什么"></a>1、插件（plugin）是什么</h4><ul>
<li>通常是用于对某个现有的架构进行扩展</li>
<li>webpack中的插件，就是对webpack现有功能的各种扩展，比如打包优化，文件压缩等等</li>
</ul>
<h4 id="2、loader和plugin区别"><a href="#2、loader和plugin区别" class="headerlink" title="2、loader和plugin区别"></a>2、loader和plugin区别</h4><ul>
<li>loader主要用于转换某些类型的模块，它是一个转换器和加载器。</li>
<li>plugin是插件，它是对webpack本身的扩展，是一个扩展器</li>
</ul>
<h4 id="3、plugin的使用过程"><a href="#3、plugin的使用过程" class="headerlink" title="3、plugin的使用过程"></a>3、plugin的使用过程</h4><ol>
<li>通过npm安装需要使用的plugins(某些webpack已经内置的插件不需要安装)</li>
<li>在webpack.config.js中的plugins中配置插件</li>
</ol>
<h4 id="4、webpack的常用插件"><a href="#4、webpack的常用插件" class="headerlink" title="4、webpack的常用插件"></a>4、webpack的常用插件</h4><h5 id="1、添加版权的Plugin（BannerPlugin）"><a href="#1、添加版权的Plugin（BannerPlugin）" class="headerlink" title="1、添加版权的Plugin（BannerPlugin）"></a>1、添加版权的Plugin（BannerPlugin）</h5><p>BannerPlugin可以为打包的文件添加版权声明，属于webpack自带的插件</p>
<p>可以按照下面的方式来修改webpack.config.js的文件：</p>
<p><img src="VUE/89.png" alt="image-20210326140918356"></p>
<p>重新打包程序：查看bundle.js文件的头部，看到如下信息:</p>
<p><img src="VUE/90.png" alt="image-20210326141001962"></p>
<h5 id="2、打包html的plugin（HtmlWebpackPlugin）"><a href="#2、打包html的plugin（HtmlWebpackPlugin）" class="headerlink" title="2、打包html的plugin（HtmlWebpackPlugin）"></a>2、打包html的plugin（HtmlWebpackPlugin）</h5><p>目前，我们的index.html文件是存放在项目的根目录下的。我们知道，在真实发布项目时，发布的是dist文件夹中的内容，但是dist文件夹中如果没有index.html文件，那么打包的js等文件也就没有意义了。所以，我们需要将index.html文件打包到dist文件夹中，这个时候就可以使用HtmlWebpackPlugin插件。</p>
<p>HtmlWebpackPlugin插件可以为我们做这些事情：</p>
<ul>
<li>自动生成一个index.html文件(可以指定模板来生成)</li>
<li>将打包的js文件，自动通过script标签插入到body中</li>
</ul>
<p>安装HtmlWebpackPlugin插件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install html-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure>

<p>使用插件，修改webpack.config.js文件中plugins部分的内容如下：</p>
<ul>
<li>这里的template表示根据什么模板来生成index.html</li>
<li>另外，我们需要删除之前在output中添加的publicPath属性</li>
<li>否则插入的script标签中的src可能会有问题</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">      <span class="keyword">new</span> webpack.BannerPlugin(<span class="string">&#x27;最终版权归aaa所有&#x27;</span>),</span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        template: <span class="string">&#x27;index.html&#x27;</span></span><br><span class="line">      &#125;),</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<h5 id="3、js压缩的Plugin（uglifyjs-webpack-plugin）"><a href="#3、js压缩的Plugin（uglifyjs-webpack-plugin）" class="headerlink" title="3、js压缩的Plugin（uglifyjs-webpack-plugin）"></a>3、js压缩的Plugin（uglifyjs-webpack-plugin）</h5><p>在项目发布之前，我们必然需要对js等文件进行压缩处理，这里，我们就对打包的js文件进行压缩。我们使用一个第三方的插件uglifyjs-webpack-plugin，并且版本号指定1.1.1，和CLI2保持一致。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install uglifyjs-webpack-plugin@1.1.1 --save-dev</span><br></pre></td></tr></table></figure>

<p>修改webpack.config.js文件，使用插件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UglifyjsWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;uglifyjs-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">      <span class="keyword">new</span> webpack.BannerPlugin(<span class="string">&#x27;最终版权归aaa所有&#x27;</span>),</span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        template: <span class="string">&#x27;index.html&#x27;</span></span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="keyword">new</span> UglifyjsWebpackPlugin()</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<p>注意：<code>uglifyjs-webpack-plugin丑化插件</code>会将js代码进行压缩处理，删除多余的注释、空行与空格，并将出现的变量使用简单的字母进行替换。也就是说，也会删除我们之前由<code>添加版权的插件BannerPlugin</code>生成的注释版权信息。</p>
<p>解决方法：由于在配置文件中，plugins为一个数组，只要将<code>uglifyjs-webpack-plugin丑化插件</code>放在<code>添加版权的插件BannerPlugin</code>前面，让<code>uglifyjs-webpack-plugin丑化插件</code>先执行，在执行<code>添加版权的插件BannerPlugin</code>。就可以实现在丑化的js文件中添加版本信息。</p>
<h5 id="4、搭建本地服务器"><a href="#4、搭建本地服务器" class="headerlink" title="4、搭建本地服务器"></a>4、搭建本地服务器</h5><p>我们在开发的时候，如果要一次次经过重建项目的方式去查看代码效果，这将给我们的开发带来很大麻烦，开发效率也很低。webpack提供了一个可选的本地开发服务器，这个本地服务器基于node.js搭建，内部使用express框架，每次点击保存的时候就可以实现我们想要的让浏览器自动刷新显示我们修改后的结果。等我们将代码修改完成后在将代码进行构建。</p>
<p>express框架的在Vue本地服务器的粗略理解：</p>
<p>express服务于某个文件夹，实时的监听该文件夹里面的代码有没有发生改动，一旦发生改变，它就会对这些改变的代码重新进行编译。重新编译的话一开始并不会生成最终的文件，而是会将其生成一些新的我们要编译的东西，但并没有将其存入磁盘里面，而是存进内存之中，方便开发人员进行测试。当真正进行发布的时候在存储进磁盘里面。</p>
<p>一句话总结：由于系统访问内存的速度要远远快于访问磁盘的速度。而express就相当于一个中间件，我们开发过程的编译生成的代码先通过express存储进内存，方便测试。发布的时候再有express将其存储进磁盘。</p>
<p>本地开发服务器它是一个单独的模块，在webpack中使用之前需要先安装它</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev webpack-dev-server@2.9.3</span><br></pre></td></tr></table></figure>

<p>devserver也是作为webpack中的一个选项，选项本身可以设置如下属性：</p>
<ul>
<li>contentBase：为哪一个文件夹提供本地服务，默认是根文件夹，我们这里要填写./dist</li>
<li>inline：页面实时刷新</li>
<li>port：端口号（默认8080）</li>
<li>historyApiFallback：在SPA页面中，依赖HTML5的history模式</li>
</ul>
<p>webpack.config.js文件配置修改如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  contentBase: <span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">  inline: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以再package.json配置另外一个scripts：–open参数表示直接打开浏览器</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;webpack&quot;,</span><br><span class="line">    &quot;dev&quot;: &quot;webpack-dev-server --open&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<h4 id="5、开发与发布配置文件的分离"><a href="#5、开发与发布配置文件的分离" class="headerlink" title="5、开发与发布配置文件的分离"></a>5、开发与发布配置文件的分离</h4><p>在webpack.config.js配置文件中，我们进行了很多的配置，有些配置是在开发时才需要使用（如：本地服务器的配置），而生产环境下需要将其移除；有些配置是在发布的时候才需要使用（如：js丑化插件），而开发环境不需要使用（js丑化后不利于开发人员调试）。而我们在生产到发布的进行转换时，每次都需要删除开发时注释，在去添加生产时注释。如果项目代码量大的话，这也是一种灾难。</p>
<p>解决方法：</p>
<p>对webpack.config.js配置文件中的配置进行分离，将其中<code>公共的配置（base.config.js）</code>抽离出来，再将剩余配置分成<code>开发时配置（dev.config.js）</code>与<code>生产时配置（prod.config.js）</code>。我们在开发的时候就使用base.config.js + dev.config.js，发布的时候就使用base.config.js + prod.config.js。</p>
<p>实现步骤：</p>
<ol>
<li><p>在项目根目录新建文件夹build，在build文件夹里新建base.config.js、dev.config.js、prod.config.js三个js配置文件。</p>
<ul>
<li><p>base.config.js：一些公共的配置，开发时和生产时都需要使用到的配置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> UglifyjsWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;uglifyjs-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">      app: <span class="string">&#x27;./src/main.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    filename: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">    <span class="comment">// publicPath: &#x27;dist/&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// css-loader只负责将css文件进行加载</span></span><br><span class="line">        <span class="comment">// style-loader负责将样式添加到DOM中</span></span><br><span class="line">        <span class="comment">// 使用多个loader时, 是从右向左</span></span><br><span class="line">        use: [ <span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span> ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [&#123;</span><br><span class="line">          loader: <span class="string">&quot;style-loader&quot;</span>, <span class="comment">// creates style nodes from JS strings</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">          loader: <span class="string">&quot;css-loader&quot;</span> <span class="comment">// translates CSS into CommonJS</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">          loader: <span class="string">&quot;less-loader&quot;</span>, <span class="comment">// compiles Less to CSS</span></span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif|jpeg)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              <span class="comment">// 当加载的图片, 小于limit时, 会将图片编译成base64字符串形式.</span></span><br><span class="line">              <span class="comment">// 当加载的图片, 大于limit时, 需要使用file-loader模块进行加载.</span></span><br><span class="line">              limit: <span class="number">13000</span>,</span><br><span class="line">              name: <span class="string">&#x27;img/[name].[hash:8].[ext]&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="comment">// exclude: 排除</span></span><br><span class="line">        <span class="comment">// include: 包含</span></span><br><span class="line">        exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            presets: [<span class="string">&#x27;es2015&#x27;</span>]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;vue-loader&#x27;</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    <span class="comment">// alias: 别名</span></span><br><span class="line">    extensions: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.css&#x27;</span>, <span class="string">&#x27;.vue&#x27;</span>],</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">&#x27;vue$&#x27;</span>: <span class="string">&#x27;vue/dist/vue.esm.js&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.BannerPlugin(<span class="string">&#x27;最终版权归aaa所有&#x27;</span>),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">&#x27;index.html&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>dev.config.js：开发时需要的配置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">    inline: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>prod.config.js：生产时需要的配置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UglifyjsWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;uglifyjs-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">    <span class="keyword">new</span> UglifyjsWebpackPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>对当前配置文件进行合并，安装合并插件webpack-merge，来帮助我们对配置文件进行合并：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-merge@4.1.5 --save-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>在dev.config.js与prod.config.js配置文件里对webpack-merge插件进行导入使用</p>
<p>dev.config.js：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpackMerge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">&#x27;./base.config&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackMerge(baseConfig, &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">    inline: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>prod.config.js：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UglifyjsWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;uglifyjs-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> webpackMerge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">&#x27;./base.config&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackMerge(baseConfig, &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> UglifyjsWebpackPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改package.json文件里的脚本（scripts）：指定运行时的配置文件。否则打包时会报找不到webpack.config.js配置文件的错误</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;webpack --config ./build/prod.config.js&quot;,</span><br><span class="line">    &quot;dev&quot;: &quot;webpack-dev-server --open --config ./build/dev.config.js&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>但是存在问题：项目打包并没有打包在dist文件夹中，而是打包在了build下新建的一个dist文件夹里</p>
<p>原因：在base.config.js配置文件里，我们配置的绝对路径是当前文件的dist文件夹：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br></pre></td></tr></table></figure>

<p>而base.config.js配置文件是在build文件夹里，所以他会在build文件夹中新建dist文件夹存放打包的东西。所以主要是修改绝对路径的值就行了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path: path.resolve(__dirname, <span class="string">&#x27;../dist&#x27;</span>),</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="六、Vue-cli脚手架"><a href="#六、Vue-cli脚手架" class="headerlink" title="六、Vue-cli脚手架"></a>六、Vue-cli脚手架</h2><h3 id="1、什么是脚手架"><a href="#1、什么是脚手架" class="headerlink" title="1、什么是脚手架"></a>1、什么是脚手架</h3><p>如果你在开发大型项目, 那么你需要, 并且必然需要使用Vue CLI。</p>
<ul>
<li>使用Vue.js开发大型应用时，我们需要考虑代码目录结构、项目结构和部署、热加载、代码单元测试等事情</li>
<li>如果每个项目都要手动完成这些工作，那无疑效率比较低效，所以通常我们会使用一些脚手架工具来帮助完成这些事情</li>
</ul>
<p>CLI是什么意思？</p>
<ul>
<li>CLI是Command-Line Interface, 翻译为命令行界面, 但是俗称脚手架</li>
<li>Vue CLI是一个官方发布 vue.js 项目脚手架</li>
<li>使用 vue-cli 可以快速搭建Vue开发环境以及对应的webpack配置</li>
</ul>
<h3 id="2、使用Vue-cli的前提"><a href="#2、使用Vue-cli的前提" class="headerlink" title="2、使用Vue-cli的前提"></a>2、使用Vue-cli的前提</h3><ol>
<li><p>Nodejs</p>
<p><a target="_blank" rel="noopener" href="http://nodejs.cn/download/">安装NodeJS</a></p>
<p><strong>检测安装的版本</strong>：</p>
<ul>
<li><p>默认情况下自动安装Node和NPM</p>
</li>
<li><p>Vue CLI 4.x 需要 <a target="_blank" rel="noopener" href="https://nodejs.org/">Node.js</a><a target="_blank" rel="noopener" href="https://nodejs.org/"> </a> v8.9 或更高版本 (推荐 v10 以上)。（官方推荐）</p>
</li>
</ul>
<p>什么是NPM：</p>
<ul>
<li>NPM的全称是Node Package Manager</li>
<li>是一个NodeJS包管理和分发工具，已经成为了非官方的发布Node模块（包）的标准。</li>
<li>后续我们会经常使用NPM来安装一些开发过程中依赖包.</li>
</ul>
</li>
<li><p>webpack</p>
<p>Vue.js官方脚手架工具就使用了webpack模板</p>
<ul>
<li>对所有的资源会压缩等优化操作</li>
<li>它在开发过程中提供了一套完整的功能，能够使得我们开发过程中变得高效。</li>
</ul>
</li>
</ol>
<h3 id="3、安装Vue-cli"><a href="#3、安装Vue-cli" class="headerlink" title="3、安装Vue-cli"></a>3、安装Vue-cli</h3><p>安装Vue脚手架：默认下载最新版本（Vue-cli4）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install @vue/cli -g</span><br><span class="line"><span class="meta">#</span><span class="bash"> OR</span></span><br><span class="line">yarn global add @vue/cli</span><br></pre></td></tr></table></figure>

<p>若想要安装Vue-cli3版本的，只需要在@vue/cli后面加上@版本号就行了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @vue/cli@3.0.4 -g</span><br></pre></td></tr></table></figure>

<p>其实，Vue-cli3与Vue-cli4之间只有一些微小的差别，具体查看：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://cli.vuejs.org/migrating-from-v3/#vue-cli-plugin-unit-jest">官网</a></li>
<li><a target="_blank" rel="noopener" href="http://t.zoukankan.com/Super-scarlett-p-12495902.html">相关blog</a></li>
</ul>
<p>关于旧版本（Vue-cli1.x或2.x）</p>
<blockquote>
<p>Vue CLI 的包名称由 <code>vue-cli</code> 改成了 <code>@vue/cli</code>。 如果你已经全局安装了旧版本的 <code>vue-cli</code> (1.x 或 2.x)，你需要先通过 <code>npm uninstall vue-cli -g</code> 或 <code>yarn global remove vue-cli</code> 卸载它。</p>
</blockquote>
<p>安装之后，你就可以用这个命令来验证它是否安装成功以及检查其版本是否正确：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue --version</span><br></pre></td></tr></table></figure>

<p><img src="VUE/91.png" alt="image-20210326200446984"></p>
<p>注意：上面安装的是Vue CLI4的版本，如果需要想按照Vue CLI2的方式初始化项目时不可以的。如果你在Vue-cli3.x/4.x环境下仍然需要使用旧版本Vue-cli2.x的模板，你可以全局安装一个桥接工具：（之后就可以按照Vue CLI2的方式初始化项目）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli-init</span><br><span class="line"><span class="meta">#</span><span class="bash"> `vue init` 的运行效果将会跟 `vue-cli@2.x` 相同</span></span><br><span class="line">vue init webpack my-project</span><br></pre></td></tr></table></figure>

<p><img src="VUE/92.png" alt="image-20210326200544804"></p>
<p>Vue CLI2.x与Vue CLI3.x/4.x怎么初始化项目：</p>
<ul>
<li><p>Vue CLI2初始化项目</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init webpack my-project</span><br></pre></td></tr></table></figure>
</li>
<li><p>Vue CLI3初始化项目</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create my-project</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4、Vue-CLI2项目详解"><a href="#4、Vue-CLI2项目详解" class="headerlink" title="4、Vue CLI2项目详解"></a>4、Vue CLI2项目详解</h3><h4 id="1、Vue-CLI2项目的创建"><a href="#1、Vue-CLI2项目的创建" class="headerlink" title="1、Vue CLI2项目的创建"></a>1、Vue CLI2项目的创建</h4><p>在终端输入<code>vue init webpack 项目名称</code>来初始化Vue CLI2项目：</p>
<ol>
<li><p>Project name：项目名称。括号里面是默认值，即直接回车就默认使用括号里面的内容，但不能包含大写字母。我们使用<code>vue init webpack 项目名称</code>命令使用的<code>项目名称</code>并不是项目的真正名称，而是会根据<code>项目名称</code>创建一个文件夹。项目的名称可以在这里进行命名。（默认就是<code>项目名称</code>）</p>
</li>
<li><p>Project description：项目描述。（默认：A Vue.js project）</p>
</li>
<li><p>Author：作者。（会默认从.gitconfig(C:\Users\Admin.gitconfig)在读取信息）</p>
</li>
<li><p>Vue build：Vue项目构建的方式：</p>
<ul>
<li><p>Runtime + Compiler：推荐大多数用户使用（暂时使用，以后会用Runtime-only的）</p>
</li>
<li><p>Runtime-only：常用</p>
<p>原因：</p>
<ul>
<li>Runtime-only打包后的程序比Runtime + Compiler小</li>
<li>Runtime-only的运行效率更高</li>
</ul>
<p><img src="VUE/94.png" alt="image-20210326202702064"></p>
</li>
</ul>
</li>
<li><p>Install vue-router：是否安装vue路由</p>
</li>
<li><p>Use ESLint to lint your code：是否使用ESLint 检测代码规范</p>
<p>若选择了y，则它会让你选择一种代码规范：</p>
<ul>
<li>Standard：标准规范</li>
<li>Airbnb：爱彼迎。（民宿）</li>
<li>none：不选择，自己配置</li>
</ul>
<p>就算开启，之后也可以在config/index.js中将<code>useEslint</code>的值从true改成false进行关闭。</p>
<p><img src="VUE/95.png" alt="image-20210326203148480"></p>
</li>
<li><p>Set up uint tests：单元测试</p>
</li>
<li><p>Set e2e(end to end 端到端测试) tests with NightWatch</p>
</li>
<li><p>Should we run <code>npm install</code> for you after the project has been create? </p>
</li>
</ol>
<p><img src="VUE/93.png" alt="image-20210326201123763"></p>
<h4 id="2、Vue-cli2项目的目录结构详解"><a href="#2、Vue-cli2项目的目录结构详解" class="headerlink" title="2、Vue-cli2项目的目录结构详解"></a>2、Vue-cli2项目的目录结构详解</h4><p>项目创建完成之后，vue-cli2会帮我们生成一些文件：</p>
<p>我们怎么看一个项目：</p>
<ol>
<li><p>先看package.json，里面有运行的一些脚本scripts</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;start&quot;</span>: <span class="string">&quot;npm run dev&quot;</span>,</span><br><span class="line">    <span class="string">&quot;lint&quot;</span>: <span class="string">&quot;eslint --ext .js,.vue src&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build&quot;</span>: <span class="string">&quot;node build/build.js&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>npm run dev</strong>：本地服务器。执行的指令为<code>webpack-dev-server --inline --progress --config build/webpack.dev.conf.js</code></p>
</li>
<li><p><strong>npm run start</strong>：所有项目的默认开始命令。实际上执行的是<code>npm run dev</code>。（如上）</p>
</li>
<li><p><strong>npm run lint</strong>：执行一些约束</p>
</li>
<li><p><strong>npm run build</strong>：打包项目。实际执行的是<code>node build/build.js</code>命令。</p>
<p>关于node指令：</p>
<p>node为js提供了运行环境，可以直接执行js文件，不需要借助html文件去访问浏览器。</p>
<p>nodejs本身是用C++开发的，里面的核心为：<code>V8引擎</code>（Google开发的，用C++写的）。</p>
<ul>
<li>一般js代码的执行过程是：js -&gt;字节码（class）-&gt;浏览器。（慢）</li>
<li>V8引擎（可以直接跳过字节码，直接把js编译成二进制代码）：js-&gt;二进制代码-&gt;浏览器（快）</li>
</ul>
<p>node的V8引擎为js代码的执行做了一个底层支撑。</p>
</li>
</ul>
</li>
<li><p><strong>构建项目</strong>：由于执行打包命令<strong>npm run build</strong>，执行的是<code>node build/build.js</code>命令。所以再去看build/build.js</p>
<ol>
<li>rm：通过执行rm命令删除之前打包生成的dist文件夹</li>
<li>webpack：通过webpackConfig执行相关配置</li>
<li>webpackConfig：const webpackConfig = require(‘./webpack.prod.conf’)</li>
</ol>
</li>
<li><p>查看build/webpack.prod.conf</p>
<p>merge(baseWebpackConfig,{})</p>
</li>
<li><p>再查看baseWebpackConfig</p>
<p>里面抽取了很多东西（有很多之前讲过的插件）</p>
<p><img src="VUE/99.png" alt="image-20210327013437402"></p>
</li>
<li><p><strong>开发项目</strong>：由于执行本地服务器命令<strong>npm run dev</strong>,执行的指令为<code>webpack-dev-server --inline --progress --config build/webpack.dev.conf.js</code></p>
</li>
<li><p>查看build/webpack.dev.conf.js</p>
<p>merge(baseWebpackConfig,{})</p>
</li>
<li><p>build文件夹中的其他配置都是为前面的配置服务的</p>
</li>
<li><p>在看看config中的配置：</p>
<p>index.js中主要是配置了两个模块：dev、build</p>
<ul>
<li><p>dev配置都是定义了一些变量：</p>
<ul>
<li><p>host: ‘localhost’</p>
</li>
<li><p>port: 8080</p>
</li>
<li><p>autoOpenBrowser: false</p>
<p>……</p>
</li>
</ul>
</li>
<li><p>build配置的是一些index.html的模板路径，资源等等</p>
</li>
</ul>
<p><img src="VUE/98.png" alt="image-20210327013206531"></p>
</li>
<li><p>**<code>node_modules</code>**：放置项目依赖的包</p>
</li>
<li><p>**<code>src</code>**：进行开发的地方</p>
</li>
<li><p>**<code>static</code>**：存放静态资源的地方。到时候打包的时候，Vue-cli会将static文件里的内容原封不动的复制到dist文件夹中。若你把一些图片资源放到src/assets中，Vue-cli会根据你图片的大小与url-loader中<code>limit</code>里的数值进行比对，并将图片重新命名后放入dist。</p>
<p>其中有一个文件：.gitkeep：如果不管该文件夹是否为空，Vue-cli打包的时候都会将其打包上传到服务器。</p>
</li>
<li><p>**<code>.babelrc</code>**：ES代码相关转化配置</p>
<p>其中”browsers”: [“&gt; 1%”, “last 2 versions”, “not ie &lt;= 8”]：</p>
<ul>
<li>“&gt; 1%”：市场份额大于1%</li>
<li>“last 2 versions”：最后的两个版本</li>
<li>“not ie &lt;= 8”：不支持低于IE8版本</li>
</ul>
</li>
<li><p>**<code>.editorconfig</code>**：代码规范</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root &#x3D; true</span><br><span class="line"></span><br><span class="line">[*]</span><br><span class="line">charset &#x3D; utf-8</span><br><span class="line">indent_style &#x3D; space</span><br><span class="line">indent_size &#x3D; 2</span><br><span class="line">end_of_line &#x3D; lf</span><br><span class="line">insert_final_newline &#x3D; true</span><br><span class="line">trim_trailing_whitespace &#x3D; true</span><br></pre></td></tr></table></figure>

<p>root = true：根据root进行查找文件。Vue-cli在查找.editorconfig文件的时候，只有在root = true的时候才会开始解析。</p>
<p>end_of_line = lf：换行。值<code>lf</code>不同操作系统可能不同，具体网上查看即可</p>
<p>insert_final_newline = true：文件结尾是否空出一行</p>
<p>trim_trailing_whitespace = true：清除掉多余无效的空格</p>
</li>
<li><p>**<code>.eslintignore</code>**：忽略eslint规范的文件夹配置。</p>
</li>
<li><p>**<code>.gitignore</code>**：Git查看忽略的文件夹配置</p>
</li>
<li><p>**<code>.eslintrc.js</code>**：eslint代码检测的配置的js文件</p>
</li>
<li><p>**<code>.postcssrc.js</code>**：在进行css转化的时候配置的js文件</p>
</li>
<li><p>**<code>index.html</code>**：dist文件夹中index.html的模板</p>
</li>
<li><p>package.json与package-lock.json：</p>
<p>在package.json中的插件与依赖存在许多版本，但大部分都不是安装对应版本的依赖（一般会大于设定值），安装的依赖由两个符号决定：</p>
<ul>
<li><code>^</code>开头：改变的是最后一个数值。如<code>^4.15.0</code>，他就只会安装4.15.0到4.15.9之间的依赖</li>
<li><code>~</code>开头：改变的可以是最后两个值。如<code>~4.15.0</code>，它就会安装在4版本内大于4.15.0版本的其它版本，如4.20.7版本。但绝对不会安装到5.xx.x的版本。</li>
</ul>
<p>而package-lock.json就是对应package.json中设定的版本号与实际安装的版本之间的映射关系的js配置文件。</p>
<p>一句话：package.json为依赖安装的大概版本，package-lock.json为依赖安装的实际版本。</p>
</li>
<li><p>README.md：书写项目相关文档</p>
</li>
</ol>
<p><img src="VUE/96.png" alt="image-20210326203911636"></p>
<h3 id="5、Runtime-Compiler和Runtime-only的区别"><a href="#5、Runtime-Compiler和Runtime-only的区别" class="headerlink" title="5、Runtime-Compiler和Runtime-only的区别"></a>5、Runtime-Compiler和Runtime-only的区别</h3><h4 id="1、代码区别"><a href="#1、代码区别" class="headerlink" title="1、代码区别"></a>1、代码区别</h4><p>他们的区别只在一个文件里面：main.js</p>
<ul>
<li><p>Runtime-Compiler的main.js：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">	el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">	template: <span class="string">&#x27;&lt;App/&gt;&#x27;</span>,</span><br><span class="line">	components: &#123; App &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>app的使用步骤：</p>
<ol>
<li>先导入</li>
<li>然后在components里进行注册</li>
<li>最后在template里使用</li>
</ol>
</li>
<li><p>Runtime-only的main.js：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(App);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="comment">// render: h =&gt; h(App)</span></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">h</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h(App)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>app的使用步骤：</p>
<ol>
<li>先导入</li>
<li>使用render进行渲染</li>
</ol>
<p>注意：Runtime-only并不是完全没有template标签，在App.vue里面存在template标签。但是不妨碍代码的执行。因为App.vue里面的template标签在使用之前已经进行渲染了。</p>
</li>
</ul>
<p>  Vue.config.productionTip = false：发布产品的时候（npm run build）会给你一些提示信息；但我在开发的时候（npm run dev）不需要这些提示信息。所以默认为false。但项目真正需要构建build的时候可以改为true。</p>
<h4 id="2、Vue程序的运行过程中的区别"><a href="#2、Vue程序的运行过程中的区别" class="headerlink" title="2、Vue程序的运行过程中的区别"></a>2、Vue程序的运行过程中的区别</h4><p>Vue程序的运行过程：</p>
<p><img src="VUE/97.png" alt="image-20210327001054379"></p>
<ul>
<li><p>对于Runtime-Compiler：template -(解析)-&gt; ast-(编译) -&gt; render -&gt; vdom(虚拟DOM) -&gt; 真实DOM（UI）</p>
</li>
<li><p>对于Runtime-only：render -&gt; vdom(虚拟DOM) -&gt; 真实DOM（UI）</p>
<p>所以，对于Runtime-only有Runtime-Compiler不具备的优势：</p>
<ol>
<li>性能更高 </li>
<li>代码量更少（没有Compiler编译template标签的那部分代码）（6KB左右）</li>
</ol>
</li>
</ul>
<h4 id="3、Runtime-only的实现"><a href="#3、Runtime-only的实现" class="headerlink" title="3、Runtime-only的实现"></a>3、Runtime-only的实现</h4><h5 id="1、对于Runtime-only的render的解析："><a href="#1、对于Runtime-only的render的解析：" class="headerlink" title="1、对于Runtime-only的render的解析："></a>1、对于Runtime-only的render的解析：</h5><p>内部有一个函数<code>h</code>，其实h就是createElement。其中的内容是用来替换app模板里的内容。</p>
<p>函数createElement的用法：</p>
<ol>
<li><p>普通用法: createElement(‘标签’, {标签的属性}, [ ‘内容’ ])：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">render: <span class="function"><span class="keyword">function</span>(<span class="params">createElement</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createElement(<span class="string">&#x27;h2&#x27;</span>,&#123;<span class="attr">class</span>: <span class="string">&#x27;box&#x27;</span>&#125;,[<span class="string">&#x27;Hello World&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行发现：<h2 class="box">Hello World<h2/>代替了<div id="app"></div></p>
</li>
<li><p>普通用法的扩展：既然内容部分是一个数组，那么就可以在里面继续嵌套标签：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> createElement(<span class="string">&#x27;h2&#x27;</span>,</span><br><span class="line">      &#123;<span class="attr">class</span>: <span class="string">&#x27;box&#x27;</span>&#125;,</span><br><span class="line">      [<span class="string">&#x27;Hello World&#x27;</span>, createElement(<span class="string">&#x27;button&#x27;</span>, [<span class="string">&#x27;按钮&#x27;</span>])])</span><br></pre></td></tr></table></figure>

<p>运行发现：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">	&quot;Hello World&quot;</span><br><span class="line">	<span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>传入组件对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cpn = &#123;</span><br><span class="line">  template: <span class="string">&#x27;&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">&#x27;我是组件message&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> createElement(cpn)</span><br></pre></td></tr></table></figure>

<p>运行发现：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>我是组件message<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>有上可得我们可以将App组件传入createElement函数，得到的结果就是Runtime-only的main.js中的写法：只是将createElement换成h。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">render: function (h) &#123;</span><br><span class="line">    return h(App)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="2、对Runtime-only的App-vue中的template标签的解惑"><a href="#2、对Runtime-only的App-vue中的template标签的解惑" class="headerlink" title="2、对Runtime-only的App.vue中的template标签的解惑"></a>2、对Runtime-only的App.vue中的template标签的解惑</h5><p>Runtime-only的Vue程序的运行过程：render -&gt; vdom(虚拟DOM) -&gt; 真实DOM（UI）。并没有对标签template进行编译解析。那怎么解决Runtime-only的App.vue中的template标签呢？</p>
<p>解答：Runtime-only的App.vue中的template标签并不需要经历template -(解析)-&gt; ast-(编译) -&gt; render的过程，因为在App.vue中的template标签最终被编译出来的就是一个普通的对象，而在这个普通的对象里面，已经将template全部渲染成render函数了。即我们最终用到的App这个对象里面是没有template标签的。所以我们并不需要使用Runtime-Compiler对App进行编译解析了，因为App里面已经没有template标签了。只需要使用我们的Runtime-only进行打包就行了。</p>
<p>那么.vue文件中的template是由谁处理的了?</p>
<p>是由vue-template-compiler对它进行解析处理的</p>
<h3 id="6、Vue-cli3-4（以下以Vue-cli3为例，Vue-cli4差别不大）"><a href="#6、Vue-cli3-4（以下以Vue-cli3为例，Vue-cli4差别不大）" class="headerlink" title="6、Vue-cli3/4（以下以Vue-cli3为例，Vue-cli4差别不大）"></a>6、Vue-cli3/4（以下以Vue-cli3为例，Vue-cli4差别不大）</h3><h4 id="1、nvue-cli-3-与-2-版本有很大区别："><a href="#1、nvue-cli-3-与-2-版本有很大区别：" class="headerlink" title="1、nvue-cli 3 与 2 版本有很大区别："></a>1、nvue-cli 3 与 2 版本有很大区别：</h4><ul>
<li>vue-cli 3 是基于 webpack 4 打造，vue-cli 2 还是 webapck 3</li>
<li>vue-cli 3 的设计原则是“0配置”，移除了根目录下的的配置文件，build和config等目录</li>
<li>vue-cli 3 提供了 vue ui 命令，提供了可视化配置，更加人性化</li>
<li>移除了static文件夹，新增了public文件夹，并且index.html移动到public中</li>
</ul>
<h4 id="2、Vue-CLI3项目详解（Vue-CLI4在创建过程只是多了版本选择）"><a href="#2、Vue-CLI3项目详解（Vue-CLI4在创建过程只是多了版本选择）" class="headerlink" title="2、Vue CLI3项目详解（Vue CLI4在创建过程只是多了版本选择）"></a>2、Vue CLI3项目详解（Vue CLI4在创建过程只是多了版本选择）</h4><h5 id="1、Vue-CLI3项目的创建"><a href="#1、Vue-CLI3项目的创建" class="headerlink" title="1、Vue CLI3项目的创建"></a>1、Vue CLI3项目的创建</h5><p>在终端输入：<code>vue create my-project</code>进行Vue CLI3的项目创建。</p>
<p>创建步骤：</p>
<ol>
<li><p>Please pick a prset：选择配置方式</p>
<ol>
<li>default（bable，eslint）：默认配置</li>
<li>Manually select feature：手动选择特性</li>
<li>若你之前有保存过你的一些特性，可以在这里选择。</li>
</ol>
</li>
<li><p>Check the feature needed for your project：若上一步选择Manually select feature，则这一步会让你选择需要加入的特性。空格选中或反选，回车确定。一些特性说明：</p>
<ul>
<li>TypeScript：相当于ES的超级（有点像java）</li>
<li>Progressive Web App （PWA）Support：先进的web app。里面增加了很多功能：<ul>
<li>可以进行大量的缓存</li>
<li>拥有推送通知的功能</li>
</ul>
</li>
</ul>
</li>
<li><p>Where do you prefer placing config for Babel,PostCSS,ESLint,etc.?</p>
<p>选择对应的配置的生成位置，有两个选择：</p>
<ul>
<li>In dedicated config files：单独生成一个对应的配置文件</li>
<li>In package.json：生成在package.json文件中</li>
</ul>
</li>
<li><p>Save this as a preset for future projects?是否将刚才自己选择的配置保存下来。</p>
</li>
<li><p>Save preset as :若选择保存下来，则会让你设置保存的名称。这样在创建其他项目的时候，第1步就能选择你保存的配置。</p>
<p>如何删除自己保存的配置：</p>
<p>在.vuerc(C:\Users\Admin.vuerc)文件里进行删除</p>
</li>
<li><p>Pick the package manager to use when installing dependencies：在安装依赖的时候选择使用哪个包管理工具，两个选择：</p>
<ul>
<li>Use Yarn</li>
<li>Use NPM</li>
</ul>
</li>
</ol>
<p><img src="VUE/100.png" alt="image-20210327022546764"></p>
<p>Vue-cli3在创建项目时会在当前目录下创建.git文件。它会默认将代码放进git仓库进行管理。</p>
<h5 id="2、Vue-cli3项目的目录结构详解"><a href="#2、Vue-cli3项目的目录结构详解" class="headerlink" title="2、Vue-cli3项目的目录结构详解"></a>2、Vue-cli3项目的目录结构详解</h5><p>项目创建完成之后，vue-cli3会帮我们生成一些文件：</p>
<ul>
<li>**<code>node_modules</code>**：放置项目依赖的包</li>
<li>**<code>public</code>**：相当于之前的static。存放静态资源的地方。到时候打包的时候，Vue-cli会将public文件里的内容原封不动的复制到dist文件夹中。里面存放两个文件：<ul>
<li>favicon.ico：Vue的小图标</li>
<li>index.html</li>
</ul>
</li>
<li>**<code>src</code>**：进行开发的地方</li>
<li>**<code>.browserslistrc</code>**：浏览器相关的配置</li>
<li>**<code>.gitignore</code>**：Git查看忽略的文件夹配置</li>
<li>**<code>babel.config.js</code>**：babel的相关配置</li>
<li>package.json与package-lock.json</li>
<li>**<code>postcss.config.js</code>**：在进行css转化的时候配置的js文件，用来配置转化一些特殊的CSS文件</li>
<li>README.md：书写项目相关文档</li>
</ul>
<p><img src="VUE/101.png" alt="image-20210327025419742"></p>
<p>运行Vue-cli3：npm run serve</p>
<p>查看package.json中的scripts属性：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;serve&quot;: &quot;vue-cli-service serve&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;vue-cli-service build&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>main.js文件：</p>
<ul>
<li><p>Vue-cli3：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    render: <span class="function"><span class="params">h</span>=&gt;</span> h(App),</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>其实使用el: ‘#app’挂载app的时候，其底层还是使用了mount方法，只是多了个判断。所以这里是使用了mount方法代替el挂载App。</p>
</li>
<li><p>Vue-cli4：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line">createApp(App).mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="3、Vue-cli3配置文件的查看与修改"><a href="#3、Vue-cli3配置文件的查看与修改" class="headerlink" title="3、Vue-cli3配置文件的查看与修改"></a>3、Vue-cli3配置文件的查看与修改</h4><p>vue-cli 3 的设计原则是“0配置”，移除了根目录下的配置文件，build和config等目录。但是配置并不是说消失了，因为要用到webpack，配置是必须的。所以vue-cli 3只是将配置隐藏起来了。那么我们该怎么查看与修改隐藏的配置文件呢？有三种方法：</p>
<ul>
<li><p>通过命令<code>vue ui</code>打开vue-cli 3为我们提供的ui图形界面，端口默认为8000（查看与修改）</p>
<p><img src="VUE/111.png" alt="image-20210327150713404"></p>
<ul>
<li><p>仪表盘：</p>
<p><img src="VUE/104.png" alt="image-20210327144223290"></p>
</li>
<li><p>插件：</p>
<p><img src="VUE/105.png" alt="image-20210327144450855"></p>
</li>
<li><p>依赖</p>
<p><img src="VUE/106.png" alt="image-20210327144610556"></p>
</li>
<li><p>配置</p>
<p><img src="VUE/107.png" alt="image-20210327145616237"></p>
<p><img src="VUE/108.png" alt="image-20210327145738257"></p>
</li>
<li><p>任务：</p>
<p><img src="VUE/109.png" alt="image-20210327150018316"></p>
</li>
</ul>
</li>
<li><p>在项目文件的根目录下有node_modules@vue\cli-service\lib\Service.js（查看）</p>
<p><img src="VUE/112.png" alt="image-20210327151311282"></p>
<p><img src="VUE/110.png" alt="image-20210327150122955"></p>
</li>
<li><p>在项目的根目录下创建文件：<code>vue.config.js</code>（固定）进行自定义配置。如果我们对默认的配置不满意的话，可以在该文件下写我们的配置，最终项目打包时会将<code>vue.config.js</code>里编写的配置与项目隐藏的配置合并一起作为项目的总配置。（修改）</p>
<p><img src="VUE/113.png" alt="image-20210327151516954"></p>
</li>
</ul>
<h2 id="七、箭头函数"><a href="#七、箭头函数" class="headerlink" title="七、箭头函数"></a>七、箭头函数</h2><h3 id="1、箭头函数的基本使用"><a href="#1、箭头函数的基本使用" class="headerlink" title="1、箭头函数的基本使用"></a>1、箭头函数的基本使用</h3><p>箭头函数: 也是一种定义函数的方式</p>
<p>定义函数的方式：</p>
<ul>
<li><p>function：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> aaa = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象字面量中定义函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="function"><span class="title">bbb</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ES6中的箭头函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ccc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2、箭头函数的参数与返回值"><a href="#2、箭头函数的参数与返回值" class="headerlink" title="2、箭头函数的参数与返回值"></a>2、箭头函数的参数与返回值</h3><p>箭头函数最基础的写法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ccc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1、箭头函数的参数"><a href="#1、箭头函数的参数" class="headerlink" title="1、箭头函数的参数"></a>1、箭头函数的参数</h4><h5 id="1、没参数"><a href="#1、没参数" class="headerlink" title="1、没参数"></a>1、没参数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ccc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、有两个参数"><a href="#2、有两个参数" class="headerlink" title="2、有两个参数"></a>2、有两个参数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、只有一个参数（括号可删除）"><a href="#3、只有一个参数（括号可删除）" class="headerlink" title="3、只有一个参数（括号可删除）"></a>3、只有一个参数（括号可删除）</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> power = <span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num * num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、箭头函数的返回值"><a href="#2、箭头函数的返回值" class="headerlink" title="2、箭头函数的返回值"></a>2、箭头函数的返回值</h4><h5 id="1、函数代码块中有多行代码时"><a href="#1、函数代码块中有多行代码时" class="headerlink" title="1、函数代码块中有多行代码时"></a>1、函数代码块中有多行代码时</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> test = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 1.打印Hello World</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.打印Hello Vuejs</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello Vuejs&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、函数代码块中只有一行代码（大括号与return可以省略）"><a href="#2、函数代码块中只有一行代码（大括号与return可以省略）" class="headerlink" title="2、函数代码块中只有一行代码（大括号与return可以省略）"></a>2、函数代码块中只有一行代码（大括号与return可以省略）</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mul = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 * num2</span><br></pre></td></tr></table></figure>

<p>当函数没有返回值，返回undefined</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hello Demo</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">const</span> demo = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;Hello Demo&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3、什么时候使用箭头函数"><a href="#3、什么时候使用箭头函数" class="headerlink" title="3、什么时候使用箭头函数"></a>3、什么时候使用箭头函数</h3><p>箭头函数一般使用在<strong>作为函数参数</strong>传入一个函数时</p>
<h3 id="4、this的使用"><a href="#4、this的使用" class="headerlink" title="4、this的使用"></a>4、this的使用</h3><ul>
<li>以function函数的形式调用时，this永远都是window </li>
<li>以箭头函数的形式调用时，this就是调用方法的那个对象</li>
</ul>
<p>这是因为两者的执行方式不同：</p>
<ul>
<li>function函数是执行了call函数，在call函数中将window作为第一个参数传入，使用this就是window</li>
<li>箭头函数是向外层作用域中, 一层层查找this, 直到有this的定义。</li>
</ul>
<p>例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="function"><span class="title">aaa</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 通过function函数方式</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span> + <span class="built_in">this</span>); <span class="comment">// 1window</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span> + <span class="built_in">this</span>); <span class="comment">// 2window</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">	 <span class="comment">// 通过箭头函数方式</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span> + <span class="built_in">this</span>); <span class="comment">// 3window</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">      	<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&#x27;4&#x27;</span> + <span class="built_in">this</span>); <span class="comment">// 4obj</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<ul>
<li>1、3好理解，都是通过function函数，this都是window</li>
<li>2是找到上一层，发现是通过function函数方式，箭头函数指向外层的this，外层this是function的this 指向window</li>
<li>4也是找到上一层，上一层还是个箭头函数，就继续往上找，找到了aaa( )</li>
</ul>
<p>总结：function函数的this是由调用者决定，而箭头函数是直接看代码就能知道this是谁，嵌套的话，只要遇到一个function，就由function的this作为最终this。</p>
<h2 id="八、Vue-router路由"><a href="#八、Vue-router路由" class="headerlink" title="八、Vue-router路由"></a>八、Vue-router路由</h2><h3 id="1、认识路由"><a href="#1、认识路由" class="headerlink" title="1、认识路由"></a>1、认识路由</h3><p>路由是一个网络工程里面的术语</p>
<p><strong>路由</strong>（<strong>routing</strong>）就是通过互联的网络把信息从源地址传输到目的地址的活动.     — 维基百科</p>
<p>生活中的路由器是做什么的? 路由和转送</p>
<ul>
<li><p>路由是决定数据包从<strong>来源</strong>到<strong>目的地</strong>的路径</p>
</li>
<li><p>转送将<strong>输入端</strong>的数据转移到合适的<strong>输出端</strong></p>
</li>
<li><p>路由器的工作原理：</p>
<p><img src="VUE/115.png" alt="image-20210327171111712"></p>
</li>
</ul>
<p>路由中有一个非常重要的概念叫路由表。路由表本质上就是一个<strong>映射表</strong>, 决定了数据包的指向。</p>
<h3 id="2、网页开发的发展过程"><a href="#2、网页开发的发展过程" class="headerlink" title="2、网页开发的发展过程"></a>2、网页开发的发展过程</h3><h4 id="1、后端路由阶段"><a href="#1、后端路由阶段" class="headerlink" title="1、后端路由阶段"></a>1、<strong>后端路由阶段</strong></h4><p>早期的网站开发整个HTML页面是由服务器来渲染的。<strong>服务器直接生产渲染好对应的HTML页面</strong>, 返回给客户端进行展示。（jsp + servelet ）（jsp = java server page）</p>
<p>但是, 一个网站, 这么多页面服务器如何处理呢?</p>
<ul>
<li>一个页面有自己对应的网址, 也就是URL</li>
<li>URL会发送到服务器, 服务器会通过正则对该URL进行匹配, 并且最后交给一个Controller进行处理。</li>
<li>Controller进行各种处理, 最终生成HTML或者数据, 返回给前端。</li>
<li>这就完成了一个IO操作。</li>
</ul>
<p>上面的这种操作, 就是<strong>后端路由</strong>：</p>
<ul>
<li>当我们页面中需要请求不同的<strong>路径</strong>内容时, 交给服务器来进行处理, 服务器渲染好整个页面, 并且将页面返回给客户顿。</li>
<li>这种情况下渲染好的页面, 不需要单独加载任何的js和css, 可以直接交给浏览器展示, 这样也有利SEO的优化。</li>
</ul>
<p>后端路由的缺点:</p>
<ul>
<li>一种情况是整个页面的模块由后端人员来编写和维护的。</li>
<li>另一种情况是前端开发人员如果要开发页面, 需要通过PHP和Java等语言来编写页面代码。</li>
<li>而且通常情况下HTML代码和数据以及对应的逻辑会混在一起, 编写和维护都是非常糟糕的事情。</li>
</ul>
<p><img src="VUE/116.png" alt="01-后端路由阶段"></p>
<h4 id="2、前后端分离阶段"><a href="#2、前后端分离阶段" class="headerlink" title="2、前后端分离阶段"></a>2、前后端分离阶段</h4><p>随着Ajax的出现, 有了前后端分离的开发模式：</p>
<ul>
<li>后端只提供API接口来返回数据, 前端通过Ajax获取数据, 并且可以通过JavaScript将数据渲染到页面中。</li>
<li>这样做最大的优点就是前后端责任的清晰, 后端专注于数据上, 前端专注于交互和可视化上。</li>
<li>并且当移动端(iOS/Android)出现后, 后端不需要进行任何处理, 依然使用之前的一套API即可。</li>
<li>目前很多的网站依然采用这种模式开发。</li>
</ul>
<p><img src="VUE/117.png" alt="02-前端后端分离阶段"></p>
<h4 id="3、单页面复应用（SPA）阶段"><a href="#3、单页面复应用（SPA）阶段" class="headerlink" title="3、单页面复应用（SPA）阶段"></a>3、<strong>单页面复应用（SPA）阶段</strong></h4><p>其实SPA最主要的特点就是在前后端分离的基础上加了一层前端路由，也就是前端来维护一套路由规则</p>
<p>上面的这种操作, 就是<strong>前端路由</strong>，前端路由的核心是什么呢？</p>
<ul>
<li>改变URL，但是页面不进行整体的刷新，即不用向服务器请求任何资源。</li>
</ul>
<p><img src="VUE/118.png" alt="03-SPA页面页面的阶段"></p>
<p>前端路由中url和组件的关系：</p>
<p><img src="VUE/119.png" alt="04-前端路由中url和组件的关系"></p>
<p><strong>总结</strong>：（前端路由与后端路由、前端渲染与后端渲染）</p>
<ul>
<li><strong>前端路由与后端路由的区别：看是谁在管理url与页面组件的映射关系</strong>。由前端管理就是前端路由，由后台管理就是后端路由。</li>
<li><strong>前端渲染与后端渲染的区别：看是谁在进行页面的开发渲染。</strong>即上面第一阶段后端路由阶段就是由后台开发渲染页面，称为后端渲染。而第二第三阶段都是由前端开发渲染页面，称为前端渲染。</li>
</ul>
<h3 id="3、前端路由的规则"><a href="#3、前端路由的规则" class="headerlink" title="3、前端路由的规则"></a>3、前端路由的规则</h3><p>怎么实现改变URL，但是页面不进行整体的刷新</p>
<p>有两种方法：URL的hash 与 HTML5的history模式</p>
<ul>
<li><p>URL的hash</p>
<p>URL的hash也就是锚点(#), 本质上是改变window.location的href属性。</p>
<p>我们可以通过直接赋值location.hash来改变href, 但是页面不发生刷新</p>
<p><img src="VUE/120.png" alt="image-20210327194500087"></p>
</li>
<li><p>HTML5的history模式。history接口是HTML5新增的, 它有五种模式改变URL而不刷新页面：</p>
<p><strong>pushState</strong>、<strong>back/forward</strong>、<strong>replaceState</strong>、<strong>go</strong></p>
<ul>
<li><p><strong>pushState</strong>：类似于栈结构，可以实现页面的前进与后退。（实际上每使用一次pushState,都会生成一个新页面代替掉当前页面，浏览器会缓存当前页面的前后页面，可以实现前进与后退）</p>
<ul>
<li>参数1：data数据</li>
<li>参数2：title标题</li>
<li>参数3：url路径</li>
</ul>
<p><img src="VUE/121.png" alt="image-20210327195727256"></p>
</li>
<li><p><strong>back()/forward()**：back()往后，forward()向前（在</strong>pushState**可以使用这两个方法）</p>
<p><img src="VUE/122.png" alt="image-20210327200723241"></p>
<p><img src="VUE/125.png" alt="image-20210327202012268"></p>
</li>
<li><p><strong>replaceState</strong>：修改当前页面。（单一页面，并不存在前进后退。即back()/forward()方法不能使用）</p>
<ul>
<li>参数1：data数据</li>
<li>参数2：title标题</li>
<li>参数3：url路径</li>
</ul>
<p><img src="VUE/123.png" alt="image-20210327201422199"></p>
</li>
<li><p><strong>go</strong>：可以在当前页面指定跳转到前或后页面。参数为跳转的页面数。<code>-</code>表示后退，否则为前进，数值的大小为跳转的页面数。</p>
<p>不适用于replaceState。</p>
<ul>
<li>history.back() 等价于 history.go(-1)</li>
<li>history.forward() 则等价于 history.go(1)</li>
<li>这三个接口等同于浏览器界面的前进后退。</li>
</ul>
<p><img src="VUE/124.png" alt="image-20210327201802927"></p>
</li>
</ul>
</li>
</ul>
<h3 id="4、vue-router"><a href="#4、vue-router" class="headerlink" title="4、vue-router"></a>4、vue-router</h3><h4 id="1、认识vue-router"><a href="#1、认识vue-router" class="headerlink" title="1、认识vue-router"></a>1、认识vue-router</h4><p>目前前端流行的三大框架, 都有自己的路由实现:</p>
<ul>
<li>Angular的ngRouter</li>
<li>React的ReactRouter</li>
<li>Vue的vue-router</li>
</ul>
<p>vue-router：</p>
<ul>
<li>vue-router是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。</li>
<li><a target="_blank" rel="noopener" href="https://router.vuejs.org/zh/">vue-router官网</a></li>
</ul>
<p>vue-router是基于路由和组件的</p>
<ul>
<li>路由用于设定访问路径, 将路径和组件映射起来.</li>
<li>在vue-router的单页面应用中, 页面的路径的改变就是组件的切换.</li>
</ul>
<h4 id="2、安装与使用vue-router"><a href="#2、安装与使用vue-router" class="headerlink" title="2、安装与使用vue-router"></a>2、安装与使用vue-router</h4><p>因为我们已经学习了webpack, 后续开发中我们主要是通过<strong>工程化的方式</strong>进行开发的。所以在后续, 我们直接使用npm来安装路由即可。</p>
<p>步骤一: 安装vue-router</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router --save</span><br></pre></td></tr></table></figure>

<p>步骤二: 在模块化工程中使用它(因为是一个插件, 所以可以通过Vue.use()来安装路由功能)</p>
<ul>
<li>第一步：导入路由对象，并且调用 Vue.use(VueRouter)</li>
<li>第二步：创建路由实例，并且传入路由映射配置</li>
<li>第三步：在Vue实例中挂载创建的路由实例</li>
</ul>
<p>使用vue-router的步骤:</p>
<ol>
<li><p>第一步: 创建路由对象VueRouter</p>
<ol>
<li>配置路由相关的信息</li>
<li>通过Vue.use(插件), 安装插件</li>
<li>创建VueRouter对象，配置路由和组件之间的应用关系</li>
<li>将router对象传入到Vue实例</li>
<li>到main.js中的Vue实例中挂载router对象</li>
</ol>
<p><img src="D:\blog\XGH-blog\source_posts\VUE\129.png" alt="image-20210328012024702"></p>
<p><img src="VUE/126.png" alt="image-20210328011844476"></p>
</li>
<li><p>第二步: 创建路由组件</p>
<p>在src/cpmponents文件夹下创建组件Home.vue与About.vue</p>
<p><img src="VUE/127.png" alt="image-20210328011915263"></p>
</li>
<li><p>第三步:配置路由映射: 组件和路径映射关系。在main.js中的routes。</p>
<p><img src="VUE/128.png" alt="image-20210328011939671"></p>
</li>
<li><p>第四步:使用路由: 通过<router-link>和<router-view>都是vue-router内定义过的全局组件</p>
<p><router-link>：用于建立与对应组件之间关系，最终会被渲染成<a>标签（页面效果）在App.vue的模板中使用</p>
<p><router-view>：用于占位，展示页面，该标签会根据当前的路径, 动态渲染出不同的组件。<router-view>用在哪里，组件对应模板就渲染在哪里。网页的其他内容, 比如顶部的标题/导航, 或者底部的一些版权信息等会和<router-view>处于同一个等级。在路由切换时, 切换的是<router-view>挂载的组件, 其他内容不会发生改变。</p>
<p><img src="VUE/130.png" alt="image-20210328012112753"></p>
</li>
</ol>
<p>最终效果：</p>
<p><img src="VUE/131.png" alt="image-20210328012306928"></p>
<h4 id="3、细节处理"><a href="#3、细节处理" class="headerlink" title="3、细节处理"></a>3、细节处理</h4><h5 id="1、路由的默认值与修改为history模式"><a href="#1、路由的默认值与修改为history模式" class="headerlink" title="1、路由的默认值与修改为history模式"></a>1、路由的默认值与修改为history模式</h5><h6 id="1、路由的默认值"><a href="#1、路由的默认值" class="headerlink" title="1、路由的默认值"></a>1、路由的默认值</h6><p>我们这里还有一个不太好的实现:</p>
<ul>
<li>默认情况下, 进入网站的首页, 我们希望<router-view>渲染<strong>首页</strong>的内容。</li>
<li>但是我们的实现中, 默认没有显示首页组件, 必须让用户点击才可以。</li>
</ul>
<p>如何可以让一开始的<strong>路径</strong>就默认跳到到<strong>首页</strong>, 并且<router-view>渲染首页组件呢?</p>
<p>我只需要在router的index.js只修改，在配置路由和组件之间的应用关系时再配置一下重定向就可以了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="comment">// redirect重定向</span></span><br><span class="line">    redirect: <span class="string">&#x27;/home&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    component: Home</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    component: About</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>配置解析:</p>
<ul>
<li>我们在routes中又配置了一个映射。</li>
<li>path配置的是根路径: <code>/</code></li>
<li>redirect是重定向, 也就是我们将根路径重定向到/home的路径下, 这样就可以得到我们想要的结果了</li>
</ul>
<h6 id="2、修改为history模式"><a href="#2、修改为history模式" class="headerlink" title="2、修改为history模式"></a>2、修改为history模式</h6><p>我们前面说过改变路径的方式有两种:</p>
<ul>
<li>URL的hash</li>
<li>HTML5的history</li>
</ul>
<p><strong>默认情况下, 路径的改变使用的URL的hash。</strong>即路径后面会存在只有在hash模式才会出现的<code>#</code>，这其实是hash的锚点。</p>
<p>如果希望使用HTML5的history模式,可以在router的index.js里的router实例的属性进行如下配置即可:</p>
<p><img src="VUE/132.png" alt="image-20210328013637723"></p>
<p>效果：</p>
<p><img src="VUE/133.png" alt="image-20210328014008677"></p>
<h5 id="2、router-link补充"><a href="#2、router-link补充" class="headerlink" title="2、router-link补充"></a>2、router-link补充</h5><p>在前面的<router-link>中, 我们只是使用了一个属性: to, 用于指定跳转的路径。</p>
<p><router-link>中的属性：</p>
<ul>
<li><p>to：用于指定跳转的路径</p>
</li>
<li><p>tag: tag可以指定<router-link>之后渲染成什么组件（默认渲染成<a>）, 比如下面的代码会被渲染成一个<button>元素, 而不是<a></p>
</li>
<li><p>replace: replace不会留下history记录, 所以指定replace的情况下, 后退键返回不能返回到上一个页面中。（默认为pushState）</p>
</li>
<li><p>active-class: 当<router-link>对应的路由匹配成功时, 会自动给当前元素设置一个router-link-active的class, 设置active-class可以修改默认的名称。</p>
<ul>
<li><p>在进行高亮显示的导航菜单或者底部tabbar时, 会使用到该类。</p>
</li>
<li><p>但是通常不会修改类的属性, 会直接使用默认的router-link-active即可。</p>
<p><img src="VUE/134.png" alt="image-20210328014507832"></p>
</li>
<li><p>exact-active-class</p>
<ul>
<li>类似于active-class, 只是在精准匹配下才会出现的class。</li>
<li>后面看到嵌套路由时, 我们再看下这个属性。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to=<span class="string">&quot;/home&quot;</span> tag=<span class="string">&quot;button&quot;</span> replace active-<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;active&quot;</span>&gt;首页&lt;/router-link&gt;</span><br><span class="line">&lt;router-link to=<span class="string">&quot;/about&quot;</span> tag=<span class="string">&quot;button&quot;</span> replace active-<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;active&quot;</span>&gt;关于&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>若存在很多<router-link>标签，在每一个<router-link>标签内修改active-class的值将十分繁琐，所以有一个全局的配置，在router的index.js里的router实例的属性进行如下配置即可:</p>
<p>!<img src="VUE/136.png" alt="image-20210328015613180"></p>
</li>
</ul>
</li>
</ul>
<h5 id="3、路由代码跳转"><a href="#3、路由代码跳转" class="headerlink" title="3、路由代码跳转"></a>3、路由代码跳转</h5><p>有时候, 页面的跳转可能需要执行对应的JavaScript代码, 这个时候, 就可以使用第二种跳转方式了：</p>
<p><img src="VUE/138.png" alt="138"></p>
<h5 id="4、动态路由"><a href="#4、动态路由" class="headerlink" title="4、动态路由"></a>4、动态路由</h5><p>在某些情况下，一个页面的path路径可能是不确定的，比如我们进入用户界面时，希望是如下的路径：</p>
<ul>
<li>/user/aaaa或/user/bbbb</li>
<li>除了有前面的/user之外，后面还跟上了用户的ID</li>
</ul>
<p>这种path和Component的匹配关系，我们称之为动态路由(也是路由传递数据的一种方式)。</p>
<p>实现：路由有前面的/user之外，后面还<strong>动态</strong>跟上了用户的ID，并在页面展示用户的数据</p>
<ol>
<li><p>创建一个用户组件User.vue</p>
<p><img src="VUE/137.png" alt="image-20210328022521749"></p>
</li>
<li><p>在index.js中配置用户组件User.vue与路由之间的应用关系：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">&#x27;../components/User&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routers = [</span><br><span class="line">    &#123;</span><br><span class="line">    	path: <span class="string">&#x27;/user/:id&#x27;</span>,</span><br><span class="line">    	component: User,</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>在App.vue进行动态渲染：</p>
<p>使用<router-link>方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--通过v-bind实现字符串拼接--&gt;</span><br><span class="line">&lt;!--如果直接拼接：to&#x3D;&quot;&#x2F;user&#x2F;+userId&quot;，它会将&#x2F;user&#x2F;+userId当成一个字符串--&gt;</span><br><span class="line">&lt;router-link :to&#x3D;&quot;&#39;&#x2F;user&#x2F;&#39;+userId&quot;&gt;用户&lt;&#x2F;router-link&gt;</span><br><span class="line">&lt;router-view&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">      name: &#39;App&#39;,</span><br><span class="line">      data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          userId: &#39;zhangsan&#39;,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>也可以使用JavaScript代码的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click&#x3D;&quot;userClick&quot;&gt;用户&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">      name: &#39;App&#39;,</span><br><span class="line">      data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          userId: &#39;zhangsan&#39;,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        userClick() &#123;</span><br><span class="line">          this.$router.push(&#39;&#x2F;user&#x2F;&#39; + this.userId)</span><br><span class="line">    	&#125;</span><br><span class="line">  	  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在User.vue进行模板编写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;我是用户界面&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;p&gt;我是用户的相关信息, 嘿嘿嘿&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123;userId&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;!--也可以不使用计算属性，直接写--&gt;</span><br><span class="line">    &lt;!--&lt;h2&gt;&#123;&#123;$route.params.id&#125;&#125;&lt;&#x2F;h2&gt;--&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;User&quot;,</span><br><span class="line">        computed: &#123;</span><br><span class="line">          userId() &#123;</span><br><span class="line">            &#x2F;&#x2F; 注意：这里的id要与index.js中的routers里路由的path的对应一致</span><br><span class="line">            return this.$route.params.id</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>效果：</p>
<p><img src="VUE/102.png" alt="image-20210328025647282"></p>
<h4 id="4、-route与-router的区别："><a href="#4、-route与-router的区别：" class="headerlink" title="4、$route与$router的区别："></a>4、$route与$router的区别：</h4><p><img src="VUE/114.png" alt="image-20210328030540747"></p>
<ul>
<li><p>$router：指的是路由器这一个整体。也就是我们在index.js中<code>const router = new VueRouter</code>的这个VueRouter对象，它里面包含routes[]路由数组里面有很多的路由，分别与组件对应。</p>
<p>其中图2通过修改路由器这一个整体的history模式去修改所有在该路由器下的路由的history模式。</p>
</li>
<li><p>$route：指的是当前活跃的路由。即当前使用页面对应的路由即为活跃路由。</p>
<p>其中图1通过当前活跃路由去获取的当前路由的参数数组中对应的参数。</p>
</li>
</ul>
<h4 id="5、路由的懒加载（使用时在加载）"><a href="#5、路由的懒加载（使用时在加载）" class="headerlink" title="5、路由的懒加载（使用时在加载）"></a>5、路由的懒加载（使用时在加载）</h4><h5 id="1、vue-router打包文件的解析"><a href="#1、vue-router打包文件的解析" class="headerlink" title="1、vue-router打包文件的解析"></a>1、vue-router打包文件的解析</h5><p>我们执行<code>npm run build</code>进行打包的时候，Vue-cli会在当前项目的目录下生成一个dist的文件夹。里面有css/js/img等文件夹和index.html文件。其中css文件夹里存放css.[hash].js，项目中关于css的部分打包在里面，img文件夹里面存放的是图片资源。还有一个js文件夹，里面有：</p>
<ul>
<li>app.[hash].js：当前应用程序开发的所有代码（业务代码）</li>
<li>manifest.[hash].js：为了打包的代码做底层支撑(导入导出)（Commonjs/ES6-&gt;ES5）</li>
<li>vendor.[hash].js：vendor（第三方/提供商）第三方vue/vue-router/axios/bs</li>
</ul>
<p><img src="VUE/74.png" alt="image-20210328142724755"></p>
<h5 id="2、对之前没用脚手架打包的bundle-js的粗略解析"><a href="#2、对之前没用脚手架打包的bundle-js的粗略解析" class="headerlink" title="2、对之前没用脚手架打包的bundle.js的粗略解析"></a>2、对之前没用脚手架打包的bundle.js的粗略解析</h5><p>之前的某个bundle.js：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******/</span> (<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>) </span>&#123; <span class="comment">// webpackBootstrap</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// The module cache</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="keyword">var</span> installedModules = &#123;&#125;;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// The require function</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="comment">// Check if module is in cache</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="function"><span class="title">if</span>(<span class="params">installedModules[moduleId]</span>)</span> &#123;</span><br><span class="line"><span class="comment">/******/</span> 			<span class="keyword">return</span> installedModules[moduleId].exports;</span><br><span class="line"><span class="comment">/******/</span> 		&#125;</span><br><span class="line"><span class="comment">/******/</span> 		<span class="comment">// Create a new module (and put it into the cache)</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="keyword">var</span> <span class="built_in">module</span> = installedModules[moduleId] = &#123;</span><br><span class="line"><span class="comment">/******/</span> 			i: moduleId,</span><br><span class="line"><span class="comment">/******/</span> 			l: <span class="literal">false</span>,</span><br><span class="line"><span class="comment">/******/</span> 			<span class="built_in">exports</span>: &#123;&#125;</span><br><span class="line"><span class="comment">/******/</span> 		&#125;;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="comment">// Execute the module function</span></span><br><span class="line"><span class="comment">/******/</span> 		modules[moduleId].call(<span class="built_in">module</span>.exports, <span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="comment">// Flag the module as loaded</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="built_in">module</span>.l = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="comment">// Return the exports of the module</span></span><br><span class="line"><span class="comment">/******/</span> 		<span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line"><span class="comment">/******/</span> 	&#125;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// expose the modules object (__webpack_modules__)</span></span><br><span class="line"><span class="comment">/******/</span> 	__webpack_require__.m = modules;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// expose the module cache</span></span><br><span class="line"><span class="comment">/******/</span> 	__webpack_require__.c = installedModules;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// define getter function for harmony exports</span></span><br><span class="line"><span class="comment">/******/</span> 	__webpack_require__.d = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">exports</span>, name, getter</span>) </span>&#123;</span><br><span class="line"><span class="comment">/******/</span> 		<span class="function"><span class="title">if</span>(<span class="params">!__webpack_require__.o(<span class="built_in">exports</span>, name)</span>)</span> &#123;</span><br><span class="line"><span class="comment">/******/</span> 			<span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, name, &#123;</span><br><span class="line"><span class="comment">/******/</span> 				configurable: <span class="literal">false</span>,</span><br><span class="line"><span class="comment">/******/</span> 				enumerable: <span class="literal">true</span>,</span><br><span class="line"><span class="comment">/******/</span> 				get: getter</span><br><span class="line"><span class="comment">/******/</span> 			&#125;);</span><br><span class="line"><span class="comment">/******/</span> 		&#125;</span><br><span class="line"><span class="comment">/******/</span> 	&#125;;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// getDefaultExport function for compatibility with non-harmony modules</span></span><br><span class="line"><span class="comment">/******/</span> 	__webpack_require__.n = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line"><span class="comment">/******/</span> 		<span class="keyword">var</span> getter = <span class="built_in">module</span> &amp;&amp; <span class="built_in">module</span>.__esModule ?</span><br><span class="line"><span class="comment">/******/</span> 			<span class="function"><span class="keyword">function</span> <span class="title">getDefault</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">module</span>[<span class="string">&#x27;default&#x27;</span>]; &#125; :</span><br><span class="line"><span class="comment">/******/</span> 			<span class="function"><span class="keyword">function</span> <span class="title">getModuleExports</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">module</span>; &#125;;</span><br><span class="line"><span class="comment">/******/</span> 		__webpack_require__.d(getter, <span class="string">&#x27;a&#x27;</span>, getter);</span><br><span class="line"><span class="comment">/******/</span> 		<span class="keyword">return</span> getter;</span><br><span class="line"><span class="comment">/******/</span> 	&#125;;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// Object.prototype.hasOwnProperty.call</span></span><br><span class="line"><span class="comment">/******/</span> 	__webpack_require__.o = <span class="function"><span class="keyword">function</span>(<span class="params">object, property</span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.hasOwnProperty.call(object, property); &#125;;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// __webpack_public_path__</span></span><br><span class="line"><span class="comment">/******/</span> 	__webpack_require__.p = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// Load entry module and return exports</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="keyword">return</span> __webpack_require__(__webpack_require__.s = <span class="number">0</span>);</span><br><span class="line"><span class="comment">/******/</span> &#125;)</span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="comment">/******/</span> ([</span><br><span class="line"><span class="comment">/* 0 */</span></span><br><span class="line"><span class="comment">/***/</span> (<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(__webpack_exports__, <span class="string">&quot;__esModule&quot;</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="comment">/* harmony import */</span> <span class="keyword">var</span> __WEBPACK_IMPORTED_MODULE_0__info__ = __webpack_require__(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1.使用commonjs的模块化规范</span></span><br><span class="line"><span class="keyword">const</span> &#123;add, mul,dec&#125; = __webpack_require__(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"><span class="built_in">console</span>.log(mul(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"><span class="built_in">console</span>.log(dec(<span class="number">30</span>, <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.使用ES6的模块化的规范</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(__WEBPACK_IMPORTED_MODULE_0__info__[<span class="string">&quot;c&quot;</span> <span class="comment">/* name */</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(__WEBPACK_IMPORTED_MODULE_0__info__[<span class="string">&quot;a&quot;</span> <span class="comment">/* age */</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(__WEBPACK_IMPORTED_MODULE_0__info__[<span class="string">&quot;b&quot;</span> <span class="comment">/* height */</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/***/</span> &#125;),</span><br><span class="line"><span class="comment">/* 1 */</span></span><br><span class="line"><span class="comment">/***/</span> (<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, <span class="built_in">exports</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 * num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dec</span>(<span class="params">num1,num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 - num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  add,</span><br><span class="line">  mul,</span><br><span class="line">  dec</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***/</span> &#125;),</span><br><span class="line"><span class="comment">/* 2 */</span></span><br><span class="line"><span class="comment">/***/</span> (<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;why&#x27;</span>;</span><br><span class="line"><span class="comment">/* harmony export (immutable) */</span> __webpack_exports__[<span class="string">&quot;c&quot;</span>] = name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="comment">/* harmony export (immutable) */</span> __webpack_exports__[<span class="string">&quot;a&quot;</span>] = age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> height = <span class="number">1.88</span>;</span><br><span class="line"><span class="comment">/* harmony export (immutable) */</span> __webpack_exports__[<span class="string">&quot;b&quot;</span>] = height;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***/</span> &#125;)</span><br><span class="line"><span class="comment">/******/</span> ]);</span><br></pre></td></tr></table></figure>

<p>其实bundle.js中本质上是一个闭包函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)([])</span><br></pre></td></tr></table></figure>

<p>从后往前看：</p>
<ol>
<li><p><code>([])</code>中的内容其实是一个数组，存放的就是我们写的js代码。</p>
<p>即：我们写了main.js、mathUtil.js、info.js三个js文件，他们在<code>([])</code>中就按数组的方式存放：([main.js,mathUtil.js,info.js])。其中main.js为第0号元素。</p>
</li>
<li><p><code>(function(modules) &#123;&#125;)</code>这里对下面的js文件数组做底层支撑（commonjs/ES6-&gt;ES5、导入导出等等）。其中最重要的是<code>__webpack_require__()</code>方法。在<code>(function(modules) &#123;&#125;)</code>最后的返回<code>return __webpack_require__(__webpack_require__.s = 0)</code>作为入口。</p>
</li>
</ol>
<h5 id="3、vue-router的懒加载"><a href="#3、vue-router的懒加载" class="headerlink" title="3、vue-router的懒加载"></a>3、vue-router的懒加载</h5><p>官方给出了解释:</p>
<ul>
<li>当打包构建应用时，Javascript 包会变得非常大，影响页面加载。</li>
<li>如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效</li>
</ul>
<p>通俗解释：</p>
<ul>
<li>首先, 我们知道路由中通常会定义很多不同的页面；</li>
<li>这个页面最后被打包在哪里呢? 一般情况下, 是放在一个js文件（app.[hash].js）中，因为app.[hash].js是当前应用程序开发的所有代码（业务代码）；</li>
<li>但是, 页面这么多放在一个js文件中, 必然会造成这个页面非常的大；</li>
<li>如果我们一次性从服务器请求下来这个页面, 可能需要花费一定的时间, 甚至用户的电脑上还出现了短暂空白的情况，这对用户是很不友好的；</li>
<li>如何避免这种情况呢? 使用路由懒加载就可以了。</li>
</ul>
<p>路由懒加载的作用：使用了在加载</p>
<ul>
<li>路由懒加载的主要作用就是<strong>将路由对应的组件打包成一个个的js代码块</strong>。</li>
<li>只有在这个路由被访问到的时候, 才加载对应的组件。</li>
</ul>
<p>路由懒加载的实现：</p>
<ul>
<li><p>方式一: 结合Vue的异步组件和Webpack的代码分析（早期使用，现已不常用）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">resolve</span> =&gt;</span> &#123; <span class="built_in">require</span>.ensure([<span class="string">&#x27;../components/Home.vue&#x27;</span>], <span class="function">() =&gt;</span> &#123; resolve(<span class="built_in">require</span>(<span class="string">&#x27;../components/Home.vue&#x27;</span>)) &#125;)&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式二: AMD写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> About = <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">require</span>([<span class="string">&#x27;../components/About.vue&#x27;</span>], resolve);</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式三: 在ES6中, 我们可以有更加简单的写法来组织Vue异步组件和Webpack的代码分割（常用）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Home = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../components/Home.vue&#x27;</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>路由懒加载的实现的效果：</p>
<p><img src="VUE/139.png" alt="image-20210328143539544"></p>
<h4 id="6、路由的嵌套"><a href="#6、路由的嵌套" class="headerlink" title="6、路由的嵌套"></a>6、路由的嵌套</h4><p>嵌套路由是一个很常见的功能</p>
<ul>
<li>比如在home页面中, 我们希望通过/home/news和/home/message访问一些内容。</li>
<li>一个路径映射一个组件, 访问这两个路径也会分别渲染两个组件。</li>
</ul>
<p>路径和组件的关系如下：</p>
<p><img src="VUE/140.png" alt="image-20210328145310299"></p>
<p>实现嵌套路由有两个步骤:</p>
<ul>
<li><p>创建对应的子组件HomeNews.vue和HomeMessage.vue, 并且在index.js引入并设置其中的路由映射中配置对应的子路由。在父路由里使用children属性，值是一个数组，在其中配置对应的子路由以及对应的子组件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒加载</span></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../components/Home&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> HomeNews = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../components/HomeNews&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> HomeMessage = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../components/HomeMessage&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    path: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    component: Home,</span><br><span class="line">    children: [</span><br><span class="line">      <span class="comment">// &#123;</span></span><br><span class="line">      <span class="comment">//   path: &#x27;&#x27;,</span></span><br><span class="line">      <span class="comment">//   redirect: &#x27;news&#x27;</span></span><br><span class="line">      <span class="comment">// &#125;,</span></span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">        component: HomeNews</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">&#x27;message&#x27;</span>,</span><br><span class="line">        component: HomeMessage</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>若在home主页中要设置默认页的可以在路由映射中配置对应的子路由中配置重定向redirect到想要的默认页。</p>
</li>
<li><p>在父组件Home.vue模板内部使用<router-link>进行相连与<router-view>标签进行占位。</p>
<p><strong>其中注意：<router-link>中to属性值的”/home/xxx”的第一个<code>/</code>不能省略。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;我是首页&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;p&gt;我是首页内容, 哈哈哈&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">    &lt;router-link to&#x3D;&quot;&#x2F;home&#x2F;news&quot;&gt;新闻&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;router-link to&#x3D;&quot;&#x2F;home&#x2F;message&quot;&gt;消息&lt;&#x2F;router-link&gt;</span><br><span class="line"></span><br><span class="line">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line"></span><br><span class="line">    &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="7、参数传递"><a href="#7、参数传递" class="headerlink" title="7、参数传递"></a>7、参数传递</h4><p>为了演示传递参数, 我们这里再创建一个组件, 并且将其配置好</p>
<ol>
<li>第一步: 创建新的组件Profile.vue </li>
<li>第二步: 配置路由映射 </li>
<li>第三步: 添加跳转的<router-link></li>
</ol>
<p><img src="VUE/141.png" alt="image-20210328153143736"></p>
<h5 id="1、传递参数"><a href="#1、传递参数" class="headerlink" title="1、传递参数"></a>1、传递参数</h5><p><strong>传递参数主要有两种类型: params和query</strong></p>
<p><strong>params</strong>的类型（之前的动态路由）：</p>
<ul>
<li><p>配置路由格式：</p>
<p>/user/:id</p>
</li>
<li><p>传递的方式: 在path后面跟上对应的值：</p>
<p>:to=”‘/user/‘+userId”</p>
</li>
<li><p>传递后形成的路径：</p>
<p>在User.vue的模板template中</p>
</li>
</ul>
<p><strong>query</strong>的类型：</p>
<ul>
<li><p>配置路由格式： </p>
<p>path: ‘/profile’, 也就是普通配置</p>
</li>
<li><p>传递的方式： 对象中使用query的key作为传递方式：</p>
<p>使用<router-link>的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to&#x3D;&quot;&#123;path: &#39;&#x2F;profile&#39;, query: &#123;name: &#39;why&#39;, age: 18, height: 1.88&#125;&#125;档案&lt;&#x2F;router-link&gt;</span><br></pre></td></tr></table></figure>

<p>即在<code>:to</code>后面是一个对象，对象里面有两个属性path/query</p>
<ul>
<li>path：访问路由</li>
<li>query：查询参数，也是可以一个对象（里面存有多个数据）<ul>
<li>name: ‘why’</li>
<li>age: 18</li>
<li>height: 1.88</li>
</ul>
</li>
</ul>
<p>使用JavaScript代码方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click&#x3D;&quot;profileClick&quot;&gt;档案&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">   methods: &#123;</span><br><span class="line">        profileClick() &#123;</span><br><span class="line">          this.$router.push(&#123;</span><br><span class="line">            path: &#39;&#x2F;profile&#39;,</span><br><span class="line">            query: &#123;</span><br><span class="line">              name: &#39;kobe&#39;,</span><br><span class="line">              age: 19,</span><br><span class="line">              height: 1.87</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>传递后形成的路径: /profile?name=why&amp;age=18&amp;height=1.88</p>
<p>通过这种方式可以传递多个参数。</p>
<p><strong>注意：连点报错的在push的小括号后面加.catch(err =&gt;err)。</strong></p>
<p>例如：this.$router.replace(‘/home’).catch(err =&gt; {})</p>
</li>
</ul>
<h5 id="2、获取参数"><a href="#2、获取参数" class="headerlink" title="2、获取参数"></a>2、获取参数</h5><p><strong>获取参数通过$route对象获取的。</strong></p>
<p>在使用了 <code>vue-router</code> 的应用中，<strong>路由对象会被注入每个组件中</strong>，赋值为 <code>this.$route</code> ，并且当路由切换时，路由对象会被更新。</p>
<p>在profile.vue中的模板template中进行展示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;我是Profile组件&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123;$route.query.name&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123;$route.query.age&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123;$route.query.height&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="VUE/143.png" alt="image-20210328172651274"></p>
<h5 id="3、-route和-router在参数传递过程中的区别："><a href="#3、-route和-router在参数传递过程中的区别：" class="headerlink" title="3、$route和$router在参数传递过程中的区别："></a>3、$route和$router在参数传递过程中的区别：</h5><ul>
<li>$router为VueRouter实例，想要导航到不同URL，则使用$router.push方法；</li>
<li>$route为当前router跳转对象里面可以获取name、path、query、params等 。</li>
</ul>
<p><img src="VUE/144.png" alt="image-20210328172939825"></p>
<h5 id="4、所有的组件都继承自Vue类的原型"><a href="#4、所有的组件都继承自Vue类的原型" class="headerlink" title="4、所有的组件都继承自Vue类的原型"></a>4、<strong>所有的组件都继承自Vue类的原型</strong></h5><p>在main.js里定义的变量，在任何组件里都可以使用。</p>
<p>main.js：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.name = <span class="string">&quot;coderwhy&quot;</span></span><br></pre></td></tr></table></figure>

<p>User.vue：在User.vue里并没有定义name，但可以使用Vue类中的name</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    methods: &#123;</span><br><span class="line">          btnClick() &#123;</span><br><span class="line">            &#x2F;&#x2F; 所有的组件都继承自Vue类的原型</span><br><span class="line">            console.log(this.name);</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>这也是$route和$router的原理</p>
<ul>
<li><p>Vue.prototype.$router = return this.routerBoot.router</p>
<ul>
<li> this.routerBoot：Vue</li>
<li>router：Vue中的router</li>
</ul>
</li>
<li><p>Vue.prototype.$route = return this.routerBoot.route</p>
<p>this.routerBoot：Vue中的router</p>
<p>route：当前活跃路由</p>
</li>
</ul>
<h4 id="8、全局导航守卫"><a href="#8、全局导航守卫" class="headerlink" title="8、全局导航守卫"></a>8、全局导航守卫</h4><h5 id="1、beforeEach前置守卫-guard"><a href="#1、beforeEach前置守卫-guard" class="headerlink" title="1、beforeEach前置守卫(guard)"></a>1、beforeEach前置守卫(guard)</h5><p>我们来考虑一个需求: 在一个SPA应用中, 如何改变网页的标题呢?</p>
<ul>
<li>网页标题是通过<title>来显示的, 但是SPA只有一个固定的HTML, 切换不同的页面时, 标题并不会改变。（index.html）</li>
<li>但是我们可以通过生命周期函数+JavaScript来修改<title>的内容。 window.document.title = ‘新的标题’</li>
</ul>
<p>那么在Vue项目中, 在哪里修改? 什么时候修改比较合适呢?</p>
<ul>
<li><p>普通的修改方式</p>
<ul>
<li><p>我们比较容易想到的修改标题的位置是<strong>每一个路由对应的组件.vue文件中</strong>。<strong>通过mounted/created声明周期函数, 执行对应的代码进行修改即可</strong>。</p>
<p>在每一个对应的组件.vue中添加对应的created钩子函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    created() &#123;</span><br><span class="line">      console.log(&#39;home created&#39;);</span><br><span class="line">      document.title &#x3D; &#39;首页&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>但是当页面比较多时, 这种方式不容易维护(因为需要在多个页面执行类似的代码)。</p>
</li>
</ul>
</li>
<li><p>导航守卫的方式：</p>
<p>什么是导航守卫?</p>
<ul>
<li>vue-router提供的导航守卫主要用来监<strong>听路由的进入和离开</strong>的。</li>
<li>vue-router提供了<strong>beforeEach前置守卫(guard)和afterEach后置钩子(hook)的函数</strong>, 它们会在<strong>路由即将改变前和改变后</strong>触发.</li>
</ul>
</li>
<li><p>实现：可以利用beforeEach前置守卫来完成标题的修改</p>
<ol>
<li><p>首先, 我们可以在路由当中定义一些标题, 可以利用meta(元数据)来定义；</p>
<p><img src="VUE/145.png" alt="image-20210328222421995"></p>
</li>
<li><p>其次, 利用beforeEach前置守卫(guard),来修改我们的标题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前置守卫(guard)</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 从from跳转到to</span></span><br><span class="line">  <span class="built_in">document</span>.title = to.matched[<span class="number">0</span>].meta.title</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>beforeEach前置守卫(guard)的三个参数：</p>
<ul>
<li>to: 即将要进入的目标的路由对象.</li>
<li>from: 当前导航即将要离开的路由对象.</li>
<li>next: 调用该方法后, 才能进入下一个钩子。</li>
</ul>
<p><strong>注意</strong>：</p>
<ol>
<li><p>上面的<code>document.title</code>为什么要写成<code>to.matched[0].meta.title</code>?不写成<code>to.meta.title</code>？</p>
<p>因为<code>to.meta.title</code>只能用于当前路由，即没有进行路由嵌套的当前路由。一旦有嵌套路由，那么<code>to.meta.title</code>将取不到值，为undefined，因为在嵌套路由，即当前路由是没有meta定义的，我们的mata只是定义在父路由（最基础的路由）那里。浏览器把嵌套路由的<code>meta</code>放在了<code>match[]数组</code>当中，在<strong>该数组中存放着当前路由的层级数组</strong>。而<code>match[]数组</code>的第0号元素就是当前路由的父路由，而对于没有嵌套的来源来说，自己就是自己的父路由。所有使用<code>to.matched[0].meta.title</code>就能取到每一个<code>meta</code>中的内容，无论路由有没有进行嵌套。</p>
<p><img src="VUE/146.png" alt="image-20210328225211032"></p>
</li>
<li><p><strong>在beforeEach方法里必须使用next函数</strong>。Vue-router默认实现了next方法，让网页可以进入下一步，但当我们调用beforeEach方法，vue-router就会使用我们在beforeEach方法里写的next函数，不会使用默认的那个。但如果我们没有写next函数（也就是在beforeEach方法中没有next函数），那么浏览器报错，不能渲染内容。</p>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<h5 id="2、如果是后置钩子-也就是afterEach-不需要主动调用next-函数"><a href="#2、如果是后置钩子-也就是afterEach-不需要主动调用next-函数" class="headerlink" title="2、如果是后置钩子, 也就是afterEach, 不需要主动调用next()函数"></a>2、如果是后置钩子, 也就是afterEach, 不需要主动调用next()函数</h5><p>afterEach后置钩子的参数只有afterEach(to,from)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后置钩子(hook)</span></span><br><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// console.log(&#x27;----&#x27;);</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="3、路由独享的守卫与组件内的守卫"><a href="#3、路由独享的守卫与组件内的守卫" class="headerlink" title="3、路由独享的守卫与组件内的守卫"></a>3、路由独享的守卫与组件内的守卫</h5><p>上面我们使用的导航守卫, 被称之为<strong>全局守卫</strong>.</p>
<ul>
<li>路由独享的守卫。</li>
<li>组件内的守卫。</li>
</ul>
<p>查看<a target="_blank" rel="noopener" href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%90%8E%E7%BD%AE%E9%92%A9%E5%AD%90">官网</a>进行学习</p>
<h4 id="9、keep-alive"><a href="#9、keep-alive" class="headerlink" title="9、keep-alive"></a>9、keep-alive</h4><h5 id="1、keep-alive实现页面缓存"><a href="#1、keep-alive实现页面缓存" class="headerlink" title="1、keep-alive实现页面缓存"></a>1、keep-alive实现页面缓存</h5><ul>
<li>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。</li>
<li>router-view 也是一个组件，如果直接被包在 keep-alive 里面，所有路径匹配到的视图组件都会被缓存。</li>
<li>在没有实现页面缓存的时候，每一次的页面跳转浏览器都会重新创建一个新的组件进行渲染。所以，页面缓存对于提高浏览器的性能是很有帮助的。</li>
</ul>
<p><img src="VUE/147.png" alt="image-20210328232633881"></p>
<p>需求：用户进入主页home的时候，默认显示新闻news页面。当用户点击主页home中的消息message页面后离开主页home，进入其他页面（如关于我们about）再回来主页home的时候，浏览器显示的是上次浏览的页面，也就是消息message页面（实现缓存）。</p>
<p>实现：（使用keep-alive加上组件内的守卫）</p>
<ol>
<li><p>直接在App.vue中的使用keep-alive将router-view包裹进来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;router-view&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;keep-alive&gt;</span><br></pre></td></tr></table></figure>

<p>按道理来说浏览器已经实现的页面缓存了，实际上浏览器也实现了页面缓存（没有重新创建组件）。但是并没有实现我们想要的需求（浏览器显示的是上次浏览的页面），还是实现home的news页面。</p>
<p><img src="VUE/148.png" alt="image-20210329001711312"></p>
<p>为什么？</p>
<p>在浏览器处于其他页面的时候（如about页面）我们再点击主页home。浏览器实现to路由跳转，相当于在url传入了path=home，因为主页home会默认显示news页面，即在组件与路由匹配的时候进行了重定向redirect: ‘news’。所以在传入home的同时，浏览器重定向到了news页面。</p>
</li>
<li><p>修改重定向的方式，不使用组件与路由匹配的时候进行了重定向redirect: ‘news’，将对应的代码注释掉。在Home.vue中，在生命周期函数created中实现重定向。因为created是在组件被创建后的钩子函数，所以在Home组件被创建的时候进行重定向。又因为使用了keep-alive实现了页面缓存，从而实现浏览器显示的是上次浏览的页面这个需求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;Home&quot;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        path: &#39;&#x2F;home&#x2F;news&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line">      this.$router.push(this.path)</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>能实现首页home默认显示新闻news页面，但是不能实现重新进入主页home的时候显示的是上次浏览的页面。显示的是home主页，不是新闻news页面，也不是消息message页面。</p>
<p><img src="VUE/149.png" alt="image-20210329002247904"></p>
<p>原因（忽略了返回的home）：在其它页面进入主页home的时候，浏览器实现to路由跳转，相当于在url传入了path=home。但是主页home由keep-alive实现了页面缓存，Home组件不会被重新创建，也就是不会重复多次的调用created方法。组件没有销毁，所以只调用一次create方法，就是在主页创建的时候实现的重定向，之后并不会进行重定向。但传入home的时候没有重定向所以没有修改到home的news界面。</p>
</li>
<li><p>使用activated()与deactivated()函数：</p>
<ul>
<li>activated()：活跃时调用，当点击某个页面时，该页面进入活跃状态</li>
<li>deactivated()：非活跃时调用，离开某个页面时，该页面进入非活跃状态</li>
</ul>
<p>注释掉之前的created函数，使用activated()与deactivated()函数。在activated()实现重定向news，在deactivated()中实现在离开之前获取主页上次浏览的页面，如消息message主页。实现主页home默认显示新闻news页面，在离开的时候更新path的值，使重新回到主页home的时候，通过path的值重定向到上次浏览的页面，实现需求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;Home&quot;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        path: &#39;&#x2F;home&#x2F;news&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    activated() &#123;</span><br><span class="line">      this.$router.push(this.path);</span><br><span class="line">    &#125;,</span><br><span class="line">    deactivated() &#123;</span><br><span class="line">        this path &#x3D; this.$route.push;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>能实现主页home默认显示新闻news页面，但是当离开首页home，就点不回去主页home了。。。</p>
<p><img src="VUE/151.png" alt="image-20210329005822319"></p>
<p>原因：因为this.$route.push获取的是当前活跃路由，并不是主页home，所以不能拿到离开的时候主页的path值。拿到的path是用户User页面。弄错了执行顺序。正确的执行顺序：activated()主页显示默认页news =&gt; 点击用户，执行deactivated()函数将path修改成/user/zhangsan =&gt; 点击主页home执行activated()函数重定向到/user/zhangsan =&gt; 再执行deactivated()函数将path修改成/user/zhangsan =&gt; …….一直重复。所以显示的一直是用户User页面，点不回去主页home。</p>
</li>
<li><p>使用组件内导航的beforeRouteLeave()函数实现在离开之前获取主页上次浏览的页面，如消息message主页。实现主页home默认显示新闻news页面，在离开的时候更新path的值，使重新回到主页home的时候，通过path的值重定向到上次浏览的页面，实现需求。</p>
<p><img src="VUE/152.png" alt="image-20210329010318911"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;Home&quot;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        path: &#39;&#x2F;home&#x2F;news&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    activated() &#123;</span><br><span class="line">      this.$router.push(this.path);</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeRouteLeave (to, from, next) &#123;</span><br><span class="line">      console.log(this.$route.path);</span><br><span class="line">      this.path &#x3D; this.$route.path;</span><br><span class="line">      next()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>实现需求。就是在第二种解决方法上使用beforeRouteLeave()去代替了deactivated()。因为deactivated()的route是用户User页面，而beforeRouteLeave()的route还是主页home。</p>
<p><img src="VUE/153.png" alt="image-20210329011235744"></p>
<p>总结如下：</p>
<ol>
<li>注释掉之前的默认页的重定向方式，采用activated()的方式进行默认页的重定向</li>
<li>使用组件内导航beforeRouteLeave记录离开时的状态，修改path的值方便下次重定向</li>
<li>使用keep-alive实现页面缓存</li>
</ol>
</li>
</ol>
<h5 id="2、activated-与deactivated-函数"><a href="#2、activated-与deactivated-函数" class="headerlink" title="2、activated()与deactivated()函数"></a>2、activated()与deactivated()函数</h5><p>activated()与deactivated()函数这两个函数只有在该组件被保持了状态使用了keep-alive时, 才是有效的。否则不能使用这两个函数。</p>
<h5 id="3、keep-alive的属性"><a href="#3、keep-alive的属性" class="headerlink" title="3、keep-alive的属性"></a>3、keep-alive的属性</h5><p>keep-alive有两个非常重要的属性：</p>
<ul>
<li>include - 字符串或正则表达，只有匹配的组件会被缓存</li>
<li>exclude - 字符串或正则表达式，任何匹配的组件都不会被缓存</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive exclude&#x3D;&quot;Profile,User&quot;&gt;</span><br><span class="line">  &lt;router-view&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;keep-alive&gt;</span><br></pre></td></tr></table></figure>

<p><strong>注意：Profile,User中的逗号<code>,</code>后面不能加空格。（与正则表达式元素一样”\d{2,9}”）</strong></p>
<h2 id="九、Promise"><a href="#九、Promise" class="headerlink" title="九、Promise"></a>九、Promise</h2><h3 id="1、什么是promise"><a href="#1、什么是promise" class="headerlink" title="1、什么是promise"></a>1、什么是promise</h3><p>ES6中一个非常重要和好用的特性就是Promise。</p>
<p>Promis的作用：<strong>Promise是异步编程的一种解决方案。</strong></p>
<p>那什么时候我们会来处理异步事件呢？</p>
<ul>
<li>一种很常见的场景应该就是网络请求了。</li>
<li>我们封装一个网络请求的函数，因为<strong>不能立即拿到结果，需要等待网络请求</strong>，所以不能像简单的3+4=7一样将结果返回。</li>
<li>所以往往我们会传入另外一个函数，在数据请求成功时，将数据通过传入的函数回调出去。当数据请求失败时提示错误信息。</li>
<li>如果只是一个简单的网络请求，那么这种方案不会给我们带来很大的麻烦，但是当网络请求非常复杂时，就会出现回调地狱。</li>
</ul>
<p>什么是回调地狱？</p>
<p>我们来考虑下面的场景(有夸张的成分)，但在实际上也有可能出现以下情况：</p>
<ul>
<li><p>我们需要通过一个url1从服务器加载一个数据data1，data1中包含了下一个请求的url2；</p>
</li>
<li><p>我们需要通过data1取出url2，从服务器加载数据data2，data2中包含了下一个请求的url3；</p>
</li>
<li><p>我们需要通过data2取出url3，从服务器加载数据data3，data3中包含了下一个请求的url4；</p>
</li>
<li><p>发送网络请求url4，获取最终的数据data4。</p>
<p><img src="VUE/154.png" alt="image-20210329213713985"></p>
</li>
</ul>
<p>上面的代码存在的问题：</p>
<ul>
<li>正常情况下，不会有什么问题，可以正常运行并且获取我们想要的结果。</li>
<li>但是，当中间每一次进行数据处理的代码都有多于100行的时候，这样的代码难看而且不容易维护，简直就是地狱。</li>
<li>我们更加期望的是一种更加优雅的方式来进行这种异步操作。</li>
</ul>
<p>所以可以通过Promise以一种非常优雅的方式来解决这个问题。</p>
<h3 id="2、promise的使用"><a href="#2、promise的使用" class="headerlink" title="2、promise的使用"></a>2、promise的使用</h3><h4 id="1、基本使用"><a href="#1、基本使用" class="headerlink" title="1、基本使用"></a>1、基本使用</h4><p>这里用一个定时器来模拟异步事件：</p>
<ul>
<li><p>假设下面的data是从网络上1秒后请求的数据</p>
</li>
<li><p>console.log就是我们的处理方式。</p>
</li>
<li><p>这是我们过去的处理方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">error</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Promise的方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 成功的时候调用resolve</span></span><br><span class="line">      <span class="comment">// resolve(&#x27;Hello World&#x27;)</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 失败的时候调用reject</span></span><br><span class="line">      reject(<span class="string">&#x27;error message&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 拿到请求数据，执行100行的处理代码</span></span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 100行的处理代码</span></span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>解析promise：</p>
<ul>
<li>new Promise很明显是创建一个Promise对象；</li>
<li>Promise传入两个参数函数((resolve, reject) =&gt; {})很明显就是一个函数，其中的参数resolve, reject<ul>
<li>resolve和reject函数只是一个标识，没有真正的函数体，你在newPromise中执行哪两个函数时会采用异步执行，也就先被挂载起来了。</li>
<li>在通常情况下，我们会根据请求数据的成功和失败来决定调用哪一个。</li>
</ul>
</li>
<li>成功与失败：<ul>
<li>如果是<strong>成功</strong>的，那么通常我们会调用resolve(message)，这个时候，我们后续的<code>then</code>会被回调</li>
<li>如果是<strong>失败</strong>的，那么通常我们会调用reject(error)，这个时候，我们后续的<code>catch</code>会被回调</li>
</ul>
</li>
</ul>
<p>这就是Promise最基本的使用。那么，什么情况下会用到Promise?</p>
<ul>
<li>一般情况下是有异步操作时,使用Promise对这个异步操作进行封装。</li>
<li>通常将数据的网络请求部分代码放在(resolve, reject) =&gt; { 网络请求部分代码 }中，</li>
<li>将获取到网络请求的数据data后，对data进行数据处理的部分代码放在<code>then</code>当中，</li>
<li>将获取数据失败后的错误处理代码部分放在<code>catch</code>当中。</li>
</ul>
<p>执行过程：</p>
<ol>
<li>new Promise</li>
<li>构造函数(1.保存了一些状态信息 2.执行传入的函数)</li>
<li>在执行传入的回调函数时, 会传入两个参数, resolve, reject.本身又是函数</li>
<li>网路请求数据</li>
<li>获取数据成功进入then进行数据处理</li>
<li>获取数据失败进入catch进行错误处理</li>
</ol>
<h4 id="2、Promise链式调用"><a href="#2、Promise链式调用" class="headerlink" title="2、Promise链式调用"></a>2、Promise链式调用</h4><p>我们在看Promise的流程图时，发现无论在then还是catch中都可以返回一个Promise对象。所以，我们的代码其实是可以进行链式调用的：</p>
<p>我们可以直接通过Promise包装一下新的数据，将Promise对象返回了</p>
<ul>
<li>Promise.resovle()：将数据包装成Promise对象，并且在内部回调resolve()函数</li>
<li>Promise.reject()：将数据包装成Promise对象，并且在内部回调reject()函数</li>
</ul>
<p>需求：</p>
<ol>
<li>网络请求: aaa -&gt; 自己处理(10行)</li>
<li>处理: aaa111 -&gt; 自己处理(10行)</li>
<li>处理: aaa111222 -&gt; 自己处理</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 第一次网络请求的代码</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 第一次拿到结果的处理代码</span></span><br><span class="line">    <span class="comment">// 自己处理10行代码</span></span><br><span class="line">    <span class="built_in">console</span>.log(res, <span class="string">&#x27;第一层的10行处理代码&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 对结果进行第一次处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      resolve(res + <span class="string">&#x27;111&#x27;</span>)</span><br><span class="line">      <span class="comment">// 过程中出现错误，直接执行catch，不会在执行以下的then</span></span><br><span class="line">      <span class="comment">// reject(&#x27;err&#x27;)</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 第二次拿到结果的处理代码</span></span><br><span class="line">    <span class="built_in">console</span>.log(res, <span class="string">&#x27;第二层的10行处理代码&#x27;</span>);</span><br><span class="line">    <span class="comment">// 对结果进行第二次处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(res + <span class="string">&#x27;222&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 第三次拿到结果的处理代码</span></span><br><span class="line">    <span class="built_in">console</span>.log(res, <span class="string">&#x27;第三层的10行处理代码&#x27;</span>);</span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p><strong>链式调用简写</strong>：</p>
<ul>
<li><p>如果我们希望数据直接包装成Promise.resolve，那么在then中可以直接返回数据</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new Promise(resolve =&gt; resolve(结果))简写</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 第一次网络请求的代码</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 第一次拿到结果的处理代码</span></span><br><span class="line">    <span class="comment">// 自己处理10行代码</span></span><br><span class="line">    <span class="built_in">console</span>.log(res, <span class="string">&#x27;第一层的10行处理代码&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对结果进行第一次处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(res + <span class="string">&#x27;111&#x27;</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 第二次拿到结果的处理代码</span></span><br><span class="line">    <span class="built_in">console</span>.log(res, <span class="string">&#x27;第二层的10行处理代码&#x27;</span>);</span><br><span class="line">    <span class="comment">// 对结果进行第二次处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(res + <span class="string">&#x27;222&#x27;</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 第三次拿到结果的处理代码</span></span><br><span class="line">    <span class="built_in">console</span>.log(res, <span class="string">&#x27;第三层的10行处理代码&#x27;</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意下面的代码中，我讲return Promise.resovle(data)改成了return data</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略掉Promise.resolve</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 1.自己处理10行代码</span></span><br><span class="line">    <span class="built_in">console</span>.log(res, <span class="string">&#x27;第一层的10行处理代码&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.对结果进行第一次处理</span></span><br><span class="line">    <span class="keyword">return</span> res + <span class="string">&#x27;111&#x27;</span></span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res, <span class="string">&#x27;第二层的10行处理代码&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res + <span class="string">&#x27;222&#x27;</span></span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res, <span class="string">&#x27;第三层的10行处理代码&#x27;</span>);</span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果依然是一样的</p>
</li>
<li><p>Promise.reject(‘error message’)的另一种写法：都可以进入到catch</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return Promise.reject(&#x27;error message&#x27;)</span></span><br><span class="line"><span class="keyword">throw</span> <span class="string">&#x27;error message&#x27;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="3、Promise的all方法："><a href="#3、Promise的all方法：" class="headerlink" title="3、Promise的all方法："></a>3、Promise的all方法：</h4><p>当某个需求需要同时拿到两个或多个网络请求到的数据才能进行实现。为了分析那个网络请求先拿到数据（因为是同步的，所以不清楚哪个请求会先拿到。因为如果能够肯定网路请求2在网路请求1请求之后拿到数据的话，就可以将业务统一在网路请求1中实现。没必要进行下面的步骤。）这个时候如果使用之前jQuery + ajax的方式将变得很麻烦，但使用Promise的all方法将十分轻松的实现。</p>
<ul>
<li><p>使用jQuery + ajax的方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 网路请求一:</span></span><br><span class="line"><span class="keyword">let</span> isResult1 = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> isResult2 = <span class="literal">false</span></span><br><span class="line">$ajax(&#123;</span><br><span class="line">    url: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;结果1&#x27;</span>);</span><br><span class="line">      isResult1 = <span class="literal">true</span></span><br><span class="line">      handleResult()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 网路请求二:</span></span><br><span class="line">$ajax(&#123;</span><br><span class="line">    url: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;结果1&#x27;</span>);</span><br><span class="line">      isResult2 = <span class="literal">true</span></span><br><span class="line">      handleResult()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleResult</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isResult1 &amp;&amp; isResult2) &#123;</span><br><span class="line">      <span class="comment">// 实现业务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Promise的all方法的方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">      <span class="comment">// 网路请求一:</span></span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">          url: <span class="string">&#x27;url1&#x27;</span>,</span><br><span class="line">          success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            resolve(data)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="comment">// 网路请求二:</span></span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">          url: <span class="string">&#x27;url2&#x27;</span>,</span><br><span class="line">          success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            resolve(data)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">]).then(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 第一个网路请求</span></span><br><span class="line">    <span class="built_in">console</span>.log(results[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 第二个网路请求</span></span><br><span class="line">    <span class="built_in">console</span>.log(results[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>Promise.all()的参数是一个<code>可迭代对象iterator</code>，也就是可遍历的，数组只是其中之一。</li>
<li>resolve(data)：中的data不只可以是一个数值，也可以是一个对象。</li>
</ul>
</li>
</ul>
<h3 id="3、Promise三种状态"><a href="#3、Promise三种状态" class="headerlink" title="3、Promise三种状态"></a>3、Promise三种状态</h3><p>当我们开发中有异步操作时, 就可以给异步操作包装一个Promise。异步操作之后会有三种状态：</p>
<p><img src="VUE/156.png" alt="image-20210329224000758"></p>
<ul>
<li>pending：等待状态，比如正在进行网络请求，或者定时器没有到时间。</li>
<li>fulfill：满足状态，当我们主动回调了resolve时，就处于该状态，并且会回调.then()</li>
<li>reject：拒绝状态，当我们主动回调了reject时，就处于该状态，并且会回调.catch()</li>
</ul>
<h2 id="十、Vuex"><a href="#十、Vuex" class="headerlink" title="十、Vuex"></a>十、Vuex</h2><h3 id="1、什么是Vuex"><a href="#1、什么是Vuex" class="headerlink" title="1、什么是Vuex"></a>1、什么是Vuex</h3><p><a target="_blank" rel="noopener" href="https://vuex.vuejs.org/zh/">官方</a>解释：Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。</p>
<ul>
<li>它采用<strong>集中式存储管理</strong>应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</li>
<li>Vuex 也集成到 Vue 的官方调试工具 <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-devtools">devtools</a><a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-devtools"> extension</a>，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。</li>
</ul>
<p>是什么<strong>状态管理</strong>？</p>
<ul>
<li><strong>状态管理模式、集中式存储管理</strong>这些名词听起来就非常高大上，让人捉摸不透。</li>
<li>其实，你可以简单的将其看成把<strong>需要多个组件共享的变量</strong>全部存储在一个单一对象里面。</li>
<li>然后，将这个单一对象放在顶层的Vue实例中，让其他组件可以使用。</li>
<li>那么，多个组件就可以共享这个对象中的所有变量属性了。</li>
</ul>
<p>如果是这样的话，为什么官方还要专门出一个插件Vuex呢？难道我们不能自己封装一个对象来管理吗？</p>
<ul>
<li>当然可以，只是我们要先想想VueJS带给我们最大的便利是什么呢？没错，就是<strong>响应式</strong>。</li>
<li>如果你自己封装实现一个对象能不能保证它里面所有的属性做到响应式呢？当然也可以，只是自己封装可能稍微麻烦一些。</li>
</ul>
<p><strong>总结：Vuex就是为了提供这样一个在多个组件间共享状态的插件，同时又具备响应式的特点。</strong></p>
<h3 id="2、需要管理的状态"><a href="#2、需要管理的状态" class="headerlink" title="2、需要管理的状态"></a>2、需要管理的状态</h3><p>有什么状态时需要我们在多个组件间共享的呢？</p>
<ul>
<li>如果你做过大型开放，你一定遇到过多个状态，在多个界面间的共享问题。</li>
<li>比如用户的<strong>登录状态（token）</strong>、用户名称、头像、地理位置信息等等。</li>
<li>比如商品的收藏、购物车中的物品等等。</li>
</ul>
<p>这些状态信息，都是在很多组件里需要使用到的，我们可以放在Vuex中，对它们进行保存和管理，而且它们还是响应式的。</p>
<h3 id="3、界面的状态管理"><a href="#3、界面的状态管理" class="headerlink" title="3、界面的状态管理"></a>3、界面的状态管理</h3><h4 id="1、单界面的状态管理"><a href="#1、单界面的状态管理" class="headerlink" title="1、单界面的状态管理"></a>1、单界面的状态管理</h4><p>要在单个组件中进行状态管理是一件非常简单的事情。具体看下图：</p>
<p>单界面状态管理的图示：</p>
<p><img src="VUE/157.png" alt="image-20210330013105126"></p>
<ul>
<li>State：就是我们的状态。（你姑且可以当做就是data中的属性变量）</li>
<li>View：视图层，可以针对State的变化，显示不同的信息。</li>
<li>Actions：这里的Actions主要是用户的各种操作：点击、输入等等，会导致状态的改变。</li>
</ul>
<p>单界面图解（从State开始）：</p>
<p>State就是我们的状态，也就是data中的属性 =&gt; 我们可以将State展示到浏览器上，也就是View层 =&gt; 在浏览器View上，我们可以经过一些Actions行为（如点击/滑动等等）去改变State属性的值 =&gt; 浏览器响应式的将改变后的State属性返回到State</p>
<p>案例：状态管理<code>个数counter</code></p>
<p><img src="VUE/155.png" alt="image-20210330133234214"></p>
<ul>
<li>counter需要某种方式被记录下来，也就是我们的State。</li>
<li>counter目前的值需要被显示在界面中，也就是我们的View部分。</li>
<li>界面发生某些操作时（我们这里是用户的点击，也可以是用户的input），需要去更新状态State，也就是我们的Actions.</li>
</ul>
<h4 id="2、多界面状态管理"><a href="#2、多界面状态管理" class="headerlink" title="2、多界面状态管理"></a>2、多界面状态管理</h4><p>Vue已经帮我们做好了单个界面的状态管理，但是如果是多个界面呢？</p>
<ul>
<li>多个视图都依赖同一个状态（一个状态改了，多个界面需要进行更新）</li>
<li>不同界面的Actions都想修改同一个状态（Home.vue需要修改，Profile.vue也需要修改这个状态）</li>
<li>也就是说对于某些状态(状态1/状态2/状态3)来说只属于我们某一个试图，但是也有一些状态(状态a/状态b/状态c)属于多个试图共同想要维护的</li>
<li>状态1/状态2/状态3你放在自己的房间中，你自己管理自己用，没问题。但是状态a/状态b/状态c我们希望交给一个大管家来统一帮助我们管理！！！</li>
<li>这个帮助我们管理的大管家就是Vuex。</li>
</ul>
<p><strong>全局单例模式（大管家）</strong></p>
<ul>
<li>我们现在要做的就是将共享的状态抽取出来，交给Vuex统一进行管理。</li>
<li>之后，你们每个试图，按照我<strong>规定好的</strong>规定，进行访问和修改等操作。</li>
<li>这就是Vuex背后的基本思想。</li>
</ul>
<p>多界面状态管理的图示：</p>
<p><img src="VUE/159.png" alt="image-20210330143646693"></p>
<p>图解：</p>
<ul>
<li>Mutations与Devtools：<ul>
<li>Vue开发的一个浏览器插件。安装在浏览器上，为后续的Vuex开发提供的插件。</li>
<li>作用：记录浏览器每次修改State的状态，让你清楚地跟踪到是哪一个组件修改了State，发生错误的时候也可以及时精准定位到出错的组件，对其代码进行修改。大大提高了开发效率。</li>
<li>但这个插件实现的前提是修改的数据有经过Mutations进入到State。所以官方不推荐将数据直接从Vue Component发回State，没经过Mutations，devtools就不能对State进行实时跟踪。</li>
<li>在Mutations里一般都是同步操作，如果需求中没有异步操作，也可以从Vue Component直接发送到Mutations。官方没有说这样做不可以</li>
<li>在没有使用Devtools时，由于每个组件都在使用State，使用很难跟踪到哪个组件对State进行修改。当某一个组件错误的修改了数据State，这个时候将很难进行查错。</li>
</ul>
</li>
<li>Actions与Mutations：<ul>
<li>在Actions中实现业务的异步操作，发送网络请求与后台API接口进行数据交互。</li>
<li>由于在Mutations中不能追踪到异步操作的State，所以将异步操作放在Actions当中进行处理。</li>
<li>经Actions处理过后变成同步操作在交由Mutations中的Devtools进行State追踪。</li>
<li>如果业务不需要进行异步操作，可以跳过Actions直接发送给Mutations进行追踪。</li>
</ul>
</li>
</ul>
<h3 id="4、Vuex的使用"><a href="#4、Vuex的使用" class="headerlink" title="4、Vuex的使用"></a>4、Vuex的使用</h3><p>案例：两个组件同时使用<code>属性count</code>，使用Vuex管理count</p>
<p>实现步骤：</p>
<ol>
<li><p>首先，我们需要在某个地方存放我们的Vuex代码：</p>
<p>这里，我们先创建一个文件夹store，并且在其中创建一个index.js文件。</p>
</li>
<li><p>其次，我们让所有的Vue组件都可以使用这个store对象，</p>
<p>来到main.js文件，导入store对象，并且放在new Vue中，</p>
<p>这样，在其他Vue组件中，我们就可以通过this.$store的方式，获取到这个store对象了。</p>
</li>
<li><p>提取出一个公共的store对象，用于保存在多个组件中共享的状态</p>
</li>
<li><p>将store对象放置在new Vue对象中，这样可以保证在所有的组件中都可以使用到</p>
</li>
<li><p>在其他组件中使用store对象中保存的状态即可</p>
<ul>
<li>通过this.$store.state.属性的方式来访问状态</li>
<li>通过this.$store.commit(‘mutation中方法’)来修改状态</li>
</ul>
</li>
<li><p>注意事项：</p>
<ul>
<li>我们通过提交mutation的方式，而非直接改变store.state.count。</li>
<li>这是因为Vuex可以更明确的追踪状态的变化，所以不要直接改变store.state.count的值。</li>
</ul>
</li>
</ol>
<p>代码：</p>
<ol>
<li><p>在src下建立<code>store</code>（仓库）文件夹，在里面创建index.js文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.安装插件</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建对象</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">      count: <span class="number">1000</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">      <span class="comment">// 方法</span></span><br><span class="line">      <span class="function"><span class="title">incrememt</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">          state.counr++</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">deincrememt</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">          state.counr--</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">      </span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">      </span><br><span class="line">  &#125;,</span><br><span class="line">  modules: &#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.导出store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>

<p>在main.js中挂载：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  store,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在两个组件中使用Vuex管理的count：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2&gt;&#123;&#123;$store.state.counter&#125;&#125;&lt;&#x2F;h2&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在两个组件中使用Vuex的mutations去修改State的值：使用this.$store.commit(对应方法名)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">	  addition() &#123;</span><br><span class="line">        this.$store.commit(INCREMENT)</span><br><span class="line">      &#125;,</span><br><span class="line">      subtraction() &#123;</span><br><span class="line">        this.$store.commit(&#39;decrement&#39;)</span><br><span class="line">      &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="5、Vuex的五大属性"><a href="#5、Vuex的五大属性" class="headerlink" title="5、Vuex的五大属性"></a>5、Vuex的五大属性</h3><ul>
<li>State</li>
<li>Getters</li>
<li>Mutation</li>
<li>Action</li>
<li>Module</li>
</ul>
<h4 id="1、State"><a href="#1、State" class="headerlink" title="1、State"></a>1、State</h4><h5 id="单一状态树"><a href="#单一状态树" class="headerlink" title="单一状态树"></a>单一状态树</h5><p>Vuex提出使用单一状态树, 什么是单一状态树呢？</p>
<p>英文名称是Single Source of Truth，也可以翻译成<strong>单一数据源</strong>。</p>
<p>来看一个生活中的例子。</p>
<ul>
<li>OK，我用一个生活中的例子做一个简单的类比。</li>
<li>我们知道，在国内我们有很多的信息需要被记录，比如上学时的个人档案，工作后的社保记录，公积金记录，结婚后的婚姻信息，以及其他相关的户口、医疗、文凭、房产记录等等（还有很多信息）。</li>
<li>这些信息被分散在很多地方进行管理，有一天你需要办某个业务时(比如入户某个城市)，你会发现你需要到各个对应的工作地点去打印、盖章各种资料信息，最后到一个地方提交证明你的信息无误。</li>
<li>这种保存信息的方案，不仅仅低效，而且不方便管理，以及日后的维护也是一个庞大的工作(需要大量的各个部门的人力来维护，当然国家目前已经在完善我们的这个系统了)。</li>
</ul>
<p>这个和我们在应用开发中比较类似：</p>
<ul>
<li>如果你的状态信息是保存到多个Store对象中的，那么之后的管理和维护等等都会变得特别困难。</li>
<li>所以Vuex也使用了单一状态树来管理应用层级的全部状态。</li>
<li>单一状态树能够让我们最直接的方式找到某个状态的片段，而且在之后的维护和调试过程中，也可以非常方便的管理和维护。</li>
</ul>
<h4 id="2、Getters"><a href="#2、Getters" class="headerlink" title="2、Getters"></a>2、Getters</h4><h5 id="1、Getters作为全局的computed"><a href="#1、Getters作为全局的computed" class="headerlink" title="1、Getters作为全局的computed"></a>1、Getters作为全局的computed</h5><p>我们需要从store中获取一些state变异后的状态。在单一界面中，我们是通过计算属性computed实现data的一些修改后的数据。然而在多界面中，我们通过Vuex进行管理。若仍使用单一界面的方法，用computed修改Store里State的值（$store.state.counter），则每一个需要用到State的组件都得使用computed，会增加很多冗余的代码。而使用Vuex的getters对State做统一的处理，让有需要的组件直接调用即可。</p>
<p>案例：获取学生年龄大于20的个数</p>
<p>Vuex的State：</p>
<p><img src="VUE/158.png" alt="image-20210330203308770"></p>
<ul>
<li><p>方式一：使用computed</p>
<p><img src="VUE/163.png" alt="image-20210330204204000"></p>
</li>
<li><p>方式二：使用getters</p>
<p><img src="VUE/164.png" alt="获取"></p>
</li>
</ul>
<h5 id="2、Getters作为参数和传递参数"><a href="#2、Getters作为参数和传递参数" class="headerlink" title="2、Getters作为参数和传递参数"></a>2、Getters作为参数和传递参数</h5><h6 id="1、将Getters作为参数，通过调用Getters的方法进行获取"><a href="#1、将Getters作为参数，通过调用Getters的方法进行获取" class="headerlink" title="1、将Getters作为参数，通过调用Getters的方法进行获取"></a>1、将Getters作为参数，通过调用Getters的方法进行获取</h6><p>如果我们已经通过getters获取了一个所有年龄大于20岁学生列表，那么怎么拿到学生列表的长度：</p>
<p><img src="VUE/162.png" alt="image-20210330203841286"></p>
<h6 id="2、Getters传递参数"><a href="#2、Getters传递参数" class="headerlink" title="2、Getters传递参数"></a>2、Getters传递参数</h6><p>getters默认是<strong>不能传递参数</strong>的, 如果希望传递参数, 那么只能<strong>让getters本身返回另一个函数</strong>。</p>
<p>比如上面的案例中,我们希望根据我们输入的age来获取年龄大于age的用户的信息（不写死）：</p>
<p>index.js：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">moreAgeStu</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">age</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.students.filter(<span class="function"><span class="params">s</span> =&gt;</span> s.age &gt; age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他组件调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2&gt;&#123;&#123;$store.getters.moreAgeStu(12)&#125;&#125;&lt;&#x2F;h2&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3、Mutation"><a href="#3、Mutation" class="headerlink" title="3、Mutation"></a>3、Mutation</h4><h5 id="1、状态更新"><a href="#1、状态更新" class="headerlink" title="1、状态更新"></a>1、状态更新</h5><p>官方：Vuex的store状态的更新唯一方式：<strong>提交Mutation</strong></p>
<p>Mutation主要包括两部分：</p>
<ul>
<li>字符串的<strong>事件类型（type）</strong></li>
<li>一个<strong>回调函数（handler）</strong>,该回调函数的<strong>第一个参数就是state</strong></li>
</ul>
<p>如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">decrement</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">    state.counter--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中</p>
<ul>
<li>decrement：事件类型（type）</li>
<li>(state){}：回调函数（handler），第一个参数就是state。</li>
</ul>
<p>通过mutation更新：this.commit(“事件类型”)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">subtraction() &#123;</span><br><span class="line">  this.$store.commit(&#39;decrement&#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、传递参数"><a href="#2、传递参数" class="headerlink" title="2、传递参数"></a>2、传递参数</h5><p>在通过mutation更新数据的时候, 有可能我们希望携带一些<strong>额外的参数</strong></p>
<p>参数被称为是mutation的载荷(Payload)，但需要记住：mutation的回调函数的第一个参数就是state，第二个才是载荷(Payload)。</p>
<h6 id="1、传递一个参数"><a href="#1、传递一个参数" class="headerlink" title="1、传递一个参数"></a>1、传递一个参数</h6><p><img src="VUE/165.png" alt="image-20210330232321987"></p>
<h6 id="2、传递多个参数（封装成一个对象）"><a href="#2、传递多个参数（封装成一个对象）" class="headerlink" title="2、传递多个参数（封装成一个对象）"></a>2、传递多个参数（封装成一个对象）</h6><ul>
<li>比如我们有很多参数需要传递。</li>
<li>这个时候, 我们通常会<strong>以对象的形式传递</strong>, 也就是<strong>payload是一个对象</strong>。</li>
<li>这个时候可以再<strong>从对象中取出相关的信息</strong>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stu = &#123;<span class="attr">id</span>: <span class="number">114</span>, <span class="attr">name</span>: <span class="string">&#x27;alan&#x27;</span>, <span class="attr">age</span>: <span class="number">35</span>&#125;</span><br><span class="line"><span class="function"><span class="title">addStudent</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;addStudent&#x27;</span>, stu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、提交风格"><a href="#3、提交风格" class="headerlink" title="3、提交风格"></a>3、提交风格</h5><p>上面的通过<strong>commit</strong>进行提交是一种普通的方式。</p>
<p>Vue还提供了另外一种风格, 它是一个包含type属性的对象。</p>
<ul>
<li><p>特殊提交：因为变成了一个对象，里面除了count以外，还可以放入age等等，所以在Mutations的实现中需要使用payload.xxx的方式拿到xxx的值，否则直接拿到的xxx是一个payload对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">addCount</span>(<span class="params">count</span>)</span> &#123;</span><br><span class="line">   <span class="comment">// 2.特殊的提交封装</span></span><br><span class="line">   <span class="built_in">this</span>.$store.commit(&#123;</span><br><span class="line">       type: <span class="string">&#x27;incrementCount&#x27;</span>,</span><br><span class="line">       count</span><br><span class="line">   &#125;)     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Mutation中的处理方式是<strong>将整个commit的对象作为payload使用</strong>, 所以代码没有改变, 依然如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">incrementCount(state, payload) &#123;</span><br><span class="line">    state.counter +&#x3D; payload.count</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="4、响应规则（新版2-6-12以上不同，看总结）"><a href="#4、响应规则（新版2-6-12以上不同，看总结）" class="headerlink" title="4、响应规则（新版2.6.12以上不同，看总结）"></a>4、响应规则（新版2.6.12以上不同，看总结）</h5><p>Vuex的store中的state是响应式的, 当state中的数据发生改变时, Vue组件会自动更新。</p>
<p>原理：（观察者模式：监听 -&gt; 发现变化 -&gt; 刷新页面）</p>
<ul>
<li><p>在我们创建好store对象时已经将state里的所有的属性，所有的对象放在vue的响应式系统里面了</p>
</li>
<li><p>之后vue都会观察着在state中每一个属性/对象的变化。</p>
</li>
<li><p>vue会为每个属性对象设定Dep，每一个属性对象对应着一个Dep，这个Dep可以监听属性对象的变化（观察者模式），而Dep对应着许多Watcher，Dep里有一个Watcher数组，里面就是所有与该属性数据绑定的地方。一旦属性数据发生变化，它会看一下（Watcher）有哪些地方会根据数据的变化去刷新页面的。</p>
<p><img src="VUE/166.png" alt="属性被添加到响应式系统中"></p>
</li>
</ul>
<p>但这就要求我们必须遵守一些Vuex对应的规则:</p>
<ol>
<li><strong>提前在store中初始化好所需的属性</strong>。</li>
<li>当给state中的对象添加/删除新属性时, 使用下面的方式：<ul>
<li>方式一: 使用Vue.set(obj, ‘newProp’, 123)</li>
<li>方式二: 用新对象给旧对象重新赋值</li>
</ul>
</li>
</ol>
<p>对应规则讲解：</p>
<ul>
<li><p>规则1：info:{name: ‘why’,age: 18}，给info添加属性height: 1.88</p>
<p><img src="VUE/167.png" alt="image-20210331001216170"></p>
<p><strong>提前在store中初始化好所需的属性</strong>。对已经创建store对象之后在进行初始化的属性并不会加入Vue的响应式系统里面。虽然声明了属性并成功赋值了，但没有响应。</p>
</li>
<li><p>规则2：若要实现在创建store对象之后添加或删除的属性，而且要实现响应式，怎么做？</p>
<p><img src="VUE/168.png" alt="image-20210331001552856"></p>
<p>删除也一样，如果在Mutations中使用delete方式<code>delete state.info.age</code>进行实现删除，并不会实现响应式。但如果使用Vue.delete<code>Vue.delete(state.info,&#39;age&#39;)</code>的话就可以实现响应式，给info赋值一个新的对象也是。</p>
</li>
</ul>
<p>总结：以上规则在旧版本是这样的，但在新版本2.12.6以上不一样了，区别：</p>
<ul>
<li>如果你在方法里面使用与响应式相关的东西（如修改响应式数据，Vue.set、Vue.delete等等），这个时候使用非响应式的方式修改属性数据是可以做到响应式的。</li>
<li>但是，如果你在方法里面没有使用与响应式相关的东西，直接就是一些非响应式的操作，那么就不能实现响应式。</li>
<li>新版本同时写了响应式和非响应式的操作，在使用响应式的基础上，非响应式的也显示了。但是单单写非响应式的操作并不能实现响应式。</li>
</ul>
<h5 id="5、Mutation常量类型"><a href="#5、Mutation常量类型" class="headerlink" title="5、Mutation常量类型"></a>5、Mutation常量类型</h5><p>我们来考虑下面的问题:</p>
<ul>
<li>在mutation中, 我们定义了很多事件类型(也就是其中的方法名称)。</li>
<li>当我们的项目增大时, Vuex管理的状态越来越多, 需要更新状态的情况越来越多, 那么意味着Mutation中的方法越来越多。</li>
<li>方法过多, 使用者需要花费大量的经历去记住这些方法, 甚至是多个文件间来回切换, 查看方法名称, 甚至如果不是复制的时候, 可能还会出现写错的情况。</li>
</ul>
<p>如何避免上述的问题呢?</p>
<ul>
<li>在各种Flux实现中, 一种很常见的方案就是使用<strong>常量</strong>替代<strong>Mutation事件的类型</strong>。</li>
<li>我们可以将这些常量放在一个<strong>单独的文件</strong>中, 方便管理以及让整个app所有的事件类型一目了然。</li>
</ul>
<p>具体怎么实现?</p>
<ul>
<li>我们可以创建一个文件: mutation-types.js, 并且在其中定义我们的常量。</li>
<li>定义常量时, 我们可以使用ES2015中的风格, 使用一个常量来作为函数的名称。</li>
</ul>
<p><img src="VUE/169.png" alt="image-20210331003230794"></p>
<p>官网：用不用常量取决于你——在需要多人协作的大型项目中，这会很有帮助。但如果你不喜欢，你完全可以不这样做。</p>
<h5 id="6、同步函数"><a href="#6、同步函数" class="headerlink" title="6、同步函数"></a>6、同步函数</h5><p>通常情况下, Vuex要求我们Mutation中的方法必须是同步方法。</p>
<ul>
<li><p>主要的原因是当我们使用devtools时, 可以devtools可以帮助我们捕捉mutation的快照。</p>
</li>
<li><p>比如我们之前的代码, 当执行更新时, devtools中会有如下信息：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">updateInfo</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">	state.info.name = <span class="string">&#x27;codewhy&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="VUE/172.png" alt="image-20210331004509394"></p>
</li>
<li><p>但是如果是异步操作, 那么devtools将不能很好的追踪这个操作什么时候会被完成。即不能实现State跟踪。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">updateInfo</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span>&#123;</span><br><span class="line">		state.info.name = <span class="string">&#x27;codewhy&#x27;</span></span><br><span class="line">	&#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="VUE/173.png" alt="image-20210331004903309"></p>
</li>
</ul>
<p><strong>总结：通常情况下, 不要再mutation中进行异步的操作。</strong></p>
<h4 id="4、Actions"><a href="#4、Actions" class="headerlink" title="4、Actions"></a>4、Actions</h4><h5 id="1、基本定义"><a href="#1、基本定义" class="headerlink" title="1、基本定义"></a>1、基本定义</h5><p>我们强调, 不要再Mutation中进行异步操作。但是某些情况, 我们确实希望在Vuex中进行一些异步操作, 比如网络请求, 必然是异步的。这个时候怎么处理呢?</p>
<p>Action类似于Mutation, 但是是用来代替Mutation进行异步操作的。</p>
<p>Action的基本使用代码：</p>
<p>index.js：</p>
<p>注意：这里的commit是在使用Mutations当中的updateInfo方法进行数据更改。通过这个方法将数据经过Mutations，使Devtools可以跟踪到。因为Actions到Mutations中间就是commit。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.安装插件</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建对象</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">      info: &#123;</span><br><span class="line">          name: <span class="string">&#x27;koby&#x27;</span>,</span><br><span class="line">          age: <span class="number">18</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="function"><span class="title">updateInfo</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      state.info.name = <span class="string">&#x27;coderwhy&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">      <span class="comment">// context: 上下文</span></span><br><span class="line">	  <span class="function"><span class="title">aUpdateInfo</span>(<span class="params">context, payload</span>)</span> &#123;</span><br><span class="line">    	<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      	  context.commit(<span class="string">&#x27;updateInfo&#x27;</span>)</span><br><span class="line">      	  <span class="built_in">console</span>.log(payload.message);</span><br><span class="line">      	  payload.success()</span><br><span class="line">    	&#125;, <span class="number">1000</span>)</span><br><span class="line">  	  &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">      </span><br><span class="line">  &#125;,</span><br><span class="line">  modules: &#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.导出store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>

<p>组件：</p>
<p>注意：在这里不能使用this.#store.commit，因为现在是使用Actions里的方法进行异步操作，如果在这里使用commit，相当于将数据直接从Actions发送到了State，没有经过Mutations。Devtools不能进行属性跟踪。也违反了：Vuex的store状态的更新唯一方式：<strong>提交Mutation</strong>。而通过多界面状态管理图也可以发现：Actions到Mutations是dispatch，不是commit。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">updateInfo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;aUpdateInfo&#x27;</span>, &#123;</span><br><span class="line">    	message: <span class="string">&#x27;我是携带的信息&#x27;</span>,</span><br><span class="line">    	success: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    		<span class="built_in">console</span>.log(<span class="string">&#x27;里面已经完成了&#x27;</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>context是什么?</p>
<ul>
<li>context是和store对象具有相同方法和属性的对象。</li>
<li>也就是说, 我们可以通过context去进行commit相关的操作, 也可以获取context.state等。</li>
<li>但是注意, 这里它们并不是同一个对象, 为什么呢? 我们后面学习Modules的时候, 再具体说。</li>
</ul>
<p>这样的代码是否多此一举呢?</p>
<ul>
<li>我们定义了actions, 然后又在actions中去进行commit, 这不是脱裤放屁吗?</li>
<li>事实上并不是这样, 如果在Vuex中有异步操作, 那么我们就可以在actions中完成了。</li>
</ul>
<h5 id="2、Actions返回的Promise"><a href="#2、Actions返回的Promise" class="headerlink" title="2、Actions返回的Promise"></a>2、Actions返回的Promise</h5><p>前面我们学习ES6语法的时候说过, Promise经常用于异步操作。而Actions又是让我们实现异步操作的地方，所以能不能在Actions中使用Promise进行异步操作呢？</p>
<p>在Actions中, 我们可以将异步操作放在一个Promise中, 并且在成功或者失败后, 调用对应的resolve或reject</p>
<p>修改上面代码：</p>
<p>index.js：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">aUpdateInfo</span>(<span class="params">context, payload</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        context.commit(<span class="string">&#x27;updateInfo&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(payload);</span><br><span class="line">	   <span class="comment">// 在返回的时候还能携带信息</span></span><br><span class="line">        resolve(<span class="string">&#x27;1111111&#x27;</span>)</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">updateInfo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.$store</span><br><span class="line">      .dispatch(<span class="string">&#x27;aUpdateInfo&#x27;</span>, <span class="string">&#x27;我是携带的信息&#x27;</span>)</span><br><span class="line">          .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;里面完成了提交&#x27;</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(res);</span><br><span class="line">          &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>其实本质上就是链式调用：</p>
<ol>
<li>在组件中使用<code>aUpdateInfo</code>去Actions里调用aUpdateInfo实现异步操作，同时传过去一些参数（’我是携带的信息’）</li>
<li>由于组件用了aUpdateInfo，在Actions中调用aUpdateInfo方法实现一些异步操作，同时使用<code>updateInfo</code>去Mutations里调用updateInfo方法实现store状态的更新，并Devtools实现State跟踪，而且还使用了组件传递过来的参数。最后返回一个Promise对象，在异步操作成功的时候进行resolve()/reject()，告诉组件这次异步操作成功还是失败，还可以向组件传递一些参数。</li>
<li>组件在使用<code>aUpdateInfo</code>去Actions里实现的时候就在等待Actions中的异步操作是否成功。因为Actions返回一个Promise对象，在组件里执行dispatch成功后就表示这次异步操作已经成功了（因为dispatch失败的话就会报错）由于异步操作成功实现，resolve()会进入到组件的then()当中，组件在then当中就可以获取来自Actions的一些消息和参数并使用。</li>
</ol>
<h4 id="5、Module"><a href="#5、Module" class="headerlink" title="5、Module"></a>5、Module</h4><h5 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h5><p>Module是模块的意思, 为什么在Vuex中我们要使用模块呢?</p>
<ul>
<li>Vue使用单一状态树,那么也意味着很多状态都会交给Vuex来管理。</li>
<li>当应用变得非常复杂时,store对象就有可能变得相当臃肿。</li>
<li>为了解决这个问题, Vuex允许我们将store分割成模块(Module), 而每个模块拥有自己的state、mutations、actions、getters等</li>
</ul>
<p>我们按照什么样的方式来组织模块呢? </p>
<p><img src="VUE/174.png" alt="image-20210331013941265"></p>
<h5 id="2、Module局部状态"><a href="#2、Module局部状态" class="headerlink" title="2、Module局部状态"></a>2、Module局部状态</h5><p>上面的代码中, 我们已经有了整体的组织结构, 下面我们来看看具体的局部模块中的代码如何书写。</p>
<p>我们在moduleA中添加State、Mutations、Getters、Actions，然后在组件去使用store当中模块里的这四个核心：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    name: <span class="string">&#x27;zhangsan&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="function"><span class="title">updateName</span>(<span class="params">state, payload</span>)</span> &#123;</span><br><span class="line">      state.name = payload</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    <span class="function"><span class="title">fullname</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.name + <span class="string">&#x27;11111&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">fullname2</span>(<span class="params">state, getters</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> getters.fullname + <span class="string">&#x27;2222&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">fullname3</span>(<span class="params">state, getters, rootState</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> getters.fullname2 + rootState.counter</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    <span class="function"><span class="title">aUpdateName</span>(<span class="params">context</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(context);</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        context.commit(<span class="string">&#x27;updateName&#x27;</span>, <span class="string">&#x27;wangwu&#x27;</span>)</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>State：由于Vuex是单一状态树，用a定义在moduleA模块，最后会被转化为store的State中的一个a对象。</p>
<p><img src="VUE/175.png" alt="image-20210331020306951"></p>
<p>组件：a是store的state的一个对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2&gt;&#123;&#123;$store.state.a.name&#125;&#125;&lt;&#x2F;h2&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Mutations：在模块里进行提交也是使用commit方法，但要注意：在模块的Mutations里定义的方法名不要与store当中Mutations里的方法重复。若是方法名重复的话，在组件进行commit提交的时候，不知道要提交给tore还是模块。</p>
<p>组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click&#x3D;&quot;updateName&quot;&gt;修改名字&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">updateName() &#123;</span><br><span class="line">  this.$store.commit(&#39;updateName&#39;, &#39;lisi&#39;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>Getters：</p>
<ul>
<li>组件调用时不会理会这个fullname是来自哪里的，与之前一样调用就行。</li>
<li>当中模块当中要用到之前Getters获得到的值，就需要fullname2传入第二个参数getters，通过getters去获取之前定义的值。</li>
<li>当在模块中要使用store中state里的值，在fullname3当中传入第三个参数：rootState。可以通过rootState这个参数取到store当中state里的值。</li>
</ul>
<p>组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2&gt;&#123;&#123;$store.getters.fullname&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">&lt;h2&gt;&#123;&#123;$store.getters.fullname2&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">&lt;h2&gt;&#123;&#123;$store.getters.fullname3&#125;&#125;&lt;&#x2F;h2&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Actions：在Actions里commit进行提交的时候使用的只能是模块里的Mutations中的方法，不能去使用store中Mutations当中的方法。同理store的Actions也是一样。</p>
<p>模块中的Actions的context：里面包含了很多东西：</p>
<ul>
<li><p>commit：提交到自身的Mutations</p>
</li>
<li><p>dispatch：分发到组件</p>
</li>
<li><p>getters：调用自身Getters的值</p>
</li>
<li><p>rootGetters：调用store中Getters的值</p>
</li>
<li><p>rootState：调用store中State的值</p>
<p>即在模块中使用comtext.rootState调用store里state的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(comtext.rootState.count)</span><br></pre></td></tr></table></figure>
</li>
<li><p>state：调用自身state的值</p>
</li>
</ul>
<p><img src="VUE/176.png" alt="image-20210331023258944"></p>
<p>Actions的另外一种写法：局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState</p>
<p><img src="VUE/177.png" alt="image-20210331024203961"></p>
<p>其实这就是对象的结构（ES6语法），也是对象的一种语法糖：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象的解构</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;why&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  height: <span class="number">1.88</span>,</span><br><span class="line">  address: <span class="string">&#x27;洛杉矶&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;name, height, age&#125; = obj;</span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// why</span></span><br></pre></td></tr></table></figure>

<p>同理，数组也是可以解构的，但是并不常用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> names = [<span class="string">&#x27;why&#x27;</span>,<span class="string">&#x27;koby&#x27;</span>,<span class="string">&#x27;james&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;name1,name2,name3&#125; = names</span><br><span class="line"><span class="built_in">console</span>.log(name1) <span class="comment">// why</span></span><br></pre></td></tr></table></figure>

<p>组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click&#x3D;&quot;asyncUpdateName&quot;&gt;异步修改名字&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">asyncUpdateName() &#123;</span><br><span class="line">  this.$store.dispatch(&#39;aUpdateName&#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="6、项目结构组织"><a href="#6、项目结构组织" class="headerlink" title="6、项目结构组织"></a>6、项目结构组织</h3><p>因为我有关于Vuex的使用都是在index.js当中，无论是Vuex的安装导出，还是Vuex的五大核心，特别是module模块里还可以使用四大核心。但我们的项目越来越大，越来越复杂的时候，我们的index.js就会变得十分臃肿。十分不利于我们进行查看与管理。当我们的Vuex帮助我们管理过多的内容时,我们可以将代码进行抽离</p>
<p>官方推荐：</p>
<ul>
<li>State：一般会放在index.js里面，可以在外面定义一个state变量，在store里引用。因为我们一般是希望在index.js当中可以一样看到Vuex管理的状态。（当然进行抽离也是可以的）</li>
<li>Getters/Mutations/Action：s新建成一个js文件，将在index.js里Getters/Mutations/Actions的那一部分抽离到对应的js文件当中。而在index.js里只需要导入后在store进行使用就行了。</li>
<li>Module：新建一个modules文件夹，把index.js当中定义的每一个module部分分别在modules文件夹当中建立对应的js文件。而在index.js中只需要导入后在store里的module进行对应模块的引用就行。</li>
</ul>
<p>抽离过后的index.js：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> mutations <span class="keyword">from</span> <span class="string">&#x27;./mutations&#x27;</span></span><br><span class="line"><span class="keyword">import</span> actions <span class="keyword">from</span> <span class="string">&#x27;./actions&#x27;</span></span><br><span class="line"><span class="keyword">import</span> getters <span class="keyword">from</span> <span class="string">&#x27;./getters&#x27;</span></span><br><span class="line"><span class="keyword">import</span> moduleA <span class="keyword">from</span> <span class="string">&#x27;./modules/moduleA&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.安装插件</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建对象</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  counter: <span class="number">1000</span>,</span><br><span class="line">  students: [</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="number">110</span>, <span class="attr">name</span>: <span class="string">&#x27;why&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="number">111</span>, <span class="attr">name</span>: <span class="string">&#x27;kobe&#x27;</span>, <span class="attr">age</span>: <span class="number">24</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="number">112</span>, <span class="attr">name</span>: <span class="string">&#x27;james&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="number">113</span>, <span class="attr">name</span>: <span class="string">&#x27;curry&#x27;</span>, <span class="attr">age</span>: <span class="number">10</span>&#125;</span><br><span class="line">  ],</span><br><span class="line">  info: &#123;</span><br><span class="line">    name: <span class="string">&#x27;kobe&#x27;</span>,</span><br><span class="line">    age: <span class="number">40</span>,</span><br><span class="line">    height: <span class="number">1.98</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state,</span><br><span class="line">  mutations,</span><br><span class="line">  actions,</span><br><span class="line">  getters,</span><br><span class="line"></span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.导出store独享</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>

<p>好的项目结构可以让我们的代码更加清晰：</p>
<p><img src="VUE/178.png" alt="image-20210331024637532"></p>
<h2 id="十一、网络请求模块aniox"><a href="#十一、网络请求模块aniox" class="headerlink" title="十一、网络请求模块aniox"></a>十一、网络请求模块aniox</h2><h3 id="1、网络模块的选择"><a href="#1、网络模块的选择" class="headerlink" title="1、网络模块的选择"></a>1、网络模块的选择</h3><p>Vue中发送网络请求有非常多的方式, 那么, 在开发中, 如何选择呢？</p>
<ol>
<li><p>选择一: 传统的Ajax是基于XMLHttpRequest(XHR)</p>
<p>为什么不用它呢?</p>
<ul>
<li>非常好解释, 配置和调用方式等非常混乱。</li>
<li>编码起来看起来就非常蛋疼。</li>
<li>所以真实开发中很少直接使用, 而是使用jQuery-Ajax。</li>
</ul>
</li>
<li><p>选择二: 在前面的学习中, 我们经常会使用jQuery-Ajax</p>
<p>相对于传统的Ajax非常好用。</p>
<p>为什么不选择它呢?</p>
<ul>
<li>首先, 我们先明确一点: 在Vue的整个开发中都是不需要使用jQuery了。</li>
<li>那么, 就意味着为了方便我们进行一个网络请求, 特意引用一个jQuery, 你觉得合理吗?<ul>
<li>jQuery的代码1w+行。</li>
<li>Vue的代码才1w+行。</li>
</ul>
</li>
<li>完全没有必要为了用网络请求就引用这个重量级的框架</li>
</ul>
</li>
<li><p>选择三: 官方在Vue1.x的时候, 推出了Vue-resource。</p>
<p>Vue-resource的体积相对于jQuery小很多。</p>
<p>另外Vue-resource是官方推出的。</p>
<p>为什么不选择它呢?</p>
<ul>
<li>在Vue2.0退出后, Vue作者就在GitHub的Issues中说明了去掉vue-resource, 并且以后也不会再更新。</li>
<li>那么意味着以后vue-reource不再支持新的版本时, 也不会再继续更新和维护。</li>
<li>对以后的项目开发和维护都存在很大的隐患。</li>
</ul>
</li>
<li><p>选择四: 在说明不再继续更新和维护vue-resource的同时, 作者还推荐了一个框架: axios为什么不用它呢?</p>
<ul>
<li>axios有非常多的优点, 并且用起来也非常方便。</li>
</ul>
</li>
</ol>
<h3 id="2、跨域"><a href="#2、跨域" class="headerlink" title="2、跨域"></a>2、跨域</h3><h4 id="1、为什么会出现跨域问题？"><a href="#1、为什么会出现跨域问题？" class="headerlink" title="1、为什么会出现跨域问题？"></a>1、为什么会出现跨域问题？</h4><p>出于浏览器的<strong>同源策略</strong>限制。</p>
<p>同源策略（Sameoriginpolicy）是一种约定，它是<strong>浏览器最核心也最基本的安全功能</strong>，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。</p>
<p>同源策略会<strong>阻止一个域的javascript脚本和另外一个域的内容进行交互</strong>。所谓同源（即指在同一个域）就是两个页面具有<strong>相同的<code>协议（protocol）</code>，<code>主机（host）</code>和<code>端口号（port）</code></strong></p>
<h4 id="2、什么是跨域？"><a href="#2、什么是跨域？" class="headerlink" title="2、什么是跨域？"></a>2、什么是跨域？</h4><p>当一个请求url的<strong>协议、域名、端口</strong>三者之间任意一个与当前页面url不同即为跨域。</p>
<table>
<thead>
<tr>
<th>当前页面url</th>
<th>被请求页面url</th>
<th>是否跨域</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="http://www.test.com/">http://www.test.com/</a></td>
<td><a target="_blank" rel="noopener" href="http://www.test.com/index.html">http://www.test.com/index.html</a></td>
<td>否</td>
<td>同源（协议、域名、端口号相同）</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.test.com/">http://www.test.com/</a></td>
<td><a target="_blank" rel="noopener" href="https://www.test.com/index.html">https://www.test.com/index.html</a></td>
<td>跨域</td>
<td>协议不同（http/https）</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.test.com/">http://www.test.com/</a></td>
<td><a target="_blank" rel="noopener" href="http://www.baidu.com/">http://www.baidu.com/</a></td>
<td>跨域</td>
<td>主域名不同（test/baidu）</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.test.com/">http://www.test.com/</a></td>
<td><a target="_blank" rel="noopener" href="http://blog.test.com/">http://blog.test.com/</a></td>
<td>跨域</td>
<td>子域名不同（www/blog）</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.test.com:8080/">http://www.test.com:8080/</a></td>
<td><a target="_blank" rel="noopener" href="http://www.test.com:7001/">http://www.test.com:7001/</a></td>
<td>跨域</td>
<td>端口号不同（8080/7001）</td>
</tr>
</tbody></table>
<h4 id="3、非同源限制"><a href="#3、非同源限制" class="headerlink" title="3、非同源限制"></a>3、非同源限制</h4><p>同源策略限制了一下行为：</p>
<ul>
<li>Cookie、LocalStorage 和 IndexDB 无法读取</li>
<li>DOM 和 JS 对象无法获取</li>
<li>Ajax请求发送不出去</li>
</ul>
<h4 id="4、跨域解决方法"><a href="#4、跨域解决方法" class="headerlink" title="4、跨域解决方法"></a>4、跨域解决方法</h4><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903521163182088">更多详情</a></p>
<h5 id="1、后台"><a href="#1、后台" class="headerlink" title="1、后台"></a>1、后台</h5><h6 id="1、使用nginx进行反向代理"><a href="#1、使用nginx进行反向代理" class="headerlink" title="1、使用nginx进行反向代理"></a>1、使用nginx进行反向代理</h6><p>既然跨域会产生问题，那么我们就不跨域不就完了嘛！！！</p>
<p><img src="VUE/180.png" alt="img"></p>
<p>首先我们用nginx作为代理服务器和用户交互，这样用户就只需要在80端口上进行交互就可以了，这样就避免了跨域问题，因为我们都是在80端口上进行交互的：</p>
<p>利用nginx作为反向代理的具体配置：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line"></span><br><span class="line">        listen      80; #监听80端口，可以改成其他端口</span><br><span class="line"></span><br><span class="line">        server_name  localhost; # 当前服务的域名</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line"></span><br><span class="line">            proxy_pass http://localhost:81;</span><br><span class="line"></span><br><span class="line">            proxy_redirect default;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">location /apis &#123; #添加访问目录为/apis的代理配置</span><br><span class="line"></span><br><span class="line">rewrite  ^/apis/(.*)$ /$1 break;</span><br><span class="line"></span><br><span class="line">proxy_pass  http://localhost:82;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">#以下配置省略</span><br></pre></td></tr></table></figure>

<ol>
<li>当用户发送localhost:80/时会被nginx转发到<a href="http://localhost:81服务；">http://localhost:81服务；</a></li>
<li>当界面请求接口数据时，只要以/apis 为开头，就会被nginx转发到后端接口服务器上。</li>
</ol>
<p>总结：nginx实现跨域的原理，实际就是把web项目和后端接口项目放到一个域中，这样就不存在跨域问题，然后根据请求地址去请求不同服务器（真正干活的服务器）。</p>
<h5 id="2、前端"><a href="#2、前端" class="headerlink" title="2、前端"></a>2、前端</h5><h6 id="1、设置document-domain解决无法读取非同源网页的-Cookie问题"><a href="#1、设置document-domain解决无法读取非同源网页的-Cookie问题" class="headerlink" title="1、设置document.domain解决无法读取非同源网页的 Cookie问题"></a>1、设置document.domain解决无法读取非同源网页的 Cookie问题</h6><p>因为浏览器是通过document.domain属性来检查两个页面是否同源，因此只要通过设置相同的document.domain，两个页面就可以共享Cookie（此方案仅限主域相同，子域不同的跨域应用场景。）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个页面都设置</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">&#x27;test.com&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h6 id="2、跨文档通信-API：window-postMessage"><a href="#2、跨文档通信-API：window-postMessage" class="headerlink" title="2、跨文档通信 API：window.postMessage()"></a>2、跨文档通信 API：window.postMessage()</h6><p>调用postMessage方法实现父窗口<a target="_blank" rel="noopener" href="http://test1.com向子窗口http//test2.com%E5%8F%91%E6%B6%88%E6%81%AF%EF%BC%88%E5%AD%90%E7%AA%97%E5%8F%A3%E5%90%8C%E6%A0%B7%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E8%AF%A5%E6%96%B9%E6%B3%95%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E7%BB%99%E7%88%B6%E7%AA%97%E5%8F%A3%EF%BC%89">http://test1.com向子窗口http://test2.com发消息（子窗口同样可以通过该方法发送消息给父窗口）</a></p>
<p>它可用于解决以下方面的问题：</p>
<ul>
<li>页面和其打开的新窗口的数据传递</li>
<li>多窗口之间消息传递</li>
<li>页面与嵌套的iframe消息传递</li>
<li>上面三个场景的跨域数据传递</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父窗口打开一个子窗口</span></span><br><span class="line"><span class="keyword">var</span> openWindow = <span class="built_in">window</span>.open(<span class="string">&#x27;http://test2.com&#x27;</span>, <span class="string">&#x27;title&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 父窗口向子窗口发消息(第一个参数代表发送的内容，第二个参数代表接收消息窗口的url)</span></span><br><span class="line">openWindow.postMessage(<span class="string">&#x27;Nice to meet you!&#x27;</span>, <span class="string">&#x27;http://test2.com&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>调用message事件，监听对方发送的消息</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听 message 消息</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.source); <span class="comment">// e.source 发送消息的窗口</span></span><br><span class="line">  <span class="built_in">console</span>.log(e.origin); <span class="comment">// e.origin 消息发向的网址</span></span><br><span class="line">  <span class="built_in">console</span>.log(e.data);   <span class="comment">// e.data   发送的消息</span></span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h6 id="3、JSONP"><a href="#3、JSONP" class="headerlink" title="3、JSONP"></a>3、JSONP</h6><p>JSONP 是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，兼容性好（兼容低版本IE），缺点是只支持get请求，不支持post请求。</p>
<p>核心思想：网页通过添加一个<script>元素，向服务器请求 JSON 数据，服务器收到请求后，将数据放在一个指定名字的回调函数的参数位置传回来。</p>
<ol>
<li><p>原生实现：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://test.com/data.php?callback=dosomething&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">// 向服务器test.com发出请求，该请求的查询字符串有一个callback参数，用来指定回调函数的名字</span><br><span class="line"> </span><br><span class="line">// 处理服务器返回回调函数的数据</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">dosomething</span>(<span class="params">res</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 处理获得的数据</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(res.data)</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>jQuery ajax：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">&#x27;http://www.test.com:8080/login&#x27;</span>,</span><br><span class="line">    type: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    dataType: <span class="string">&#x27;jsonp&#x27;</span>,  <span class="comment">// 请求方式为jsonp</span></span><br><span class="line">    jsonpCallback: <span class="string">&quot;handleCallback&quot;</span>,    <span class="comment">// 自定义回调函数名</span></span><br><span class="line">    data: &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Vue.js：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$http.jsonp(<span class="string">&#x27;http://www.domain2.com:8080/login&#x27;</span>, &#123;</span><br><span class="line">    params: &#123;&#125;,</span><br><span class="line">    jsonp: <span class="string">&#x27;handleCallback&#x27;</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res); </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h6 id="4、CORS"><a href="#4、CORS" class="headerlink" title="4、CORS"></a>4、CORS</h6><p>CORS 是跨域资源分享（Cross-Origin Resource Sharing）的缩写。它是 W3C 标准，属于跨源 AJAX 请求的根本解决方法。</p>
<ol>
<li><p><strong>普通跨域请求：只需服务器端设置Access-Control-Allow-Origin</strong></p>
</li>
<li><p><strong>带cookie跨域请求：前后端都需要进行设置</strong></p>
<p><strong>【前端设置】</strong></p>
<p>根据xhr.withCredentials字段判断是否带有cookie：</p>
<ol>
<li><p>原生ajax：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest(); <span class="comment">// IE8/9需用window.XDomainRequest兼容</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">xhr.open(<span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;http://www.domain2.com:8080/login&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br><span class="line">xhr.send(<span class="string">&#x27;user=admin&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">        alert(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>jQuery ajax：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">   url: <span class="string">&#x27;http://www.test.com:8080/login&#x27;</span>,</span><br><span class="line">   type: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">   data: &#123;&#125;,</span><br><span class="line">   xhrFields: &#123;</span><br><span class="line">       withCredentials: <span class="literal">true</span>    <span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">   &#125;,</span><br><span class="line">   crossDomain: <span class="literal">true</span>,   <span class="comment">// 会让请求头中包含跨域的额外信息，但不会含cookie</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>vue-resource：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.http.options.credentials = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>axios：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.withCredentials = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>【服务端设置】</strong></p>
<p>服务器端对于CORS的支持，主要是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。</p>
<ol>
<li><p>Java后台：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 导入包：import javax.servlet.http.HttpServletResponse;</span></span><br><span class="line"><span class="comment"> * 接口参数中定义：HttpServletResponse response</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 允许跨域访问的域名：若有端口需写全（协议+域名+端口），若没有端口末尾不用加&#x27;/&#x27;</span></span><br><span class="line">response.setHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;http://www.domain1.com&quot;</span>); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 允许前端带认证cookie：启用此项后，上面的域名不能为&#x27;*&#x27;，必须指定具体的域名，否则浏览器会提示</span></span><br><span class="line">response.setHeader(<span class="string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="string">&quot;true&quot;</span>); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 提示OPTIONS预检时，后端需要设置的两个常用自定义头</span></span><br><span class="line">response.setHeader(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;Content-Type,X-Requested-With&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Nodejs后台</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line"><span class="keyword">var</span> qs = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> postData = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 数据块接收中</span></span><br><span class="line">    req.addListener(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">        postData += chunk;</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 数据接收完毕</span></span><br><span class="line">    req.addListener(<span class="string">&#x27;end&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        postData = qs.parse(postData);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 跨域后台设置</span></span><br><span class="line">        res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">            <span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span>: <span class="string">&#x27;true&#x27;</span>,     <span class="comment">// 后端允许发送Cookie</span></span><br><span class="line">            <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="string">&#x27;http://www.domain1.com&#x27;</span>,    <span class="comment">// 允许访问的域（协议+域名+端口）</span></span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">             * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)，</span></span><br><span class="line"><span class="comment">             * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="string">&#x27;Set-Cookie&#x27;</span>: <span class="string">&#x27;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&#x27;</span>  <span class="comment">// HttpOnly的作用是让js无法读取cookie</span></span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        res.write(<span class="built_in">JSON</span>.stringify(postData));</span><br><span class="line">        res.end();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">server.listen(<span class="string">&#x27;8080&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Server is running at port 8080...&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>PHP后台：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> header(<span class="string">&quot;Access-Control-Allow-Origin:*&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Apache需要使用mod_headers模块来激活HTTP头的设置，它默认是激活的。你只需要在Apache配置文件的<Directory>, <Location>, <Files>或<VirtualHost>的配置里加入以下内容即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Header set Access-Control-Allow-Origin *</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h3 id="3、JSONP的封装"><a href="#3、JSONP的封装" class="headerlink" title="3、JSONP的封装"></a>3、JSONP的封装</h3><h4 id="1、什么是JSONP"><a href="#1、什么是JSONP" class="headerlink" title="1、什么是JSONP"></a>1、什么是JSONP</h4><p>在前端开发中, 我们一种常见的网络请求方式就是JSONP：使用JSONP最主要的原因往往是为了解决跨域访问的问题。</p>
<p>JSONP的原理是什么呢?</p>
<ul>
<li>JSONP的核心在于通过<script>标签的src来帮助我们请求数据。</li>
<li>原因是我们的项目部署在domain1.com服务器上时, 是不能直接访问domain2.com服务器上的资料的。</li>
<li>这个时候, 我们利用<script>标签的src帮助我们去服务器请求到数据, 将数据当做一个javascript的函数来执行, 并且执行的过程中传入我们需要的json。</li>
<li>所以, 封装jsonp的核心就在于我们监听window上的jsonp进行回调时的名称。</li>
</ul>
<p><img src="VUE/171.png" alt="image-20210331231151444"></p>
<h4 id="2、JSONP的封装"><a href="#2、JSONP的封装" class="headerlink" title="2、JSONP的封装"></a>2、JSONP的封装</h4><p><img src="VUE/170.png" alt="image-20210331231233559"></p>
<h3 id="4、认识axios"><a href="#4、认识axios" class="headerlink" title="4、认识axios"></a>4、认识axios</h3><p>更多学习：<a target="_blank" rel="noopener" href="https://www.runoob.com/vue3/vue3-ajax-axios.html">菜鸟教程</a></p>
<h4 id="1、为什么选择axios"><a href="#1、为什么选择axios" class="headerlink" title="1、为什么选择axios?"></a>1、为什么选择axios?</h4><ul>
<li><p>作者推荐：</p>
<p><img src="VUE/161.png" alt="image-20210331231358415"></p>
</li>
<li><p>功能特点:</p>
<ul>
<li>在浏览器中发送 XMLHttpRequests 请求</li>
<li>在 node.js 中发送 http请求</li>
<li>支持 Promise API</li>
<li>拦截请求和响应</li>
<li>转换请求和响应数据</li>
<li>….</li>
</ul>
</li>
</ul>
<h4 id="2、axios请求方式"><a href="#2、axios请求方式" class="headerlink" title="2、axios请求方式"></a>2、axios请求方式</h4><p>支持多种请求方式:</p>
<ul>
<li>axios(config)</li>
<li>axios.request(config)</li>
<li>axios.get(url[, config])</li>
<li>axios.delete(url[, config])</li>
<li>axios.head(url[, config])</li>
<li>axios.post(url[, data[, config]])</li>
<li>axios.put(url[, data[, config]])</li>
<li>axios.patch(url[, data[, config]])</li>
</ul>
<p>演示：</p>
<ul>
<li><p>发送get请求演示：（使用 response.data 读取 JSON 数据）</p>
<p>没有参数传递：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>网站列表<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">&quot;site in info&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    &#123;&#123; site.name &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span> = <span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = &#123;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      info: <span class="string">&#x27;Ajax 测试!!&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    axios</span><br><span class="line"><span class="javascript">      .get(<span class="string">&#x27;https://www.runoob.com/try/ajax/json_demo.json&#x27;</span>)</span></span><br><span class="line"><span class="javascript">      .then(<span class="function"><span class="params">response</span> =&gt;</span> (<span class="built_in">this</span>.info = response))</span></span><br><span class="line"><span class="javascript">      .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123; <span class="comment">// 请求失败处理</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(error);</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="javascript">Vue.createApp(app).mount(<span class="string">&#x27;#app&#x27;</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>传递参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接在 URL 上添加参数 ID=12345</span></span><br><span class="line">axios.get(<span class="string">&#x27;/user?ID=12345&#x27;</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 也可以通过 params 设置参数：</span></span><br><span class="line">axios.get(<span class="string">&#x27;/user&#x27;</span>, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">      ID: <span class="number">12345</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>发送post请求演示：</p>
<p>没有传递参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      info: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    axios</span><br><span class="line">      .post(<span class="string">&#x27;https://www.runoob.com/try/ajax/demo_axios_post.php&#x27;</span>)</span><br><span class="line">      .then(<span class="function"><span class="params">response</span> =&gt;</span> (<span class="built_in">this</span>.info = response))</span><br><span class="line">      .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123; <span class="comment">// 请求失败处理</span></span><br><span class="line">        <span class="built_in">console</span>.log(error);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>参数传递：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">axios.post(<span class="string">&#x27;/user&#x27;</span>, &#123;</span><br><span class="line">    firstName: <span class="string">&#x27;Fred&#x27;</span>,        <span class="comment">// 参数 firstName</span></span><br><span class="line">    lastName: <span class="string">&#x27;Flintstone&#x27;</span>    <span class="comment">// 参数 lastName</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>执行多个并发请求：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserAccount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.get(<span class="string">&#x27;/user/12345&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserPermissions</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.get(<span class="string">&#x27;/user/12345/permissions&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">axios.all([getUserAccount(), getUserPermissions()])</span><br><span class="line">  .then(axios.spread(<span class="function"><span class="keyword">function</span> (<span class="params">acct, perms</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 两个请求现在都执行完成</span></span><br><span class="line">  &#125;));</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="3、axios的使用"><a href="#3、axios的使用" class="headerlink" title="3、axios的使用"></a>3、axios的使用</h4><p>除了上面两种方法，axios还可以直接传递相关配置来创建请求。</p>
<h5 id="1、发送axios-config-请求演示："><a href="#1、发送axios-config-请求演示：" class="headerlink" title="1、发送axios(config)请求演示："></a>1、发送axios(config)请求演示：</h5><p>可以通过向 axios <strong>传递相关配置</strong>来创建请求：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">axios(config)</span><br><span class="line"><span class="comment">// 发送 POST 请求</span></span><br><span class="line">axios(&#123;</span><br><span class="line">  method: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">  url: <span class="string">&#x27;/user/12345&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">&#x27;Fred&#x27;</span>,</span><br><span class="line">    lastName: <span class="string">&#x27;Flintstone&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//  GET 请求远程图片</span></span><br><span class="line">axios(&#123;</span><br><span class="line">  method:<span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">  url:<span class="string">&#x27;http://bit.ly/2mTM3nY&#x27;</span>,</span><br><span class="line">  responseType:<span class="string">&#x27;stream&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  response.data.pipe(fs.createWriteStream(<span class="string">&#x27;ada_lovelace.jpg&#x27;</span>))</span><br><span class="line">&#125;);</span><br><span class="line">axios(url[, config])</span><br><span class="line"><span class="comment">// 发送 GET 请求（默认的方法）</span></span><br><span class="line">axios(<span class="string">&#x27;/user/12345&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="2、请求方法的别名："><a href="#2、请求方法的别名：" class="headerlink" title="2、请求方法的别名："></a><strong>2、请求方法的别名</strong>：</h5><p>为方便使用，官方为所有支持的请求方法提供了别名，可以直接使用别名来发起请求：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.request(config)</span><br><span class="line">axios.get(url[, config])</span><br><span class="line">axios.delete(url[, config])</span><br><span class="line">axios.head(url[, config])</span><br><span class="line">axios.post(url[, data[, config]])</span><br><span class="line">axios.put(url[, data[, config]])</span><br><span class="line">axios.patch(url[, data[, config]])</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>在使用别名方法时， url、method、data 这些属性都不必在配置中指定。</p>
<h5 id="3、并发："><a href="#3、并发：" class="headerlink" title="3、并发："></a><strong>3、并发：</strong></h5><p>有时候, 我们可能需求同时发送两个请求</p>
<ul>
<li><p>使用axios.all, 可以放入多个请求的数组.</p>
</li>
<li><p>axios.all([]) 返回的结果是一个数组，使用 axios.spread 可将数组 [res1,res2] 展开为 res1, res2</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理并发请求的助手函数:</span></span><br><span class="line"><span class="comment">// axios.all(iterable)</span></span><br><span class="line"><span class="comment">// axios.spread(callback)</span></span><br><span class="line">axios.all([axios(&#123;</span><br><span class="line">  url: <span class="string">&#x27;/home/multidata&#x27;</span></span><br><span class="line">&#125;), axios(&#123;</span><br><span class="line">  url: <span class="string">&#x27;/home/data&#x27;</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    type: <span class="string">&#x27;sell&#x27;</span>,</span><br><span class="line">    page: <span class="number">5</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)]).then(axios.spread(<span class="function">(<span class="params">res1, res2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res1);</span><br><span class="line">  <span class="built_in">console</span>.log(res2);</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

<h5 id="4、全局配置："><a href="#4、全局配置：" class="headerlink" title="4、全局配置："></a><strong>4、全局配置</strong>：</h5><p>在上面的示例中, 我们的BaseURL是固定的</p>
<ul>
<li>事实上, 在开发中可能很多参数都是固定的。</li>
<li>这个时候我们可以进行一些抽取, 也可以利用axiox的全局配置。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用全局的axios和对应的配置在进行网络请求</span></span><br><span class="line">axios.defaults.baseURL = <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span></span><br><span class="line">axios.defaults.timeout = <span class="number">5000</span></span><br><span class="line">axios.defaults.headers.post[‘Content-Type’] = ‘application/x-www-form-urlencoded’;</span><br></pre></td></tr></table></figure>

<p><strong>常见的配置选项</strong>：</p>
<p><img src="VUE/179.png" alt="image-20210401002517223"></p>
<h5 id="5、axios实例："><a href="#5、axios实例：" class="headerlink" title="5、axios实例："></a><strong>5、axios实例：</strong></h5><p>为什么要创建axios的实例呢?</p>
<ul>
<li>当我们从axios模块中导入对象时, 使用的实例是<strong>默认的实例</strong>。</li>
<li>当给该实例设置一些默认配置时, 这些配置就被固定下来了(<strong>全局配置</strong>)。</li>
<li>但当项目越来越大的时候，并发量会越来越大。一个服务器可能承受不了很大的请求量。这个时候可能会使用多个服务器去承载大量请求，即我们说的<code>分布式</code>。由于每一个服务器ip不一样，这个时候不会向客户端传递多个ip地址，往往会使用一个反向代理服务器nginx对每一服务器进行反向代理和负载均衡，并向客户端提供一个公共的ip。而每一客户端都是面向这个代理服务器。</li>
<li>比如某些请求需要使用特定的baseURL或者timeout或者content-Type等。</li>
<li>这个时候, 我们就可以创建新的实例, 并且传入属于该实例的配置信息。</li>
</ul>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建对应的axios的实例</span></span><br><span class="line"><span class="keyword">const</span> instance1 = axios.create(&#123;</span><br><span class="line">  baseURL: <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">  timeout: <span class="number">5000</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送网络请求</span></span><br><span class="line">instance1(&#123;</span><br><span class="line">  url: <span class="string">&#x27;/home/multidata&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 发送网络请求</span></span><br><span class="line">instance1(&#123;</span><br><span class="line">  url: <span class="string">&#x27;/home/data&#x27;</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    type: <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">    page: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance2 = axios.create(&#123;</span><br><span class="line">  baseURL: <span class="string">&#x27;http://222.111.33.33:8000&#x27;</span>,</span><br><span class="line">  timeout: <span class="number">10000</span>,</span><br><span class="line">  <span class="comment">// headers: &#123;&#125;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="5、对网络请求进行模块封装（重要）"><a href="#5、对网络请求进行模块封装（重要）" class="headerlink" title="5、对网络请求进行模块封装（重要）"></a>5、对网络请求进行模块封装（重要）</h3><h4 id="1、为什么要进行网络封装？"><a href="#1、为什么要进行网络封装？" class="headerlink" title="1、为什么要进行网络封装？"></a>1、为什么要进行网络封装？</h4><ul>
<li><p>一般来说，我们都是在需要的组件里进行axios进行导入，并在组件内使用axios进行网络请求。</p>
</li>
<li><p>这种方式也可以实现网络请求。但存在了一个致命的问题：组件与框架（axios）之间的依赖太高了。</p>
</li>
<li><p>只会导致什么结果：但某一天该框架不在进行维护了，即这个框架废弃了。这个时候对项目的维护将是一个噩梦。举一个极端的例子：一个项目有100个组件，每个组件都依赖了10个框架。有一天这10个都宣布不再进行维护了。这个时候就需要对在100个组件中的框架进行替换。相当于可以放弃这个项目了。</p>
</li>
<li><p>所以，必须对我们要使用的第三方的东西（如框架）在进行一层封装，封装成一个文件。所以的组件对框架的使用都通过我们封装过后的这个文件，而该文件在对第三方的东西（框架）进行依赖。当有一天第三方的东西不再进行维护或者要对其进行替换的时候，直接修改我们封装的文件，在其中加入要替换的东西并修改代码即可，最后将结果转换为组件能够直接使用的形式进行返回，组件里的代码不用进行一点修改，就完成对第三方东西的替换。这样就完成了组件与第三方的解耦，大大增加了项目的维护性</p>
<p><img src="VUE/181.png" alt="image-20210401022031968"></p>
</li>
</ul>
<h4 id="2、对axios框架进行封装"><a href="#2、对axios框架进行封装" class="headerlink" title="2、对axios框架进行封装"></a>2、对axios框架进行封装</h4><p>在src新建文件夹network，里面封装网络层需要用到的东西。在network文件夹中新建request.js文件，里面存放对axios中网络请求的封装。</p>
<p>在request.js中使用方法function进行导出，不使用default导出的原因：</p>
<p>因为调用的时候可能不止一个实例，定义成function在使用时就可以导出为多个实例。而定义成default就只能导出一个能自定义名称的实例而已。</p>
<h5 id="1、通过回调函数进行封装"><a href="#1、通过回调函数进行封装" class="headerlink" title="1、通过回调函数进行封装"></a>1、通过回调函数进行封装</h5><p>注意：调用者（组件）调用封装的request.js进行网络请求，request.js要将封装后的结果回调给调用者，让调用者知晓本次网络请求是否成功。</p>
<h6 id="1、参数有config、success、-failure"><a href="#1、参数有config、success、-failure" class="headerlink" title="1、参数有config、success、 failure"></a>1、参数有config、success、 failure</h6><p>request.js：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config, success, failure</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1.创建axios的实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">    timeout: <span class="number">5000</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送真正的网络请求</span></span><br><span class="line">  instance(config)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(res);</span></span><br><span class="line">      success(res);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(err);</span></span><br><span class="line">      failure(err)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用function导出可以创建多个实例</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request1</span>(<span class="params">config</span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5.封装request模块</span></span><br><span class="line"><span class="keyword">import</span> &#123;request&#125; <span class="keyword">from</span> <span class="string">&quot;./network/request&quot;</span>;</span><br><span class="line"></span><br><span class="line">request(&#123;</span><br><span class="line">  url: <span class="string">&#x27;/home/multidata&#x27;</span></span><br><span class="line">&#125;, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 回调success</span></span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 回调failure</span></span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h6 id="2、参数只有config"><a href="#2、参数只有config" class="headerlink" title="2、参数只有config"></a>2、参数只有config</h6><p>request.js：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1.创建axios的实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">    timeout: <span class="number">5000</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送真正的网络请求</span></span><br><span class="line">  instance(config.baseConfig)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(res);</span></span><br><span class="line">      config.success(res);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(err);</span></span><br><span class="line">      config.failure(err)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5.封装request模块</span></span><br><span class="line"><span class="keyword">import</span> &#123;request&#125; <span class="keyword">from</span> <span class="string">&quot;./network/request&quot;</span>;</span><br><span class="line"></span><br><span class="line">request(&#123;</span><br><span class="line">  <span class="comment">// 传入基本配置</span></span><br><span class="line">  baseConfig: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 回调success</span></span><br><span class="line">  success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 回调failure</span></span><br><span class="line">  failure: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="2、通过promise进行封装"><a href="#2、通过promise进行封装" class="headerlink" title="2、通过promise进行封装"></a>2、通过promise进行封装</h5><h6 id="1、通过promise的resolve-reject-进行传递"><a href="#1、通过promise的resolve-reject-进行传递" class="headerlink" title="1、通过promise的resolve()/reject()进行传递"></a>1、通过promise的resolve()/reject()进行传递</h6><p>request.js：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建axios的实例</span></span><br><span class="line">    <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">      baseURL: <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">      timeout: <span class="number">5000</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送真正的网络请求</span></span><br><span class="line">    instance(config)</span><br><span class="line">      .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(res)</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5.封装request模块</span></span><br><span class="line"><span class="keyword">import</span> &#123;request&#125; <span class="keyword">from</span> <span class="string">&quot;./network/request&quot;</span>;</span><br><span class="line"></span><br><span class="line">request(&#123;</span><br><span class="line">  url: <span class="string">&#x27;/home/multidata&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h6 id="2、直接返回instance实例（本质上是一个promise对象）（最终方案）"><a href="#2、直接返回instance实例（本质上是一个promise对象）（最终方案）" class="headerlink" title="2、直接返回instance实例（本质上是一个promise对象）（最终方案）"></a>2、直接返回instance实例（本质上是一个promise对象）（最终方案）</h6><p>request.js：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1.创建axios的实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">    timeout: <span class="number">5000</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.发送真正的网络请求</span></span><br><span class="line">  <span class="keyword">return</span> instance(config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5.封装request模块</span></span><br><span class="line"><span class="keyword">import</span> &#123;request&#125; <span class="keyword">from</span> <span class="string">&quot;./network/request&quot;</span>;</span><br><span class="line"></span><br><span class="line">request(&#123;</span><br><span class="line">  url: <span class="string">&#x27;/home/multidata&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h6 id="3、两种promise方式的对比"><a href="#3、两种promise方式的对比" class="headerlink" title="3、两种promise方式的对比"></a>3、两种promise方式的对比</h6><p>第一种方式只是比第二种方式多套了一层的promise。在某些情况下也是有用的。套一层promise可以做一些全局网络处理，比如全局dialog一个加载中。这个时候就得使用第一种方式而不是第二种方式。（具体使用需要根据业务进行选择）</p>
<h4 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h4><p>通过以上对axios框架进行封装，就可以实现组件与axios的解耦。</p>
<p>假设：当有一天axios不在进行维护，我们使用android对axios进行替换。只需要修改request.js文件即可：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入android框架</span></span><br><span class="line"><span class="keyword">import</span> android <span class="keyword">from</span> <span class="string">&#x27;android&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 将axios的代码替换成android的代码</span></span><br><span class="line">	android代码</span><br><span class="line">	<span class="comment">// 最后将android的相关代码包装到Promise里面进行返回</span></span><br><span class="line">	<span class="comment">// 组件代码不用进行任何修改</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为Promise是ES6原生语法，而不是第三方框架。不用担心Promise失效。因为一旦ES6不再维护，那就不是一个框架的问题了。</p>
<h3 id="6、axios的拦截器"><a href="#6、axios的拦截器" class="headerlink" title="6、axios的拦截器"></a>6、axios的拦截器</h3><p>axios提供了拦截器，用于我们在<strong>发送每次请求</strong>或者<strong>得到相应结果后</strong>，即在请求或响应被 then 或 catch 处理前拦截他们，对他们进行对应的处理。</p>
<p>axios提供了四种拦截：</p>
<ul>
<li>请求成功时的拦截</li>
<li>请求失败时的拦截</li>
<li>响应成功时的拦截</li>
<li>响应失败时的拦截</li>
</ul>
<p>前后端的拦截：</p>
<p>后端也要做拦截校验的，但是前端要拦截，如页面权限、参数之类的校验。然后到后端会再拦截，再校验一遍，如果前端校验都不通过，那就不用调后端了，前端要是通过了，后端还是会做校验，保证安全性之类的。</p>
<p>过滤器与拦截器：</p>
<p>过滤器和监听器是web.xml中配置的，拦截器是springMVC中的，只有你的请求过了过滤器并且交由dispatchServlet处理，才会到拦截器这。</p>
<h4 id="1、请求拦截"><a href="#1、请求拦截" class="headerlink" title="1、请求拦截"></a>1、请求拦截</h4><p>请求拦截可以做到的事情：</p>
<ul>
<li><p>比如config中的一些信息不符合服务器的要求</p>
</li>
<li><p>比如每次发送网络请求时, 都希望在界面中显示一个请求中的图标：</p>
<p>将<code>加载中</code>图标show展示出来，在响应拦截中再把它隐藏。</p>
</li>
<li><p>某些网络请求(比如登录(token)), 必须携带一些特殊的信息：</p>
<p>在config中有一个属性url，里面存放着本次请求的路径（接口api），判断该请求是否为登陆之后才能进行访问，再去判断这次请求有没有携带token。如果有携带token的话就放行，如果没有携带token就可以提示一些错误信息并跳转到登陆界面让用户进行登陆。</p>
</li>
</ul>
<p>注意：</p>
<ul>
<li><p>某些网络请求，比如登录(token)的携带也可以通过导航守卫来实现，但是存在不同：</p>
<ul>
<li>导航首位是前端在页面跳转的时候使用的，一般是同源；</li>
<li>请求拦截是请求后端数据的时候使用的，一般要跨域。</li>
</ul>
</li>
<li><p>在请求拦截，对config进行操作之后记住要放行config。不然之后响应的时候拿不到config。</p>
</li>
<li><p>被拦截的config当中的信息：</p>
<p><img src="VUE/135.png" alt="image-20210401171319639"></p>
</li>
</ul>
<p>实现：instance.interceptors.request.use(config(),err())</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1.创建axios的实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">    timeout: <span class="number">5000</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.axios的拦截器</span></span><br><span class="line">  <span class="comment">// 2.1.请求拦截的作用</span></span><br><span class="line">  instance.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(config);</span></span><br><span class="line">    <span class="comment">// 1.比如config中的一些信息不符合服务器的要求</span></span><br><span class="line">    <span class="comment">// 2.比如每次发送网络请求时, 都希望在界面中显示一个请求的图标</span></span><br><span class="line">    <span class="comment">// 3.某些网络请求(比如登录(token)), 必须携带一些特殊的信息</span></span><br><span class="line">    <span class="comment">// 在请求拦截，完成操作之后记住要放行请求</span></span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(err);</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 3.发送真正的网络请求</span></span><br><span class="line">  <span class="keyword">return</span> instance(config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、响应拦截"><a href="#2、响应拦截" class="headerlink" title="2、响应拦截"></a>2、响应拦截</h4><p>响应拦截可以做到的事情：</p>
<ul>
<li>在响应结果中一般只有data（服务器返回的真正结果）对我们有用，所以可以把响应结果当中的data过滤出来</li>
<li>在请求到响应的过程中做一些样式的显示/隐藏</li>
</ul>
<p>注意：</p>
<ul>
<li><p>响应拦截的结果res：</p>
<p><img src="VUE/182.png" alt="image-20210401172834396"></p>
</li>
<li><p><strong>在拦截了响应后，要记住将结果（可以直接返回res.data）返回给组件</strong></p>
</li>
</ul>
<p>实现：instance.interceptors.response.use(res(),err())</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1.创建axios的实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">    timeout: <span class="number">5000</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.axios的拦截器</span></span><br><span class="line">  <span class="comment">// 2.2.响应拦截</span></span><br><span class="line">  instance.interceptors.response.use(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(res);</span></span><br><span class="line">    <span class="comment">// 把响应结果当中的data过滤出来</span></span><br><span class="line">    <span class="comment">// 将结果返回给组件</span></span><br><span class="line">    <span class="keyword">return</span> res.data</span><br><span class="line">  &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.发送真正的网络请求</span></span><br><span class="line">  <span class="keyword">return</span> instance(config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、其他"><a href="#3、其他" class="headerlink" title="3、其他"></a>3、其他</h4><p><strong>如果你想在稍后移除拦截器</strong>，可以这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myInterceptor = axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">/*...*/</span>&#125;);</span><br><span class="line">axios.interceptors.request.eject(myInterceptor);</span><br></pre></td></tr></table></figure>

<p><strong>请求时使用 application/x-www-form-urlencoded</strong>：</p>
<p>axios 会默认序列化 JavaScript 对象为 JSON。 如果想使用 application/x-www-form-urlencoded 格式，你可以使用下面的配置。</p>
<p><strong>浏览器</strong></p>
<p>在浏览器环境，你可以使用 URLSearchParams API：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> params = <span class="keyword">new</span> URLSearchParams();</span><br><span class="line">params.append(<span class="string">&#x27;param1&#x27;</span>, <span class="string">&#x27;value1&#x27;</span>);</span><br><span class="line">params.append(<span class="string">&#x27;param2&#x27;</span>, <span class="string">&#x27;value2&#x27;</span>);</span><br><span class="line">axios.post(<span class="string">&#x27;/foo&#x27;</span>, params);</span><br></pre></td></tr></table></figure>

<p>URLSearchParams 不是所有的浏览器均支持。</p>
<p>除此之外，你可以使用 qs 库来编码数据:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> qs = <span class="built_in">require</span>(<span class="string">&#x27;qs&#x27;</span>);</span><br><span class="line">axios.post(<span class="string">&#x27;/foo&#x27;</span>, qs.stringify(&#123; <span class="string">&#x27;bar&#x27;</span>: <span class="number">123</span> &#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Or in another way (ES6),</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> qs <span class="keyword">from</span> <span class="string">&#x27;qs&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> data = &#123; <span class="string">&#x27;bar&#x27;</span>: <span class="number">123</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  headers: &#123; <span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span> &#125;,</span><br><span class="line">  data: qs.stringify(data),</span><br><span class="line">  url,</span><br><span class="line">&#125;;</span><br><span class="line">axios(options);</span><br></pre></td></tr></table></figure>

<p><strong>Promises</strong></p>
<p>axios 依赖原生的 ES6 Promise 实现而<a target="_blank" rel="noopener" href="http://caniuse.com/promises">被支持</a>。</p>
<p> 如果你的环境不支持 ES6 Promise，你可以使用 <a target="_blank" rel="noopener" href="https://github.com/jakearchibald/es6-promise">polyfill</a>。</p>
<p><strong>TypeScript支持</strong></p>
<p>axios 包含 TypeScript 的定义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line">axios.get(<span class="string">&quot;/user?ID=12345&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="7、封装的网络请求模块request-js最终版本"><a href="#7、封装的网络请求模块request-js最终版本" class="headerlink" title="7、封装的网络请求模块request.js最终版本"></a>7、封装的网络请求模块request.js最终版本</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1.创建axios的实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">    timeout: <span class="number">5000</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.axios的拦截器</span></span><br><span class="line">  <span class="comment">// 2.1.请求拦截的作用</span></span><br><span class="line">  instance.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(config);</span></span><br><span class="line">    <span class="comment">// 1.比如config中的一些信息不符合服务器的要求</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.比如每次发送网络请求时, 都希望在界面中显示一个请求的图标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.某些网络请求(比如登录(token)), 必须携带一些特殊的信息</span></span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(err);</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.2.响应拦截</span></span><br><span class="line">  instance.interceptors.response.use(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(res);</span></span><br><span class="line">    <span class="keyword">return</span> res.data</span><br><span class="line">  &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.发送真正的网络请求</span></span><br><span class="line">  <span class="keyword">return</span> instance(config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="十二、其他补充"><a href="#十二、其他补充" class="headerlink" title="十二、其他补充"></a>十二、其他补充</h2><h3 id="1、httpbin-org"><a href="#1、httpbin-org" class="headerlink" title="1、httpbin.org/"></a>1、httpbin.org/</h3><p>httpbin.org：该网站可以做很多网站的模拟。如果之后你想对网络模块进行封装的话，可以用该网站进行很多测试。</p>
<h3 id="2、常见的（github）："><a href="#2、常见的（github）：" class="headerlink" title="2、常见的（github）："></a>2、常见的（github）：</h3><h4 id="1、ui库"><a href="#1、ui库" class="headerlink" title="1、ui库"></a>1、ui库</h4><ul>
<li>mint-ui</li>
<li>iview</li>
</ul>
<h4 id="2、上下滚动"><a href="#2、上下滚动" class="headerlink" title="2、上下滚动"></a>2、上下滚动</h4><ul>
<li><p>scroll（不再维护）</p>
</li>
<li><p>better-scroll</p>
<p>使用：</p>
<ol>
<li>默认情况下BScroll是不可以实时的监听滚动位置，</li>
</ol>
</li>
</ul>
<h4 id="3、关于ref"><a href="#3、关于ref" class="headerlink" title="3、关于ref"></a>3、关于ref</h4><p>ref如果是绑定在组件中的, 那么通过<strong>this.$refs.refname</strong>获取到的是一个组件对象.</p>
<p>ref如果是绑定在普通的元素中, 那么通过<strong>this.$refs.refname</strong>获取到的是一个元素对象.</p>
<h3 id="4、开发新项目"><a href="#4、开发新项目" class="headerlink" title="4、开发新项目"></a>4、开发新项目</h3><h4 id="1、划分目录结构"><a href="#1、划分目录结构" class="headerlink" title="1、划分目录结构"></a>1、划分目录结构</h4><p><img src="VUE/183.png" alt="image-20210401210958061"></p>
<ul>
<li>assets:里面存放图片img与css资源<ul>
<li>img：图片资源</li>
<li>css：css相关资源</li>
</ul>
</li>
<li>common：项目相关的公共文件，如常量、工具类</li>
<li>components：项目的公共组件<ul>
<li>common：项目常用的组件（可在多个项目中使用）</li>
<li>context：当前项目数据相关的公共组件</li>
</ul>
</li>
<li>network：用来存放有关网络请求封装的文件</li>
<li>router：Vue-router路由相关<ul>
<li>index.js</li>
</ul>
</li>
<li>store：Vuex状态管理相关<ul>
<li>index.js</li>
</ul>
</li>
<li>views：用来存放视图相关的组件<ul>
<li>home.js：首页相关的视图</li>
<li>category.js：分类相关的视图</li>
</ul>
</li>
<li>App.vue</li>
<li>main.js</li>
</ul>
<h3 id="2、引用了两个css文件（normalize-css与base-css）"><a href="#2、引用了两个css文件（normalize-css与base-css）" class="headerlink" title="2、引用了两个css文件（normalize.css与base.css）"></a>2、引用了两个css文件（normalize.css与base.css）</h3><h4 id="1、统一CSS标签"><a href="#1、统一CSS标签" class="headerlink" title="1、统一CSS标签"></a>1、统一CSS标签</h4><p>使用normalize.css对CSS进行统一</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*! normalize.css v8.0.0 | MIT License | github.com/necolas/normalize.css */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Document</span></span><br><span class="line"><span class="comment">   ========================================================================== */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. Correct the line height in all browsers.</span></span><br><span class="line"><span class="comment"> * 2. Prevent adjustments of font size after orientation changes in iOS.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.15</span>; <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="attribute">-webkit-text-size-adjust</span>: <span class="number">100%</span>; <span class="comment">/* 2 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Sections</span></span><br><span class="line"><span class="comment">   ========================================================================== */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Remove the margin in all browsers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Correct the font size and margin on `h1` elements within `section` and</span></span><br><span class="line"><span class="comment"> * `article` contexts in Chrome, Firefox, and Safari.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0.67em</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Grouping content</span></span><br><span class="line"><span class="comment">   ========================================================================== */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. Add the correct box sizing in Firefox.</span></span><br><span class="line"><span class="comment"> * 2. Show the overflow in Edge and IE.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">hr</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: content-box; <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>; <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="attribute">overflow</span>: visible; <span class="comment">/* 2 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. Correct the inheritance and scaling of font size in all browsers.</span></span><br><span class="line"><span class="comment"> * 2. Correct the odd `em` font sizing in all browsers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">pre</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: monospace, monospace; <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1em</span>; <span class="comment">/* 2 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Text-level semantics</span></span><br><span class="line"><span class="comment">   ========================================================================== */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Remove the gray background on active links in IE 10.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. Remove the bottom border in Chrome 57-</span></span><br><span class="line"><span class="comment"> * 2. Add the correct text decoration in Chrome, Edge, IE, Opera, and Safari.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">abbr</span><span class="selector-attr">[title]</span> &#123;</span><br><span class="line">  <span class="attribute">border-bottom</span>: none; <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="attribute">text-decoration</span>: underline; <span class="comment">/* 2 */</span></span><br><span class="line">  <span class="attribute">text-decoration</span>: underline dotted; <span class="comment">/* 2 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add the correct font weight in Chrome, Edge, and Safari.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">b</span>,</span><br><span class="line"><span class="selector-tag">strong</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: bolder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. Correct the inheritance and scaling of font size in all browsers.</span></span><br><span class="line"><span class="comment"> * 2. Correct the odd `em` font sizing in all browsers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">code</span>,</span><br><span class="line"><span class="selector-tag">kbd</span>,</span><br><span class="line"><span class="selector-tag">samp</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: monospace, monospace; <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1em</span>; <span class="comment">/* 2 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add the correct font size in all browsers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">small</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">80%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Prevent `sub` and `sup` elements from affecting the line height in</span></span><br><span class="line"><span class="comment"> * all browsers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">sub</span>,</span><br><span class="line"><span class="selector-tag">sup</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">75%</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">vertical-align</span>: baseline;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">sub</span> &#123;</span><br><span class="line">  <span class="attribute">bottom</span>: -<span class="number">0.25em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">sup</span> &#123;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">0.5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Embedded content</span></span><br><span class="line"><span class="comment">   ========================================================================== */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Remove the border on images inside links in IE 10.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">border-style</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Forms</span></span><br><span class="line"><span class="comment">   ========================================================================== */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. Change the font styles in all browsers.</span></span><br><span class="line"><span class="comment"> * 2. Remove the margin in Firefox and Safari.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span>,</span><br><span class="line"><span class="selector-tag">input</span>,</span><br><span class="line"><span class="selector-tag">optgroup</span>,</span><br><span class="line"><span class="selector-tag">select</span>,</span><br><span class="line"><span class="selector-tag">textarea</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: inherit; <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">100%</span>; <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.15</span>; <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>; <span class="comment">/* 2 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Show the overflow in IE.</span></span><br><span class="line"><span class="comment"> * 1. Show the overflow in Edge.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span>,</span><br><span class="line"><span class="selector-tag">input</span> &#123; <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="attribute">overflow</span>: visible;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Remove the inheritance of text transform in Edge, Firefox, and IE.</span></span><br><span class="line"><span class="comment"> * 1. Remove the inheritance of text transform in Firefox.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span>,</span><br><span class="line"><span class="selector-tag">select</span> &#123; <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="attribute">text-transform</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Correct the inability to style clickable types in iOS and Safari.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span>,</span><br><span class="line"><span class="selector-attr">[type=<span class="string">&quot;button&quot;</span>]</span>,</span><br><span class="line"><span class="selector-attr">[type=<span class="string">&quot;reset&quot;</span>]</span>,</span><br><span class="line"><span class="selector-attr">[type=<span class="string">&quot;submit&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-appearance</span>: button;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Remove the inner border and padding in Firefox.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">::-moz-focus-inner</span>,</span><br><span class="line"><span class="selector-attr">[type=<span class="string">&quot;button&quot;</span>]</span><span class="selector-pseudo">::-moz-focus-inner</span>,</span><br><span class="line"><span class="selector-attr">[type=<span class="string">&quot;reset&quot;</span>]</span><span class="selector-pseudo">::-moz-focus-inner</span>,</span><br><span class="line"><span class="selector-attr">[type=<span class="string">&quot;submit&quot;</span>]</span><span class="selector-pseudo">::-moz-focus-inner</span> &#123;</span><br><span class="line">  <span class="attribute">border-style</span>: none;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Restore the focus styles unset by the previous rule.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">:-moz-focusring</span>,</span><br><span class="line"><span class="selector-attr">[type=<span class="string">&quot;button&quot;</span>]</span><span class="selector-pseudo">:-moz-focusring</span>,</span><br><span class="line"><span class="selector-attr">[type=<span class="string">&quot;reset&quot;</span>]</span><span class="selector-pseudo">:-moz-focusring</span>,</span><br><span class="line"><span class="selector-attr">[type=<span class="string">&quot;submit&quot;</span>]</span><span class="selector-pseudo">:-moz-focusring</span> &#123;</span><br><span class="line">  <span class="attribute">outline</span>: <span class="number">1px</span> dotted ButtonText;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Correct the padding in Firefox.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">fieldset</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.35em</span> <span class="number">0.75em</span> <span class="number">0.625em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. Correct the text wrapping in Edge and IE.</span></span><br><span class="line"><span class="comment"> * 2. Correct the color inheritance from `fieldset` elements in IE.</span></span><br><span class="line"><span class="comment"> * 3. Remove the padding so developers are not caught out when they zero out</span></span><br><span class="line"><span class="comment"> *    `fieldset` elements in all browsers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">legend</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box; <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="attribute">color</span>: inherit; <span class="comment">/* 2 */</span></span><br><span class="line">  <span class="attribute">display</span>: table; <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">100%</span>; <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>; <span class="comment">/* 3 */</span></span><br><span class="line">  <span class="attribute">white-space</span>: normal; <span class="comment">/* 1 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add the correct vertical alignment in Chrome, Firefox, and Opera.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">progress</span> &#123;</span><br><span class="line">  <span class="attribute">vertical-align</span>: baseline;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Remove the default vertical scrollbar in IE 10+.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">textarea</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. Add the correct box sizing in IE 10.</span></span><br><span class="line"><span class="comment"> * 2. Remove the padding in IE 10.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[type=<span class="string">&quot;checkbox&quot;</span>]</span>,</span><br><span class="line"><span class="selector-attr">[type=<span class="string">&quot;radio&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box; <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>; <span class="comment">/* 2 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Correct the cursor style of increment and decrement buttons in Chrome.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[type=<span class="string">&quot;number&quot;</span>]</span><span class="selector-pseudo">::-webkit-inner-spin-button</span>,</span><br><span class="line"><span class="selector-attr">[type=<span class="string">&quot;number&quot;</span>]</span><span class="selector-pseudo">::-webkit-outer-spin-button</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. Correct the odd appearance in Chrome and Safari.</span></span><br><span class="line"><span class="comment"> * 2. Correct the outline style in Safari.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[type=<span class="string">&quot;search&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-appearance</span>: textfield; <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="attribute">outline-offset</span>: -<span class="number">2px</span>; <span class="comment">/* 2 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Remove the inner padding in Chrome and Safari on macOS.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[type=<span class="string">&quot;search&quot;</span>]</span><span class="selector-pseudo">::-webkit-search-decoration</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-appearance</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. Correct the inability to style clickable types in iOS and Safari.</span></span><br><span class="line"><span class="comment"> * 2. Change font properties to `inherit` in Safari.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-pseudo">::-webkit-file-upload-button</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-appearance</span>: button; <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="attribute">font</span>: inherit; <span class="comment">/* 2 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Interactive</span></span><br><span class="line"><span class="comment">   ========================================================================== */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Add the correct display in Edge, IE 10+, and Firefox.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">details</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Add the correct display in all browsers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">summary</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: list-item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Misc</span></span><br><span class="line"><span class="comment">   ========================================================================== */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add the correct display in IE 10+.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">template</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add the correct display in IE 10.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[hidden]</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、创建全局基本样式base-css（可以去github上查找）"><a href="#2、创建全局基本样式base-css（可以去github上查找）" class="headerlink" title="2、创建全局基本样式base.css（可以去github上查找）"></a>2、创建全局基本样式base.css（可以去github上查找）</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&quot;./normalize.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*:root -&gt; 获取根元素html*/</span></span><br><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attribute">--color-text</span>: <span class="number">#666</span>;</span><br><span class="line">  <span class="attribute">--color-high-text</span>: <span class="number">#ff5777</span>;</span><br><span class="line">  <span class="attribute">--color-tint</span>: <span class="number">#ff8198</span>;</span><br><span class="line">  <span class="attribute">--color-background</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">--font-size</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">--line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*,</span><br><span class="line">*<span class="selector-pseudo">::before</span>,</span><br><span class="line">*<span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&quot;Helvetica Neue&quot;</span>,Helvetica,<span class="string">&quot;PingFang SC&quot;</span>,<span class="string">&quot;Hiragino Sans GB&quot;</span>,<span class="string">&quot;Microsoft YaHei&quot;</span>,<span class="string">&quot;微软雅黑&quot;</span>,Arial,sans-serif;</span><br><span class="line">  <span class="attribute">user-select</span>: none; <span class="comment">/* 禁止用户鼠标在页面上选中文字/图片等 */</span></span><br><span class="line">  <span class="attribute">-webkit-tap-highlight-color</span>: transparent; <span class="comment">/* webkit是苹果浏览器引擎，tap点击，highlight背景高亮，color颜色，颜色用数值调节 */</span></span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">var</span>(--color-background);</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--color-text);</span><br><span class="line">  <span class="comment">/* rem vw/vh */</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100vw</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--color-text);</span><br><span class="line">  <span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clear-fix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clear-fix</span> &#123;</span><br><span class="line">  <span class="attribute">zoom</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>:root -&gt; 获取根元素html：可用于定义变量。在该文件的其他地方可以通过var(–变量名)拿到变量的值。<ul>
<li>–color-text: 文本颜色</li>
<li>–color-high-text: 文本颜色高亮</li>
<li>–color-tint: 整体的颜色，用于设置导航栏的背景颜色</li>
<li>–color-background: 背景颜色</li>
<li>–font-size: 整体的字体大小</li>
<li>–line-height: 线高</li>
</ul>
</li>
</ul>
<h3 id="3、配置别名与设置规范"><a href="#3、配置别名与设置规范" class="headerlink" title="3、配置别名与设置规范"></a>3、配置别名与设置规范</h3><h4 id="1、vue-config-js"><a href="#1、vue-config-js" class="headerlink" title="1、vue.config.js"></a>1、vue.config.js</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41107231/article/details/107576861">创建vue.config.js配置别名</a>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    configureWebpack: &#123;</span><br><span class="line">      resolve: &#123;</span><br><span class="line">        alias: &#123;</span><br><span class="line">          <span class="string">&#x27;assets&#x27;</span>: <span class="string">&#x27;@/assets&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;common&#x27;</span>: <span class="string">&#x27;@/common&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;components&#x27;</span>: <span class="string">&#x27;@/components&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;network&#x27;</span>: <span class="string">&#x27;@/network&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;views&#x27;</span>: <span class="string">&#x27;@/views&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、-editorconfig设置规范"><a href="#2、-editorconfig设置规范" class="headerlink" title="2、.editorconfig设置规范"></a>2、.editorconfig设置规范</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root &#x3D; true</span><br><span class="line"></span><br><span class="line">[*]</span><br><span class="line">charset &#x3D; utf-8</span><br><span class="line">indent_style &#x3D; space</span><br><span class="line">indent_size &#x3D; 2</span><br><span class="line">end_of_line &#x3D; lf</span><br><span class="line">insert_final_newline &#x3D; true</span><br><span class="line">trim_trailing_whitespace &#x3D; true</span><br></pre></td></tr></table></figure>

<h3 id="4、项目的模块划分-tabbar-gt-路由映射关系"><a href="#4、项目的模块划分-tabbar-gt-路由映射关系" class="headerlink" title="4、项目的模块划分: tabbar -&gt; 路由映射关系"></a>4、项目的模块划分: tabbar -&gt; 路由映射关系</h3><h3 id="5、首页开发"><a href="#5、首页开发" class="headerlink" title="5、首页开发"></a>5、首页开发</h3><ul>
<li>navbar 的封装</li>
<li>网络数据的请求</li>
<li>轮播图</li>
<li>推荐信息</li>
</ul>
</script></p></li></ul>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xgh-user.github.io/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_little-star_">
      <meta itemprop="description" content="记录个人在平时学习的过程中的一些笔记、感受与遇到的坑,例如：java、计算机考研四件套等等。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_little-star_">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-19 03:10:19" itemprop="dateCreated datePublished" datetime="2021-04-19T03:10:19+08:00">2021-04-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-07 00:20:12" itemprop="dateModified" datetime="2021-08-07T00:20:12+08:00">2021-08-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%90%8E%E5%8F%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">java后台学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%90%8E%E5%8F%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="23种设计模式"><a href="#23种设计模式" class="headerlink" title="23种设计模式"></a>23种设计模式</h1><hr>
<p>[TOC]</p>
<h2 id="1、引子"><a href="#1、引子" class="headerlink" title="1、引子"></a>1、引子</h2><h3 id="1、设计模式采用的七大原则："><a href="#1、设计模式采用的七大原则：" class="headerlink" title="1、设计模式采用的七大原则："></a>1、设计模式采用的七大原则：</h3><ul>
<li><p>单一职责原则</p>
</li>
<li><p>接口隔离原则</p>
</li>
<li><p>依赖倒转原则</p>
</li>
<li><p>里氏替换原则</p>
</li>
<li><p>开闭原则（ocp）</p>
<ul>
<li><p>工厂模式</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.png" alt="image-20210410201229604"></p>
</li>
</ul>
</li>
<li><p>迪米特原则</p>
</li>
<li><p>合成复用原则</p>
</li>
</ul>
<p>单例设计模式一共有 <strong>8</strong> 种写法:</p>
<ul>
<li>饿汉式 两种</li>
<li>懒汉式 三种</li>
<li>双重检查</li>
<li>静态内部类</li>
<li>枚举</li>
</ul>
<h3 id="2、设计模式的重要性"><a href="#2、设计模式的重要性" class="headerlink" title="2、设计模式的重要性"></a>2、设计模式的重要性</h3><ul>
<li>软件工程中，<strong>设计模式</strong>（design pattern）是对软件设计中<strong>普遍存在（反复出现）</strong>的各种问题，所提出的<strong>解决方案</strong>。这个术语是由埃里希·伽玛（Erich Gamma）等人在 1990 年代从建筑设计领域引入到计算机科学的</li>
<li>拿实际工作经历来说, 当一个项目开发完后，如果<strong>客户提出增新功能</strong>，怎么办?（<strong>可扩展性</strong>,使用设计模式，软件具有很好的扩展性）</li>
<li>如果项目开发完后，原来程序员离职，你接手维护该项目怎么办? (<strong>维护性</strong>[可读性、规范性])</li>
<li>目前程序员门槛越来越高，一线IT公司(大厂)，都会问你在实际项目中<strong>使用过什么设计模式，怎样使用的，解决了什么问题</strong></li>
<li><strong>设计模式在软件中哪里</strong>？面向对象(oo)=&gt;<strong>功能模块</strong>[设计模式+算法(数据结构)]=&gt;<strong>框架</strong>[使用到多种设计模式]=&gt; 架构 [服务器集群]</li>
<li>如果想成为合格软件工程师，那就花时间来研究下设计模式是非常必要的.</li>
</ul>
<h3 id="3、设计模式的讲解过程"><a href="#3、设计模式的讲解过程" class="headerlink" title="3、设计模式的讲解过程"></a>3、设计模式的讲解过程</h3><p>讲解的步骤</p>
<ol>
<li>应用场景</li>
<li>普通代码解决</li>
<li>设计模式解决【对比】</li>
<li>剖析原理</li>
<li>分析实现步骤(图解)</li>
<li>代码实现</li>
<li> 框架或项目源码分析(找到使用的地方)  的步骤讲解</li>
</ol>
<hr>
<h2 id="2、设计模式七大原则（单接依里开迪合）"><a href="#2、设计模式七大原则（单接依里开迪合）" class="headerlink" title="2、设计模式七大原则（单接依里开迪合）"></a>2、设计模式七大原则（单接依里开迪合）</h2><h3 id="2-1、设计模式的目的"><a href="#2-1、设计模式的目的" class="headerlink" title="2.1、设计模式的目的"></a>2.1、设计模式的目的</h3><p>编写软件过程中，程序员面临着来自 耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性 等多方面的挑战，设计模式是为了让程序(软件)，具有更好的：</p>
<ol>
<li>代码重用性 (即：相同功能的代码，不用多次编写)</li>
<li>可读性 (即：编程规范性, 便于其他程序员的阅读和理解)</li>
<li>可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护)</li>
<li>可靠性 (即：当我们增加新的功能后，对原来的功能没有影响)</li>
<li>使程序呈现<strong>高内聚，低耦合</strong>的特性</li>
</ol>
<h3 id="2-2-、设计模式七大原则"><a href="#2-2-、设计模式七大原则" class="headerlink" title="2.2 、设计模式七大原则"></a>2.2 、设计模式七大原则</h3><p>设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础(即：<strong>设计模式为什么这样设计的依据</strong>)</p>
<p>设计模式常用的七大原则有:</p>
<ol>
<li>单一职责原则</li>
<li>接口隔离原则</li>
<li>依赖倒转(倒置)原则</li>
<li>里氏替换原则</li>
<li>开闭原则</li>
<li>迪米特法则</li>
<li>合成复用原则</li>
</ol>
<h3 id="2-3、单一职责原则-Single-Responsibility-Principle"><a href="#2-3、单一职责原则-Single-Responsibility-Principle" class="headerlink" title="2.3、单一职责原则(Single Responsibility Principle)"></a>2.3、单一职责原则(Single Responsibility Principle)</h3><h4 id="2-3-1、基本介绍"><a href="#2-3-1、基本介绍" class="headerlink" title="2.3.1、基本介绍"></a>2.3.1、基本介绍</h4><p>单一职责的含义是：<strong>类的职责单一，引起类变化的原因单一</strong>。对类来说的，即<strong>一个类应该只负责一项职责</strong>。解释一下，这也是灵活的前提，如果我们把类拆分成最小的职能单位，那组合与复用就简单的多了，如果一个类做的事情太多，在组合的时候，必然会产生不必要的方法出现，这实际上是一种污染。</p>
<p>如类 A 负责两个不同职责：职责 1，职责 2。当职责 1 需求变更而改变 A 时，可能造成职责 2 执行错误，所以需要将类 A 的粒度分解为 A1，A2。</p>
<p>SRP优点：消除耦合，减小因需求变化引起代码僵化。</p>
<h4 id="2-3-2、应用实例"><a href="#2-3-2、应用实例" class="headerlink" title="2.3.2、应用实例"></a>2.3.2、应用实例</h4><p>需求：以交通工具案例讲解（海陆空）</p>
<p>方案 1  [分析说明]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleResponsibility1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        Vehicle vehicle = <span class="keyword">new</span> Vehicle();</span><br><span class="line">        vehicle.run(<span class="string">&quot;摩托车&quot;</span>);</span><br><span class="line">        vehicle.run(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line">        vehicle.run(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 交通工具类</span></span><br><span class="line">    <span class="comment">// 方式 1</span></span><br><span class="line">    <span class="comment">// 1. 在方式 1 的 run 方法中，违反了单一职责原则</span></span><br><span class="line">    <span class="comment">// 2. 解决的方案非常的简单，根据交通工具运行方法不同，分解成不同类即可</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">            System.out.println(vehicle + <span class="string">&quot; 在公路上运行....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方案 2  [分析说明]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleResponsibility1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        RoadVehicle roadVehicle = <span class="keyword">new</span> RoadVehicle();</span><br><span class="line">        roadVehicle.run(<span class="string">&quot;摩托车&quot;</span>);</span><br><span class="line">        roadVehicle.run(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        AirVehicle airVehicle = <span class="keyword">new</span> AirVehicle();</span><br><span class="line">        airVehicle.run(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方案 2</span></span><br><span class="line">    <span class="comment">//1. 遵守单一职责原则</span></span><br><span class="line">    <span class="comment">//2. 但是这样做的改动很大，即将类分解，同时修改客户端</span></span><br><span class="line">    <span class="comment">//3. 改进：直接修改 Vehicle 类，改动的代码会比较少=&gt;方案 3</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">RoadVehicle</span> </span>&#123;</span><br><span class="line">    	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123; </span><br><span class="line">            System.out.println(vehicle + <span class="string">&quot;公路运行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AirVehicle</span> </span>&#123;</span><br><span class="line">    	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123; </span><br><span class="line">            System.out.println(vehicle + <span class="string">&quot;天空运行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WaterVehicle</span> </span>&#123;</span><br><span class="line">    	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123; </span><br><span class="line">            System.out.println(vehicle + <span class="string">&quot;水中运行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方案 3     [分析说明]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleResponsibility3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub Vehicle2 vehicle2	= new Vehicle2();</span></span><br><span class="line">        vehicle2.run(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line">        vehicle2.runWater(<span class="string">&quot;轮船&quot;</span>);</span><br><span class="line">        vehicle2.runAir(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式 3 </span></span><br><span class="line">    <span class="comment">//1. 这种修改方法没有对原来的类做大的修改，只是增加方法</span></span><br><span class="line">	<span class="comment">//2. 这里虽然没有在类这个级别上遵守单一职责原则，但是在方法级别上，仍然是遵守单一职责</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Vehicle2</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//处理</span></span><br><span class="line">            System.out.println(vehicle + <span class="string">&quot; 在公路上运行....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runAir</span><span class="params">(String vehicle)</span> </span>&#123; </span><br><span class="line">            System.out.println(vehicle + <span class="string">&quot; 在天空上运行....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runWater</span><span class="params">(String vehicle)</span> </span>&#123; </span><br><span class="line">            System.out.println(vehicle + <span class="string">&quot; 在水中行....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-3、单一职责原则注意事项和细节"><a href="#2-3-3、单一职责原则注意事项和细节" class="headerlink" title="2.3.3、单一职责原则注意事项和细节"></a>2.3.3、单一职责原则注意事项和细节</h4><ol>
<li>降低类的复杂度，一个类只负责一项职责。</li>
<li>提高类的可读性，可维护性</li>
<li>降低变更引起的风险</li>
<li>在实际编码的过程中很难将它恰当地运用，需要结合实际情况进行运用。</li>
<li>通常情况下，<strong>我们应当遵守单一职责原则</strong>，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则</li>
</ol>
<h3 id="2-4-、接口隔离原则-Interface-Segregation-Principle"><a href="#2-4-、接口隔离原则-Interface-Segregation-Principle" class="headerlink" title="2.4 、接口隔离原则(Interface Segregation Principle)"></a>2.4 、接口隔离原则(Interface Segregation Principle)</h3><h4 id="2-4-1、基本介绍"><a href="#2-4-1、基本介绍" class="headerlink" title="2.4.1、基本介绍"></a>2.4.1、基本介绍</h4><ol>
<li><p>它的含义是<strong>尽量使用职能单一的接口，而不使用职能复杂、全面的接口。</strong></p>
</li>
<li><p>接口是为了让子类实现的，如果子类想达到职能单一，那么接口也必须满足职能单一。 相反，如果接口融合了多个不相关的方法，那它的子类就被迫要实现所有方法，尽管有些方法是根本用不到的。这就是接口污染。</p>
</li>
<li><p>客户端不应该依赖它不需要的接口，即<strong>一个类对另一个类的依赖应该建立在最小的接口上</strong></p>
</li>
<li><p>先看一张图:</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02.png" alt="image-20210411004513392"></p>
</li>
<li><p>类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D，如果接口 Interface1 对于类 A 和类 C来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法。</p>
</li>
<li><p>按隔离原则应当这样处理：</p>
<p>将接口 <strong>Interface1</strong> 拆分为独立的几个接口**(<strong>这里我们拆分成 **3</strong> 个接口**)**，类 A 和类 C 分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则</p>
</li>
</ol>
<h4 id="2-4-2、应用实例"><a href="#2-4-2、应用实例" class="headerlink" title="2.4.2、应用实例"></a>2.4.2、应用实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Segregation1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//接口</span></span><br><span class="line">	<span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span></span>; </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span></span>; </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Interface1</span> </span>&#123; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    		System.out.println(<span class="string">&quot;B 实现了 operation1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;B 实现了 operation2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        	System.out.println(<span class="string">&quot;B 实现了 operation3&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        	System.out.println(<span class="string">&quot;B 实现了 operation4&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        	System.out.println(<span class="string">&quot;B 实现了 operation5&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">Interface1</span> </span>&#123; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;D 实现了 operation1&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;D 实现了 operation2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;D 实现了 operation3&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;D 实现了  operation4&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">operation5</span><span class="params">()</span>  </span>&#123; </span><br><span class="line">            System.out.println(<span class="string">&quot;D 实现了  operation5&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; <span class="comment">//A 类通过接口 Interface1 依赖(使用) B 类，但是只会用到 1,2,3 方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(Interface1 i)</span> </span>&#123; </span><br><span class="line">            i.operation1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(Interface1 i)</span> </span>&#123; </span><br><span class="line">            i.operation2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(Interface1 i)</span> </span>&#123; </span><br><span class="line">            i.operation3();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123; <span class="comment">//C 类通过接口 Interface1  依赖(使用) D 类，但是只会用到 1,4,5 方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(Interface1 i)</span> </span>&#123; </span><br><span class="line">            i.operation1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend4</span><span class="params">(Interface1 i)</span> </span>&#123; </span><br><span class="line">            i.operation4();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend5</span><span class="params">(Interface1 i)</span> </span>&#123; </span><br><span class="line">            i.operation5();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-4-3、应传统方法的问题和使用接口隔离原则改进"><a href="#2-4-3、应传统方法的问题和使用接口隔离原则改进" class="headerlink" title="2.4.3、应传统方法的问题和使用接口隔离原则改进"></a>2.4.3、应传统方法的问题和使用接口隔离原则改进</h4><ol>
<li><p>类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D，如果接口 Interface1 对于类 A 和类 C来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法</p>
</li>
<li><p>将接口 <strong>Interface1</strong> 拆分为独立的几个接口，类 A 和类 C 分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则</p>
</li>
<li><p>接口 Interface1 中出现的方法，根据实际情况拆分为三个接口：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/03.png" alt="image-20210411010354543"></p>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Segregation1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="comment">// 使用一把</span></span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        a.depend1(<span class="keyword">new</span> B()); <span class="comment">// A 类通过接口去依赖 B 类</span></span><br><span class="line">        a.depend2(<span class="keyword">new</span> B());</span><br><span class="line">        a.depend3(<span class="keyword">new</span> B());</span><br><span class="line"></span><br><span class="line">        C c = <span class="keyword">new</span> C();</span><br><span class="line"></span><br><span class="line">        c.depend1(<span class="keyword">new</span> D()); <span class="comment">// C 类通过接口去依赖(使用)D 类</span></span><br><span class="line">        c.depend4(<span class="keyword">new</span> D());</span><br><span class="line">        c.depend5(<span class="keyword">new</span> D());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接 口 1</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接 口 2</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface2</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接 口 3</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface3</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Interface1</span>, <span class="title">Interface2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 实现了 operation1&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 实现了 operation2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B 实现了 operation3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">Interface1</span>, <span class="title">Interface3</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;D 实现了  operation1&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">operation4</span><span class="params">()</span>  </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;D 实现了  operation4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D 实现了 operation5&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; <span class="comment">// A 类通过接口 Interface1,Interface2 依赖(使用) B 类，但是只会用到 1,2,3 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(Interface1 i)</span> </span>&#123; </span><br><span class="line">        i.operation1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(Interface2 i)</span> </span>&#123; </span><br><span class="line">        i.operation2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(Interface2 i)</span> </span>&#123; </span><br><span class="line">        i.operation3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123; <span class="comment">// C  类通过接口 Interface1,Interface3  依赖(使用) D 类，但是只会用到 1,4,5 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(Interface1 i)</span> </span>&#123; </span><br><span class="line">        i.operation1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend4</span><span class="params">(Interface3 i)</span> </span>&#123; </span><br><span class="line">        i.operation4();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend5</span><span class="params">(Interface3 i)</span> </span>&#123;</span><br><span class="line">        i.operation5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="2-4-4、接口隔离原则注意事项和细节"><a href="#2-4-4、接口隔离原则注意事项和细节" class="headerlink" title="2.4.4、接口隔离原则注意事项和细节"></a>2.4.4、接口隔离原则注意事项和细节</h4><ol>
<li>接口隔离原则的思想在于建立单一接口，尽可能地去细化接口，接口中的方法尽可能少</li>
<li>但是凡事都要有个度，如果接口设计过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。</li>
</ol>
<h3 id="2-5-、依赖倒转原则-Dependence-Inversion-Principle"><a href="#2-5-、依赖倒转原则-Dependence-Inversion-Principle" class="headerlink" title="2.5 、依赖倒转原则(Dependence Inversion Principle)"></a>2.5 、依赖倒转原则(Dependence Inversion Principle)</h3><h4 id="2-5-1、基本介绍"><a href="#2-5-1、基本介绍" class="headerlink" title="2.5.1、基本介绍"></a>2.5.1、基本介绍</h4><p>依赖倒转原则(Dependence Inversion Principle)是指：</p>
<ol>
<li>高层模块不应该依赖低层模块，二者都应该<strong>依赖其抽象</strong></li>
<li>抽象不应该依赖细节，细节应该依赖抽象</li>
<li>依赖倒转(倒置)的中心思想是<strong>面向接口编程</strong>，<strong>面向抽象编程，解耦调用和被调用者</strong></li>
<li>依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在 java 中，<strong>抽象指的是接口或抽象类，细节就是具体的实现类</strong></li>
<li>当两个模块之间存在紧密的耦合关系时，最好的方法就是<strong>分离接口和实现</strong>：在<strong>依赖之间</strong>定义一个抽象的接口使得高层模块调用接口，而底层模块实现接口的定义，以此来有效控制耦合关系，达到依赖于抽象的设计目标。</li>
<li>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把<strong>展现细节</strong>的任务交给他们的<strong>实现类</strong>去完成</li>
</ol>
<h4 id="2-5-2、应用实例"><a href="#2-5-2、应用实例" class="headerlink" title="2.5.2、应用实例"></a>2.5.2、应用实例</h4><p>请编程完成 Person 接收消息 的功能。</p>
<p>实现方案 1 + 分析说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependecyInversion</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Person person = <span class="keyword">new</span> Person();</span><br><span class="line">		person.receive(<span class="keyword">new</span> Email());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;电子邮件信息: hello,world&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//完成Person接收消息的功能</span></span><br><span class="line"><span class="comment">//方式1分析</span></span><br><span class="line"><span class="comment">//1. 简单，比较容易想到</span></span><br><span class="line"><span class="comment">//2. 但如果我们获取的对象是 微信，短信等等，则新增类，同时Perons也要增加相应的接收方法</span></span><br><span class="line"><span class="comment">//3. 解决思路：引入一个抽象的接口IReceiver, 表示接收者, 这样Person类与接口IReceiver发生依赖</span></span><br><span class="line"><span class="comment">//   因为Email, WeiXin 等等属于接收的范围，他们各自实现IReceiver 接口就ok, 这样我们就符号依赖倒转原则</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Email email)</span> </span>&#123;</span><br><span class="line">		System.out.println(email.getInfo());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现方案 2(依赖倒转) + 分析说明（同时也满足了开闭原则ocp）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependecyInversion</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//客户端无需改变</span></span><br><span class="line">		Person person = <span class="keyword">new</span> Person();</span><br><span class="line">		person.receive(<span class="keyword">new</span> Email());</span><br><span class="line">		</span><br><span class="line">		person.receive(<span class="keyword">new</span> WeiXin());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> <span class="keyword">implements</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;电子邮件信息: hello,world&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加微信</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeiXin</span> <span class="keyword">implements</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;微信信息: hello,ok&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="comment">//这里我们是对接口的依赖</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(IReceiver receiver )</span> </span>&#123;</span><br><span class="line">		System.out.println(receiver.getInfo());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-3、-依赖关系传递的三种方式和应用案例"><a href="#2-5-3、-依赖关系传递的三种方式和应用案例" class="headerlink" title="2.5.3、 依赖关系传递的三种方式和应用案例"></a>2.5.3、 依赖关系传递的三种方式和应用案例</h4><h5 id="2-5-3-1、接口传递"><a href="#2-5-3-1、接口传递" class="headerlink" title="2.5.3.1、接口传递"></a>2.5.3.1、接口传递</h5><p>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyPass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ChangHong changHong = <span class="keyword">new</span> ChangHong();</span><br><span class="line">        <span class="comment">// 方式1： 通过接口传递实现依赖</span></span><br><span class="line">		OpenAndClose openAndClose = <span class="keyword">new</span> OpenAndClose();</span><br><span class="line">		openAndClose.open(changHong);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式1： 通过接口传递实现依赖</span></span><br><span class="line"><span class="comment">// 开关的接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="comment">//抽象方法,接收接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(ITV tv)</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ITV接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITV</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChangHong</span> <span class="keyword">implements</span> <span class="title">ITV</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;长虹电视机，打开&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现IOpenAndClose接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenAndClose</span> <span class="keyword">implements</span> <span class="title">IOpenAndClose</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(ITV tv)</span></span>&#123;</span><br><span class="line">        tv.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现ITV接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChangHong</span> <span class="keyword">implements</span> <span class="title">ITV</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;长虹电视机，打开&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-5-3-2、构造方法传递"><a href="#2-5-3-2、构造方法传递" class="headerlink" title="2.5.3.2、构造方法传递"></a>2.5.3.2、构造方法传递</h5><p>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyPass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ChangHong changHong = <span class="keyword">new</span> ChangHong();</span><br><span class="line">		<span class="comment">// 方式2: 通过构造方法依赖传递</span></span><br><span class="line">		OpenAndClose openAndClose = <span class="keyword">new</span> OpenAndClose(changHong);</span><br><span class="line">		openAndClose.open();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2: 通过构造方法依赖传递</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ITV接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITV</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现IOpenAndClose接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenAndClose</span> <span class="keyword">implements</span> <span class="title">IOpenAndClose</span></span>&#123;</span><br><span class="line">    <span class="comment">//成员</span></span><br><span class="line">    <span class="keyword">public</span> ITV tv; </span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OpenAndClose</span><span class="params">(ITV tv)</span></span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tv.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现ITV接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChangHong</span> <span class="keyword">implements</span> <span class="title">ITV</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;长虹电视机，打开&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-5-3-3、setter-方式传递"><a href="#2-5-3-3、setter-方式传递" class="headerlink" title="2.5.3.3、setter 方式传递"></a>2.5.3.3、setter 方式传递</h5><p>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyPass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ChangHong changHong = <span class="keyword">new</span> ChangHong();</span><br><span class="line">		<span class="comment">//通过setter方法进行依赖传递</span></span><br><span class="line">		OpenAndClose openAndClose = <span class="keyword">new</span> OpenAndClose();</span><br><span class="line">		openAndClose.setTv(changHong);</span><br><span class="line">		openAndClose.open();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式3 , 通过setter方法传递</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// setter方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTv</span><span class="params">(ITV tv)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ITV接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITV</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现IOpenAndClose接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenAndClose</span> <span class="keyword">implements</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ITV tv;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTv</span><span class="params">(ITV tv)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.tv = tv;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.tv.play();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现ITV接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChangHong</span> <span class="keyword">implements</span> <span class="title">ITV</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;长虹电视机，打开&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-4、依赖倒转原则的注意事项和细节"><a href="#2-5-4、依赖倒转原则的注意事项和细节" class="headerlink" title="2.5.4、依赖倒转原则的注意事项和细节"></a>2.5.4、依赖倒转原则的注意事项和细节</h4><ol>
<li><strong>低层模块尽量都要有抽象类或接口</strong>，或者两者都有，程序稳定性更好.</li>
<li><strong>变量的声明类型尽量是抽象类或接口</strong>, 这样我们的变量引用和实际对象间，就存在一个<strong>缓冲层</strong>，利于程序扩展和优化</li>
<li><strong>继承时遵循里氏替换原则</strong>.</li>
</ol>
<h3 id="2-6、里氏替换原则-Liskov-Substitution-Principle"><a href="#2-6、里氏替换原则-Liskov-Substitution-Principle" class="headerlink" title="2.6、里氏替换原则(Liskov Substitution Principle)"></a>2.6、里氏替换原则(Liskov Substitution Principle)</h3><h4 id="2-6-1、OO-中的继承性的思考和说明"><a href="#2-6-1、OO-中的继承性的思考和说明" class="headerlink" title="2.6.1、OO 中的继承性的思考和说明"></a>2.6.1、OO 中的继承性的思考和说明</h4><ol>
<li>继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果<strong>子类对这些已经实现的方法任意修改</strong>，就会对<strong>整个继承体系造成破坏</strong>。</li>
<li><strong>继承在给程序设计带来便利的同时，也带来了弊端</strong>。比如使用继承会给程序带来<strong>侵入性</strong>，程序的<strong>可移植性降低</strong>， <strong>增加对象间的耦合性</strong>，如果<strong>一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类</strong>，并且<strong>父类修改</strong>后，<strong>所有涉及到子类的功能都有可能产生故障</strong></li>
<li><strong>里氏替换原则的重点在不影响原功能，而不是不覆盖原方法。</strong></li>
<li>问题提出：在编程中，<strong>如何正确的使用继承</strong>? =&gt; <strong>里氏替换</strong>原则</li>
</ol>
<h4 id="2-6-2、-基本介绍"><a href="#2-6-2、-基本介绍" class="headerlink" title="2.6.2、 基本介绍"></a>2.6.2、 基本介绍</h4><ol>
<li>里氏替换原则(Liskov Substitution Principle)在 1988 年，由麻省理工学院的以为姓里的女士提出的。</li>
<li>里氏替换原则的含义是：<strong>子类可以在任何地方替换它的父类。</strong></li>
<li>也就是说在程序中将基类替换为子类，程序的行为不会发生任何变化。</li>
<li>Liskov替换原则是<strong>关于继承机制的设计原则</strong>，<strong>违反了Liskov替换原则就必然导致违反开放封闭原则</strong></li>
<li>如果对每个类型为 T1 的对象 o1，都有类型为 T2 的对象 o2，使得以 T1 定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。换句话说，<strong>所有引用基类的地方必须能透明地使用其子类的对象</strong>。</li>
<li>在使用继承时，遵循里氏替换原则，在**<code>子类中尽量不要重写父类的方法</code>**。</li>
<li>里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过**<code>聚合，组合，依赖</code>**来解决问题。</li>
</ol>
<p>里氏原则的优点：</p>
<ol>
<li>能够保证系统具有良好的拓展性</li>
<li>同时实现基于多态的抽象机制</li>
<li>能够减少代码冗余</li>
<li>避免运行期的类型判别</li>
</ol>
<h4 id="2-6-3、-一个程序引出的问题和思考"><a href="#2-6-3、-一个程序引出的问题和思考" class="headerlink" title="2.6.3、 一个程序引出的问题和思考"></a>2.6.3、 一个程序引出的问题和思考</h4><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/04.png" alt="image-20210411022902982"></p>
<p>程序员原本是想调用b中继承的a的func1的方法求出11-3，但b无意重写了a的func1方法，使相减变成了相加。</p>
<h4 id="2-6-4、解决方法"><a href="#2-6-4、解决方法" class="headerlink" title="2.6.4、解决方法"></a>2.6.4、解决方法</h4><ol>
<li><p>我们发现原来运行正常的相减功能发生了错误。原因就是类 B 无意中重写了父类的方法，造成原有功能出现错误。在实际编程中，我们常常会通过重写父类的方法完成新的功能，这样写起来虽然简单，但整个继承体系的复用性会比较差。特别是<strong>运行多态比较频繁</strong>的时候</p>
</li>
<li><p>通用的做法是：<strong>原来的父类和子类都继承一个更通俗的基类</strong>，原有的继承关系去掉，采用<strong>依赖，聚合，组合</strong>等关系代替.</p>
</li>
<li><p>即：子类可以扩展父类的功能，但不能改变父类原有的功能。</p>
</li>
<li><p>改进方案：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/05.png" alt="image-20210411023703967"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Liskov</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		A a = <span class="keyword">new</span> A();</span><br><span class="line">		System.out.println(<span class="string">&quot;11-3=&quot;</span> + a.func1(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;1-8=&quot;</span> + a.func1(<span class="number">1</span>, <span class="number">8</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">		B b = <span class="keyword">new</span> B();</span><br><span class="line">		<span class="comment">//因为B类不再继承A类，因此调用者，不会再认为func1是求减法</span></span><br><span class="line">		<span class="comment">//调用完成的功能就会很明确</span></span><br><span class="line">		System.out.println(<span class="string">&quot;11+3=&quot;</span> + b.func1(<span class="number">11</span>, <span class="number">3</span>));<span class="comment">//这里本意是求出11+3</span></span><br><span class="line">		System.out.println(<span class="string">&quot;1+8=&quot;</span> + b.func1(<span class="number">1</span>, <span class="number">8</span>));<span class="comment">// 1+8</span></span><br><span class="line">		System.out.println(<span class="string">&quot;11+3+9=&quot;</span> + b.func2(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//使用组合仍然可以使用到A类相关方法</span></span><br><span class="line">		System.out.println(<span class="string">&quot;11-3=&quot;</span> + b.func3(<span class="number">11</span>, <span class="number">3</span>));<span class="comment">// 这里本意是求出11-3</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个更加基础的基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">	<span class="comment">//把更加基础的方法和成员写到Base类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A类继承了Base</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 重写func1返回两个数的差</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> num1 - num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// B类继承了Base</span></span><br><span class="line"><span class="comment">// 增加了一个新功能：完成两个数相加,然后和9求和</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">	<span class="comment">//如果B需要使用A类的方法,使用组合关系</span></span><br><span class="line">	<span class="keyword">private</span> A a = <span class="keyword">new</span> A();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//这里，重写了Base类的方法,</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> func1(a, b) + <span class="number">9</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//我们仍然想使用A的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.a.func1(a, b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="2-7、开闭原则（Open-Closed-Principle）"><a href="#2-7、开闭原则（Open-Closed-Principle）" class="headerlink" title="2.7、开闭原则（Open Closed Principle）"></a>2.7、开闭原则（Open Closed Principle）</h3><h4 id="2-7-1、基本介绍"><a href="#2-7-1、基本介绍" class="headerlink" title="2.7.1、基本介绍"></a>2.7.1、基本介绍</h4><ol>
<li>开闭原则（Open Closed Principle）是编程中<strong>最基础、最重要</strong>的设计原则</li>
<li>一个软件实体如类，模块和函数应该<strong>对扩展开放(对提供方)**，</strong>对修改关闭(对使用方)<strong>。用</strong>抽象构建框架<strong>，用</strong>实现扩展细节**。</li>
<li>采用逆向思维方式来想。如果每次需求变动都去修改原有的代码，那原有的代码就存在被修改错误的风险，当然这其中存在有意和无意的修改，都会导致原有正常运行的功能失效的风险，这样很有可能会展开可怕的蝴蝶效应，使维护工作剧增。</li>
<li>所以当软件需要变化时，尽量<strong>通过扩展软件实体</strong>的行为来实现变化，而<strong>不是通过修改已有的代码</strong>来实现变化。</li>
<li><strong>编程中遵循其它原则</strong>，以及<strong>使用设计模式的目的就是遵循开闭原则</strong>。</li>
</ol>
<h4 id="2-7-2、看下面一段代码"><a href="#2-7-2、看下面一段代码" class="headerlink" title="2.7.2、看下面一段代码"></a>2.7.2、看下面一段代码</h4><p>实现画图形的功能</p>
<p>类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/06.png" alt="image-20210411025709019"></p>
<p>代码：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/07.png" alt="image-20210411025938974"></p>
<p>但我们增加一个功能：画三角形</p>
<p>方式1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ocp</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		GraphicEditor graphicEditor = <span class="keyword">new</span> GraphicEditor();</span><br><span class="line">		graphicEditor.drawShape(<span class="keyword">new</span> Rectangle());</span><br><span class="line">		graphicEditor.drawShape(<span class="keyword">new</span> Circle());</span><br><span class="line">        <span class="comment">//使用看看存在的问题</span></span><br><span class="line">		graphicEditor.drawShape(<span class="keyword">new</span> Triangle());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个用于绘图的类 [使用方]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicEditor</span> </span>&#123;</span><br><span class="line">	<span class="comment">//接收Shape对象，然后根据type，来绘制不同的图形</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (s.m_type == <span class="number">1</span>)</span><br><span class="line">			drawRectangle(s);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (s.m_type == <span class="number">2</span>)</span><br><span class="line">			drawCircle(s);</span><br><span class="line">        <span class="comment">// 修改1</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (s.m_type == <span class="number">3</span>)</span><br><span class="line">			drawTriangle(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//绘制矩形</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRectangle</span><span class="params">(Shape r)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; 绘制矩形 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//绘制圆形</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">(Shape r)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; 绘制圆形 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//绘制三角形</span></span><br><span class="line">    <span class="comment">//修改2</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawTriangle</span><span class="params">(Shape r)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; 绘制三角形 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Shape类，基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m_type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	Rectangle() &#123;</span><br><span class="line">		<span class="keyword">super</span>.m_type = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	Circle() &#123;</span><br><span class="line">		<span class="keyword">super</span>.m_type = <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新增功能：画三角形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	Triangle() &#123;</span><br><span class="line">		<span class="keyword">super</span>.m_type = <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-7-3、方式-1-的优缺点"><a href="#2-7-3、方式-1-的优缺点" class="headerlink" title="2.7.3、方式 1 的优缺点"></a>2.7.3、方式 1 的优缺点</h4><ol>
<li><p>优点是比较好理解，简单易操作。</p>
</li>
<li><p>缺点是违反了设计模式的 ocp 原则，即**对扩展开放(提供方)，对修改关闭(使用方)**。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码.</p>
</li>
<li><p>比如我们这时要<strong>新增加一个图形种类三角形，我们需要做如下修改，修改的地方较多（使用方要修改两次）</strong></p>
</li>
<li><p>代码演示（方式2）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ocp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		GraphicEditor graphicEditor = <span class="keyword">new</span> GraphicEditor();</span><br><span class="line">		graphicEditor.drawShape(<span class="keyword">new</span> Rectangle());</span><br><span class="line">		graphicEditor.drawShape(<span class="keyword">new</span> Circle());</span><br><span class="line">         <span class="comment">//使用方直接使用</span></span><br><span class="line">		graphicEditor.drawShape(<span class="keyword">new</span> Triangle());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是一个用于绘图的类 [使用方]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicEditor</span> </span>&#123;</span><br><span class="line">	<span class="comment">//接收Shape对象，调用draw方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape s)</span> </span>&#123;</span><br><span class="line">		s.draw();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Shape类，基类（使用抽象类）</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="comment">//抽象方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承抽象类Shape</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot; 绘制矩形 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承抽象类Shape</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot; 绘制圆形 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新增功能：画三角形</span></span><br><span class="line"><span class="comment">// 继承抽象类Shape</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot; 绘制三角形 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="2-7-4、改进的思路分析"><a href="#2-7-4、改进的思路分析" class="headerlink" title="2.7.4、改进的思路分析"></a>2.7.4、改进的思路分析</h4><p>把创建 <strong>Shape</strong> 类做成<strong>抽象类</strong>，并提供一个<strong>抽象的 draw 方法</strong>，让<strong>子类去实现</strong>即可，这样我们有<strong>新的图形种类</strong>时，只需要让<strong>新的图形类继承 Shape</strong>，并<strong>实现 draw 方法</strong>即可，<strong>使用方的代码就不需要修改-&gt;    满足了开闭原则</strong></p>
<h4 id="2-7-5、开闭原则注意事项和细节"><a href="#2-7-5、开闭原则注意事项和细节" class="headerlink" title="2.7.5、开闭原则注意事项和细节"></a>2.7.5、开闭原则注意事项和细节</h4><ol>
<li>OCP 可以具有良好的可扩展性，可维护性。</li>
<li>不可能让一个系统的所有模块都满足 OCP 原则，我们能做到的是尽可能地不要修改已经写好的代码，已有的功能，而是去扩展它。</li>
</ol>
<h3 id="2-8、迪米特法则-Demeter-Principle"><a href="#2-8、迪米特法则-Demeter-Principle" class="headerlink" title="2.8、迪米特法则(Demeter Principle)"></a>2.8、迪米特法则(Demeter Principle)</h3><h4 id="2-8-1、基本介绍"><a href="#2-8-1、基本介绍" class="headerlink" title="2.8.1、基本介绍"></a>2.8.1、基本介绍</h4><ol>
<li>迪米特原则要求尽量的封装，尽量的独立，尽量的使用低级别的访问修饰符。就是说<strong>一个对象应当对其他对象有尽可能少的了解,不和陌生人说话。</strong></li>
<li>一个对象应该对其他对象<strong>保持最少的了解</strong></li>
<li>类与类关系越密切，耦合度越大</li>
<li>迪米特法则(Demeter Principle)又叫<strong>最少知道原则</strong>，即一个类对自己依赖的类知道的越少越好。也就是说，对于<strong>被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部</strong>。对外除了提供的 public 方法，不对外泄露任何信息</li>
<li>迪米特法则还有个更简单的定义：<strong>只与直接的朋友通信</strong></li>
<li><strong>直接的朋友</strong>：每个对象都会与其他对象有耦合关系，只要<strong>两个对象之间有耦合关系</strong>，我们就说这两个对象之间是<strong>朋友关系</strong>。耦合的方式很多，<strong>依赖</strong>，<strong>关联</strong>，<strong>组合</strong>，<strong>聚合</strong>等。其中，我们称出现<strong>成员变量</strong>，<strong>方法参数</strong>，<strong>方法返回值</strong>中的类为<strong>直接的朋友</strong>，而出现在<strong>局部变量中的类不是直接的朋友</strong>。也就是说，<strong>陌生的类最好不要以局部变量的形式出现在类的内部</strong>。最好将其封装到直接朋友里面。</li>
<li>迪米特原则要求类之间的直接联系尽量的少，两个类的访问，通过第三个中介类来实现。</li>
</ol>
<h4 id="2-8-2、应用实例"><a href="#2-8-2、应用实例" class="headerlink" title="2.8.2、应用实例"></a>2.8.2、应用实例</h4><p>有一个学校，下属有各个学院和总部，现要求打印出学校总部员工 ID 和学院员工的 id。编程实现上面的功能, 看代码演示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demeter1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建了一个 SchoolManager 对象</span></span><br><span class="line">		SchoolManager schoolManager = <span class="keyword">new</span> SchoolManager();</span><br><span class="line">		<span class="comment">//输出学院的员工id 和  学校总部的员工信息</span></span><br><span class="line">		schoolManager.printAllEmployee(<span class="keyword">new</span> CollegeManager());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//学校总部员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String id;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//学院的员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeEmployee</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String id;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管理学院员工的管理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeManager</span> </span>&#123;</span><br><span class="line">	<span class="comment">////添加学院的员工</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		List&lt;CollegeEmployee&gt; list = <span class="keyword">new</span> ArrayList&lt;CollegeEmployee&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">//这里我们增加了10个员工到 list</span></span><br><span class="line">			CollegeEmployee emp = <span class="keyword">new</span> CollegeEmployee();</span><br><span class="line">			emp.setId(<span class="string">&quot;学院员工id= &quot;</span> + i);</span><br><span class="line">			list.add(emp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//学校管理类</span></span><br><span class="line"><span class="comment">//分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager</span></span><br><span class="line"><span class="comment">//CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchoolManager</span> </span>&#123;</span><br><span class="line">	<span class="comment">//返回学校总部的员工</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line">		<span class="comment">//这里我们增加了5个员工到 list</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; </span><br><span class="line">			Employee emp = <span class="keyword">new</span> Employee();</span><br><span class="line">			emp.setId(<span class="string">&quot;学校总部员工id= &quot;</span> + i);</span><br><span class="line">			list.add(emp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//该方法完成输出学校总部和学院员工信息(id)</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(CollegeManager sub)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//分析问题</span></span><br><span class="line">		<span class="comment">//1. 这里的 CollegeEmployee 不是  SchoolManager的直接朋友</span></span><br><span class="line">		<span class="comment">//2. CollegeEmployee 是以局部变量方式出现在 SchoolManager</span></span><br><span class="line">		<span class="comment">//3. 违反了 迪米特法则 </span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//获取到学院员工</span></span><br><span class="line">		List&lt;CollegeEmployee&gt; list1 = sub.getAllEmployee();</span><br><span class="line">		System.out.println(<span class="string">&quot;------------学院员工------------&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (CollegeEmployee e : list1) &#123;</span><br><span class="line">			System.out.println(e.getId());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//获取到学校总部员工</span></span><br><span class="line">		List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line">		System.out.println(<span class="string">&quot;------------学校总部员工------------&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (Employee e : list2) &#123;</span><br><span class="line">			System.out.println(e.getId());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-8-3、应用实例改进"><a href="#2-8-3、应用实例改进" class="headerlink" title="2.8.3、应用实例改进"></a>2.8.3、应用实例改进</h4><ol>
<li><p>前面设计的问题在于 SchoolManager 中，<strong>CollegeEmployee</strong> 类并不是 <strong>SchoolManager</strong> 类的直接朋友 (分析)</p>
</li>
<li><p>按照迪米特法则，应该<strong>避免类中出现这样非直接朋友关系的耦合</strong></p>
</li>
<li><p>对代码按照迪米特法则 进行改进：</p>
</li>
<li><p>代码演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demeter1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建了一个 SchoolManager 对象</span></span><br><span class="line">		SchoolManager schoolManager = <span class="keyword">new</span> SchoolManager();</span><br><span class="line">		<span class="comment">//输出学院的员工id 和  学校总部的员工信息</span></span><br><span class="line">		schoolManager.printAllEmployee(<span class="keyword">new</span> CollegeManager());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//学校总部员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String id;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//学院的员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeEmployee</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String id;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//管理学院员工的管理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeManager</span> </span>&#123;</span><br><span class="line">	<span class="comment">//添加学院的员工</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		List&lt;CollegeEmployee&gt; list = <span class="keyword">new</span> ArrayList&lt;CollegeEmployee&gt;();</span><br><span class="line">         <span class="comment">//这里我们增加了10个员工到 list</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line">			CollegeEmployee emp = <span class="keyword">new</span> CollegeEmployee();</span><br><span class="line">			emp.setId(<span class="string">&quot;学院员工id= &quot;</span> + i);</span><br><span class="line">			list.add(emp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//输出学院员工的信息</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//获取到学院员工</span></span><br><span class="line">		List&lt;CollegeEmployee&gt; list1 = getAllEmployee();</span><br><span class="line">		System.out.println(<span class="string">&quot;------------学院员工------------&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (CollegeEmployee e : list1) &#123;</span><br><span class="line">			System.out.println(e.getId());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//学校管理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchoolManager</span> </span>&#123;</span><br><span class="line">	<span class="comment">//返回学校总部的员工</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line">         <span class="comment">//这里我们增加了5个员工到 list</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; </span><br><span class="line">			Employee emp = <span class="keyword">new</span> Employee();</span><br><span class="line">			emp.setId(<span class="string">&quot;学校总部员工id= &quot;</span> + i);</span><br><span class="line">			list.add(emp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//该方法完成输出学校总部和学院员工信息(id)</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(CollegeManager sub)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//分析问题</span></span><br><span class="line">		<span class="comment">//1. 将输出学院的员工方法，封装到CollegeManager</span></span><br><span class="line">		sub.printEmployee();</span><br><span class="line">		<span class="comment">//获取到学校总部员工</span></span><br><span class="line">		List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line">		System.out.println(<span class="string">&quot;------------学校总部员工------------&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (Employee e : list2) &#123;</span><br><span class="line">			System.out.println(e.getId());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="2-8-4、迪米特法则注意事项和细节"><a href="#2-8-4、迪米特法则注意事项和细节" class="headerlink" title="2.8.4、迪米特法则注意事项和细节"></a>2.8.4、迪米特法则注意事项和细节</h4><ol>
<li><p>迪米特法则的核心是<strong>降低类之间的耦合</strong></p>
</li>
<li><p>但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间(对象间)耦合关系， 并不是要求完全没有依赖关系</p>
</li>
</ol>
<h3 id="2-9、合成复用原则（Composite-Reuse-Principle）"><a href="#2-9、合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="2.9、合成复用原则（Composite Reuse Principle）"></a>2.9、合成复用原则（Composite Reuse Principle）</h3><h4 id="2-9-1、基本介绍"><a href="#2-9-1、基本介绍" class="headerlink" title="2.9.1、基本介绍"></a>2.9.1、基本介绍</h4><p>原则是尽量使用<strong>合成/聚合</strong>的方式，而<strong>不是使用继承</strong></p>
<p>聚合组合是一种 “黑箱” 复用，因为细节对象的内容对客户端来说是不可见的。</p>
<p>因为继承的耦合性更大，组合聚合只是引用其他的类的方法，而不会受引用的类的继承而改变血统。说白了就是我只用你的方法，但我们并不是同类。</p>
<p>在面向对象的设计中，如果直接继承基类，会破坏封装，因为继承将基类的实现细节暴露给子类；如果基类的实现发生了改变，则子类的实现也不得不改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性。于是就提出了组合/聚合复用原则，也就是在实际开发设计中，尽量使用组合/聚合，不要使用类继承。</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/08.png" alt="image-20210411150334377"></p>
<h3 id="2-10、设计原则核心思想"><a href="#2-10、设计原则核心思想" class="headerlink" title="2.10、设计原则核心思想"></a>2.10、设计原则核心思想</h3><ol>
<li>找出应用中<strong>可能需要变化</strong>之处，把它们<strong>独立</strong>出来，不要和那些不需要变化的代码混在一起。</li>
<li><strong>针对接口编程</strong>，而不是针对实现编程。</li>
<li>为了交互对象之间的<strong>松耦合</strong>设计而努力</li>
</ol>
<h3 id="2-11、设计七大原则总结"><a href="#2-11、设计七大原则总结" class="headerlink" title="2.11、设计七大原则总结"></a>2.11、设计七大原则总结</h3><p>这 7 种设计原则是软件设计模式必须尽量遵循的原则，是设计模式的基础。在实际开发过程中，并不是一定要求所有代码都遵循设计原则，而是要综合考虑人力、时间、成本、质量，不刻意追求完美，要在适当的场景遵循设计原则。这体现的是一种平衡取舍，可以帮助我们设计出更加优雅的代码结构。</p>
<p>各种原则要求的侧重点不同，下面我们分别用一句话归纳总结软件设计模式的七大原则，如下表所示。</p>
<table>
<thead>
<tr>
<th>设计原则</th>
<th>一句话归纳</th>
<th>目的</th>
</tr>
</thead>
<tbody><tr>
<td>开闭原则</td>
<td>对扩展开放，对修改关闭</td>
<td>降低维护带来的新风险</td>
</tr>
<tr>
<td>依赖倒置原则</td>
<td>高层不应该依赖低层，要面向接口编程</td>
<td>更利于代码结构的升级扩展</td>
</tr>
<tr>
<td>单一职责原则</td>
<td>一个类只干一件事，实现类要单一</td>
<td>便于理解，提高代码的可读性</td>
</tr>
<tr>
<td>接口隔离原则</td>
<td>一个接口只干一件事，接口要精简单一</td>
<td>功能解耦，高聚合、低耦合</td>
</tr>
<tr>
<td>迪米特法则</td>
<td>不该知道的不要知道，一个类应该保持对其它对象最少的了解，降低耦合度</td>
<td>只和朋友交流，不和陌生人说话，减少代码臃肿</td>
</tr>
<tr>
<td>里氏替换原则</td>
<td>不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义</td>
<td>防止继承泛滥</td>
</tr>
<tr>
<td>合成复用原则</td>
<td>尽量使用组合或者聚合关系实现代码复用，少使用继承</td>
<td>降低代码耦合</td>
</tr>
</tbody></table>
<p>实际上，这些原则的目的只有一个：<strong>降低对象之间的耦合，增加程序的可复用性、可扩展性和可维护性</strong>。</p>
<blockquote>
<p>记忆口诀：访问加限制，函数要节俭，依赖不允许，动态加接口，父类要抽象，扩展不更改。</p>
</blockquote>
<p>在程序设计时，我们应该将程序功能最小化，每个类只干一件事。若有类似功能基础之上添加新功能，则要合理使用继承。对于多方法的调用，要会运用接口，同时合理设置接口功能与数量。最后类与类之间做到低耦合高内聚。</p>
<h2 id="3、UML-类图"><a href="#3、UML-类图" class="headerlink" title="3、UML 类图"></a>3、UML 类图</h2><h3 id="3-1、UML-基本介绍"><a href="#3-1、UML-基本介绍" class="headerlink" title="3.1、UML 基本介绍"></a>3.1、UML 基本介绍</h3><ol>
<li><p>UML——Unified modeling language UML (统一建模语言)，是一种用于软件系统分析和设计的语言工具，它用于帮助软件开发人员进行思考和记录思路的结果</p>
</li>
<li><p>UML 本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他们之间的关系，比如<strong>类、接口、实现、泛化、依赖、组合、聚合</strong>等，如右图:</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/09.png" alt="image-20210411172838273"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10.png" alt="image-20210411173002251"></p>
</li>
<li><p>使用 UML 来建模，常用的工具有 Rational Rose , 也可以使用一些插件来建模</p>
</li>
</ol>
<h3 id="3-2、UML-图"><a href="#3-2、UML-图" class="headerlink" title="3.2、UML 图"></a>3.2、UML 图</h3><p>画 UML 图与写文章差不多，都是把自己的思想描述给别人看，关键在于思路和条理，UML 图分类：</p>
<ol>
<li>用例图(use case)</li>
<li> 静态结构图：<strong>类图</strong>、对象图、包图、组件图、部署图</li>
<li>动态行为图：交互图（时序图与协作图）、状态图、活动图</li>
</ol>
<p>说明：</p>
<ol>
<li>类图是描述<strong>类与类之间的关系</strong>的，是 UML 图中最核心的</li>
<li>在讲解设计模式时，我们必然会使用类图，为了让学员们能够把设计模式学到位，需要先给大家讲解类图</li>
</ol>
<h3 id="3-3、UML-类图"><a href="#3-3、UML-类图" class="headerlink" title="3.3、UML 类图"></a>3.3、UML 类图</h3><ol>
<li><p>用于描述系统中的类**(<strong>对象</strong>)<strong>本身的组成和类</strong>(<strong>对象</strong>)**之间的各种静态关系。</p>
</li>
<li><p>类之间的关系：依赖、泛化（继承）、实现、关联、聚合与组合。</p>
</li>
<li><p>类图简单举例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123; <span class="comment">//代码形式-&gt;类图</span></span><br><span class="line">    <span class="keyword">private</span> Integer id; <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span>	name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类图</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/11.png" alt="image-20210411192255196"></p>
</li>
</ol>
<h3 id="3-4、类图—依赖关系（Dependence）"><a href="#3-4、类图—依赖关系（Dependence）" class="headerlink" title="3.4、类图—依赖关系（Dependence）"></a>3.4、类图—依赖关系（Dependence）</h3><p>只要是<strong>在类中用到了对方</strong>，那么他们之间就存在依赖关系。如果没有对方，连编绎都通过不了。</p>
<p>对应类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/12.png" alt="image-20210411192418668"></p>
<p>依赖关系小结：</p>
<ol>
<li><strong>类中用到了对方</strong></li>
<li>如果是类的<strong>成员属性</strong></li>
<li>如果是<strong>方法的返回类型</strong></li>
<li>是方法<strong>接收的参数类型</strong></li>
<li><strong>方法中使用到</strong></li>
</ol>
<h3 id="3-5、类图—泛化关系-generalization）"><a href="#3-5、类图—泛化关系-generalization）" class="headerlink" title="3.5、类图—泛化关系(generalization）"></a>3.5、类图—泛化关系(generalization）</h3><p>泛化关系实际上就是<strong>继承关系</strong>，他是<strong>依赖关系的特例</strong></p>
<p>相关类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/13.png" alt="image-20210411192748570"></p>
<p>泛化关系小结:</p>
<ol>
<li>泛化关系实际上就是<strong>继承关系</strong></li>
<li>如果 A 类继承了 B 类，我们就说 A 和 B 存在<strong>泛化关系</strong></li>
</ol>
<h3 id="3-6、类图—实现关系（Implementation）"><a href="#3-6、类图—实现关系（Implementation）" class="headerlink" title="3.6、类图—实现关系（Implementation）"></a>3.6、类图—实现关系（Implementation）</h3><p>实现关系实际上就是 <strong>A 类实现 B 接口</strong>，他是<strong>依赖关系的特例</strong></p>
<p>相关类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14.png" alt="image-20210411193029031"></p>
<h3 id="3-7、类图—关联关系（Association）"><a href="#3-7、类图—关联关系（Association）" class="headerlink" title="3.7、类图—关联关系（Association）"></a>3.7、类图—关联关系（Association）</h3><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15.png" alt="image-20210411193416238"></p>
<h3 id="3-8、类图—聚合关系（Aggregation）"><a href="#3-8、类图—聚合关系（Aggregation）" class="headerlink" title="3.8、类图—聚合关系（Aggregation）"></a>3.8、类图—聚合关系（Aggregation）</h3><h4 id="3-8-1、基本介绍"><a href="#3-8-1、基本介绍" class="headerlink" title="3.8.1、基本介绍"></a>3.8.1、基本介绍</h4><p>聚合关系（Aggregation）表示的是<strong>整体和部分的关系</strong>，<strong>整体与部分可以分开</strong>。聚合关系是<strong>关联关系的特例</strong>，所以他具有关联的<strong>导航性与多重性</strong>。</p>
<p>如：一台电脑由键盘(keyboard)、显示器(monitor)，鼠标等组成；组成电脑的各个配件是可以从电脑上分离出来的，使用带空心菱形的实线来表示：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/16.png" alt="image-20210411193519679"></p>
<h3 id="3-9、类图—组合关系（Composition）"><a href="#3-9、类图—组合关系（Composition）" class="headerlink" title="3.9、类图—组合关系（Composition）"></a>3.9、类图—组合关系（Composition）</h3><h4 id="3-9-1、基本介绍"><a href="#3-9-1、基本介绍" class="headerlink" title="3.9.1、基本介绍"></a>3.9.1、基本介绍</h4><p>组合关系：也是<strong>整体与部分的关系</strong>，但是<strong>整体与部分不可以分开</strong>。</p>
<p>再看一个案例：在程序中我们定义实体：Person 与 IDCard、Head, 那么 <strong>Head 和 Person 就是 组合</strong>，<strong>IDCard 和Person 就是聚合。</strong></p>
<p>但是如果在程序中 Person 实体中定义了对 IDCard 进行<strong>级联删除</strong>，即删除 Person 时连同 IDCard 一起删除，那么 <strong>IDCard 和 Person 就是组合了.</strong></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> IDCard card;</span><br><span class="line">    <span class="comment">// 在创建Person对象的同时创建了Head对象</span></span><br><span class="line">    <span class="keyword">private</span> Head head = <span class="keyword">new</span> Head();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IDCard</span></span>&#123;&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Head</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>对应类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/17.png" alt="image-20210411193901631"></p>
<h2 id="4、设计模式概述"><a href="#4、设计模式概述" class="headerlink" title="4、设计模式概述"></a>4、设计模式概述</h2><h3 id="4-1、设计模式介绍"><a href="#4-1、设计模式介绍" class="headerlink" title="4.1、设计模式介绍"></a>4.1、设计模式介绍</h3><ol>
<li>设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验，<strong>模式</strong>不是代码，而是某类问题的<strong>通用解决方案</strong>，设计模式（Design pattern）代表了最佳的实践。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</li>
<li>设计模式的本质提高<strong>软件的维护性，通用性和扩展性，并降低软件的复杂度</strong>。</li>
<li>&lt;&lt;设计模式&gt;&gt; 是经典的书，作者是 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides Design（俗称 “四人组 GOF”）</li>
<li>设计模式并不局限于某种语言，java，php，c++ 都有设计模式.</li>
</ol>
<h3 id="4-2、设计模式类型"><a href="#4-2、设计模式类型" class="headerlink" title="4.2、设计模式类型"></a>4.2、设计模式类型</h3><p>设计模式分为<strong>三种类型</strong>，共 <strong>23</strong> 种</p>
<ol>
<li><strong>创建型</strong>模式：<strong>单例模式</strong>、抽象工厂模式、原型模式、建造者模式、<strong>工厂模式</strong>。</li>
<li><strong>结构型</strong>模式：适配器模式、桥接模式、<strong>装饰模式</strong>、组合模式、外观模式、享元模式、<strong>代理模式</strong>。</li>
<li><strong>行为型</strong>模式：模版方法模式、命令模式、访问者模式、迭代器模式、<strong>观察者模式</strong>、中介者模式、备忘录模式、解释器模式（Interpreter 模式）、状态模式、策略模式、职责链模式(责任链模式)。</li>
</ol>
<p>注意：不同的书籍上对分类和名称略有差别</p>
<p>对于创建型模式的概述请看第27点</p>
<p>对于结构型模式的概述请看第28点</p>
<p>对于行为型模式的概述请看第29点</p>
<h2 id="5、单例设计模式Singleton（创建型设计模式）"><a href="#5、单例设计模式Singleton（创建型设计模式）" class="headerlink" title="5、单例设计模式Singleton（创建型设计模式）"></a>5、单例设计模式Singleton（创建型设计模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/76.png" alt="image-20210415031845856"></p>
<h3 id="5-1、单例设计模式介绍"><a href="#5-1、单例设计模式介绍" class="headerlink" title="5.1、单例设计模式介绍"></a>5.1、单例设计模式介绍</h3><p>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对<strong>某个类只能存在一个对象实例</strong>， 并且该类**只提供一个取得其对象实例的方法(静态方法)**。</p>
<p>比如 Hibernate 的 SessionFactory，它充当数据存储源的代理，并负责创建 Session 对象。<strong>SessionFactory 并不是轻量级的</strong>，一般情况下，<strong>一个项目通常只需要一个</strong> SessionFactory 就够，这是就会<strong>使用到单例模式</strong>。</p>
<p>注意：</p>
<ol>
<li>单例类只有一个实例对象；</li>
<li>该单例对象必须由单例类自行创建；</li>
<li>单例类对外提供一个访问该单例的全局访问点。</li>
</ol>
<p>测试方法（除了枚举）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//判断创建的两个实例是不是同一个</span></span><br><span class="line">		Singleton instance = Singleton.getInstance();</span><br><span class="line">		Singleton instance2 = Singleton.getInstance();</span><br><span class="line">		<span class="comment">// true</span></span><br><span class="line">		System.out.println(instance == instance2); </span><br><span class="line">		System.out.println(<span class="string">&quot;instance.hashCode=&quot;</span> + instance.hashCode());</span><br><span class="line">		System.out.println(<span class="string">&quot;instance2.hashCode=&quot;</span> + instance2.hashCode());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-2、单例设计模式八种方式"><a href="#5-2、单例设计模式八种方式" class="headerlink" title="5.2、单例设计模式八种方式"></a>5.2、单例设计模式八种方式</h3><p><strong>加黑属于推荐使用</strong></p>
<ol>
<li><strong>饿汉式（两种）</strong><ol>
<li>饿汉式**(静态常量)**</li>
<li>饿汉式<strong>（静态代码块）</strong></li>
</ol>
</li>
<li>懒汉式（三种）<ol>
<li>懒汉式(线程不安全)</li>
<li>懒汉式(线程安全，同步方法)</li>
<li> 懒汉式(同步代码块)</li>
</ol>
</li>
<li><strong>双重检查</strong></li>
<li><strong>静态内部类</strong></li>
<li><strong>枚举</strong></li>
</ol>
<h3 id="5-3、饿汉式（两种）"><a href="#5-3、饿汉式（两种）" class="headerlink" title="5.3、饿汉式（两种）"></a>5.3、饿汉式（两种）</h3><h4 id="5-3-1、饿汉式（静态常量）"><a href="#5-3-1、饿汉式（静态常量）" class="headerlink" title="5.3.1、饿汉式（静态常量）"></a>5.3.1、饿汉式（静态常量）</h4><p>使用步骤：</p>
<ol>
<li><strong>构造器私有化</strong> (防止外部使用new创建实例)</li>
<li>类的<strong>内部创建对象</strong></li>
<li>向外暴露一个<strong>静态的公共方法</strong>getInstance</li>
</ol>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式（静态常量）</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;	</span><br><span class="line">	<span class="comment">//1. 构造器私有化, 外部不能new</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="comment">//2.本类内部创建对象实例</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">	<span class="comment">//3. 提供一个公有的静态方法，返回实例对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优缺点说明：</p>
<ul>
<li>优点：这种写法比较简单，就是<strong>在类装载的时候就完成实例化</strong>。避免了线程同步问题。</li>
<li>缺点：在类装载的时候就完成实例化，没有达到 Lazy Loading 的效果。如果从始至终<strong>从未使用</strong>过这个实例，则会造成<strong>内存的浪费</strong></li>
<li>这种方式基于 <code>classloder</code> 机制<strong>避免了多线程的同步问题</strong>，不过，<strong>instance 在类装载时就实例化</strong>，在单例模式中大多数都是调用 getInstance 方法， 但是导致<strong>类装载的原因有很多种</strong>，因此<strong>不能确定有其他的方式（或者其他的静态方法）导致类装载</strong>，这时候初始化 instance 就<strong>没有达到 <code>lazy loading</code> 的效果</strong></li>
<li>结论：这种单例模式<strong>可用</strong>，<strong>可能</strong>造成<strong>内存浪费</strong>，同时也不能实现懒加载（lazy loading）</li>
</ul>
<h4 id="5-3-2、饿汉式（静态代码块）"><a href="#5-3-2、饿汉式（静态代码块）" class="headerlink" title="5.3.2、饿汉式（静态代码块）"></a>5.3.2、饿汉式（静态代码块）</h4><p>使用步骤：</p>
<ol>
<li><strong>构造器私有化</strong> (防止外部使用new创建实例)</li>
<li>在<strong>静态代码块</strong>中，创建单例对象</li>
<li>向外暴露一个<strong>静态的公共方法</strong>getInstance</li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式（静态代码块）</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1. 构造器私有化, 外部不能new</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 2.在静态代码块中，创建单例对象</span></span><br><span class="line">	<span class="keyword">private</span>  <span class="keyword">static</span> Singleton instance;</span><br><span class="line">	<span class="keyword">static</span> &#123; </span><br><span class="line">		instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//3. 提供一个公有的静态方法，返回实例对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优缺点说明：</p>
<ol>
<li>这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在<strong>类装载</strong>的时候，就<strong>执行静态代码块中的代码</strong>，<strong>初始化类的实例</strong>。优缺点和上面是一样的。</li>
<li>结论：这种单例模式可用，但是可能造成<strong>内存浪费</strong></li>
</ol>
<h3 id="5-4、懒汉式（三种）"><a href="#5-4、懒汉式（三种）" class="headerlink" title="5.4、懒汉式（三种）"></a>5.4、懒汉式（三种）</h3><h4 id="5-4-1、懒汉式-线程不安全"><a href="#5-4-1、懒汉式-线程不安全" class="headerlink" title="5.4.1、懒汉式(线程不安全)"></a>5.4.1、懒汉式(线程不安全)</h4><p>使用步骤：</p>
<ol>
<li><strong>构造器私有化</strong> (防止外部使用new创建实例)</li>
<li>提供一个静态的公有方法getInstance()，当<strong>使用到该方法</strong>时，才去创建 instance</li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式(线程不安全)</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="comment">// 1.构造器私有化(防止外部使用new创建实例)</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.提供一个静态的公有方法，当使用到该方法时，才去创建 instance</span></span><br><span class="line">	<span class="comment">//即懒汉式</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优缺点说明：</p>
<ol>
<li>起到了 <strong>Lazy Loading</strong> 的效果，但是只能在<strong>单线程下使用</strong>。</li>
<li>如果在多线程下，一个线程进入了 if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在<strong>多线程环境下不可使用</strong>这种方式。（线程不安全）</li>
<li>结论：在实际开发中，<strong>不要使用这种方式.</strong></li>
</ol>
<h4 id="5-4-2、懒汉式-线程安全，同步方法"><a href="#5-4-2、懒汉式-线程安全，同步方法" class="headerlink" title="5.4.2、懒汉式(线程安全，同步方法)"></a>5.4.2、懒汉式(线程安全，同步方法)</h4><p>使用步骤：</p>
<ol>
<li><strong>构造器私有化</strong> (防止外部使用new创建实例)</li>
<li>提供一个静态的公有方法getInstance()，加入同步处理的代码<strong>synchronized</strong> ，解决线程安全问题</li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式(线程安全，同步方法)</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="comment">// 1.构造器私有化(防止外部使用new创建实例)</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 2.提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题</span></span><br><span class="line">	<span class="comment">//即懒汉式</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优缺点说明：</p>
<ol>
<li><strong>解决了线程安全问题</strong></li>
<li>效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而<strong>其实</strong>这个方法<strong>只执行一次实例化代码就够了</strong>，<strong>后面的想获得该类实例，直接 return 就行了</strong>。方法进行同步<strong>效率太低。</strong></li>
<li>结论：在实际开发中，<strong>不推荐使用</strong>这种方式</li>
</ol>
<h4 id="5-4-3、懒汉式-同步代码块"><a href="#5-4-3、懒汉式-同步代码块" class="headerlink" title="5.4.3、懒汉式(同步代码块)"></a>5.4.3、懒汉式(同步代码块)</h4><ol>
<li><strong>构造器私有化</strong> (防止外部使用new创建实例)</li>
<li>提供一个静态的公有方法getInstance()，加入<strong>同步产生实例化的的代码块</strong>，解决效率问题。</li>
</ol>
<p>代码：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/18.png" alt="image-20210412194454470"></p>
<p>优缺点说明：</p>
<ol>
<li>这种方式，本意是想对第四种实现方式的改进，因为前面同步方法效率太低，改为<strong>同步产生实例化的的代码块。</strong></li>
<li>但是这种同步并<strong>不能起到线程同步的作用</strong>。跟第3种实现方式遇到的情形一致，假如一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便<strong>会产生多个实例</strong>。（<strong>线程不安全</strong>）</li>
<li>结论：在实际开发中，**<code>不能使用</code>**这种方式</li>
</ol>
<h3 id="5-5、双重检查"><a href="#5-5、双重检查" class="headerlink" title="5.5、双重检查"></a>5.5、双重检查</h3><p>使用步骤：</p>
<ol>
<li><strong>构造器私有化</strong> (防止外部使用new创建实例)</li>
<li>提供一个静态的公有方法，加入**双重检查代码(双if)**，解决线程安全问题, 同时解决懒加载问题</li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双重检查</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="comment">//提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题</span></span><br><span class="line">	<span class="comment">//同时保证了效率, 推荐使用</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">				<span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">					instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优缺点说明：</p>
<ol>
<li>Double-Check 概念是多线程开发中常使用到的，如代码中所示，我们<strong>进行了两次 if (singleton == null)检查</strong>，这样就可以<strong>保证线程安全</strong>了。</li>
<li>是对懒汉式(线程安全，同步方法)的优化</li>
<li>这样，实例化代码只用执行一次，后面再次访问时，判断 if (singleton == null)，直接 return 实例化对象，也<strong>避免的反复进行方法同步</strong>。</li>
<li><strong>线程安全</strong>；<strong>延迟加载</strong>；<strong>效率较高</strong></li>
<li>结论：在实际开发中，<strong>推荐使用</strong>这种单例设计模式</li>
</ol>
<p>其他说明：</p>
<ul>
<li>双重检锁虽然是线程安全的，会出现<strong>内部成员变量空指针异常</strong>，如果要使用，需将<strong>类实例用volatile修饰</strong></li>
<li>volatile 是<strong>改变立即更新到主存</strong>，<strong>保证变化各线程可见</strong>，即：<strong>立即从主内存中获取值，更新工作内存的值</strong>。在多线程情况下，不仅<strong>防止指令重排</strong>，而且<strong>保证happes-before规则</strong>，前一个线程的操作对后一个线程可见。<a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenssy/p/6393321.html">（happens-before规则相关）</a></li>
<li>如果<strong>不用volatile关键字</strong>，有可能会出现异常。因为instance = new Singleton();并不是一个原子操作。new对象分为三步：<ol>
<li>第一步：分配对象的内存空间</li>
<li>第二步：初始化对象</li>
<li>第三步：设置instance指向内存空间</li>
</ol>
</li>
<li>但是这个被返回的instance是有问题的——它还没有被初始化（第二步还未被执行)。</li>
<li>这里必须要volatile，volatile就是保证一个线程更新了instance，其余线程立马可知，不然第二个if没有用。（可见性）</li>
<li>volitile保证了线程间的可见性，和一定程度上的顺序性（不能保证原子性），更好的方式是用一个boolean变量标识对象是否创建过（原子性）</li>
</ul>
<p>双重检查创建单例实现步骤</p>
<ol>
<li>第一个if(singleton==null){}：第一层检查，检查是否有引用指向对象，高并发情况下会有多个线程同时进</li>
<li>synchronized (Singleton.class) {}：第一层锁，保证只有一个线程进入</li>
<li>第二个if(singleton==null){}：第二层检查<ul>
<li>双重检查，防止多个线程同时进入第一层检查(因单例模式只允许存在一个对象，故在创建对象之前无引用指向对象，所有线程均可进入第一层检查)</li>
<li>当某一线程获得锁创建一个Singleton对象时,即已有引用指向对象，singleton不为空，从而保证只会创建一个对象</li>
<li>假设没有第二层检查，那么第一个线程创建完对象释放锁后，后面进入对象也会创建对象，会产生多个对象。（5.4.3的情况）</li>
</ul>
</li>
<li>instance = new Singleton()：volatile关键字作用为禁止指令重排，保证返回Singleton对象一定在创建对象后<ul>
<li>该语句为非原子性，实际上会执行以下内容：<ol>
<li>在堆上开辟空间</li>
<li>属性初始化</li>
<li>引用指向对象</li>
</ol>
</li>
<li>假设以上三个内容为三条单独指令，因指令重排可能会导致执行顺序为1-&gt;3-&gt;2(正常为1-&gt;2-&gt;3),当单例模式中存在普通变量需要在构造方法中进行初始化操作时，单线程情况下，顺序重排没有影响；但在多线程情况下，假如线程1执行singleton=new Singleton()语句时先1再3，由于系统调度线程2的原因没来得及执行步骤2，但此时已有引用指向对象也就是singleton!=null，故线程2在第一次检查时不满足条件直接返回singleton，此时singleton为一个没有被步骤2正确初始化的singleton。</li>
<li>volatile关键字可保证singleton=new Singleton()语句执行顺序为123，因其为非原子性依旧可能存在系统调度问题(即执行步骤时被打断)，但能确保的是只要singleton!=null，就表明一定执行了属性初始化操作；而若在步骤3之前被打断，此时singleton依旧为null，其他线程可进入第一层检查向下执行创建对象。</li>
</ul>
</li>
</ol>
<h3 id="5-6、静态内部类"><a href="#5-6、静态内部类" class="headerlink" title="5.6、静态内部类"></a>5.6、静态内部类</h3><p>使用步骤：</p>
<ol>
<li><strong>构造器私有化</strong> (防止外部使用new创建实例)</li>
<li>写一个<strong>静态内部类</strong>,该类中有一个<strong>静态属性 Singleton</strong></li>
<li>提供一个静态的公有方法，直接返回<strong>SingletonInstance.INSTANCE</strong></li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态内部类完成， 推荐使用</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">	<span class="comment">// 1.构造器私有化</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 2.写一个静态内部类,该类中有一个静态属性 Singleton</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton(); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 3.提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优缺点说明：</p>
<ol>
<li>这种方式采用了<strong>类装载的机制</strong>来<strong>保证初始化实例时只有一个线程</strong>。</li>
<li>静态内部类方式<strong>在 Singleton 类被装载时并不会立即实例化</strong>，而是在需要实例化时，<strong>调用 getInstance 方法，才会装载 SingletonInstance 类，从而完成 Singleton 的实例化</strong>。</li>
<li><strong>类的静态属性只会在第一次加载类的时候初始化</strong>，所以在这里，<strong>JVM</strong> 帮助我们<strong>保证了线程的安全性</strong>，在类进行初始化时，别的线程是无法进入的。</li>
<li>优点：<strong>避免了线程不安全</strong>，利用静态内部类特点<strong>实现延迟加载</strong>，<strong>效率高</strong></li>
<li>缺点：<strong>不能传参</strong></li>
<li>结论：在实际开发中，<strong>推荐使用</strong>这种单例设计模式</li>
</ol>
<p>其他说明：</p>
<ul>
<li>静态内部类：这里的关键是类在加载的时候是线程安全的，一个类只会被加载一次</li>
<li>JVM初始化时机：<ol>
<li>首次，主动使用才会初始化。即只有第一次加载类的时候初始化。</li>
<li>之后调用getInstance()方法，直接返回对象，不会再次初始化了</li>
</ol>
</li>
<li>这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。</li>
</ul>
<h3 id="5-7、枚举"><a href="#5-7、枚举" class="headerlink" title="5.7、枚举"></a>5.7、枚举</h3><p>使用步骤：</p>
<ol>
<li>直接使用枚举实现单例</li>
<li>在枚举里面有<strong>INSTANCE属性</strong></li>
<li>外部直接通过<strong>Singleton.INSTANCE</strong>的方式创建实例</li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// 通过Singleton.INSTANCE的方式创建实例</span></span><br><span class="line">		Singleton instance = Singleton.INSTANCE;</span><br><span class="line">		Singleton instance2 = Singleton.INSTANCE;</span><br><span class="line">		System.out.println(instance == instance2);</span><br><span class="line">		</span><br><span class="line">		System.out.println(instance.hashCode());</span><br><span class="line">		System.out.println(instance2.hashCode());</span><br><span class="line">		</span><br><span class="line">		instance.sayOK();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用枚举，可以实现单例, 推荐</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">	INSTANCE; </span><br><span class="line">    <span class="comment">// 自定义构造函数</span></span><br><span class="line">    <span class="keyword">int</span> value; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonEnum</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        value = <span class="number">1</span>; </span><br><span class="line">        System.out.println(<span class="string">&quot;INSTANCE now created!&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayOK</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;ok~&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.value = value; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优缺点说明：</p>
<ol>
<li>这借助 JDK1.5 中添加的枚举来实现单例模式。不仅能<strong>避免多线程同步</strong>问题，而且还能<strong>防止反序列化重新创建新的对象</strong>。</li>
<li><strong>JVM 会阻止反射获取枚举类的私有构造方法</strong></li>
<li>枚举真正实现了单例，把反序列化和反射创建第二对象的路都堵死了</li>
<li>这种方式是 <strong>Effective Java</strong> 作者 <strong>Josh Bloch</strong> 提倡的方式</li>
<li>缺点：<strong>无法进行懒加载</strong>。如果Singleton必须拓展一个超类，而不是扩展Enum的时候，则不宜使用这个方法。</li>
<li>结论：在实际开发中，<strong>推荐使用</strong>这种单例设计模式</li>
</ol>
<h3 id="5-8、单例模式在-JDK-应用的源码分析"><a href="#5-8、单例模式在-JDK-应用的源码分析" class="headerlink" title="5.8、单例模式在 JDK 应用的源码分析"></a>5.8、单例模式在 JDK 应用的源码分析</h3><p>我们 JDK 中，java.lang.Runtime 就是经典的<strong>单例模式(饿汉式)</strong></p>
<p>原码：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/31.png" alt="image-20210413021321623"></p>
<h3 id="5-9、单例模式总结"><a href="#5-9、单例模式总结" class="headerlink" title="5.9、单例模式总结"></a>5.9、单例模式总结</h3><h4 id="5-9-1、单例模式的优缺点"><a href="#5-9-1、单例模式的优缺点" class="headerlink" title="5.9.1、单例模式的优缺点"></a>5.9.1、单例模式的优缺点</h4><p>优点：</p>
<ul>
<li>单例模式可以保证内存里只有一个实例，减少了内存的开销。</li>
<li>可以避免对资源的多重占用。</li>
<li>单例模式设置全局访问点，可以优化和共享资源的访问。</li>
</ul>
<p>缺点：</p>
<ul>
<li>单例模式一般没有接口，扩展困难。如果要扩展，则除了修改原来的代码，没有第二种途径，违背开闭原则。</li>
<li>在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象。</li>
<li>单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。</li>
</ul>
<h4 id="5-9-2、单例模式的应用场景"><a href="#5-9-2、单例模式的应用场景" class="headerlink" title="5.9.2、单例模式的应用场景"></a>5.9.2、单例模式的应用场景</h4><p>对于 <a target="_blank" rel="noopener" href="http://c.biancheng.net/java/">Java</a> 来说，单例模式可以保证在一个 JVM 中只存在单一实例。单例模式的应用场景主要有以下几个方面。</p>
<ul>
<li>需要<strong>频繁创建的一些类</strong>，使用单例可以降低系统的内存压力，减少 GC。</li>
<li>某类<strong>只要求生成一个对象的时候</strong>，如一个班中的班长、每个人的身份证号等。</li>
<li>某些类创建实例时<strong>占用资源较多，或实例化耗时较长</strong>，且经常使用。</li>
<li>某类需要<strong>频繁实例化</strong>，而创建的对象又<strong>频繁被销毁</strong>的时候，如<strong>多线程的线程池</strong>、<strong>网络连接池</strong>等。</li>
<li><strong>频繁访问数据库或文件的对象</strong>。</li>
<li>对于一些<strong>控制硬件级别</strong>的操作，或者从系统上来讲应当是<strong>单一控制逻辑</strong>的操作，如果有多个实例，则系统会完全乱套。</li>
<li>当<strong>对象需要被共享</strong>的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 <strong>Web 中的配置对象、数据库的连接池</strong>等。</li>
</ul>
<h4 id="5-9-3、单例模式的结构"><a href="#5-9-3、单例模式的结构" class="headerlink" title="5.9.3、单例模式的结构"></a>5.9.3、单例模式的结构</h4><p>单例模式的主要角色如下。</p>
<ul>
<li>单例类：包含一个实例且能自行创建这个实例的类。</li>
<li>访问类：使用单例的类。</li>
</ul>
<p>结构：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/19.png" alt="image-20210412211111576"></p>
<h4 id="5-9-4、相关的设计模式"><a href="#5-9-4、相关的设计模式" class="headerlink" title="5.9.4、相关的设计模式"></a>5.9.4、相关的设计模式</h4><p>在以下模式中， 多数情况下只会生成一个实例。</p>
<ul>
<li>AbstractFactory模式</li>
<li>Builder模式</li>
<li>Facade模式</li>
<li>Prototype模式</li>
</ul>
<h4 id="5-9-5、单例模式注意事项和细节说明"><a href="#5-9-5、单例模式注意事项和细节说明" class="headerlink" title="5.9.5、单例模式注意事项和细节说明"></a>5.9.5、单例模式注意事项和细节说明</h4><ul>
<li>单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能</li>
<li>当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用 new</li>
<li>枚举是最安全的单例，是不可破坏的，其余所有的单例都是可以用反射破坏的</li>
<li>那我们什么时候应该用Singleton呢？实际上，很多程序，尤其是Web程序，大部分服务类都应该被视作Singleton，如果全部按Singleton的写法写，会非常麻烦，所以，通常是通过约定让框架（例如Spring）来实例化这些类，保证只有一个实例，调用方自觉通过框架获取实例而不是<code>new</code>操作符。因此，除非确有必要，否则Singleton模式一般以“约定”为主，不会刻意实现它。</li>
<li><strong>经验之谈：</strong>一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种静态内部方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。</li>
</ul>
<h4 id="5-9-6、反射与反序列化破坏单例模式的方法及解决办法"><a href="#5-9-6、反射与反序列化破坏单例模式的方法及解决办法" class="headerlink" title="5.9.6、反射与反序列化破坏单例模式的方法及解决办法"></a>5.9.6、反射与反序列化破坏单例模式的方法及解决办法</h4><p>除枚举方式外, 其他方法都会通过反射或反序列化的方式破坏单例</p>
<h5 id="5-9-6-1、反射破坏单例模式"><a href="#5-9-6-1、反射破坏单例模式" class="headerlink" title="5.9.6.1、反射破坏单例模式"></a>5.9.6.1、反射破坏单例模式</h5><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wyb628/p/6371827.html">反射如何破坏单例模式</a></p>
<p>通过反射获得单例类的构造函数，由于该构造函数是private的，通过setAccessible(true)指示反射的对象在使用时应该取消 Java 语言访问检查，使得私有的构造函数能够被访问，这样使得单例模式失效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Singleton s1 = Singleton.getInstance();</span><br><span class="line"></span><br><span class="line">        Constructor&lt;Singleton&gt; constructor = Singleton.class.getDeclaredConstructor();</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Singleton s2 = constructor.newInstance();</span><br><span class="line"> </span><br><span class="line">        System.out.println(s1.hashCode());</span><br><span class="line">        System.out.println(s2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们想要阻止单例破坏，可以在构造方法中进行判断，若已有实例, 则阻止生成新的实例，解决办法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SingletonObject1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance !=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;实例已经存在，请通过 getInstance()方法获取&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-9-6-2、反序列化破坏单例模式"><a href="#5-9-6-2、反序列化破坏单例模式" class="headerlink" title="5.9.6.2、反序列化破坏单例模式"></a>5.9.6.2、反序列化破坏单例模式</h5><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903745772339214">序列化和反序列化的对单例破坏的防止及其原理</a></p>
<p>如果单例类实现了序列化接口Serializable, 就可以通过反序列化破坏单例。</p>
<p>我们使用正常的方式来获取一个对象。通过序列化将对象写入文件中，然后我们通过反序列化的到一个对象，我们再对比这个对象，输出的内存地址和布尔结果都表示这不是同一个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> HungrySingleton hungrySingleton;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        hungrySingleton = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hungrySingleton != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;单例构造器禁止反射调用&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungrySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们使用之前的饿汉式的单例作为例子。在之前饿汉式的代码上做点小改动。就是让我们的单例类实现 Serializable接口。然后我们在测试类中测试一下怎么破坏。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        HungrySingleton instance = HungrySingleton.getInstance();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;singleton_file&quot;</span>));</span><br><span class="line">        oos.writeObject(instance);</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;singleton_file&quot;</span>);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">        HungrySingleton newInstance = (HungrySingleton) ois.readObject();</span><br><span class="line">        System.out.println(instance == newInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方法：</p>
<p>所以我们可以不实现序列化接口,如果非得实现序列化接口，可以重写反序列化方法readResolve(), 反序列化时直接返回相关单例对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-9-7、单例模式的扩展"><a href="#5-9-7、单例模式的扩展" class="headerlink" title="5.9.7、单例模式的扩展"></a>5.9.7、单例模式的扩展</h4><p>单例模式可扩展为有限的多例（Multitcm）模式，这种模式可生成有限个实例并保存在 ArrayList 中，客户需要时可随机获取，结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20.png" alt="image-20210412215700680"></p>
<h2 id="6、工厂模式（创建型设计模式）"><a href="#6、工厂模式（创建型设计模式）" class="headerlink" title="6、工厂模式（创建型设计模式）"></a>6、工厂模式（创建型设计模式）</h2><p>在日常开发中，凡是需要生成复杂对象的地方，都可以尝试考虑使用工厂模式来代替。</p>
<blockquote>
<p>注意：上述复杂对象指的是类的构造函数参数过多等对类的构造有影响的情况，因为类的构造过于复杂，如果直接在其他业务类内使用，则两者的耦合过重，后续业务更改，就需要在任何引用该类的源代码内进行更改，光是查找所有依赖就很消耗时间了，更别说要一个一个修改了。</p>
</blockquote>
<p>工厂模式的定义：定义一个<strong>创建产品对象的工厂接口</strong>，将<strong>产品对象的实际创建工作推迟到具体子工厂类</strong>当中。这满足创建型模式中所要求的“<strong>创建与使用相分离</strong>”的特点。</p>
<p>按实际业务场景划分，工厂模式有 3 种不同的实现方式，分别是</p>
<ul>
<li>简单工厂模式</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
</ul>
<h3 id="6-1、简单工厂模式SimpleFactory"><a href="#6-1、简单工厂模式SimpleFactory" class="headerlink" title="6.1、简单工厂模式SimpleFactory"></a>6.1、简单工厂模式SimpleFactory</h3><h4 id="6-1-1、简单工厂模式介绍"><a href="#6-1-1、简单工厂模式介绍" class="headerlink" title="6.1.1、简单工厂模式介绍"></a>6.1.1、简单工厂模式介绍</h4><ol>
<li>简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式。</li>
<li>简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为(代码)</li>
<li>在软件开发中，当我们会用到<strong>大量的创建某种、某类或者某批对象</strong>时，就会使用到工厂模式。</li>
<li>我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”。</li>
<li>在简单工厂模式中创建实例的方法通常为静态（static）方法，因此简单工厂模式（Simple Factory Pattern）又叫作静态工厂方法模式（Static Factory Method Pattern）。</li>
</ol>
<p>可总结：</p>
<ol>
<li>一个调用者想创建一个对象，只要知道其名称就可以了。</li>
<li>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。</li>
<li>屏蔽产品的具体实现，调用者只关心产品的接口。</li>
</ol>
<h4 id="6-1-2、模式的结构与实现"><a href="#6-1-2、模式的结构与实现" class="headerlink" title="6.1.2、模式的结构与实现"></a>6.1.2、模式的结构与实现</h4><p>简单工厂模式的主要角色如下：</p>
<ul>
<li>简单工厂（SimpleFactory）：是简单工厂模式的核心，负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。</li>
<li>抽象产品（Product）：是简单工厂创建的所有对象的父类，负责描述所有实例共有的公共接口。</li>
<li>具体产品（ConcreteProduct）：是简单工厂模式的创建目标。</li>
</ul>
<p>其结构图如下图所示：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/26.png" alt="image-20210413003915038"></p>
<p>根据上图写出该模式的代码如下：(模板)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//抽象产品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//具体产品：ProductA</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体产品1显示...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//具体产品：ProductB</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体产品2显示...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRODUCT_A = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRODUCT_B = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRODUCT_C = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">makeProduct</span><span class="params">(<span class="keyword">int</span> kind)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (kind) &#123;</span><br><span class="line">                <span class="keyword">case</span> Const.PRODUCT_A:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">                <span class="keyword">case</span> Const.PRODUCT_B:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-1-3、应用实例"><a href="#6-1-3、应用实例" class="headerlink" title="6.1.3、应用实例"></a>6.1.3、应用实例</h4><p>看一个具体的需求：披萨的项目：要便于披萨种类的扩展，要便于维护</p>
<ol>
<li>披萨的种类很多(比如 GreekPizz、CheesePizz 等)</li>
<li>披萨的制作有 prepare，bake, cut, box</li>
<li>完成披萨店订购功能。</li>
</ol>
<p>使用简单工厂模式实现：</p>
<p>简单工厂模式的设计方案: 定义一个可以实例化 Pizaa 对象的类，封装创建对象的代码。</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/25.png" alt="image-20210413001450106"></p>
<p>代码实现（省略pizza抽象类与具体实现类的编写）：</p>
<p>根据简单工厂模式创建：</p>
<ol>
<li><p>创建工厂类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line">	<span class="comment">//根据orderType 返回对应的Pizza 对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(String orderType)</span> </span>&#123;</span><br><span class="line">		Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (orderType.equals(<span class="string">&quot;greek&quot;</span>)) &#123;</span><br><span class="line">			pizza = <span class="keyword">new</span> GreekPizza();</span><br><span class="line">			pizza.setName(<span class="string">&quot; 希腊披萨 &quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">			pizza = <span class="keyword">new</span> CheesePizza();</span><br><span class="line">			pizza.setName(<span class="string">&quot; 奶酪披萨 &quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>)) &#123;</span><br><span class="line">			pizza = <span class="keyword">new</span> PepperPizza();</span><br><span class="line">			pizza.setName(<span class="string">&quot;胡椒披萨&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> pizza;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建订购披萨类OrderPizza</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderPizza</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个简单工厂对象</span></span><br><span class="line">	SimpleFactory simpleFactory;</span><br><span class="line">	Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">OrderPizza</span><span class="params">(SimpleFactory simpleFactory)</span> </span>&#123;</span><br><span class="line">		setFactory(simpleFactory);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFactory</span><span class="params">(SimpleFactory simpleFactory)</span> </span>&#123;</span><br><span class="line">		String orderType = <span class="string">&quot;&quot;</span>; <span class="comment">//用户输入的</span></span><br><span class="line">		<span class="keyword">this</span>.simpleFactory = simpleFactory; <span class="comment">//设置简单工厂对象</span></span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			orderType = getType(); </span><br><span class="line">			pizza = <span class="keyword">this</span>.simpleFactory.createPizza(orderType);</span><br><span class="line">			<span class="comment">//输出pizza</span></span><br><span class="line">			<span class="keyword">if</span>(pizza != <span class="keyword">null</span>) &#123; <span class="comment">//订购成功</span></span><br><span class="line">				pizza.prepare();</span><br><span class="line">				pizza.bake();</span><br><span class="line">				pizza.cut();</span><br><span class="line">				pizza.box();</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot; 订购披萨失败 &quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">while</span>(<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 写一个方法，可以获取客户希望订购的披萨种类</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			BufferedReader strin = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">			System.out.println(<span class="string">&quot;input pizza 种类:&quot;</span>);</span><br><span class="line">			String str = strin.readLine();</span><br><span class="line">			<span class="keyword">return</span> str;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端PizzaStore：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相当于一个客户端，发出订购</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//使用简单工厂模式</span></span><br><span class="line">		<span class="keyword">new</span> OrderPizza(<span class="keyword">new</span> SimpleFactory());</span><br><span class="line">		System.out.println(<span class="string">&quot;~~退出程序~~&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>根据静态工厂模式创建：</p>
<ol>
<li><p>创建静态工厂类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line">	<span class="comment">//简单工厂模式 也叫 静态工厂模式 </span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pizza <span class="title">createPizza</span><span class="params">(String orderType)</span> </span>&#123;</span><br><span class="line">		Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (orderType.equals(<span class="string">&quot;greek&quot;</span>)) &#123;</span><br><span class="line">			pizza = <span class="keyword">new</span> GreekPizza();</span><br><span class="line">			pizza.setName(<span class="string">&quot; 希腊披萨 &quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">			pizza = <span class="keyword">new</span> CheesePizza();</span><br><span class="line">			pizza.setName(<span class="string">&quot; 奶酪披萨 &quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>)) &#123;</span><br><span class="line">			pizza = <span class="keyword">new</span> PepperPizza();</span><br><span class="line">			pizza.setName(<span class="string">&quot;胡椒披萨&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> pizza;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建订购披萨类OrderPizza</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderPizza</span> </span>&#123;</span><br><span class="line">	Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">	String orderType = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">OrderPizza</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			orderType = getType();</span><br><span class="line">			pizza = SimpleFactory.createPizza2(orderType);</span><br><span class="line">			<span class="comment">// 输出pizza</span></span><br><span class="line">			<span class="keyword">if</span> (pizza != <span class="keyword">null</span>) &#123; <span class="comment">// 订购成功</span></span><br><span class="line">				pizza.prepare();</span><br><span class="line">				pizza.bake();</span><br><span class="line">				pizza.cut();</span><br><span class="line">				pizza.box();</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot; 订购披萨失败 &quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 写一个方法，可以获取客户希望订购的披萨种类</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			BufferedReader strin = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">			System.out.println(<span class="string">&quot;input pizza 种类:&quot;</span>);</span><br><span class="line">			String str = strin.readLine();</span><br><span class="line">			<span class="keyword">return</span> str;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端PizzaStore：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相当于一个客户端，发出订购</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;	</span><br><span class="line">		<span class="comment">//使用静态工厂模式</span></span><br><span class="line">		<span class="keyword">new</span> OrderPizza();</span><br><span class="line">         System.out.println(<span class="string">&quot;~~退出程序~~&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="6-1-4、简单工厂模式（静态工厂模式）的相关说明"><a href="#6-1-4、简单工厂模式（静态工厂模式）的相关说明" class="headerlink" title="6.1.4、简单工厂模式（静态工厂模式）的相关说明"></a>6.1.4、简单工厂模式（静态工厂模式）的相关说明</h4><ul>
<li><p>优点：</p>
<ol>
<li>工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例。<strong>客户端可以免除直接创建产品对象的职责，很方便的创建出相应的产品</strong>。工厂和产品的职责区分明确。</li>
<li>客户端<strong>无需知道所创建具体产品的类名，只需知道参数</strong>即可。</li>
<li>也可以<strong>引入配置文件</strong>，在<strong>不修改客户端代码</strong>的情况下<strong>更换和添加新的具体产品类</strong>。</li>
</ol>
</li>
<li><p>缺点：</p>
<ol>
<li>简单工厂模式的<strong>工厂类单一，负责所有产品的创建，职责过重</strong>，一旦异常，整个系统将受影响。且工厂类<strong>代码</strong>会非常<strong>臃肿</strong>，<strong>违背高聚合原则</strong>。</li>
<li>使用简单工厂模式会<strong>增加系统中类的个数</strong>（引入新的工厂类），增加系统的<strong>复杂度和理解难度</strong></li>
<li>系统<strong>扩展困难</strong>，一旦<strong>增加</strong>新产品不得不<strong>修改工厂逻辑</strong>，在产品类型较多时，可能造成逻辑过于复杂</li>
<li>简单工厂模式使用了 <strong>static 工厂方法</strong>，造成工厂角色<strong>无法形成基于继承</strong>的等级结构。</li>
</ol>
</li>
<li><p>应用场景</p>
<p>对于<strong>产品种类相对较少</strong>的情况，考虑使用简单工厂模式。使用简单工厂模式的客户端只需要传入工厂类的参数，不需要关心如何创建对象的逻辑，可以很方便地创建所需产品。</p>
</li>
<li><p>简单来说，简单工厂模式有一个具体的工厂类，可以生成多个不同的产品，属于创建型设计模式。简单工厂模式不在 GoF 23 种设计模式之列。</p>
</li>
</ul>
<h3 id="6-2、工厂方法模式Factory-Method"><a href="#6-2、工厂方法模式Factory-Method" class="headerlink" title="6.2、工厂方法模式Factory Method"></a>6.2、工厂方法模式Factory Method</h3><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/75.PNG" alt="image-20210415031807022"></p>
<h4 id="6-2-1、工厂方法模式介绍"><a href="#6-2-1、工厂方法模式介绍" class="headerlink" title="6.2.1、工厂方法模式介绍"></a>6.2.1、工厂方法模式介绍</h4><ol>
<li> 简单工厂模式提到了违背了开闭原则，而“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是<strong>可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则</strong>。</li>
<li>工厂方法模式：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。</li>
</ol>
<h4 id="6-2-2、模式的结构与实现"><a href="#6-2-2、模式的结构与实现" class="headerlink" title="6.2.2、模式的结构与实现"></a>6.2.2、模式的结构与实现</h4><p>工厂方法模式由抽象工厂、具体工厂、抽象产品和具体产品等4个要素构成。本节来分析其基本结构和实现方法。</p>
<h5 id="6-2-2-1-模式的结构"><a href="#6-2-2-1-模式的结构" class="headerlink" title="6.2.2.1. 模式的结构"></a>6.2.2.1. 模式的结构</h5><p>工厂方法模式的主要角色如下。</p>
<ol>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。</li>
<li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li>
</ol>
<p>其结构图如图 1 所示：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/27.png" alt="image-20210413004548795"></p>
<h5 id="6-2-2-2、模式的实现"><a href="#6-2-2-2、模式的实现" class="headerlink" title="6.2.2.2、模式的实现"></a>6.2.2.2、模式的实现</h5><p>根据图 1 写出该模式的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> FactoryMethod;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Product a;</span><br><span class="line">            AbstractFactory af;</span><br><span class="line">            af = (AbstractFactory) ReadXML1.getObject();</span><br><span class="line">            a = af.newProduct();</span><br><span class="line">            a.show();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象产品：提供了产品的接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体产品1：实现抽象产品中的抽象方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体产品1显示...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体产品2：实现抽象产品中的抽象方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体产品2显示...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象工厂：提供了厂品的生成方法</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">newProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体工厂1：实现了厂品的生成方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">newProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体工厂1生成--&gt;具体产品1...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体工厂2：实现了厂品的生成方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory2</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">newProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体工厂2生成--&gt;具体产品2...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-2-3、应用实例"><a href="#6-2-3、应用实例" class="headerlink" title="6.2.3、应用实例"></a>6.2.3、应用实例</h4><ol>
<li><p>披萨项目新的需求：客户在点披萨时，可以点不同口味的披萨，比如 北京的奶酪 pizza、北京的胡椒 pizza 或者是伦敦的奶酪 pizza、伦敦的胡椒 pizza</p>
</li>
<li><p>思路分析图解：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/28.png" alt="image-20210413012849728"></p>
</li>
<li><p>代码实现：</p>
<p>订购披萨OrderPizza</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderPizza</span> </span>&#123;</span><br><span class="line">	<span class="comment">//定义一个抽象方法，createPizza , 让各个工厂子类自己实现</span></span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> Pizza <span class="title">createPizza</span><span class="params">(String orderType)</span></span>;</span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">OrderPizza</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">		String orderType; <span class="comment">// 订购披萨的类型</span></span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			orderType = getType();</span><br><span class="line">			pizza = createPizza(orderType); <span class="comment">//抽象方法，由工厂子类完成</span></span><br><span class="line">			<span class="comment">//输出pizza 制作过程</span></span><br><span class="line">			pizza.prepare();</span><br><span class="line">			pizza.bake();</span><br><span class="line">			pizza.cut();</span><br><span class="line">			pizza.box();	</span><br><span class="line">		&#125; <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 写一个方法，可以获取客户希望订购的披萨种类</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			BufferedReader strin = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">			System.out.println(<span class="string">&quot;input pizza 种类:&quot;</span>);</span><br><span class="line">			String str = strin.readLine();</span><br><span class="line">			<span class="keyword">return</span> str;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>北京的pizza继承OrderPizza（伦敦同）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BJOrderPizza</span> <span class="keyword">extends</span> <span class="title">OrderPizza</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function">Pizza <span class="title">createPizza</span><span class="params">(String orderType)</span> </span>&#123;</span><br><span class="line">		Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span>(orderType.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">			pizza = <span class="keyword">new</span> BJCheesePizza();</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>)) &#123;</span><br><span class="line">			pizza = <span class="keyword">new</span> BJPepperPizza();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> pizza;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String loc = <span class="string">&quot;bj&quot;</span>;</span><br><span class="line">		<span class="keyword">if</span> (loc.equals(<span class="string">&quot;bj&quot;</span>)) &#123;</span><br><span class="line">			<span class="comment">//创建北京口味的各种Pizza</span></span><br><span class="line">			<span class="keyword">new</span> BJOrderPizza();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//创建伦敦口味的各种Pizza</span></span><br><span class="line">			<span class="keyword">new</span> LDOrderPizza();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="6-2-4、工厂方法模式的相关说明"><a href="#6-2-4、工厂方法模式的相关说明" class="headerlink" title="6.2.4、工厂方法模式的相关说明"></a>6.2.4、工厂方法模式的相关说明</h4><ul>
<li><p>优点：</p>
<ol>
<li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。</li>
<li><strong>灵活性增强，对于新产品的创建，只需多写一个相应的工厂类</strong>。</li>
<li>典型的<strong>解耦框架</strong>。高层模块只需要知道产品的抽象类，无须关心其他实现类，<strong>满足迪米特法则、依赖倒置原则和里氏替换原则。</strong></li>
</ol>
</li>
<li><p>缺点：</p>
<ol>
<li><strong>类的个数容易过多，增加复杂度</strong></li>
<li><strong>增加了系统的抽象性和理解难度</strong></li>
<li><strong>抽象产品只能生产一种产品</strong>，此弊端可使用<strong>抽象工厂模式</strong>解决。</li>
</ol>
</li>
<li><p>应用场景：</p>
<ol>
<li><strong>客户只知道创建产品的工厂名</strong>，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。</li>
<li><strong>创建对象的任务由多个具体子工厂中的某一个完成</strong>，而抽象工厂只提供创建产品的接口。</li>
<li><strong>客户</strong>不关心创建产品的细节，<strong>只关心产品的品牌</strong></li>
</ol>
</li>
<li><p>注意：</p>
<p>当需要生成的产品不多且不会增加，一个具体工厂类就可以完成任务时，可删除抽象工厂类。这时工厂方法模式将退化到简单工厂模式。</p>
</li>
</ul>
<h3 id="6-2-5、工厂方法模式的登场角色补充（来自《图解设计模式》）"><a href="#6-2-5、工厂方法模式的登场角色补充（来自《图解设计模式》）" class="headerlink" title="6.2.5、工厂方法模式的登场角色补充（来自《图解设计模式》）"></a>6.2.5、工厂方法模式的登场角色补充（来自《图解设计模式》）</h3><p>在 Factory Method 模式中有以下登场角色。 通过查看 Factory Method 模式的类图，我们可以知道， <strong>父类（框架）这一方的 Creator 角色</strong>和 <strong>Product 角色的关系</strong>与<strong>子类（具体加工）</strong>这一方的 ConcreteCreator 角色和 ConcreteProduct 角色的<strong>关系是平行的</strong>。</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/34.png" alt="image-20210413023513528"></p>
<ul>
<li><p>Product (产品）</p>
<p>Product角色属于框架这一方， 是一个抽象类。它定义了在Factory Method模式中生成的那些实例所持有的接口(API)， 但具体的处理则由子类ConcreteProduct角色决定。 在示例程序中由Product类扮演此角色。</p>
</li>
<li><p>Creator (创建者）</p>
<p>Creator角色属千框架这一方， 它是负责生成 Product角色的抽象类，但具体的处理则由子类ConcreteCreator角色决定。 在示例程序中， 由Factory类扮演此角色。</p>
</li>
<li><p>Creator角色对于实际负责生成实例的ConcreteCreator角色一无所知，它唯一知道的就是， 只要调用Product角色和生成实例的方法（图4-3中的factoryMethod 方法）， 就可以生成Productde的实例。 在示例程序中，createProduct 方法是用于生成实例的方法。 <strong>不用new关键字来生成实例， 而是调用生成实例的专用方法来生成实例， 这样就可以防止父类与其他具体类耦合。</strong></p>
</li>
<li><p>ConcreteProduct (具体的产品）</p>
<p>Concrete Product角色属于具体加工这一方，它决定了具体的产品。 在示例程序中， 由IDCard 类扮演此角色。</p>
</li>
<li><p>ConcreteCreator (具体的创建者）</p>
<p>ConcreteCreator角色属于具体加工这一方， 它负责生成具体的产品。 在示例程序中，由IDCardFactory类扮演此角色。</p>
</li>
</ul>
<h3 id="6-2-6、相关的设计模式"><a href="#6-2-6、相关的设计模式" class="headerlink" title="6.2.6、相关的设计模式"></a>6.2.6、相关的设计模式</h3><ul>
<li><p>Template Method 模式</p>
<p>Factory Method模式是Template Method的典型应用。在示例程序中， create方法就是模板方法。</p>
</li>
<li><p>Singleton 模式</p>
<p>在多数情况下我们都可以将Singleton模式用于扮演Creator角色（或是ConcreteCreator角色） 的类。这是因为在程序中没有必要存在多个 Creator角色（或是ConcreteCreator角色）的实例。不过在示例程序中， 我们并没有使用Singleton模式。</p>
</li>
<li><p>Composite 模式</p>
<p>有时可以将 Composite模式用于Product角色（或是ConcreteProduct角色）。</p>
</li>
<li><p>Iterator 模式</p>
<p>有时， 在Iterator模式中使用iterator方法生成Iterator的实例时会使用Factory Method 模式。</p>
</li>
</ul>
<h3 id="6-3、抽象工厂模式Abstract-Factory"><a href="#6-3、抽象工厂模式Abstract-Factory" class="headerlink" title="6.3、抽象工厂模式Abstract Factory"></a>6.3、抽象工厂模式Abstract Factory</h3><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/79.png" alt="image-20210415032040170"></p>
<h4 id="6-3-1、抽象工厂模式介绍"><a href="#6-3-1、抽象工厂模式介绍" class="headerlink" title="6.3.1、抽象工厂模式介绍"></a>6.3.1、抽象工厂模式介绍</h4><ol>
<li>前面介绍的<strong>工厂方法模式中考虑的是一类产品的生产</strong>，如畜牧场只养动物、电视机厂只生产电视机、计算机软件学院只培养计算机软件专业的学生等。</li>
<li>同种类称为同等级，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如农场里既养动物又种植物，电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。</li>
<li><strong>抽象工厂模式将考虑多等级产品的生产</strong>，将同一个具体工厂所生产的位于<strong>不同等级的一组产品称为一个产品族</strong>.</li>
</ol>
<p>抽象工厂（AbstractFactory）模式的定义：定义了一个 <strong>interface</strong> 用于创建相关或有依赖关系的对象簇，而无需指明具体的类，是一种<strong>为访问类提供一个创建一组相关或相互依赖对象的接口</strong>，且<strong>访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构</strong>。可以看作：抽象工厂是一个超级工厂，围绕一个超级工厂创建其他工厂，该超级工厂又称为其他工厂的工厂。</p>
<p><strong>抽象工厂模式是工厂方法模式的升级版本</strong>，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。</p>
<p>从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)。</p>
<p>将工厂抽象成两层，<strong>AbsFactory(**抽象工厂</strong>)** 和 具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展。</p>
<p>使用抽象工厂模式一般要满足以下条件。</p>
<ul>
<li>系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。</li>
<li>系统一次只可能消费其中某一族产品，即同族的产品一起使用。</li>
</ul>
<h4 id="6-3-2、模式的结构与实现"><a href="#6-3-2、模式的结构与实现" class="headerlink" title="6.3.2、模式的结构与实现"></a>6.3.2、模式的结构与实现</h4><h5 id="6-3-2-1、模式的结构"><a href="#6-3-2-1、模式的结构" class="headerlink" title="6.3.2.1、模式的结构"></a>6.3.2.1、模式的结构</h5><p>抽象工厂模式的主要角色如下。</p>
<ol>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。</li>
<li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。</li>
</ol>
<h5 id="6-3-2-2、模式的实现类图（具体代码）"><a href="#6-3-2-2、模式的实现类图（具体代码）" class="headerlink" title="6.3.2.2、模式的实现类图（具体代码）"></a>6.3.2.2、模式的实现类图（<a target="_blank" rel="noopener" href="https://www.runoob.com/design-pattern/abstract-factory-pattern.html">具体代码</a>）</h5><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/29.png" alt="image-20210413015123090"></p>
<h4 id="6-3-3、应用实例"><a href="#6-3-3、应用实例" class="headerlink" title="6.3.3、应用实例"></a>6.3.3、应用实例</h4><p>使用抽象工厂模式来完成披萨项目。</p>
<p>类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/30.png" alt="image-20210413015603989"></p>
<p>代码：</p>
<p>抽象工厂：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个抽象工厂模式的抽象层(接口)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbsFactory</span> </span>&#123;</span><br><span class="line">	<span class="comment">//让下面的工厂子类来 具体实现</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(String orderType)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>北京工厂实现抽象工厂生产披萨（伦敦同）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是工厂子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BJFactory</span> <span class="keyword">implements</span> <span class="title">AbsFactory</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(String orderType)</span> </span>&#123;</span><br><span class="line">		Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span>(orderType.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">			pizza = <span class="keyword">new</span> BJCheesePizza();</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>))&#123;</span><br><span class="line">			pizza = <span class="keyword">new</span> BJPepperPizza();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> pizza;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>订购披萨：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderPizza</span> </span>&#123;</span><br><span class="line">	AbsFactory factory;</span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">OrderPizza</span><span class="params">(AbsFactory factory)</span> </span>&#123;</span><br><span class="line">		setFactory(factory);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setFactory</span><span class="params">(AbsFactory factory)</span> </span>&#123;</span><br><span class="line">		Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">		String orderType = <span class="string">&quot;&quot;</span>; <span class="comment">// 用户输入</span></span><br><span class="line">		<span class="keyword">this</span>.factory = factory;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			orderType = getType();</span><br><span class="line">			<span class="comment">// factory 可能是北京的工厂子类，也可能是伦敦的工厂子类</span></span><br><span class="line">			pizza = factory.createPizza(orderType);</span><br><span class="line">			<span class="keyword">if</span> (pizza != <span class="keyword">null</span>) &#123; <span class="comment">// 订购ok</span></span><br><span class="line">				pizza.prepare();</span><br><span class="line">				pizza.bake();</span><br><span class="line">				pizza.cut();</span><br><span class="line">				pizza.box();</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;订购失败&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 写一个方法，可以获取客户希望订购的披萨种类</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			BufferedReader strin = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">			System.out.println(<span class="string">&quot;input pizza 种类:&quot;</span>);</span><br><span class="line">			String str = strin.readLine();</span><br><span class="line">			<span class="keyword">return</span> str;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> OrderPizza(<span class="keyword">new</span> BJFactory());</span><br><span class="line">		<span class="comment">// new OrderPizza(new LDFactory());</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-3-4、抽象工厂模式的相关说明"><a href="#6-3-4、抽象工厂模式的相关说明" class="headerlink" title="6.3.4、抽象工厂模式的相关说明"></a>6.3.4、抽象工厂模式的相关说明</h4><ul>
<li><p>抽象工厂模式除了具有工厂方法模式的优点外，其他主要优点如下。</p>
<ol>
<li>可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。</li>
<li>当需要产品族时，<strong>抽象工厂可以保证客户端始终只使用同一个产品的产品组</strong>。</li>
<li>抽象工厂增强了<strong>程序的可扩展性</strong>，当增加一个新的产品族时，不需要修改原代码，<strong>满足开闭原则</strong>。</li>
</ol>
</li>
<li><p>其缺点是：<strong>当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。增加了系统的抽象性和理解难度</strong></p>
<p>模式的应用场景</p>
<p>抽象工厂模式最早的应用是用于创建属于不同操作系统的视窗构件。如 Java 的 AWT 中的 Button 和 Text 等构件在 Windows 和 UNIX 中的本地实现是不同的。</p>
<ol>
<li>当需要创建的对象是一系列<strong>相互关联或相互依赖的产品族</strong>时，如电器工厂中的电视机、洗衣机、空调等。</li>
<li><strong>系统中有多个产品族，但每次只使用其中的某一族产品</strong>。如有人只喜欢穿某一个品牌的衣服和鞋。</li>
<li><strong>系统中提供了产品的类库，且所有产品的接口相同</strong>，客户端不依赖产品实例的创建细节和内部结构。</li>
</ol>
</li>
<li><p>模式的扩展</p>
<p>抽象工厂模式的扩展有一定的“开闭原则”倾斜性：</p>
<ol>
<li>当增加一个新的产品族时只需增加一个新的具体工厂，不需要修改原代码，满足开闭原则。</li>
<li>当产品族中需要增加一个新种类的产品时，则所有的工厂类都需要进行修改，不满足开闭原则。</li>
</ol>
<p>另一方面，当系统中只存在一个等级结构的产品时，抽象工厂模式将退化到工厂方法模式。</p>
</li>
<li><p>进阶阅读</p>
<p>如果您想了解抽象工厂在框架源码中的应用，可阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8392.html">《抽象工厂在Java源码中的应用》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8393.html">《抽象工厂模式在Spring源码中的应用》</a></li>
</ul>
</li>
</ul>
<h4 id="6-3-5、相关的设计模式"><a href="#6-3-5、相关的设计模式" class="headerlink" title="6.3.5、相关的设计模式"></a>6.3.5、相关的设计模式</h4><ul>
<li><p>Builder模式</p>
<p>Abstract Factory模式通过调用抽象产品的接口 (APl) 来组装抽象产品， 生成具有复杂结构的实例。</p>
<p>Builder模式则是分阶段地制作复杂实例。</p>
</li>
<li><p>Factory Method模式</p>
<p>有时AbstractFactory模式中零件和产品的生成会使用到Factory Method模式。</p>
</li>
<li><p>Composite模式</p>
<p>有时AbstractFactory模式在制作产品时会使用Composite模式。</p>
</li>
<li><p>Singleton模式</p>
<p>有时AbstractFactory模式中的具体工厂会使用Singleton模式。</p>
</li>
</ul>
<h3 id="6-4、工厂模式在-JDK-Calendar-应用的源码分析"><a href="#6-4、工厂模式在-JDK-Calendar-应用的源码分析" class="headerlink" title="6.4、工厂模式在 JDK-Calendar 应用的源码分析"></a>6.4、工厂模式在 JDK-Calendar 应用的源码分析</h3><p>JDK 中的 Calendar 类中，就使用了<strong>简单工厂模式</strong></p>
<p>原码：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/33.png" alt="image-20210413021425940"></p>
<p>其中createCalendar()方法：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/32.png" alt="image-20210413022320157"></p>
<h3 id="6-5、工厂模式小结"><a href="#6-5、工厂模式小结" class="headerlink" title="6.5、工厂模式小结"></a>6.5、工厂模式小结</h3><ol>
<li><p>工厂模式的意义</p>
<p>将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。</p>
</li>
<li><p>三种工厂模式 </p>
<ol>
<li>简单工厂模式（不在23种之中）</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
</ol>
</li>
<li><p>设计模式的<strong>依赖抽象原则</strong></p>
</li>
</ol>
<p>创建对象实例时，不要直接 new 类, 而是把这个 new 类的动作放在一个工厂的方法中，并返回。有的书上说， 变量不要直接持有具体类的引用。</p>
<p>不要让类继承具体类，而是继承抽象类或者是实现 interface(接口)</p>
<p>不要覆盖基类中已经实现的方法。</p>
<h2 id="7、原型模式ProtoType（创建型设计模式）"><a href="#7、原型模式ProtoType（创建型设计模式）" class="headerlink" title="7、原型模式ProtoType（创建型设计模式）"></a>7、原型模式ProtoType（创建型设计模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/77.png" alt="image-20210415031921912"></p>
<h3 id="7-1、基本介绍"><a href="#7-1、基本介绍" class="headerlink" title="7.1、基本介绍"></a>7.1、基本介绍</h3><ol>
<li>原型模式(Prototype 模式)是指：用<strong>原型实例指定创建对象的种类</strong>，并且通过<strong>拷贝</strong>这些原型，创建新的对象</li>
<li>原型模式是一种<strong>创建型设计</strong>模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节</li>
<li>工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象<strong>通过请求原型对象拷贝它们自己来实施创建</strong>，即 对象**.clone**()</li>
</ol>
<h3 id="7-2、原型模式原理结构图-uml-类图"><a href="#7-2、原型模式原理结构图-uml-类图" class="headerlink" title="7.2、原型模式原理结构图-uml 类图"></a>7.2、原型模式原理结构图-uml 类图</h3><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/21.png" alt="image-20210413222550496"></p>
<p>原理结构图说明：</p>
<ul>
<li>Prototype : 原型类，<strong>声明一个克隆自己的接口</strong></li>
<li>ConcretePrototype: 具体的原型类, <strong>实现</strong>一个克隆自己的操作</li>
<li>Client: 使用者；让一个原型对象克隆自己，从而创建一个新的对象(属性一样）</li>
</ul>
<h3 id="7-3、应用举例"><a href="#7-3、应用举例" class="headerlink" title="7.3、应用举例"></a>7.3、应用举例</h3><p>克隆羊问题：</p>
<p>现在有一只羊 tom，姓名为: tom, 年龄为：1，颜色为：白色，请编写程序创建和 tom 羊 属性完全相同的 10只羊。</p>
<h4 id="7-3-1、传统方式解决克隆羊问题"><a href="#7-3-1、传统方式解决克隆羊问题" class="headerlink" title="7.3.1、传统方式解决克隆羊问题"></a>7.3.1、传统方式解决克隆羊问题</h4><h5 id="7-3-1-1、思路分析-类图"><a href="#7-3-1-1、思路分析-类图" class="headerlink" title="7.3.1.1、思路分析(类图)"></a>7.3.1.1、思路分析(类图)</h5><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/22.png" alt="image-20210413222817657"></p>
<h5 id="7-3-1-2、相关代码：（在Client中）"><a href="#7-3-1-2、相关代码：（在Client中）" class="headerlink" title="7.3.1.2、相关代码：（在Client中）"></a>7.3.1.2、相关代码：（在Client中）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传统的方法</span></span><br><span class="line">Sheep sheep = <span class="keyword">new</span> Sheep(<span class="string">&quot;tom&quot;</span>, <span class="number">1</span>, <span class="string">&quot;白色&quot;</span>);</span><br><span class="line">Sheep sheep2 = <span class="keyword">new</span> Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); </span><br></pre></td></tr></table></figure>

<h5 id="7-3-1-3、传统的方式的优缺点"><a href="#7-3-1-3、传统的方式的优缺点" class="headerlink" title="7.3.1.3、传统的方式的优缺点"></a>7.3.1.3、传统的方式的优缺点</h5><ol>
<li>优点是比较好理解，简单易操作。</li>
<li>在创建新的对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂时，效率较低</li>
<li>总是需要重新初始化对象，而不是动态地获得对象运行时的状态, 不够灵活</li>
</ol>
<h5 id="7-3-1-4、改进方法（使用原型模式）"><a href="#7-3-1-4、改进方法（使用原型模式）" class="headerlink" title="7.3.1.4、改进方法（使用原型模式）"></a>7.3.1.4、改进方法（使用原型模式）</h5><p>Java 中 Object 类是所有类的根类，Object 类提供了一个 clone()方法，该方法可以将一个 Java 对象复制一份，但是需要实现 clone 的 Java 类必须要实现一个接口 Cloneable，该接口表示该类能够复制且具有复制的能力 =&gt;原型模式</p>
<h4 id="7-3-2、原型模式解决克隆羊问题"><a href="#7-3-2、原型模式解决克隆羊问题" class="headerlink" title="7.3.2、原型模式解决克隆羊问题"></a>7.3.2、原型模式解决克隆羊问题</h4><p>实现步骤：</p>
<ol>
<li>实例实现接口Cloneable，并重写Object的clone方法</li>
<li>在Client使用创建的实例的clone方法进行对象的克隆</li>
</ol>
<p>代码实现：</p>
<p>sheep：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> String color;</span><br><span class="line">	<span class="keyword">private</span> String address = <span class="string">&quot;蒙古羊&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> Sheep friend; <span class="comment">//是对象, 克隆是会如何处理</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Sheep</span><span class="params">(String name, <span class="keyword">int</span> age, String color)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">		<span class="keyword">this</span>.color = color;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> color;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.color = color;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Sheep [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;, color=&quot;</span> + color + <span class="string">&quot;, address=&quot;</span> + address + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//克隆该实例，使用默认的clone方法来完成</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">		Sheep sheep = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			sheep = (Sheep)<span class="keyword">super</span>.clone();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			System.out.println(e.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sheep;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Sheep sheep = <span class="keyword">new</span> Sheep(<span class="string">&quot;tom&quot;</span>, <span class="number">1</span>, <span class="string">&quot;白色&quot;</span>);</span><br><span class="line">		sheep.friend = <span class="keyword">new</span> Sheep(<span class="string">&quot;jack&quot;</span>, <span class="number">2</span>, <span class="string">&quot;黑色&quot;</span>);</span><br><span class="line">		<span class="comment">//克隆</span></span><br><span class="line">		Sheep sheep2 = (Sheep)sheep.clone(); </span><br><span class="line">		System.out.println(<span class="string">&quot;sheep2 =&quot;</span> + sheep2 + <span class="string">&quot;sheep2.friend=&quot;</span> + sheep2.friend.hashCode());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用原型模式改进传统方式，让程序具有<strong>更高的效率和扩展性</strong>。</p>
<h3 id="7-4、浅拷贝和深拷贝"><a href="#7-4、浅拷贝和深拷贝" class="headerlink" title="7.4、浅拷贝和深拷贝"></a>7.4、浅拷贝和深拷贝</h3><h4 id="7-4-1、浅拷贝的介绍"><a href="#7-4-1、浅拷贝的介绍" class="headerlink" title="7.4.1、浅拷贝的介绍"></a>7.4.1、浅拷贝的介绍</h4><ol>
<li>对于数据类型是<strong>基本数据类型</strong>的成员变量，<strong>浅拷贝会直接进行值传递</strong>，也就是将该<strong>属性值复制一份给新的对象</strong>。</li>
<li>对于String，虽然String不是基本数据结构，而是应用数据类型。但是在JVM中存在字符串常量池会存储已创建的字符串。在克隆的时候也是引用也是直接指向字符串常量池里的字符串。所以在clone当中可以将String近似于看作基本数据类型。</li>
<li>对于数据类型是<strong>引用数据类型</strong>的成员变量，比如说成员变量是<strong>某个数组、某个类的对象</strong>等，那么浅拷贝会进行<strong>引用传递</strong>，也就是只是将<strong>该成员变量的引用值（内存地址）复制一份给新的对象</strong>。因为实际上两个对象的该成员变量都<strong>指向同一个实例</strong>。在这种情况下，在<strong>一个对象中修改该成员变量会影响到另一个对象的该成员变量值</strong>。</li>
<li>前面我们克隆羊就是浅拷贝（里面的friend是同一个friend，即所有的克隆羊都有同一个朋友）</li>
<li>浅拷贝是使用默认的 clone()方法来实现：sheep = (Sheep) super.clone();</li>
</ol>
<h4 id="7-4-2、深拷贝基本介绍"><a href="#7-4-2、深拷贝基本介绍" class="headerlink" title="7.4.2、深拷贝基本介绍"></a>7.4.2、深拷贝基本介绍</h4><ol>
<li>复制对象的<strong>所有基本数据类型</strong>的成员变量值</li>
<li>为<strong>所有引用数据类型的成员变量申请存储空间</strong>，并<strong>复制每个引用数据类型成员变量所引用的对象</strong>，直到该对象可达的所有对象。也就是说，对象进行深拷贝要<strong>对整个对象(包括对象的引用类型)进行拷贝</strong></li>
<li>深拷贝实现方式 1：重写 <strong>clone</strong> 方法来实现深拷贝</li>
<li>深拷贝实现方式 2：通过<strong>对象序列化</strong>实现深拷贝(<strong>推荐</strong>)</li>
</ol>
<h4 id="7-4-3、深拷贝应用实例"><a href="#7-4-3、深拷贝应用实例" class="headerlink" title="7.4.3、深拷贝应用实例"></a>7.4.3、深拷贝应用实例</h4><h5 id="7-4-3-1、使用-重写-clone-方法实现深拷贝"><a href="#7-4-3-1、使用-重写-clone-方法实现深拷贝" class="headerlink" title="7.4.3.1、使用 重写 clone 方法实现深拷贝"></a>7.4.3.1、使用 重写 clone 方法实现深拷贝</h5><p>DeepCloneableTarget：其他实例当中的成员变量：实现克隆接口与序列化接口Serializable, Cloneable</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepCloneableTarget</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">	<span class="keyword">private</span> String cloneName;</span><br><span class="line">	<span class="keyword">private</span> String cloneClass;</span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DeepCloneableTarget</span><span class="params">(String cloneName, String cloneClass)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.cloneName = cloneName;</span><br><span class="line">		<span class="keyword">this</span>.cloneClass = cloneClass;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//因为该类的属性，都是String , 因此我们这里使用默认的clone完成即可</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DeepProtoType：要进行克隆的实例类，其中有成员变量DeepCloneableTarget</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepProtoType</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> String name; <span class="comment">//String 属性</span></span><br><span class="line">	<span class="keyword">public</span> DeepCloneableTarget deepCloneableTarget;<span class="comment">// 引用类型</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DeepProtoType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//深拷贝 - 方式 1 使用clone 方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">		Object deep = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">//这里完成对基本数据类型(属性)和String的克隆</span></span><br><span class="line">		deep = <span class="keyword">super</span>.clone(); </span><br><span class="line">		<span class="comment">//对引用类型的属性，进行单独处理</span></span><br><span class="line">		DeepProtoType deepProtoType = (DeepProtoType)deep;</span><br><span class="line">		deepProtoType.deepCloneableTarget  = (DeepCloneableTarget)deepCloneableTarget.clone();</span><br><span class="line">		<span class="keyword">return</span> deepProtoType;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：对DeepProtoType进行克隆</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DeepProtoType p = <span class="keyword">new</span> DeepProtoType();</span><br><span class="line">        p.name = <span class="string">&quot;宋江&quot;</span>;</span><br><span class="line">        p.deepCloneableTarget = <span class="keyword">new</span> DeepCloneableTarget(<span class="string">&quot;大牛&quot;</span>, <span class="string">&quot;小牛&quot;</span>);	</span><br><span class="line">        <span class="comment">//方式1 完成深拷贝</span></span><br><span class="line">        DeepProtoType p2 = (DeepProtoType) p.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;p.name=&quot;</span> + p.name + <span class="string">&quot;p.deepCloneableTarget=&quot;</span> + p.deepCloneableTarget.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;p2.name=&quot;</span> + p.name + <span class="string">&quot;p2.deepCloneableTarget=&quot;</span> + p2.deepCloneableTarget.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-4-3-2、使用序列化来实现深拷贝"><a href="#7-4-3-2、使用序列化来实现深拷贝" class="headerlink" title="7.4.3.2、使用序列化来实现深拷贝"></a>7.4.3.2、使用序列化来实现深拷贝</h5><p>DeepCloneableTarget：同上</p>
<p>DeepProtoType：要进行克隆的实例类，其中有成员变量DeepCloneableTarget</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepProtoType</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> String name; <span class="comment">//String 属性</span></span><br><span class="line">	<span class="keyword">public</span> DeepCloneableTarget deepCloneableTarget;<span class="comment">// 引用类型</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DeepProtoType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="comment">//深拷贝 - 方式2 通过对象的序列化实现 (推荐)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">deepClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建流对象</span></span><br><span class="line">		ByteArrayOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">		ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">		ByteArrayInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">		ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//序列化</span></span><br><span class="line">			bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">			oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">			oos.writeObject(<span class="keyword">this</span>); <span class="comment">//当前这个对象以对象流的方式输出</span></span><br><span class="line">			<span class="comment">//反序列化</span></span><br><span class="line">			bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">			ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">			DeepProtoType copyObj = (DeepProtoType)ois.readObject();</span><br><span class="line">			<span class="keyword">return</span> copyObj;	</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">//关闭流</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				bos.close();</span><br><span class="line">				oos.close();</span><br><span class="line">				bis.close();</span><br><span class="line">				ois.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">				System.out.println(e2.getMessage());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：对DeepProtoType进行克隆</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		DeepProtoType p = <span class="keyword">new</span> DeepProtoType();</span><br><span class="line">		p.name = <span class="string">&quot;宋江&quot;</span>;</span><br><span class="line">		p.deepCloneableTarget = <span class="keyword">new</span> DeepCloneableTarget(<span class="string">&quot;大牛&quot;</span>, <span class="string">&quot;小牛&quot;</span>);</span><br><span class="line">		<span class="comment">//方式2 完成深拷贝</span></span><br><span class="line">		DeepProtoType p2 = (DeepProtoType) p.deepClone();</span><br><span class="line">		System.out.println(<span class="string">&quot;p.name=&quot;</span> + p.name + <span class="string">&quot;p.deepCloneableTarget=&quot;</span> + p.deepCloneableTarget.hashCode());</span><br><span class="line">		System.out.println(<span class="string">&quot;p2.name=&quot;</span> + p.name + <span class="string">&quot;p2.deepCloneableTarget=&quot;</span> + p2.deepCloneableTarget.hashCode());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-4-3-3、对于实例类的成员变量为本身的实例的深拷贝："><a href="#7-4-3-3、对于实例类的成员变量为本身的实例的深拷贝：" class="headerlink" title="7.4.3.3、对于实例类的成员变量为本身的实例的深拷贝："></a>7.4.3.3、对于实例类的成员变量为本身的实例的深拷贝：</h5><p>使用序列化可以实现，但是使用clone方法会报StackOverflowError异常</p>
<p>sheep：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="comment">//实例类的成员变量为本身</span></span><br><span class="line">    <span class="keyword">public</span> Sheep friend;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sheep</span><span class="params">(String name, <span class="keyword">int</span> age, String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Sheep&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, color=&#x27;&quot;</span> + color + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, friend=&quot;</span> + friend +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//深拷贝 通过对象的序列化实现 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deepClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建流对象</span></span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//序列化</span></span><br><span class="line">            bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">            oos.writeObject(<span class="keyword">this</span>); <span class="comment">//当前这个对象以对象流的方式输出</span></span><br><span class="line">            <span class="comment">//反序列化</span></span><br><span class="line">            bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">            Sheep copyObj = (Sheep)ois.readObject();</span><br><span class="line">            <span class="keyword">return</span> copyObj;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bos.close();</span><br><span class="line">                oos.close();</span><br><span class="line">                bis.close();</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">                System.out.println(e2.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Sheep sheep = <span class="keyword">new</span> Sheep(<span class="string">&quot;Tom&quot;</span>,<span class="number">1</span>,<span class="string">&quot;black&quot;</span>);</span><br><span class="line">        sheep.friend = <span class="keyword">new</span> Sheep(<span class="string">&quot;john&quot;</span>, <span class="number">2</span>, <span class="string">&quot;white&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        Sheep sheep1 = (Sheep) sheep.deepClone();</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;sheep.name=&quot;</span> + sheep.getName() + <span class="string">&quot; sheep.age=&quot;</span> + sheep.getAge() + <span class="string">&quot; sheep.color=&quot;</span> + sheep.getColor() + <span class="string">&quot; sheep.friend&quot;</span> + sheep.friend.hashCode());</span><br><span class="line">		System.out.println(<span class="string">&quot;sheep1.name=&quot;</span> + sheep1.getName() + <span class="string">&quot; sheep1.age=&quot;</span> + sheep1.getAge() + <span class="string">&quot; sheep1.color=&quot;</span> + sheep1.getColor() + <span class="string">&quot; sheep1.friend&quot;</span> + sheep1.friend.hashCode());</span><br><span class="line">        System.out.println(sheep.friend == sheep1.friend);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-4-4、对于深拷贝的clone方法与序列化方法"><a href="#7-4-4、对于深拷贝的clone方法与序列化方法" class="headerlink" title="7.4.4、对于深拷贝的clone方法与序列化方法"></a>7.4.4、对于深拷贝的clone方法与序列化方法</h4><h5 id="7-4-4-1、clone方法"><a href="#7-4-4-1、clone方法" class="headerlink" title="7.4.4.1、clone方法"></a>7.4.4.1、clone方法</h5><ul>
<li>clone方法分成两步：<ol>
<li>先克隆<strong>基本数据类型和String</strong></li>
<li>在对其<strong>引用数据类型</strong>进行多次克隆</li>
</ol>
</li>
<li>如果想要深拷贝一个对象， 这个对象必须要<strong>实现Cloneable接口，实现clone方法</strong>，并且在<strong>clone方法内部，把该对象引用的其他对象也要clone一份</strong> ， 这就要求这个<strong>被引用的对象必须也要实现Cloneable接口并且实现clone方法。</strong></li>
<li>clone实际上就是实现了<strong>多重clone</strong>，实例本身有其他的应用数据类型（除String），就先重写其他的<strong>引用数据类型</strong>的clone方法；若在其他的应用数据类型（除String）又有其他的引用数据类型，又重复该过程，直到做到所有的成员变量都完成clone。</li>
<li>所以，如果在拷贝一个对象时，要想让<strong>这个拷贝的对象和源对象完全彼此独立</strong>，那么在<strong>引用链上的每一级对象都要被显式的拷贝</strong>。所以创建彻底的深拷贝是非常麻烦的，尤其是在引用关系非常复杂的情况下， 或者在引用链的某一级上引用了一个第三方的对象， 而<strong>这个对象没有实现clone方法</strong>， 那么在它之后的所有引用的对象都是被共享的。或者如果某一个类<strong>没有实现Cloneable接口</strong>，我们还要对其进行深拷贝的话，就必然需要<strong>修改该类</strong>，这样就<strong>违反了OCP原则</strong>。</li>
<li>所以在开发中这种深拷贝方式<strong>不常用</strong>。</li>
</ul>
<h5 id="7-4-4-2、序列化方法"><a href="#7-4-4-2、序列化方法" class="headerlink" title="7.4.4.2、序列化方法"></a>7.4.4.2、序列化方法</h5><ul>
<li>序列化方法也分成两步<ol>
<li>将要实现克隆的实例进行序列化</li>
<li>在将其进行反序列化出来实现实例的拷贝</li>
</ol>
</li>
<li>使用该类的<strong>对象必须要实现Serializable接口</strong>，否则是没有办法实现克隆的。无须继承Cloneable接口实现clone()方法。</li>
<li>在内存中通过字节流的拷贝是比较容易实现的。把<strong>母对象写入到一个字节流</strong>中，再<strong>从字节流中将其读出来</strong>，这样就可以<strong>创建一个新的对象</strong>了，并且该<strong>新对象与母对象之间并不存在引用共享</strong>的问题，<strong>真正实现对象的深拷贝</strong>。</li>
<li>能实现<strong>对于实例类的成员变量为本身的实例的深拷贝</strong></li>
<li>缺点：使用该类的<strong>对象必须要实现Serializable接口</strong>，所以在一些类并没有实现Serializable接口，如果还要对其进行深拷贝的话，就必然需要<strong>修改该类</strong>，这样就<strong>违反了OCP原则</strong>。</li>
<li>所以在开发中<strong>推荐</strong>使用这种方式进行深拷贝。</li>
</ul>
<h3 id="7-5、原型模式在-Spring-框架中源码分析"><a href="#7-5、原型模式在-Spring-框架中源码分析" class="headerlink" title="7.5、原型模式在 Spring 框架中源码分析"></a>7.5、原型模式在 Spring 框架中源码分析</h3><p>Spring 中原型 bean 的创建，就是原型模式的应用</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/23.png" alt="image-20210414025832896"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/24.png" alt="image-20210414030430256"></p>
<h3 id="7-6、new一个对象的过程和clone一个对象的过程区别"><a href="#7-6、new一个对象的过程和clone一个对象的过程区别" class="headerlink" title="7.6、new一个对象的过程和clone一个对象的过程区别"></a>7.6、new一个对象的过程和clone一个对象的过程区别</h3><p>关于new：</p>
<p>new操作符的本意是<strong>分配内存</strong>。程序执行到new操作符时，会<strong>先去看new操作符后面的类型</strong>，因为知道了类型，才能知道要分配多大的内存空间。<strong>分配</strong>完<strong>内存</strong>之后，<strong>再调用构造函数</strong>，填充对象的各个域，这一步叫做<strong>对象的初始化</strong>，构造方法返回后，一个对象创建完毕，可以<strong>把它的引用</strong>（也就是地址）<strong>发布到外部</strong>，在外部就可以使用这个引用操作这个对象。</p>
<p>关于clone：</p>
<p><strong>clone在第一步</strong>是和new相似的，都是<strong>分配内存</strong>，调用clone方法时，分配的内存和原对象（即调用clone方法的对象）相同，然后<strong>再使用原对象中对应的各个域，填充新对象的域</strong>，填充完成之后，clone方法返回，一个新的相同的对象被创建，同样可以把<strong>这个新对象的引用发布到外部</strong>。</p>
<blockquote>
<ol>
<li>clone()不会调用构造方法；new会调用构造方法。</li>
<li>new对象时根据类型确定分配内存空间的大小, clone是根据原对象分配内</li>
</ol>
</blockquote>
<h3 id="7-7、原型模式的总结"><a href="#7-7、原型模式的总结" class="headerlink" title="7.7、原型模式的总结"></a>7.7、原型模式的总结</h3><p>原型模式的优点：</p>
<ul>
<li>Java 自带的原型模式基于内存<strong>二进制流的复制</strong>，在<strong>性能上比直接 new 一个对象更加优良</strong>。</li>
<li>它<strong>逃避了构造函数的约束</strong>。</li>
<li>可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如<strong>恢复到历史某一状态</strong>），可辅助实现<strong>撤销操作</strong>。</li>
</ul>
<p>原型模式的缺点：</p>
<ul>
<li>需要为<strong>每一个类都配置一个 clone 方法</strong></li>
<li>clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，<strong>违背了开闭原则</strong>。</li>
<li>当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，<strong>每一层对象对应的类都必须支持深克隆</strong>，实现起来会比较麻烦。因此，深克隆、浅克隆需要运用得当。</li>
</ul>
<p>原型模式的应用场景：</p>
<ul>
<li>对象之间相同或相似，即只是个别的几个属性不同的时候。</li>
<li>创建对象成本较大，例如初始化时间长，占用CPU太多，或者占用网络资源太多等，需要优化资源。类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。</li>
<li>创建一个对象需要繁琐的数据准备或访问权限等，需要提高性能或者提高安全性。</li>
<li>一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用</li>
<li>资源优化场景</li>
<li>一个对象多个修改者的场景</li>
<li>想要生成实例的框架不依赖与具体的类，解耦框架与生成的实例</li>
</ul>
<p>在实际项目中，原型模式很少单独出现，一般是<strong>和工厂方法模式一起出现</strong>，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。</p>
<p>在 <a target="_blank" rel="noopener" href="http://c.biancheng.net/spring/">Spring</a> 中，原型模式应用的非常广泛，例如 scope=’prototype’、JSON.parseObject() 等都是原型模式的具体应用。</p>
<h3 id="7-8、原型模式的扩展（带原型管理器的原型模式）"><a href="#7-8、原型模式的扩展（带原型管理器的原型模式）" class="headerlink" title="7.8、原型模式的扩展（带原型管理器的原型模式）"></a>7.8、原型模式的扩展（带原型管理器的原型模式）</h3><p>原型模式可扩展为带原型管理器的原型模式，它在原型模式的基础上增加了一个原型管理器 PrototypeManager 类。该类用 HashMap 保存多个复制的原型，Client 类可以通过管理器的 get(String id) 方法从中获取复制的原型。其结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/35.png" alt="image-20210414092155079"></p>
<p>举例：</p>
<p>用带原型管理器的原型模式来生成包含“圆”和“正方形”等图形的原型，并计算其面积。分析：本实例中由于存在不同的图形类，例如，“圆”和“正方形”，它们计算面积的方法不一样，所以需要用一个原型管理器来管理它们，是其结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/36.png" alt="image-20210414092311712"></p>
<p>ProtoTypeManager ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProtoTypeManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Shape&gt; ht = <span class="keyword">new</span> HashMap&lt;String, Shape&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProtoTypeManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ht.put(<span class="string">&quot;Circle&quot;</span>, <span class="keyword">new</span> Circle());</span><br><span class="line">        ht.put(<span class="string">&quot;Square&quot;</span>, <span class="keyword">new</span> Square());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addshape</span><span class="params">(String key, Shape obj)</span> </span>&#123;</span><br><span class="line">        ht.put(key, obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Shape temp = ht.get(key);</span><br><span class="line">        <span class="keyword">return</span> (Shape) temp.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-9、进阶阅读"><a href="#7-9、进阶阅读" class="headerlink" title="7.9、进阶阅读"></a>7.9、进阶阅读</h3><p>原型模式也称为克隆模式，如果您想深入了解原型（克隆）模式，可以猛击阅读下面的文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8379.html">《浅克隆和深克隆》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8382.html">《克隆会破坏单例对象吗》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8383.html">《原型模式在JDK源码中的应用》</a></li>
</ul>
<h3 id="7-10、相关的设计模式"><a href="#7-10、相关的设计模式" class="headerlink" title="7.10、相关的设计模式"></a>7.10、相关的设计模式</h3><ul>
<li><p>Flyweight 模式</p>
<p>使用Prototype模式可以生成一个与当前实例的状态完全相同的实例。 而使用Flyweight模式可以在不同的地方使用同一个实例。</p>
</li>
<li><p>Memento 模式</p>
<p>使用Prototype模式可以生成一个与当前实例的状态完全相同的实例。而使用Memento模式可以保存当前实例的状态， 以实现快照和撤销功能。</p>
</li>
<li><p>Composite 模式以及 Decorator 模式</p>
<p>经常使用Composite模式和Decorator模式时， 需要能够动态地创建复杂结构的实例。 这时可 以使用Prototype模式， 以帮助我们方便地生成实例。</p>
</li>
<li><p>Command 模式</p>
<p>想要复制Command模式中出现的命令时， 可以使用Prototype模式。</p>
</li>
</ul>
<h3 id="7-11、原型模式的注意事项和细节"><a href="#7-11、原型模式的注意事项和细节" class="headerlink" title="7.11、原型模式的注意事项和细节"></a>7.11、原型模式的注意事项和细节</h3><ul>
<li>创建新的对象比较复杂时，可以利用<strong>原型模式简化对象的创建过程，同时也能够提高效率</strong></li>
<li>不用<strong>重新初始化对象</strong>，而是<strong>动态地获得对象运行时的状态</strong></li>
<li>如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码</li>
<li>在实现深克隆的时候可能需要比较复杂的代码</li>
<li>Cloneable接口是一个标记接口，没有声明方法</li>
<li>缺点：需要为<strong>每一个类配备一个克隆方法</strong>，这对全新的类来说不是很难，但<strong>对已有的类进行改造时，需要修改其源代码，违背了 ocp 原则。</strong></li>
<li>原型模式应用不是很广泛，因为很多实例会持有类似文件、Socket这样的资源，而这些资源是无法复制给另一个对象共享的，只有存储简单类型的“值”对象可以复制。</li>
</ul>
<h2 id="8、建造者模式Builder（创建型设计模式）"><a href="#8、建造者模式Builder（创建型设计模式）" class="headerlink" title="8、建造者模式Builder（创建型设计模式）"></a>8、建造者模式Builder（创建型设计模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/78.png" alt="image-20210415031952053"></p>
<h3 id="8-1、基本介绍"><a href="#8-1、基本介绍" class="headerlink" title="8.1、基本介绍"></a>8.1、基本介绍</h3><ol>
<li>建造者模式（<strong>Builder Pattern</strong>） 又叫<strong>生成器模式</strong>，是一种<strong>对象构建模式</strong>。它可以将<strong>复杂对象</strong>的建造过程<strong>抽象出来（抽象类别）</strong>，使这个抽象过程的<strong>不同实现方法可以构造出不同表现（属性）的对象</strong>。</li>
<li>建造者模式将一个复杂对象的<strong>构造</strong>与它的<strong>表示分离</strong>，使<strong>同样的构建过程可以创建不同的表示</strong>。它是将<strong>一个复杂的对象分解为多个简单的对象，然后一步一步构建而成</strong>。它将<strong>变与不变相分离</strong>，即<strong>产品的组成部分</strong>是<strong>不变</strong>的，但<strong>每一部分</strong>是可以<strong>灵活选择</strong>的。</li>
</ol>
<h3 id="8-2、建造者模原理结构图-uml类图与模板实现"><a href="#8-2、建造者模原理结构图-uml类图与模板实现" class="headerlink" title="8.2、建造者模原理结构图-uml类图与模板实现"></a>8.2、建造者模原理结构图-uml类图与模板实现</h3><h4 id="8-2-1、建造者模式的四个角色"><a href="#8-2-1、建造者模式的四个角色" class="headerlink" title="8.2.1、建造者模式的四个角色"></a>8.2.1、建造者模式的四个角色</h4><p>建造者（Builder）模式由<strong>产品</strong>、<strong>抽象建造者</strong>、<strong>具体建造者</strong>、<strong>指挥者</strong>等 4 个要素构成</p>
<ol>
<li>Product（<strong>产品角色</strong>）： 它是包含多个组成部件的复杂对象，由<strong>具体建造者来创建其各个零部件</strong>。</li>
<li>Builder（<strong>抽象建造者</strong>）： 它是一个包含创建产品各个子部件的抽象方法的<strong>接口</strong>，通常还包含一个返回**复杂产品的方法 getResult()**。</li>
<li>ConcreteBuilder（<strong>具体建造者</strong>）： <strong>实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。</strong></li>
<li>Director（<strong>指挥者</strong>）： 构建一个<strong>使用 Builder 接口的对象</strong>。它主要是用于<strong>创建一个复杂的对象</strong>。它主要有两个作用：<ol>
<li><strong>隔离</strong>了客户与对象的生产过程</li>
<li>负责<strong>控制</strong>产品对象的生产过程</li>
</ol>
</li>
</ol>
<h4 id="8-2-2、建造者模式原理类图"><a href="#8-2-2、建造者模式原理类图" class="headerlink" title="8.2.2、建造者模式原理类图"></a>8.2.2、建造者模式原理类图</h4><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/37.png" alt="image-20210414182531377"></p>
<h4 id="8-2-3、类图的模板代码实现"><a href="#8-2-3、类图的模板代码实现" class="headerlink" title="8.2.3、类图的模板代码实现"></a>8.2.3、类图的模板代码实现</h4><p>产品角色Product：包含多个组成部件的复杂对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String partA;</span><br><span class="line">    <span class="keyword">private</span> String partB;</span><br><span class="line">    <span class="keyword">private</span> String partC;</span><br><span class="line">	<span class="comment">// setters方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPartA</span><span class="params">(String partA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.partA = partA;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//显示产品的特性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象建造者Builder：包含创建产品各个子部件的抽象方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建产品对象</span></span><br><span class="line">    <span class="keyword">protected</span> Product product = <span class="keyword">new</span> Product();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartA</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartB</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartC</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//返回产品对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体建造者ConcreteBuilder：实现了抽象建造者接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPartA(<span class="string">&quot;建造 PartA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPartB(<span class="string">&quot;建造 PartB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPartC(<span class="string">&quot;建造 PartC&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指挥者Director：调用建造者中的方法完成复杂对象的创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//产品构建与组装方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        builder.buildPartA();</span><br><span class="line">        builder.buildPartB();</span><br><span class="line">        builder.buildPartC();</span><br><span class="line">        <span class="keyword">return</span> builder.getResult();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Builder builder = <span class="keyword">new</span> ConcreteBuilder();</span><br><span class="line">        Director director = <span class="keyword">new</span> Director(builder);</span><br><span class="line">        Product product = director.construct();</span><br><span class="line">        product.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-3、应用举例"><a href="#8-3、应用举例" class="headerlink" title="8.3、应用举例"></a>8.3、应用举例</h3><p>盖房项目需求</p>
<ol>
<li>需要建房子：这一过程为打桩、砌墙、封顶</li>
<li>房子有各种各样的，比如普通房，高楼，别墅，各种房子的过程虽然一样，但是要求不要相同的.</li>
<li>请编写程序，完成需求.</li>
</ol>
<h4 id="8-3-1、传统方法"><a href="#8-3-1、传统方法" class="headerlink" title="8.3.1、传统方法"></a>8.3.1、传统方法</h4><p>类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/38.png" alt="image-20210414183731177"></p>
<p>传统方式的问题分析</p>
<ol>
<li>优点是比较好理解，简单易操作。</li>
<li>设计的程序结构，过于简单，<strong>没有设计缓存层对象</strong>，程序的<strong>扩展和维护不好</strong>. 也就是说，这种设计方案，把<strong>产品(**即：房子) 和 **创建产品的过程</strong>(即：建房子流程) <strong>封装在一起，耦合性增强了</strong>。</li>
<li>解决方案：将<strong>产品和产品建造过程解耦</strong>  =&gt; <strong>建造者模式</strong></li>
</ol>
<h4 id="8-3-2、建造者模式解决盖房子问题"><a href="#8-3-2、建造者模式解决盖房子问题" class="headerlink" title="8.3.2、建造者模式解决盖房子问题"></a>8.3.2、建造者模式解决盖房子问题</h4><p>思路分析图解(类图)</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/39.png" alt="image-20210414183956399"></p>
<h3 id="8-4、建造者模式在JDK中的应用与源码分析"><a href="#8-4、建造者模式在JDK中的应用与源码分析" class="headerlink" title="8.4、建造者模式在JDK中的应用与源码分析"></a>8.4、建造者模式在JDK中的应用与源码分析</h3><p>java.lang.StringBuilder 中的建造者模式</p>
<p>代码说明：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/40.png" alt="image-20210414185001199"></p>
<p>源码中建造者模式角色分析</p>
<ul>
<li>Appendable 接口定义了多个 append 方法(抽象方法), 即 <strong>Appendable 为抽象建造者（builder）</strong>, 定义了<strong>抽象方法</strong></li>
<li>AbstractStringBuilder <strong>实现</strong>了  Appendable <strong>接口方法</strong>，这里的 AbstractStringBuilder 已经是<strong>建造者（ConcreteBuilder）</strong>，只是<strong>不能实例化</strong></li>
<li>StringBuilder 即充当了<strong>指挥者角色（Director）</strong>，同时充当了<strong>具体的建造者（ConcreteBuilder）</strong>，<strong>建造方法的实现是由 AbstractStringBuilder 完成</strong> , 而 StringBuilder <strong>继承了 AbstractStringBuilder</strong>。直接使用了AbstractStringBuilder实现的方法。</li>
</ul>
<h3 id="8-5、建造者模式与工厂模式对区别"><a href="#8-5、建造者模式与工厂模式对区别" class="headerlink" title="8.5、建造者模式与工厂模式对区别"></a>8.5、建造者模式与工厂模式对区别</h3><ul>
<li>抽象工厂模式实现对<strong>产品家族</strong>的创建，一个产品家族是这样的一系列产品：具有<strong>不同分类维度的产品组合</strong>，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。</li>
<li>建造者模式则是要求<strong>按照指定的蓝图建造产品</strong>，它的主要目的是通过<strong>组装零配件而产生一个新产品</strong>。</li>
</ul>
<p>主要区别：</p>
<ul>
<li><strong>建造者模式</strong>更加注重方法的<strong>调用顺序</strong>，<strong>工厂模式</strong>注重<strong>创建对象</strong>。</li>
<li>创建对象的<strong>力度不同</strong>，<strong>建造者模式创建复杂的对象，由各种复杂的部件组成</strong>，<strong>工厂模式创建出来的对象都一样</strong></li>
<li><strong>关注重点不一样</strong>，<strong>工厂模式</strong>只需要把<strong>对象创建出来</strong>就可以了，而<strong>建造者模式</strong>不仅要<strong>创建出对象</strong>，还要知道<strong>对象由哪些部件组成</strong>。</li>
<li><strong>建造者模式</strong>根据建造过程中的<strong>顺序不一样</strong>，最终<strong>对象部件组成也不一样</strong>。</li>
</ul>
<p>建造者模式唯一区别于工厂模式的是<strong>针对复杂对象的创建</strong>。也就是说，如果<strong>创建简单对象</strong>，通常都是使用<strong>工厂模式</strong>进行创建，而如果<strong>创建复杂对象</strong>，就可以考虑使用<strong>建造者模式</strong>。</p>
<p>当需要创建的产品具备<strong>复杂创建过程</strong>时，可以<strong>抽取出共性创建过程</strong>，然后交由<strong>具体实现类自定义创建流程</strong>，使得同样的创建行为可以生产出不同的产品，<strong>分离了创建与表示</strong>，使创建产品的灵活性大大增加。</p>
<h3 id="8-6、建造者模式总结"><a href="#8-6、建造者模式总结" class="headerlink" title="8.6、建造者模式总结"></a>8.6、建造者模式总结</h3><p>主要优点如下：</p>
<ol>
<li><strong>封装性好</strong>，构建和表示分离。</li>
<li><strong>扩展性好</strong>，各个具体的建造者相互独立，有利于系统的解耦。</li>
<li>客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于<strong>控制细节风险</strong>。</li>
</ol>
<p>缺点如下：</p>
<ol>
<li>产品的<strong>组成部分必须相同</strong>，这限制了其使用范围。</li>
<li>如果产品的<strong>内部变化复杂</strong>，如果<strong>产品内部发生变化</strong>，则<strong>建造者也要同步修改</strong>，后期<strong>维护成本较大</strong>。</li>
</ol>
<p>模式的应用场景：</p>
<ul>
<li><strong>相同的方法</strong>，<strong>不同的执行顺序</strong>，<strong>产生不同的结果</strong>。</li>
<li><strong>多个部件或零件</strong>，都可以<strong>装配到一个对象中</strong>，但是产生的<strong>结果又不相同</strong>。</li>
<li><strong>产品类非常复杂</strong>，或者产品类中<strong>不同的调用顺序产生不同的作用</strong>。</li>
<li><strong>初始化一个对象特别复杂，参数多，而且很多参数都具有默认值。</strong></li>
</ul>
<h3 id="8-7、进阶阅读"><a href="#8-7、进阶阅读" class="headerlink" title="8.7、进阶阅读"></a>8.7、进阶阅读</h3><p>如果您想了解建造者模式在实际项目中的应用，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8404.html">《建造者模式实现链式赋值》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8409.html">《使用静态内部类实现建造者模式》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8415.html">《使用建造者模式构建动态SQL语句》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8420.html">《建造者模式在框架源码中的应用》</a></li>
</ul>
<h3 id="8-8、相关的设计模式"><a href="#8-8、相关的设计模式" class="headerlink" title="8.8、相关的设计模式"></a>8.8、相关的设计模式</h3><ul>
<li><p>Template Method 模式</p>
<ul>
<li>在 Builder 模式中， Director 角色控制 Builder 角色。</li>
<li>在 Template Method 模式中 ， 父类控制子类。</li>
</ul>
</li>
<li><p>Composite 模式</p>
<p>有些情况下 Builder 模式生成的实例构成了 Composite 模式。</p>
</li>
<li><p>Abstract Factory 模式</p>
<p>Builder 模式和 Abstract Factory 模式都用千生成复杂的实例。</p>
</li>
<li><p>Facade 模式</p>
<p>在 Builder 模式中， Director 角色通过组合 Builder 角色中的复杂方法向外部提供可以简单生成 实例的接口 (API) （相当于示例程序中的 construct 方法）。</p>
<p>Facade 模式中的 Facade 角色则是通过组合内部模块向外部提供可以简单调用的接口 (API)。</p>
</li>
</ul>
<h3 id="8-9、建造者模式的注意事项和细节"><a href="#8-9、建造者模式的注意事项和细节" class="headerlink" title="8.9、建造者模式的注意事项和细节"></a>8.9、建造者模式的注意事项和细节</h3><ol>
<li>客户端(使用程序)不必知道产品内部组成的细节，将<strong>产品本身与产品的创建过程解耦</strong>，使得<strong>相同的创建过程可以创建不同的产品对象</strong></li>
<li>每一个<strong>具体建造者都相对独立</strong>，而<strong>与其他的具体建造者无关</strong>，因此可以很方便地替换具体建造者或增加新的具体建造者， <strong>用户使用不同的具体建造者即可得到不同的产品对象</strong></li>
<li>可以更加<strong>精细</strong>地控制产品的创建过程 。将<strong>复杂产品的创建步骤分解在不同的方法中</strong>，使得创建过程更加清晰， 也更方便使用程序来<strong>控制创建过程</strong></li>
<li>增加新的具体建造者<strong>无须修改原有类库的代码</strong>，指挥者类针对抽象建造者类编程，系统<strong>扩展方便</strong>，<strong>符合“开闭原则”</strong></li>
<li>建造者（Builder）模式在应用过程中可以根据需要改变，如果<strong>创建的产品种类只有一种</strong>，只需要<strong>一个具体建造者</strong>，这时可以<strong>省略</strong>掉<strong>抽象建造者</strong>，甚至可以<strong>省略掉指挥者角色</strong>。</li>
<li>建造者模式所创建的产品<strong>一般具有较多的共同点</strong>，其<strong>组成部分相似</strong>，如果<strong>产品之间的差异性很大，则不适合使用建造者模式</strong>，因此其使用范围受到一定的限制。</li>
<li>如果产品的<strong>内部变化复杂</strong>，可能会导致需要定义<strong>很多具体建造者类来实现这种变化</strong>，导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式.</li>
</ol>
<h2 id="9、适配器模式Adapter（结构型模式）"><a href="#9、适配器模式Adapter（结构型模式）" class="headerlink" title="9、适配器模式Adapter（结构型模式）"></a>9、适配器模式Adapter（结构型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/73.PNG" alt="image-20210415031546174"></p>
<h3 id="9-1、基本介绍"><a href="#9-1、基本介绍" class="headerlink" title="9.1、基本介绍"></a>9.1、基本介绍</h3><ol>
<li><p>适配器模式(Adapter Pattern)将<strong>某个类的接口转换成客户端期望的另一个接口表示</strong>，主的目的是<strong>兼容性</strong>，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为<strong>包装器(Wrapper)</strong></p>
</li>
<li><p>适配器模式属于<strong>结构型模式</strong></p>
</li>
<li><p>主要分为三类</p>
<ol>
<li>类适配器模式</li>
<li>对象适配器模式</li>
<li>接口适配器模式</li>
</ol>
</li>
<li><p>工作原理</p>
<p>适配器模式：将一个类的接口转换成另一种接口.让原本接口不兼容的类可以兼容</p>
<ol>
<li><p>从用户的角度看不到被适配者，是解耦的</p>
</li>
<li><p>用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法</p>
</li>
<li><p>用户收到反馈结果，感觉只是和目标接口交互，如图</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/41.png" alt="image-20210414214311154"></p>
</li>
</ol>
</li>
</ol>
<h3 id="9-2、适配器模式原理结构图-uml类图"><a href="#9-2、适配器模式原理结构图-uml类图" class="headerlink" title="9.2、适配器模式原理结构图-uml类图"></a>9.2、适配器模式原理结构图-uml类图</h3><p>适配器模式（Adapter）包含以下主要角色。</p>
<ol>
<li><strong>目标</strong>（Target）接口：当前系统业务<strong>所期待的接口</strong>，它可以是<strong>抽象类或接口</strong>。</li>
<li><strong>被适配者</strong>（Adaptee\src）类：它是<strong>被访问和适配</strong>的现存组件库中的<strong>组件接口</strong>。</li>
<li><strong>适配器</strong>（Adapter）类：它是一个<strong>转换器</strong>，通过<strong>继承(类适配器)或引用(对象适配器)适配者的对象</strong>，把<strong>适配者接口转换成目标接口</strong>，让客户按目标接口的格式访问适配者。</li>
</ol>
<h4 id="9-2-1、类适配器模式"><a href="#9-2-1、类适配器模式" class="headerlink" title="9.2.1、类适配器模式"></a>9.2.1、类适配器模式</h4><p>结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/42.png" alt="image-20210414215313478"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> adapter;</span><br><span class="line"><span class="comment">//目标接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//适配者接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">        System.out.println(<span class="string">&quot;适配者中的业务代码被调用！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类适配器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassAdapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassAdapterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;类适配器模式测试：&quot;</span>);</span><br><span class="line">        Target target = <span class="keyword">new</span> ClassAdapter();</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-2-2、对象适配器模式"><a href="#9-2-2、对象适配器模式" class="headerlink" title="9.2.2、对象适配器模式"></a>9.2.2、对象适配器模式</h4><p>结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/43.png" alt="image-20210414215540735"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> adapter;</span><br><span class="line"><span class="comment">//对象适配器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectAdapter</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObjectAdapter</span><span class="params">(Adaptee adaptee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee=adaptee;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectAdapterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对象适配器模式测试：&quot;</span>);</span><br><span class="line">        Adaptee adaptee = <span class="keyword">new</span> Adaptee();</span><br><span class="line">        Target target = <span class="keyword">new</span> ObjectAdapter(adaptee);</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-2-3、接口适配器模式"><a href="#9-2-3、接口适配器模式" class="headerlink" title="9.2.3、接口适配器模式"></a>9.2.3、接口适配器模式</h4><p>结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/44.png" alt="image-20210414215753292"></p>
<p>代码：</p>
<p>Interface4（适配者（Adaptee）类）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interface4</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbsAdapter（适配器（Adapter）类）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在AbsAdapter 我们将 Interface4 的方法进行默认实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsAdapter</span> <span class="keyword">implements</span> <span class="title">Interface4</span> </span>&#123;</span><br><span class="line">	<span class="comment">//默认实现</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client（）：只需要去覆盖我们 需要使用 接口方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;	</span><br><span class="line">		AbsAdapter absAdapter = <span class="keyword">new</span> AbsAdapter() &#123;</span><br><span class="line">			<span class="comment">//只需要去覆盖我们 需要使用 接口方法</span></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">				System.out.println(<span class="string">&quot;使用了m1的方法&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		absAdapter.m1();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-3、三种适配器模式的基本介绍"><a href="#9-3、三种适配器模式的基本介绍" class="headerlink" title="9.3、三种适配器模式的基本介绍"></a>9.3、三种适配器模式的基本介绍</h3><h4 id="9-3-1、类适配器模式"><a href="#9-3-1、类适配器模式" class="headerlink" title="9.3.1、类适配器模式"></a>9.3.1、类适配器模式</h4><p>实现步骤：Adapter 类，通过继承 src 类，实现 dst 类接口，完成 src-&gt;dst 的适配</p>
<p>类适配器模式注意事项和细节：</p>
<ol>
<li>由于其<strong>继承了 src 类</strong>，所以它可以<strong>根据需求重写 src 类的方法</strong>，使得 Adapter 的灵活性增强了。</li>
<li>Java 是<strong>单继承机制</strong>，所以类适配器需要<strong>继承 src 类这一点算是一个缺点</strong>, 因为这<strong>要求 dst 必须是接口</strong>，有一定局限性。</li>
<li>由于Adapter继承了src类，所以不可避免的会去重写src的方法。在一定程度上<strong>违反了里氏原则</strong>与<strong>合成复用原则</strong>。</li>
<li><strong>src 类的方法在 Adapter 中都会暴露出来</strong>，也<strong>增加了使用的成本</strong>。</li>
</ol>
<h4 id="9-3-2、对象适配器模式"><a href="#9-3-2、对象适配器模式" class="headerlink" title="9.3.2、对象适配器模式"></a>9.3.2、对象适配器模式</h4><p>对象适配器模式介绍</p>
<ol>
<li>基本思路和类的适配器模式相同，只是将 <strong>Adapter 类</strong>作修改，<strong>不是继承 src 类</strong>，而是<strong>持有 src 类的实例（依赖），</strong>以解决兼容性的问题**。 </li>
<li>实现步骤：持有 src 类，实现 dst 类接口，完成 src-&gt;dst 的适配</li>
<li>根据“<strong>合成复用原则</strong>”，在系统中尽量<strong>使用关联关系（聚合）来替代继承</strong>关系。</li>
<li>对象适配器模式是适配器模式<strong>常用</strong>的一种</li>
</ol>
<p>对象适配器模式注意事项和细节 </p>
<ol>
<li>对象适配器和类适配器其实算是<strong>同一种思想</strong>，只不过<strong>实现方式不同</strong>。</li>
<li>根据<strong>合成复用原则</strong>，使用<strong>聚合替代继承</strong>， 所以它解决了<strong>类适配器必须继承 src 的局限性问题</strong>，也<strong>不再要求 dst必须是接口</strong>。</li>
<li>使用<strong>成本更低，更灵活</strong>。</li>
</ol>
<h4 id="9-3-3、接口适配器模式"><a href="#9-3-3、接口适配器模式" class="headerlink" title="9.3.3、接口适配器模式"></a>9.3.3、接口适配器模式</h4><p>接口适配器模式介绍 </p>
<ol>
<li>一些书籍称为：<strong>适配器模式(Default Adapter Pattern)**或</strong>缺省适配器模式**。</li>
<li>核心思路：当<strong>不需要全部实现接口</strong>提供的方法时，可先<strong>设计一个抽象类实现接口</strong>，并<strong>为该接口中每个方法提供一个默认实现（空方法）</strong>，那么<strong>该抽象类的子类可有选择地覆盖父类的某些方法来实现需求</strong></li>
<li>适用于<strong>一个接口不想使用其所有的方法</strong>的情况。</li>
</ol>
<p>接口适配器模式注意事项和细节 </p>
<ol>
<li>在<strong>JDK8</strong>开始，<strong>接口就可以默认实现</strong>了，所以这个可以不要抽象类，全部弄个默认实现就好。</li>
<li>然后定义接口的实现类可有选择地覆盖接口的默认方法来实现需求</li>
</ol>
<h3 id="9-4、应用举例"><a href="#9-4、应用举例" class="headerlink" title="9.4、应用举例"></a>9.4、应用举例</h3><p>需求：</p>
<p>以生活中充电器的例子来讲解适配器，充电器本身相当于 Adapter，220V 交流电相当于 src (即被适配者)，我们的目 dst(即 目标)是 5V 直流电。</p>
<h4 id="9-4-1、使用类适配器模式实现"><a href="#9-4-1、使用类适配器模式实现" class="headerlink" title="9.4.1、使用类适配器模式实现"></a>9.4.1、使用类适配器模式实现</h4><p>思路分析(类图)</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/45.png" alt="image-20210414222333677"></p>
<p>代码实现</p>
<p>Voltage220V：<strong>被适配者</strong>（Adaptee\src）类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被适配的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Voltage220V</span> </span>&#123;</span><br><span class="line">	<span class="comment">//输出220V的电压</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output220V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> src = <span class="number">220</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;电压=&quot;</span> + src + <span class="string">&quot;伏&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> src;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IVoltage5V：<strong>目标</strong>（Target）接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//适配接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IVoltage5V</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>VoltageAdapter：<strong>适配器</strong>（Adapter）类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//适配器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter</span> <span class="keyword">extends</span> <span class="title">Voltage220V</span> <span class="keyword">implements</span> <span class="title">IVoltage5V</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="comment">//获取到220V电压</span></span><br><span class="line">		<span class="keyword">int</span> srcV = output220V();</span><br><span class="line">		<span class="keyword">int</span> dstV = srcV / <span class="number">44</span> ; <span class="comment">//转成 5v</span></span><br><span class="line">		<span class="keyword">return</span> dstV;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>phone\Client：客户端进行使用</p>
<p>phone：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">	<span class="comment">//充电</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charging</span><span class="params">(IVoltage5V iVoltage5V)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(iVoltage5V.output5V() == <span class="number">5</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;电压为5V, 可以充电~~&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (iVoltage5V.output5V() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;电压大于5V, 不能充电~~&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; === 类适配器模式 ====&quot;</span>);</span><br><span class="line">		Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">		phone.charging(<span class="keyword">new</span> VoltageAdapter());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-4-2、使用对象适配器模式实现"><a href="#9-4-2、使用对象适配器模式实现" class="headerlink" title="9.4.2、使用对象适配器模式实现"></a>9.4.2、使用对象适配器模式实现</h4><p>Voltage220V：<strong>被适配者</strong>（Adaptee\src）类：同上</p>
<p>IVoltage5V：<strong>目标</strong>（Target）接口：同上</p>
<p>VoltageAdapter：<strong>适配器</strong>（Adapter）类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//适配器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter</span> <span class="keyword">implements</span> <span class="title">IVoltage5V</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Voltage220V voltage220V; <span class="comment">// 关联关系-聚合</span></span><br><span class="line">	<span class="comment">//通过构造器，传入一个 Voltage220V 实例</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">VoltageAdapter</span><span class="params">(Voltage220V voltage220v)</span> </span>&#123;	</span><br><span class="line">		<span class="keyword">this</span>.voltage220V = voltage220v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span> </span>&#123;	</span><br><span class="line">		<span class="keyword">int</span> dst = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">null</span> != voltage220V) &#123;</span><br><span class="line">			<span class="keyword">int</span> src = voltage220V.output220V();<span class="comment">//获取220V 电压</span></span><br><span class="line">			System.out.println(<span class="string">&quot;使用对象适配器，进行适配~~&quot;</span>);</span><br><span class="line">			dst = src / <span class="number">44</span>;</span><br><span class="line">			System.out.println(<span class="string">&quot;适配完成，输出的电压为=&quot;</span> + dst);</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="keyword">return</span> dst;		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>phone\Client：客户端进行使用</p>
<p>phone：同上</p>
<p>Client：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; === 对象适配器模式 ====&quot;</span>);</span><br><span class="line">		Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">		phone.charging(<span class="keyword">new</span> VoltageAdapter(<span class="keyword">new</span> Voltage220V()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-4-3、接口适配器模式应用实例"><a href="#9-4-3、接口适配器模式应用实例" class="headerlink" title="9.4.3、接口适配器模式应用实例"></a>9.4.3、接口适配器模式应用实例</h4><ul>
<li><p>Android 中的属性动画 ValueAnimator 类可以通过 addListener(AnimatorListener listener)方法添加监听器， 那么常规写法如下：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/46.png" alt="image-20210414224410293"></p>
</li>
<li><p>有时候我们不想实现 Animator.AnimatorListener 接口的全部方法，我们只想监听 onAnimationStart，我们会如下写</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/47.png" alt="image-20210414224454278"></p>
</li>
<li><p>AnimatorListenerAdapter 类，就是一个接口适配器，代码如下图:它空实现了Animator.AnimatorListener 类(src)的所有方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/48.png" alt="image-20210414224618055"></p>
</li>
<li><p>AnimatorListener 是一个接口</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/49.png" alt="image-20210414224645907"></p>
</li>
<li><p>程序里的匿名内部类就是 Listener 具体实现类</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Users\风间&琉璃\AppData\Roaming\Typora\typora-user-images\image-20210414224710829.png" alt="image-20210414224710829"></p>
</li>
</ul>
<h3 id="9-5、适配器模式在Spring-MVC的应用与源码分析"><a href="#9-5、适配器模式在Spring-MVC的应用与源码分析" class="headerlink" title="9.5、适配器模式在Spring MVC的应用与源码分析"></a>9.5、适配器模式在Spring MVC的应用与源码分析</h3><ul>
<li><p>SpringMvc 中的 <strong>HandlerAdapter,</strong> 就使用了适配器模式</p>
</li>
<li><p>SpringMVC 处理请求的流程回顾</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/53.png" alt="image-20210414234012692"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/54.png" alt="image-20210414234049194"></p>
</li>
<li><p>使用 HandlerAdapter 的原因分析：</p>
<p>可以看到<strong>处理器的类型不同</strong>，有<strong>多重实现方式</strong>，那么<strong>调用方式就不是确定的</strong>，如果需要直接调用 Controller 方法，需要调用的时候就得<strong>不断是使用 if else 来进行判断是哪一种子类然后执行</strong>。那么如果后面要扩展 Controller， 就得修改原来的代码，这样违背了 <strong>OCP 原则</strong>。</p>
</li>
<li><p>代码分析+Debug 源码</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/55.png" alt="image-20210415002836481"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/56.png" alt="image-20210415002913253"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/57.png" alt="image-20210415002940414"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/58.png" alt="image-20210415003150913"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/59.png" alt="image-20210415003221357"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/60.png" alt="image-20210415003242857"></p>
</li>
</ul>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/61.png" alt="image-20210415003342721"></p>
<p>相关类图：<br><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/62.png" alt="image-20210415010612924"></p>
<p>动手写 SpringMVC 通过适配器设计模式获取到对应的 Controller 的源码：</p>
<p>相关类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/50.png" alt="image-20210414225130202"></p>
<p>实现代码：</p>
<p>HandlerAdapter：一个Adapter接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个Adapter接口 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Object handler)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 多种适配器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">		((SimpleController) handler).doSimplerHandler();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (handler <span class="keyword">instanceof</span> SimpleController);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">		((HttpController) handler).doHttpHandler();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (handler <span class="keyword">instanceof</span> HttpController);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnotationHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">		((AnnotationController) handler).doAnnotationHandler();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (handler <span class="keyword">instanceof</span> AnnotationController);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Controller：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多种Controller实现  </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doHttpHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;http...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSimplerHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;simple...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnotationController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAnnotationHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;annotation...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DispatchServlet：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatchServlet</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> List&lt;HandlerAdapter&gt; handlerAdapters = <span class="keyword">new</span> ArrayList&lt;HandlerAdapter&gt;();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DispatchServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		handlerAdapters.add(<span class="keyword">new</span> AnnotationHandlerAdapter());</span><br><span class="line">		handlerAdapters.add(<span class="keyword">new</span> HttpHandlerAdapter());</span><br><span class="line">		handlerAdapters.add(<span class="keyword">new</span> SimpleHandlerAdapter());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 此处模拟SpringMVC从request取handler的对象，</span></span><br><span class="line">		<span class="comment">// 适配器可以获取到希望的Controller</span></span><br><span class="line">		 HttpController controller = <span class="keyword">new</span> HttpController();</span><br><span class="line">		<span class="comment">// AnnotationController controller = new AnnotationController();</span></span><br><span class="line">		<span class="comment">//SimpleController controller = new SimpleController();</span></span><br><span class="line">		<span class="comment">// 得到对应适配器</span></span><br><span class="line">		HandlerAdapter adapter = getHandler(controller);</span><br><span class="line">		<span class="comment">// 通过适配器执行对应的controller对应方法</span></span><br><span class="line">		adapter.handle(controller);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> HandlerAdapter <span class="title">getHandler</span><span class="params">(Controller controller)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//遍历：根据得到的controller(handler), 返回对应适配器</span></span><br><span class="line">		<span class="keyword">for</span> (HandlerAdapter adapter : <span class="keyword">this</span>.handlerAdapters) &#123;</span><br><span class="line">			<span class="keyword">if</span> (adapter.supports(controller)) &#123;</span><br><span class="line">				<span class="keyword">return</span> adapter;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> DispatchServlet().doDispatch(); <span class="comment">// http...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相关补充：</p>
<ul>
<li>Spring定义了一个适配接口，使得每一种Controller有一种对应的适配器实现类</li>
<li>适配器代替Controller执行相应的方法</li>
<li>扩展Controller时（即添加一个OtherController），只需要增加一个适配器类就完成了SpringMVC的扩展了（满足OCP原则）</li>
</ul>
<h3 id="9-6、适配器模式总结"><a href="#9-6、适配器模式总结" class="headerlink" title="9.6、适配器模式总结"></a>9.6、适配器模式总结</h3><p>主要优点如下：</p>
<ul>
<li>客户端通过适配器可以<strong>透明地调用目标接口</strong>。</li>
<li><strong>复用了现存的类</strong>，程序员<strong>不需要修改原有代码</strong>而重用现有的适配者类。</li>
<li>将<strong>目标类和适配者类解耦</strong>，<strong>解决</strong>了目标类和适配者类<strong>接口不一致</strong>的问题。</li>
<li>在很多业务场景中<strong>符合开闭原则</strong>。</li>
</ul>
<p>其缺点是：</p>
<ul>
<li>适配器编写过程需要结合业务场景全面考虑，可能会<strong>增加系统的复杂性</strong>。</li>
<li>增加代码阅读难度，<strong>降低代码可读性</strong>，过多使用适配器会使系统代码变得凌乱。</li>
</ul>
<p>模式的应用场景：</p>
<ul>
<li>以前开发的系统<strong>存在满足新系统功能需求的类</strong>，但<strong>其接口同新系统的接口不一致</strong>。</li>
<li>使用<strong>第三方提供的组件</strong>，但<strong>组件接口定义和自己要求的接口定义不同</strong>。</li>
</ul>
<h3 id="9-7、适配器模式的扩展"><a href="#9-7、适配器模式的扩展" class="headerlink" title="9.7、适配器模式的扩展"></a>9.7、适配器模式的扩展</h3><p>适配器模式（Adapter）可扩展为双向适配器模式，双向适配器类既可以把适配者接口转换成目标接口，也可以把目标接口转换成适配者接口，其结构图如图所示。</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/51.png" alt="image-20210414225959454"></p>
<p>相关代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> adapter;</span><br><span class="line"><span class="comment">//目标接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TwoWayTarget</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//适配者接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TwoWayAdaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//目标实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TargetRealize</span> <span class="keyword">implements</span> <span class="title">TwoWayTarget</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">        System.out.println(<span class="string">&quot;目标代码被调用！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//适配者实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdapteeRealize</span> <span class="keyword">implements</span> <span class="title">TwoWayAdaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">        System.out.println(<span class="string">&quot;适配者代码被调用！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//双向适配器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoWayAdapter</span> <span class="keyword">implements</span> <span class="title">TwoWayTarget</span>,<span class="title">TwoWayAdaptee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TwoWayTarget target;</span><br><span class="line">    <span class="keyword">private</span> TwoWayAdaptee adaptee;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoWayAdapter</span><span class="params">(TwoWayTarget target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target=target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoWayAdapter</span><span class="params">(TwoWayAdaptee adaptee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee=adaptee;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoWayAdapterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;目标通过双向适配器访问适配者：&quot;</span>);</span><br><span class="line">        TwoWayAdaptee adaptee = <span class="keyword">new</span> AdapteeRealize();</span><br><span class="line">        TwoWayTarget targe = <span class="keyword">new</span> TwoWayAdapter(adaptee);</span><br><span class="line">        target.request();</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;适配者通过双向适配器访问目标：&quot;</span>);</span><br><span class="line">        target = <span class="keyword">new</span> TargetRealize();</span><br><span class="line">        adaptee = <span class="keyword">new</span> TwoWayAdapter(target);</span><br><span class="line">        adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-8、进阶阅读"><a href="#9-8、进阶阅读" class="headerlink" title="9.8、进阶阅读"></a>9.8、进阶阅读</h3><p>如果您想了解适配器模式在实际中的应用，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8439.html">《使用类适配器重构第三方登录自由适配》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8447.html">《适配器模式在Spring源码中的应用》</a></li>
</ul>
<h3 id="9-9、相关的设计模式"><a href="#9-9、相关的设计模式" class="headerlink" title="9.9、相关的设计模式"></a>9.9、相关的设计模式</h3><ul>
<li><p>Bridge模式</p>
<p>Adapter模式用千连接接口(API)不同的类，而Bridge模式则用于连接类的功能层次结构与实现层次结构。</p>
</li>
<li><p>Decorator 模式</p>
<p>Adapter 模式用于填补不同接口 (API) 之间的缝隙，而 Decorator 模式则是在不改变接口 (API)的前提下增加功能。</p>
</li>
</ul>
<h3 id="9-10、适配器模式的注意事项和细节"><a href="#9-10、适配器模式的注意事项和细节" class="headerlink" title="9.10、适配器模式的注意事项和细节"></a>9.10、适配器模式的注意事项和细节</h3><ol>
<li>三种命名方式，是<strong>根据 src 是以怎样的形式给到 Adapter</strong>（在 Adapter 里的形式）来命名的。</li>
<li>类适配器：以<strong>类</strong>给到，在 Adapter 里，就是将 src 当做<strong>类</strong>，<strong>继承</strong></li>
<li>对象适配器：以<strong>对象</strong>给到，在 Adapter 里，将 src 作为一个<strong>对象</strong>，持有接口适配器：以<strong>接口给到</strong>，在 Adapter 里，将 src 作为一个<strong>接口</strong>，<strong>实现</strong></li>
<li>Adapter 模式最大的作用还是<strong>将原本不兼容的接口融合在一起工作</strong>。</li>
<li>实际开发中，实现起来不拘泥于我们讲解的三种经典形式</li>
</ol>
<h2 id="10、桥接模式Bridge（结构型模式）"><a href="#10、桥接模式Bridge（结构型模式）" class="headerlink" title="10、桥接模式Bridge（结构型模式）"></a>10、桥接模式Bridge（结构型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/80.png" alt="image-20210415032242015"></p>
<h3 id="10-1、基本介绍"><a href="#10-1、基本介绍" class="headerlink" title="10.1、基本介绍"></a>10.1、基本介绍</h3><ol>
<li>桥接模式(Bridge 模式)是指：将<strong>实现与抽象放在两个不同的类层次</strong>中，使<strong>两个层次可以独立改变</strong>。</li>
<li>是一种结构型设计模式</li>
<li>Bridge 模式<strong>基于类的最小设计原则</strong>，通过使用<strong>封装</strong>、<strong>聚合</strong>及<strong>继承</strong>等行为<strong>让不同的类承担不同的职责</strong>。它的主要特点是<strong>把抽象(Abstraction)与行为实现(Implementation)分离开来</strong>，从而可以保持各部分的独立性以及应对他们的功能扩展</li>
<li>它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。</li>
<li>将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</li>
</ol>
<h3 id="10-2、桥接模式原结构图-uml类图"><a href="#10-2、桥接模式原结构图-uml类图" class="headerlink" title="10.2、桥接模式原结构图-uml类图"></a>10.2、桥接模式原结构图-uml类图</h3><p>可以将抽象化部分与实现化部分分开，取消二者的继承关系，改用组合关系。</p>
<h4 id="10-2-1、-模式的结构"><a href="#10-2-1、-模式的结构" class="headerlink" title="10.2.1、 模式的结构"></a>10.2.1、 模式的结构</h4><p>桥接（Bridge）模式包含以下主要角色。</p>
<ol>
<li><strong>抽象化（Abstraction）</strong>角色：定义抽象类，并<strong>包含一个对实现化对象的引用</strong>。</li>
<li><strong>扩展抽象化（Refined Abstraction）</strong>角色：是<strong>抽象化角色的子类</strong>，<strong>实现父类中的业务方法</strong>，并通过<strong>组合关系调用实现化角色中的业务方法</strong>。</li>
<li><strong>实现化（Implementor）</strong>角色：定义<strong>实现化角色的接口</strong>，供<strong>扩展抽象化角色调用</strong>。</li>
<li><strong>具体实现化（Concrete Implementor）</strong>角色：给出<strong>实现化角色接口的具体实现</strong>。</li>
</ol>
<p>相关类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/63.png" alt="image-20210415020129290"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bridge;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Implementor imple = <span class="keyword">new</span> ConcreteImplementorA();</span><br><span class="line">        Abstraction abs = <span class="keyword">new</span> RefinedAbstraction(imple);</span><br><span class="line">        abs.Operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现化角色</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OperationImpl</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体实现化角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementorA</span> <span class="keyword">implements</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OperationImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体实现化(Concrete Implementor)角色被访问&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象化角色</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Implementor imple;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Abstraction</span><span class="params">(Implementor imple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.imple = imple;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩展抽象化角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">RefinedAbstraction</span><span class="params">(Implementor imple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(imple);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;扩展抽象化(Refined Abstraction)角色被访问&quot;</span>);</span><br><span class="line">        imple.OperationImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-3、应用举例"><a href="#10-3、应用举例" class="headerlink" title="10.3、应用举例"></a>10.3、应用举例</h3><p>手机操作问题：</p>
<p>现在对不同手机类型的不同品牌实现操作编程(比如:开机、关机、上网，打电话等)，如图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/64.png" alt="image-20210415020831299"></p>
<h4 id="10-3-1、使用传统方式"><a href="#10-3-1、使用传统方式" class="headerlink" title="10.3.1、使用传统方式"></a>10.3.1、使用传统方式</h4><p>实现类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/65.png" alt="image-20210415021009808"></p>
<p>传统方案解决手机操作问题分析</p>
<ol>
<li>扩展性问题(<strong>类爆炸</strong>)，如果我们再增加手机的样式(旋转式)，就需要增加各个品牌手机的类，同样如果我们增加一个手机品牌，也要在各个手机样式类下增加。</li>
<li><strong>违反了单一职责原则</strong>，当我们增加手机样式时，要同时增加所有品牌的手机，这样<strong>增加了代码维护成本</strong>.</li>
<li>解决方案-使用桥接模式</li>
</ol>
<h4 id="10-3-2、使用桥接模式"><a href="#10-3-2、使用桥接模式" class="headerlink" title="10.3.2、使用桥接模式"></a>10.3.2、使用桥接模式</h4><p>对应的类图</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/66.png" alt="image-20210415021509975"></p>
<p>对于类图的相关解析：</p>
<ol>
<li>在FoldedPhone调用的open()方法其实调用了其父类Phone的open()方法</li>
<li>然而在Phone当中是通过聚合了Brand接口拿到了open()方法</li>
<li>而Vivo类才是真正实现Brank接口open()方法的实现类</li>
<li>所以FoldedPhone调用的open()方法最终是调用了Vivo的open()方法</li>
<li>而Phone在这其中起到了一个桥接的作用</li>
</ol>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/68.png" alt="image-20210415024111311"></p>
<p>代码实现：</p>
<p>Brand：实现化（Implementor）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Brand</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Phone：抽象化（Abstraction）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">	<span class="comment">//组合品牌</span></span><br><span class="line">	<span class="keyword">private</span> Brand brand;</span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Phone</span><span class="params">(Brand brand)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.brand = brand;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.brand.open();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		brand.close();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		brand.call();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FoldedPhone：扩展抽象化（Refined Abstraction）（UpRightPhone类似）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//折叠式手机类，继承 抽象类 Phone</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FoldedPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FoldedPhone</span><span class="params">(Brand brand)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(brand);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.open();</span><br><span class="line">		System.out.println(<span class="string">&quot; 折叠样式手机 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.close();</span><br><span class="line">		System.out.println(<span class="string">&quot; 折叠样式手机 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.call();</span><br><span class="line">		System.out.println(<span class="string">&quot; 折叠样式手机 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Vivo：具体实现化（Concrete Implementor）（XiaoMi类似）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vivo</span> <span class="keyword">implements</span> <span class="title">Brand</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; Vivo手机开机 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; Vivo手机关机 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; Vivo手机打电话 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：调用者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;	</span><br><span class="line">		<span class="comment">//获取折叠式手机 (样式 + 品牌 )</span></span><br><span class="line">		Phone phone1 = <span class="keyword">new</span> FoldedPhone(<span class="keyword">new</span> XiaoMi());</span><br><span class="line">		phone1.open();</span><br><span class="line">		phone1.call();</span><br><span class="line">		phone1.close();</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;=======================&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		Phone phone2 = <span class="keyword">new</span> UpRightPhone(<span class="keyword">new</span> Vivo());</span><br><span class="line">		phone2.open();</span><br><span class="line">		phone2.call();</span><br><span class="line">		phone2.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-4、桥接模式在JDBC的应用与源码分析"><a href="#10-4、桥接模式在JDBC的应用与源码分析" class="headerlink" title="10.4、桥接模式在JDBC的应用与源码分析"></a>10.4、桥接模式在JDBC的应用与源码分析</h3><p>JDBC的 <strong>Driver</strong> 接口，如果从桥接模式来看，Driver 就是一个接口，下面可以有 MySQL 的 Driver，Oracle 的Driver，这些就可以当做实现接口类</p>
<p>代码分析+Debug 源码</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/71.png" alt="image-20210415030654222"></p>
<p>相关类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/72.png" alt="image-20210415031227696"></p>
<h3 id="10-5、桥接模式总结"><a href="#10-5、桥接模式总结" class="headerlink" title="10.5、桥接模式总结"></a>10.5、桥接模式总结</h3><p>桥接模式遵循了<strong>里氏替换原则</strong>和<strong>依赖倒置原则</strong>，<strong>最终实现了开闭原则</strong>，对修改关闭，对扩展开放。这里将桥接模式的优缺点总结如下。</p>
<p>优点：</p>
<ul>
<li>抽象与实现分离，扩展能力强</li>
<li>符合开闭原则</li>
<li>符合合成复用原则</li>
<li>其实现细节对客户透明</li>
</ul>
<p>缺点：</p>
<p>由于聚合关系建立在<strong>抽象层</strong>，要求开发者针对抽象化进行设计与编程，能<strong>正确地识别出系统中两个独立变化的维度</strong>，这增加了系统的理解与设计难度。</p>
<p>桥接模式的应用场景：</p>
<p>当<strong>一个类内部具备两种或多种变化维度</strong>时，使用桥接模式可以<strong>解耦这些变化的维度</strong>，使高层代码架构稳定。</p>
<p>桥接模式通常适用于以下场景：</p>
<ol>
<li>当<strong>一个类存在两个独立变化的维度</strong>，且这<strong>两个维度都需要进行扩展</strong>时。</li>
<li>当一个系统<strong>不希望使用继承</strong>或因为<strong>多层次继承导致系统类的个数急剧增加</strong>时。</li>
<li>当一个系统<strong>需要在构件的抽象化角色</strong>和<strong>具体化角色之间增加更多的灵活性</strong>时。</li>
</ol>
<p>桥接模式的一个常见使用场景就是<strong>替换继承</strong>。我们知道，继承拥有很多优点，比如，抽象、封装、多态等，父类封装共性，子类实现特性。继承可以很好的实现代码复用（封装）的功能，但这也是继承的一大缺点。因为父类拥有的方法，子类也会继承得到，<strong>无论子类需不需要</strong>，这说明<strong>继承具备强侵入性（父类代码侵入子类）</strong>，同时会导致<strong>子类臃肿</strong>。因此，在设计模式中，<strong>有一个原则为优先使用组合/聚合，而不是继承（合成复用原则）</strong>。</p>
<p>在实际系统开发时常见的应用场景：</p>
<ul>
<li><p>JDBC 驱动程序</p>
</li>
<li><p>银行转账系统转账分类: </p>
<p>网上转账，柜台转账，AMT 转账    （抽象层）</p>
<p>转账用户类型：普通用户，银卡用户，金卡用户..    (实现层)</p>
</li>
<li><p>消息管理</p>
<p>消息类型：即时消息，延时消息    （抽象层）</p>
<p>消息分类：手机短信，邮件消息，QQ 消息…    (实现层)</p>
</li>
</ul>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/69.png" alt="image-20210415025038485"></p>
<p>很多时候，我们分不清该使用继承还是组合/聚合或其他方式等，其实可以从现实语义进行思考。因为软件最终还是提供给现实生活中的人使用的，是服务于人类社会的，软件是具备现实场景的。当我们从纯代码角度无法看清问题时，现实角度可能会提供更加开阔的思路。</p>
<h3 id="10-6、桥接模式的扩展"><a href="#10-6、桥接模式的扩展" class="headerlink" title="10.6、桥接模式的扩展"></a>10.6、桥接模式的扩展</h3><p>在软件开发中，有时<strong>桥接（Bridge）模式可与适配器模式联合使用</strong>。当桥接（Bridge）模式的实现化角色的接口与现有类的接口不一致时，可以在二者中间定义一个适配器将二者连接起来，其具体结构图如图所示。</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/70.png" alt="image-20210415025940379"></p>
<h3 id="10-7、进阶阅读"><a href="#10-7、进阶阅读" class="headerlink" title="10.7、进阶阅读"></a>10.7、进阶阅读</h3><p>如果您想深入了解桥接模式，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8458.html">《使用桥接模式设计复杂消息系统》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8460.html">《桥接模式在JDBC源码中的应用》</a></li>
</ul>
<h3 id="10-8、相关设计模式"><a href="#10-8、相关设计模式" class="headerlink" title="10.8、相关设计模式"></a>10.8、相关设计模式</h3><ul>
<li><p>Template Method 模式</p>
<p>在 Template Method 模式中使用了 ＂类的实现层次结构＂。父类调用抽象方法， 而子类实现抽象方法。</p>
</li>
<li><p>Abstract Factory 模式</p>
<p>为了能够根据需求设计出良好的 ConcreteImplementor 角色， 有时我们会使用Abstract Factory 模式。</p>
</li>
<li><p>Adapter 模式</p>
<p>使用 Bridge 模式可以达到类的功能层次结构与类的实现层次结构分离的目的， 并在此基础上使这些层次结构结合起来。</p>
<p>而使用Adapter 模式则可以结合那些功能上相似但是接口 (API) 不同的类。</p>
</li>
</ul>
<h3 id="10-9、桥接模式的注意事项和细节"><a href="#10-9、桥接模式的注意事项和细节" class="headerlink" title="10.9、桥接模式的注意事项和细节"></a>10.9、桥接模式的注意事项和细节</h3><ol>
<li>实现了<strong>抽象和实现部分的分离</strong>，从而极大的<strong>提升了系统的灵活性</strong>，让抽象部分和实现部分独立开来，这有助于<strong>系统进行分层设计</strong>，从而产生更好的<strong>结构化系统</strong>。</li>
<li>对于<strong>系统的高层部分</strong>，只需要知道<strong>抽象部分和实现部分的接口</strong>就可以了，<strong>其它的部分由具体业务</strong>来完成。</li>
<li>桥接模式<strong>替代多层继承方案</strong>，可以减少子类的个数，降低系统的管理和维护成本</li>
<li>桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者**针对抽象进行设计和编程桥接模式要求正确识别出系统中两个独立变化的维度(抽象、和实现)**，因此其使用范围有一定的局限性。</li>
</ol>
<h2 id="11、装饰者模式Decorator（结构型模式）"><a href="#11、装饰者模式Decorator（结构型模式）" class="headerlink" title="11、装饰者模式Decorator（结构型模式）"></a>11、装饰者模式Decorator（结构型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/81.png" alt="image-20210415032321784"></p>
<h3 id="11-1、基本介绍"><a href="#11-1、基本介绍" class="headerlink" title="11.1、基本介绍"></a>11.1、基本介绍</h3><ol>
<li>装饰者模式：在不改变现有对象结构的情况下，<strong>动态的将新功能附加到对象上</strong>。在对象功能扩展方面，它比继承更有弹性，装饰者模式也**体现了开闭原则(ocp)**。</li>
<li>它属于对象结构型模式</li>
</ol>
<h3 id="11-2、装饰者模式原理结构图-uml类图"><a href="#11-2、装饰者模式原理结构图-uml类图" class="headerlink" title="11.2、装饰者模式原理结构图-uml类图"></a>11.2、装饰者模式原理结构图-uml类图</h3><p>通常情况下，扩展一个类的功能会使用继承方式来实现。但<strong>继承具有静态特征，耦合度高</strong>，并且随着扩展功能的增多，<strong>子类会很膨胀（类爆炸）</strong>。如果<strong>使用<code>组合关系</code>来创建一个包装对象（即装饰对象）来包裹真实对象</strong>，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰器模式的目标。装饰者模式就像打包一个快递。</p>
<p>下面来分析其基本结构和实现方法。</p>
<h4 id="11-2-1、模式的结构"><a href="#11-2-1、模式的结构" class="headerlink" title="11.2.1、模式的结构"></a>11.2.1、模式的结构</h4><p>装饰器模式主要包含以下角色：</p>
<ol>
<li><strong>抽象构件（Component）</strong>角色：定义一个<strong>抽象接口以规范准备接收附加责任的对象</strong>。（被装饰者）</li>
<li><strong>具体构件（ConcreteComponent）</strong>角色：<strong>实现抽象构件</strong>，通过装饰角色为其添加一些职责。</li>
<li><strong>抽象装饰（Decorator）</strong>角色：<strong>继承抽象构件</strong>，并<strong>包含具体构件的实例（组合）</strong>，可以通过其子类扩展具体构件的功能。（装饰者）</li>
<li><strong>具体装饰（ConcreteDecorator）</strong>角色：<strong>实现抽象装饰的相关方法</strong>，并<strong>给具体构件对象添加附加的责任</strong>。</li>
<li>（可选）缓冲角色：如果有太多的具体构建角色，可以在<strong>具体构件（ConcreteComponent）</strong>角色与<strong>抽象构件（Component）</strong>角色建立一个缓冲角色。抽取<strong>具体构件（ConcreteComponent）</strong>角色的公共部分，对其进行进一步的抽象。</li>
</ol>
<p>装饰器模式的结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/82.png" alt="image-20210415105021790"></p>
<h4 id="11-2-2、实现代码"><a href="#11-2-2、实现代码" class="headerlink" title="11.2.2、实现代码"></a>11.2.2、实现代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> decorator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Component p = <span class="keyword">new</span> ConcreteComponent();</span><br><span class="line">        p.operation();</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------------------&quot;</span>);</span><br><span class="line">        Component d = <span class="keyword">new</span> ConcreteDecorator(p);</span><br><span class="line">        d.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象构件角色</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体构件角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteComponent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建具体构件角色&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用具体构件角色的方法operation()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象装饰角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Component component;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        component.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体装饰角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorator</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecorator</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.operation();</span><br><span class="line">        addedFunction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addedFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;为具体构件角色增加额外的功能addedFunction()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-3、应用举例"><a href="#11-3、应用举例" class="headerlink" title="11.3、应用举例"></a>11.3、应用举例</h3><p>星巴克咖啡订单项目（咖啡馆）：</p>
<ol>
<li>咖啡种类/单品咖啡：Espresso(意大利浓咖啡)、ShortBlack、LongBlack(美式咖啡)、Decaf(无因咖啡)</li>
<li>调料：Milk、Soy(豆浆)、Chocolate</li>
<li>要求在扩展新的咖啡种类时，具有良好的扩展性、改动方便、维护方便</li>
<li>使用 OO 的来计算不同种类咖啡的费用: 客户可以点单品咖啡，也可以单品咖啡+调料组合。</li>
</ol>
<h4 id="11-3-1、使用方案1（较差）解决需求"><a href="#11-3-1、使用方案1（较差）解决需求" class="headerlink" title="11.3.1、使用方案1（较差）解决需求"></a>11.3.1、使用方案1（较差）解决需求</h4><p>思路分析（类图）：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/83.png" alt="image-20210415110413076"></p>
<p>方案 1-解决星巴克咖啡订单实现与问题分析</p>
<ol>
<li>Drink 是一个抽象类，表示饮料</li>
<li>des 就是对咖啡的描述, 比如咖啡的名字</li>
<li>cost() 方法就是计算费用，Drink 类中做成一个抽象方法.</li>
<li>Decaf 就是单品咖啡， 继承 Drink, 并实现 cost</li>
<li>Espress &amp;&amp; Milk 就是单品咖啡+调料， 这个组合很多</li>
<li>问题：这样设计，<strong>会有很多类</strong>，当我们<strong>增加</strong>一个单品咖啡，或者一个新的调料，<strong>类的数量就会倍增</strong>，就会出现<strong>类爆炸</strong></li>
</ol>
<h4 id="11-3-2、使用方案2（较好）解决需求"><a href="#11-3-2、使用方案2（较好）解决需求" class="headerlink" title="11.3.2、使用方案2（较好）解决需求"></a>11.3.2、使用方案2（较好）解决需求</h4><p>思路分析（类图）：</p>
<p>前面分析到方案 1 因为咖啡单品+调料组合会造成类的倍增，因此可以做改进：</p>
<ol>
<li>将调料内置到 Drink 类，这样就不会造成类数量过多。从而提高项目的维护性</li>
<li>说明: milk,soy,chocolate 可以设计为 Boolean,表示是否要添加相应的调料.</li>
</ol>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/84.png" alt="image-20210415110911652"></p>
<p>方案 2-解决星巴克咖啡订单问题分析</p>
<ol>
<li>方案 2 将调料放在了Drink当中，把它作为<strong>成员变量</strong>。它可以<strong>控制类的数量</strong>，不至于造成很多的类。</li>
<li>在<strong>增加或者删除调料种类</strong>时，代码的维护量很大</li>
<li>考虑到用户可以<strong>添加多份调料</strong>时，可以将hasMilk返回一个对应<strong>int</strong></li>
<li>考虑使用 装饰者 模式</li>
</ol>
<h4 id="11-3-3、使用装饰者模式解决需求"><a href="#11-3-3、使用装饰者模式解决需求" class="headerlink" title="11.3.3、使用装饰者模式解决需求"></a>11.3.3、使用装饰者模式解决需求</h4><p>说明：</p>
<ul>
<li>Drink 类就是前面说的抽象类，Component</li>
<li>ShortBlack 就单品咖啡</li>
<li>Decorator 是一个装饰类，含有一个被装饰的对象(Drink obj)</li>
<li>Decorator 的cost 方法进行一个费用的叠加计算，递归的计算价格</li>
<li>Coffee类就是具体构件（ConcreteComponent）角色与抽象构件（Component）角色之间的缓冲角色，将ShortBlack等等各种咖啡抽象成一个Coffee类</li>
</ul>
<p>类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/85.png" alt="image-20210415111510913"></p>
<p>装饰者模式下的订单：2 份巧克力+一份牛奶的 LongBlack的CoffeeBar(Client)实现思路：</p>
<ul>
<li>Milk包含了LongBlack</li>
<li>一份Chocolate包含了(Milk+LongBlack)</li>
<li>一份Chocolate包含了(Chocolate+Milk+LongBlack)</li>
<li>这样不管是什么形式的单品咖啡+调料组合，通过<strong>递归方式</strong>可以方便的组合和维护。</li>
</ul>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/86.png" alt="image-20210415112049116"></p>
<p>实现代码：</p>
<p>Drink：饮料抽象类。<strong>抽象构件（Component）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> String des; <span class="comment">// 描述</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">float</span> price = <span class="number">0.0f</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> des;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDes</span><span class="params">(String des)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.des = des;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> price;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">float</span> price)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.price = price;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//计算费用的抽象方法</span></span><br><span class="line">	<span class="comment">//子类来实现</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Coffee：咖啡类。（可选）缓冲角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span>  <span class="keyword">extends</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.getPrice();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ShortBlack：具体咖啡对象。<strong>具体构件（ConcreteComponent）</strong>角色（其他具体咖啡类类似）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortBlack</span> <span class="keyword">extends</span> <span class="title">Coffee</span></span>&#123;	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ShortBlack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		setDes(<span class="string">&quot; shortblack &quot;</span>);</span><br><span class="line">		setPrice(<span class="number">4.0f</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Decorator：调料装饰者。<strong>抽象装饰（Decorator）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Drink obj;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Drink obj)</span> </span>&#123; <span class="comment">//组合</span></span><br><span class="line">		<span class="keyword">this</span>.obj = obj;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// getPrice 自己价格</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.getPrice() + obj.cost();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">// super.des/super.getPrice()：输出装饰者的描述信息与价格</span></span><br><span class="line">		<span class="comment">// obj.getDes() 输出被装饰者的信息</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.des + <span class="string">&quot; &quot;</span> + <span class="keyword">super</span>.getPrice() + <span class="string">&quot; &amp;&amp; &quot;</span> + obj.getDes();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Milk：牛奶。<strong>具体装饰（ConcreteDecorator）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Milk</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Milk</span><span class="params">(Drink obj)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(obj);</span><br><span class="line">		setDes(<span class="string">&quot; 牛奶 &quot;</span>);</span><br><span class="line">		setPrice(<span class="number">2.0f</span>); </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CoffeeBar：星巴克。调用2 份巧克力+一份牛奶的 LongBlack</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeBar</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 装饰者模式下的订单：2份巧克力+一份牛奶的LongBlack</span></span><br><span class="line">		<span class="comment">// 1. 点一份 LongBlack</span></span><br><span class="line">		Drink order = <span class="keyword">new</span> LongBlack();</span><br><span class="line">		System.out.println(<span class="string">&quot;费用1=&quot;</span> + order.cost());</span><br><span class="line">		System.out.println(<span class="string">&quot;描述=&quot;</span> + order.getDes());</span><br><span class="line">		<span class="comment">// 2. order 加入一份牛奶</span></span><br><span class="line">		order = <span class="keyword">new</span> Milk(order);</span><br><span class="line">		System.out.println(<span class="string">&quot;order 加入一份牛奶 费用 =&quot;</span> + order.cost());</span><br><span class="line">		System.out.println(<span class="string">&quot;order 加入一份牛奶 描述 = &quot;</span> + order.getDes());</span><br><span class="line">		<span class="comment">// 3. order 加入一份巧克力</span></span><br><span class="line">		order = <span class="keyword">new</span> Chocolate(order);</span><br><span class="line">		System.out.println(<span class="string">&quot;order 加入一份牛奶 加入一份巧克力  费用 =&quot;</span> + order.cost());</span><br><span class="line">		System.out.println(<span class="string">&quot;order 加入一份牛奶 加入一份巧克力 描述 = &quot;</span> + order.getDes());</span><br><span class="line">		<span class="comment">// 4. order 再加入一份巧克力</span></span><br><span class="line">		order = <span class="keyword">new</span> Chocolate(order);</span><br><span class="line">		System.out.println(<span class="string">&quot;order 加入一份牛奶 加入2份巧克力   费用 =&quot;</span> + order.cost());</span><br><span class="line">		System.out.println(<span class="string">&quot;order 加入一份牛奶 加入2份巧克力 描述 = &quot;</span> + order.getDes());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-4、装饰者模式在IO结构的应用与源码"><a href="#11-4、装饰者模式在IO结构的应用与源码" class="headerlink" title="11.4、装饰者模式在IO结构的应用与源码"></a>11.4、装饰者模式在IO结构的应用与源码</h3><p>Java 的 IO 结构，FilterInputStream 就是一个装饰者</p>
<p>相关类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/89.png" alt="image-20210415131821549"></p>
<p>源码：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/90.png" alt="image-20210415132235381"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/91.png" alt="image-20210415132326718"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/92.png" alt="image-20210415132344822"></p>
<p>对源码的解析：</p>
<ol>
<li>InputStream 是抽象类, 类似我们前面讲的 Drink</li>
<li>FileInputStream 是  InputStream 子类，类似我们前面的 DeCaf, LongBlack</li>
<li>FilterInputStream  是  InputStream 子类：类似我们前面 的 Decorator 修饰者</li>
<li>DataInputStream 是 FilterInputStream 子类，具体的修饰者，类似前面的 Milk, Soy 等</li>
<li>FilterInputStream 类 有  protected volatile InputStream in; 即含被装饰者</li>
<li>分析得出在jdk 的io体系中，就是使用装饰者模式</li>
</ol>
<h3 id="11-5、装饰者模式总结"><a href="#11-5、装饰者模式总结" class="headerlink" title="11.5、装饰者模式总结"></a>11.5、装饰者模式总结</h3><p>主要优点有：</p>
<ul>
<li>装饰器是继承的有力补充，比继承灵活，在<strong>不改变原有对象的情况下</strong>，<strong>动态的给一个对象扩展功能</strong>，即插即用</li>
<li>通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果</li>
<li>装饰器模式<strong>完全遵守开闭原则</strong></li>
<li>装饰类和被装饰类可以独立发展，不会相互耦合，<strong>装饰模式是继承的一个替代模式</strong>，装饰模式可以动态扩展一个实现类的功能。</li>
</ul>
<p>主要缺点：</p>
<ul>
<li>装饰器模式会增加许多子类，过度使用会<strong>增加程序得复杂性</strong>。</li>
</ul>
<p>装饰者模式的应用场景：</p>
<ul>
<li>当需要给一个<strong>现有类添加附加职责</strong>，而又<strong>不能采用生成子类的方法</strong>进行扩充时。例如，<strong>该类被隐藏</strong>或者<strong>该类是终极类</strong>或者<strong>采用继承方式会产生大量的子类</strong>。</li>
<li>当需要通过对<strong>现有的一组基本功能进行排列组合而产生非常多的功能</strong>时，采用继承关系很难实现，而采用装饰器模式却很好实现。</li>
<li>当对象的<strong>功能</strong>要求可以<strong>动态地添加</strong>，也可以再<strong>动态地撤销</strong>时。（可插拔）</li>
</ul>
<p>装饰器模式在 Java 语言中的最著名的应用莫过于 <strong>Java I/O 标准库</strong>的设计了。例如，InputStream 的子类 FilterInputStream，OutputStream 的子类 FilterOutputStream，Reader 的子类 BufferedReader 以及 FilterReader，还有 Writer 的子类 BufferedWriter、FilterWriter 以及 PrintWriter 等，它们都是抽象装饰类。</p>
<h3 id="11-6、装饰者模式扩展"><a href="#11-6、装饰者模式扩展" class="headerlink" title="11.6、装饰者模式扩展"></a>11.6、装饰者模式扩展</h3><p>装饰器模式所包含的 4 个角色不是任何时候都要存在的，在有些应用环境下模式是可以简化的，如以下两种情况。</p>
<h4 id="11-6-1、如果只有一个具体构件而没有抽象构件时，可以让抽象装饰继承具体构件"><a href="#11-6-1、如果只有一个具体构件而没有抽象构件时，可以让抽象装饰继承具体构件" class="headerlink" title="11.6.1、如果只有一个具体构件而没有抽象构件时，可以让抽象装饰继承具体构件"></a>11.6.1、如果只有一个具体构件而没有抽象构件时，可以让抽象装饰继承具体构件</h4><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/87.png" alt="image-20210415115027987"></p>
<h4 id="11-6-2、如果只有一个具体装饰时，可以将抽象装饰和具体装饰合并"><a href="#11-6-2、如果只有一个具体装饰时，可以将抽象装饰和具体装饰合并" class="headerlink" title="11.6.2、如果只有一个具体装饰时，可以将抽象装饰和具体装饰合并"></a>11.6.2、如果只有一个具体装饰时，可以将抽象装饰和具体装饰合并</h4><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/88.png" alt="image-20210415115057914"></p>
<h3 id="11-7、进阶阅读"><a href="#11-7、进阶阅读" class="headerlink" title="11.7、进阶阅读"></a>11.7、进阶阅读</h3><p>如果您想深入了解装饰器模式，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8461.html">《使用装饰器模式解决煎饼“加码”问题》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8463.html">《装饰器模式在JDK源码中的应用》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8464.html">《装饰器模式在Spring源码中的应用》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8466.html">《装饰器模式和代理模式的区别》</a></li>
</ul>
<h3 id="11-8、相关设计模式"><a href="#11-8、相关设计模式" class="headerlink" title="11.8、相关设计模式"></a>11.8、相关设计模式</h3><ul>
<li><p>Adapter模式</p>
<p>Decorator 模式可以在不改变被装饰物的接口 (API) 的前提下， 为被装饰物添加边框（透明性）。</p>
<p>Adapter 模式用千适配两个不同的接口 (API)。</p>
</li>
<li><p>Stragety模式</p>
<p>Decorator 模式可以像改变被装饰物的边框或是为被装饰物添加多重边框那样， 来增加类的功能。</p>
<p>Stragety 模式通过整体地替换算法来改变类的功能。</p>
</li>
</ul>
<h3 id="11-9、装饰者模式的注意事项与细节"><a href="#11-9、装饰者模式的注意事项与细节" class="headerlink" title="11.9、装饰者模式的注意事项与细节"></a>11.9、装饰者模式的注意事项与细节</h3><ul>
<li>得益于接口(API)的透明性， Decorator模式中也形成了类似千Composite模式中的递归结构。 </li>
<li>也就是说， 装饰边框里面的 ”被装饰物” 实际上又是别的物体的 ＂装饰边框＂。就像是剥洋葱时以为洋葱心要出来了， 结果却发现还是皮。 </li>
<li>不过， Decorator模式虽然与Composite模式一样， 都具有递归 结构， 但是它们的使用目的不同。 </li>
<li>Decorator模式的主要目的是通过添加装饰物来增加对象的功能。</li>
</ul>
<h2 id="12、组合模式Composite（结构型模式）"><a href="#12、组合模式Composite（结构型模式）" class="headerlink" title="12、组合模式Composite（结构型模式）"></a>12、组合模式Composite（结构型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/93.png" alt="image-20210415133116987"></p>
<h3 id="12-1、基本介绍"><a href="#12-1、基本介绍" class="headerlink" title="12.1、基本介绍"></a>12.1、基本介绍</h3><ol>
<li><p>组合模式（Composite Pattern），又叫<strong>部分整体模式</strong>，它创建了<strong>对象组的树形结构</strong>，将对象组合成树状结构以表示“<strong>整体-部分</strong>”的层次关系。</p>
</li>
<li><p>组合模式依据树形结构来组合对象，用来表示部分以及整体层次。</p>
</li>
<li><p>这种类型的设计模式属于<strong>结构型模式</strong>。</p>
</li>
<li><p>组合模式使得用户对<strong>单个对象和组合对象的访问具有一致性</strong>，即：组合能让客户以一致的方式处理个别对象以及组合对象</p>
</li>
<li><p>组合模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。</p>
</li>
<li><p>组合模式一般用来描述整体与部分的关系，它将对象组织到树形结构中，<strong>顶层的节点被称为根节点</strong>，根节点下面可以包含<strong>树枝节点</strong>和<strong>叶子节点</strong>，<strong>树枝节点</strong>下面<strong>又可以包含树枝节点和叶子节点</strong>，树形结构图如下:</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/94.png" alt="image-20210415201954362"></p>
<p>由上图可以看出，其实<strong>根节点和树枝节点本质上属于同一种数据类型</strong>，可以作为<strong>容器</strong>使用；而<strong>叶子节点与树枝节点在语义上不属于用一种类型</strong>。但是在组合模式中，会把<strong>树枝节点和叶子节点看作属于同一种数据类型</strong>（用统一接口定义），让它们<strong>具备一致行为</strong>。</p>
<p>这样，在组合模式中，整个树形结构中的对象都属于同一种类型，带来的好处就是用户不需要辨别是树枝节点还是叶子节点，可以直接进行操作，给用户的使用带来极大的便利。</p>
</li>
</ol>
<h3 id="12-2、组合模式的原理结构图-uml类图"><a href="#12-2、组合模式的原理结构图-uml类图" class="headerlink" title="12.2、组合模式的原理结构图-uml类图"></a>12.2、组合模式的原理结构图-uml类图</h3><p>组合模式主要包含以下角色：</p>
<ul>
<li><strong>抽象构件（Component）</strong>角色：这是组合中对象声明接口，在适当情况下，实现所有类共有的接口默认行为,用于访问和管理Component 子部件, Component 可以是抽象类或者接口</li>
<li><strong>树叶构件（Leaf）</strong>角色： 在组合中表示叶子节点，叶子节点没有子节点。用于继承或实现抽象构件。</li>
<li><strong>树枝构件（Composite）</strong>角色 / 中间构件：是组合中的分支节点对象，非叶子节点，用于存储子部件。它的主要作用是存储和管理子部件，在Component接口中实现子部件的相关操作，比如增加(add), 删除（remove）。</li>
</ul>
<p>装饰器模式的结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/95.png" alt="image-20210415203743668"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositePattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Component c0 = <span class="keyword">new</span> Composite();</span><br><span class="line">        Component c1 = <span class="keyword">new</span> Composite();</span><br><span class="line">        Component leaf1 = <span class="keyword">new</span> Leaf(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        Component leaf2 = <span class="keyword">new</span> Leaf(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        Component leaf3 = <span class="keyword">new</span> Leaf(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        c0.add(leaf1);</span><br><span class="line">        c0.add(c1);</span><br><span class="line">        c1.add(leaf2);</span><br><span class="line">        c1.add(leaf3);</span><br><span class="line">        c0.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象构件</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树叶构件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Leaf</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;树叶&quot;</span> + name + <span class="string">&quot;：被访问！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树枝构件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composite</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Component&gt; children = <span class="keyword">new</span> ArrayList&lt;Component&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span> </span>&#123;</span><br><span class="line">        children.add(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span> </span>&#123;</span><br><span class="line">        children.remove(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> children.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Object obj : children) &#123;</span><br><span class="line">            ((Component) obj).operation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-3、应用举例"><a href="#12-3、应用举例" class="headerlink" title="12.3、应用举例"></a>12.3、应用举例</h3><p>看一个学校院系展示需求 </p>
<p>编写程序展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院， 一个学院有多个系。如图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/96.png" alt="image-20210415205203158"></p>
<h4 id="12-3-1、传统方案解决需求"><a href="#12-3-1、传统方案解决需求" class="headerlink" title="12.3.1、传统方案解决需求"></a>12.3.1、传统方案解决需求</h4><p>思路解析（类图）</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/97.png" alt="image-20210415205605144"></p>
<p>传统方案解决学校院系展示存在的问题分析</p>
<ol>
<li>将学院看做是学校的子类，系是学院的子类，这样实际上是站在<strong>组织大小</strong>来进行分层次的</li>
<li>实际上我们的要求是 ：在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系， 因此这种方案，<strong>不能很好实现的管理</strong>的操作，比如对学院、系的添加，删除，遍历等</li>
<li>解决方案：把学校、院、系都看做是<strong>组织结构</strong>，<strong>他们之间没有继承</strong>的关系，而是一个树形结构，可以更好的实现管理操作。 =&gt; 组合模式</li>
</ol>
<h4 id="12-3-2、组合模式进阶需求"><a href="#12-3-2、组合模式进阶需求" class="headerlink" title="12.3.2、组合模式进阶需求"></a>12.3.2、组合模式进阶需求</h4><p>思路分析和图解(类图)</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/98.png" alt="image-20210415215204104"></p>
<p>代码实现</p>
<p>OrganizationComponent：组织。<strong>抽象构件（Component）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OrganizationComponent</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name; <span class="comment">// 名字</span></span><br><span class="line">	<span class="keyword">private</span> String des; <span class="comment">// 说明</span></span><br><span class="line">	<span class="comment">// add():增加</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span>  <span class="keyword">void</span> <span class="title">add</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//默认实现</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// remove():删除</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span>  <span class="keyword">void</span> <span class="title">remove</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//默认实现</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//方法print, 做成抽象的, 子类都需要实现</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">OrganizationComponent</span><span class="params">(String name, String des)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.des = des;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> des;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDes</span><span class="params">(String des)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.des = des;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>University：大学，组织的一种，管理学院College。<strong>树枝构件（Composite）</strong>角色 / 中间构件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//University 就是 Composite , 可以管理College</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">University</span> <span class="keyword">extends</span> <span class="title">OrganizationComponent</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 组合抽象构件（Component）角色:OrganizationComponent</span></span><br><span class="line">    <span class="comment">// List 中 存放的College</span></span><br><span class="line">	List&lt;OrganizationComponent&gt; organizationComponents = <span class="keyword">new</span> ArrayList&lt;OrganizationComponent&gt;();</span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">University</span><span class="params">(String name, String des)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name, des);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 重写add</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">		organizationComponents.add(organizationComponent);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 重写remove</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">		organizationComponents.remove(organizationComponent);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.getName();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.getDes();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// print方法，就是输出University 包含的学院</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;--------------&quot;</span> + getName() + <span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">		<span class="comment">//遍历 organizationComponents </span></span><br><span class="line">		<span class="keyword">for</span> (OrganizationComponent organizationComponent : organizationComponents) &#123;</span><br><span class="line">			organizationComponent.print();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>College：学院，组织的一种，被University管理，管理各个专业。<strong>树枝构件（Composite）</strong>角色 / 中间构件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">College</span> <span class="keyword">extends</span> <span class="title">OrganizationComponent</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 组合抽象构件（Component）角色:OrganizationComponent</span></span><br><span class="line">	<span class="comment">// List 中 存放的Department</span></span><br><span class="line">	List&lt;OrganizationComponent&gt; organizationComponents = <span class="keyword">new</span> ArrayList&lt;OrganizationComponent&gt;();</span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">College</span><span class="params">(String name, String des)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name, des);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 重写add</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//  将来实际业务中，Colleage 的 add 和  University add 不一定完全一样</span></span><br><span class="line">		organizationComponents.add(organizationComponent);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 重写remove</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">		organizationComponents.remove(organizationComponent);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.getName();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.getDes();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// print方法，就是输出University 包含的学院</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;--------------&quot;</span> + getName() + <span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">		<span class="comment">//遍历 organizationComponents </span></span><br><span class="line">		<span class="keyword">for</span> (OrganizationComponent organizationComponent : organizationComponents) &#123;</span><br><span class="line">			organizationComponent.print();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Department：专业，组织的一种，被学院College管理，本身是叶子构件，没有管理对象。<strong>树叶构件（Leaf）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> <span class="keyword">extends</span> <span class="title">OrganizationComponent</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 本身是叶子构件，没有管理对象，没有集合</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Department</span><span class="params">(String name, String des)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name, des);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//add , remove 就不用写了，因为他是叶子节点</span></span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.getName();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.getDes();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(getName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：调用方</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;	</span><br><span class="line">		<span class="comment">//从大到小创建对象 学校</span></span><br><span class="line">		OrganizationComponent university = <span class="keyword">new</span> University(<span class="string">&quot;清华大学&quot;</span>, <span class="string">&quot; 中国顶级大学 &quot;</span>);</span><br><span class="line">		<span class="comment">//创建 学院</span></span><br><span class="line">		OrganizationComponent computerCollege = <span class="keyword">new</span> College(<span class="string">&quot;计算机学院&quot;</span>, <span class="string">&quot; 计算机学院 &quot;</span>);</span><br><span class="line">		OrganizationComponent infoEngineercollege = <span class="keyword">new</span> College(<span class="string">&quot;信息工程学院&quot;</span>, <span class="string">&quot; 信息工程学院 &quot;</span>);</span><br><span class="line">		<span class="comment">//创建各个学院下面的系(专业)</span></span><br><span class="line">		computerCollege.add(<span class="keyword">new</span> Department(<span class="string">&quot;软件工程&quot;</span>, <span class="string">&quot; 软件工程不错 &quot;</span>));</span><br><span class="line">		computerCollege.add(<span class="keyword">new</span> Department(<span class="string">&quot;网络工程&quot;</span>, <span class="string">&quot; 网络工程不错 &quot;</span>));</span><br><span class="line">		computerCollege.add(<span class="keyword">new</span> Department(<span class="string">&quot;计算机科学与技术&quot;</span>, <span class="string">&quot; 计算机科学与技术是老牌的专业 &quot;</span>));</span><br><span class="line">		</span><br><span class="line">		infoEngineercollege.add(<span class="keyword">new</span> Department(<span class="string">&quot;通信工程&quot;</span>, <span class="string">&quot; 通信工程不好学 &quot;</span>));</span><br><span class="line">		infoEngineercollege.add(<span class="keyword">new</span> Department(<span class="string">&quot;信息工程&quot;</span>, <span class="string">&quot; 信息工程好学 &quot;</span>));</span><br><span class="line">		<span class="comment">//将学院加入到 学校</span></span><br><span class="line">		university.add(computerCollege);</span><br><span class="line">		university.add(infoEngineercollege);</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//university.print();</span></span><br><span class="line">		infoEngineercollege.print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-4、组合模式在JDK的应用与源码"><a href="#12-4、组合模式在JDK的应用与源码" class="headerlink" title="12.4、组合模式在JDK的应用与源码"></a>12.4、组合模式在JDK的应用与源码</h3><p>Java 的集合类-<strong>HashMap</strong> 就使用了组合模式</p>
<p>代码分析+Debug 源码：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/101.png" alt="image-20210415223718110"></p>
<p>相关类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/107.png" alt="image-20210415225016875"></p>
<p>说明：</p>
<ol>
<li><p>Map 就是一个抽象的构建 (类似我们的Component)</p>
</li>
<li><p>HashMap是一个中间的构建(Composite), 实现/继承了相关方法put, putall等等</p>
</li>
<li><p>Node 是 HashMap的静态内部类，类似Leaf叶子节点, 这里就没有put, putall等方法</p>
<p>static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt;</p>
</li>
</ol>
<p>Map：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/102.png" alt="image-20210415224234562"></p>
<p>AbstractMap：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/103.png" alt="image-20210415224422322"></p>
<p>HashMap：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/104.png" alt="image-20210415224607666"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/105.png" alt="image-20210415224705647"></p>
<p>Node：HashMap的静态内部类</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/106.png" alt="image-20210415224934928"></p>
<h3 id="12-5、组合模式总结"><a href="#12-5、组合模式总结" class="headerlink" title="12.5、组合模式总结"></a>12.5、组合模式总结</h3><p>主要优点有：</p>
<ol>
<li>组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；</li>
<li>更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”；</li>
</ol>
<p>主要缺点是：</p>
<ol>
<li>设计较复杂，客户端需要花更多时间理清类之间的层次关系；</li>
<li>不容易限制容器中的构件；</li>
<li><strong>不容易用继承的方法</strong>来增加构件的新功能；</li>
</ol>
<p>组合模式的应用场景</p>
<ol>
<li>在需要<strong>表示一个对象整体与部分的层次结构</strong>的场合。</li>
<li>要求对用户<strong>隐藏组合对象与单个对象的不同</strong>，用户可以<strong>用统一的接口使用组合结构中的所有对象</strong>的场合。</li>
</ol>
<p><strong>应用实例：</strong> </p>
<ol>
<li><strong>算术表达式</strong>包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作数、操作符和另一个操作数。 </li>
<li>在 <strong>JAVA AWT 和 SWING</strong> 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。</li>
</ol>
<h3 id="12-6、组合模式扩展"><a href="#12-6、组合模式扩展" class="headerlink" title="12.6、组合模式扩展"></a>12.6、组合模式扩展</h3><p>如果对前面介绍的组合模式中的树叶节点和树枝节点进行抽象，也就是说树叶节点和树枝节点还有子节点，这时组合模式就扩展成复杂的组合模式了，如 Java AWT/Swing 中的简单组件 JTextComponent 有子类 JTextField、JTextArea，容器组件 Container 也有子类 Window、Panel。复杂的组合模式的结构图如图所示。</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/99.png" alt="image-20210415221758204"></p>
<h3 id="12-7、进阶阅读"><a href="#12-7、进阶阅读" class="headerlink" title="12.7、进阶阅读"></a>12.7、进阶阅读</h3><p>如果您想深入了解组合模式，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8473.html">《使用透明组合模式实现课程目录结构》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8474.html">《使用安全组合模式实现无限级文件系统》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8475.html">《组合模式在JDK源码中的应用》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8476.html">《组合模式在MyBatis源码中的应用》</a></li>
</ul>
<h3 id="12-8、相关设计模式"><a href="#12-8、相关设计模式" class="headerlink" title="12.8、相关设计模式"></a>12.8、相关设计模式</h3><ul>
<li><p>Command模式</p>
<p>使用Command模式编写宏命令时使用了Composite模式。</p>
</li>
<li><p>Visitor模式</p>
<p>可以使用Visitor模式访问Composite模式中的递归结构。</p>
</li>
<li><p>Decorator 模式</p>
<p>Composite模式通过Component角色使容器(Composite角色）和内容(Leaf角色）具有一致性</p>
<p>Decorator模式使装饰框和内容具有一致性。</p>
</li>
</ul>
<h3 id="12-9、组合模式的注意事项与细节"><a href="#12-9、组合模式的注意事项与细节" class="headerlink" title="12.9、组合模式的注意事项与细节"></a>12.9、组合模式的注意事项与细节</h3><ol>
<li>简化客户端操作。客户端<strong>只需要面对一致的对象而不用考虑整体部分或者节点叶子</strong>的问题。</li>
<li>具有<strong>较强的扩展性</strong>。当我们要更改组合对象时，我们只需要调整内部的层次关系，客户端不用做出任何改动。<strong>满足了OCP原则</strong>。</li>
<li><strong>方便创建出复杂的层次结构</strong>。客户端不用理会组合里面的组成细节，容易添加节点或者叶子从而创建出复杂的树形结构。</li>
<li>需要<strong>遍历组织机构</strong>，或者<strong>处理的对象具有树形结构</strong>时, 非常适合使用组合模式.</li>
<li>要求<strong>较高的抽象性</strong>，如果节点和叶子有<strong>很多差异性</strong>的话，比如<strong>很多方法和属性都不一样</strong>，<strong>不适合</strong>使用组合模式</li>
</ol>
<h2 id="13、外观模式Facade（结构型模式）"><a href="#13、外观模式Facade（结构型模式）" class="headerlink" title="13、外观模式Facade（结构型模式）"></a>13、外观模式Facade（结构型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/108.png" alt="image-20210415225627971"></p>
<h3 id="13-1、基本介绍"><a href="#13-1、基本介绍" class="headerlink" title="13.1、基本介绍"></a>13.1、基本介绍</h3><ol>
<li>外观模式（Facade），也叫<strong>过程模式</strong>、<strong>门面模式</strong>：外观模式为<strong>子系统中的一组接口提供一个一致的界面</strong>，此模式定义了一个<strong>高层接口</strong>，这个接口使得这一子系统更加容易使用</li>
<li>外观模式通过定义一个一致的接口，用以<strong>屏蔽内部子系统的细节</strong>，使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节。这样会大大降低应用程序的复杂度，提高了程序的可维护性。</li>
<li>外观设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。</li>
<li>在日常编码工作中，我们都在有意无意的大量使用外观模式。只要是高层模块需要调度<strong>多个子系统（2个以上的类对象）</strong>，我们都会自觉地创建一个新的类封装这些子系统，提供精简的接口，让高层模块可以更加容易地间接调用这些子系统的功能。尤其是现阶段<strong>各种第三方SDK</strong>、<strong>开源类库</strong>，很大概率都会使用外观模式。</li>
</ol>
<h3 id="13-2、外观模式的原理结构图-uml类图"><a href="#13-2、外观模式的原理结构图-uml类图" class="headerlink" title="13.2、外观模式的原理结构图-uml类图"></a>13.2、外观模式的原理结构图-uml类图</h3><p>外观（Facade）模式的结构比较简单，主要是定义了一个高层接口。它包含了对各个子系统的引用，客户端可以通过它访问各个子系统的功能。现在来分析其基本结构和实现方法。</p>
<h4 id="13-2-1、模式的结构"><a href="#13-2-1、模式的结构" class="headerlink" title="13.2.1、模式的结构"></a>13.2.1、模式的结构</h4><p>外观（Facade）模式包含以下主要角色。</p>
<ol>
<li><strong>外观（Facade）</strong>角色：为多个子系统对外提供一个<strong>统一的接口</strong>。</li>
<li><strong>子系统（Sub System）</strong>角色：<strong>实现系统的部分功能</strong>，客户可以通过外观角色访问它。</li>
<li><strong>客户（Client）</strong>角色：通过一个外观角色访问各个子系统的功能。</li>
</ol>
<p>其结构图类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/109.png" alt="image-20210416002002708"></p>
<h4 id="13-2-2、模式的实现"><a href="#13-2-2、模式的实现" class="headerlink" title="13.2.2、模式的实现"></a>13.2.2、模式的实现</h4><p>外观模式的实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> facade;</span><br><span class="line"><span class="comment">//客户角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FacadePattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Facade f = <span class="keyword">new</span> Facade();</span><br><span class="line">        f.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//外观角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SubSystem01 obj1 = <span class="keyword">new</span> SubSystem01();</span><br><span class="line">    <span class="keyword">private</span> SubSystem02 obj2 = <span class="keyword">new</span> SubSystem02();</span><br><span class="line">    <span class="keyword">private</span> SubSystem03 obj3 = <span class="keyword">new</span> SubSystem03();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obj1.method1();</span><br><span class="line">        obj2.method2();</span><br><span class="line">        obj3.method3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子系统角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubSystem01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子系统01的method1()被调用！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子系统角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubSystem02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子系统02的method2()被调用！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子系统角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubSystem03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子系统03的method3()被调用！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-3、应用举例"><a href="#13-3、应用举例" class="headerlink" title="13.3、应用举例"></a>13.3、应用举例</h3><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/111.png" alt="image-20210416003604096"></p>
<h4 id="13-3-1、使用传统方式解决需求"><a href="#13-3-1、使用传统方式解决需求" class="headerlink" title="13.3.1、使用传统方式解决需求"></a>13.3.1、使用传统方式解决需求</h4><p>思路解析（相关类图）：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/112.png" alt="image-20210416003740197"></p>
<p>传统方式解决影院管理问题分析</p>
<ol>
<li><p>在 ClientTest 的 main 方法中，创建各个子系统的对象，并直接去调用子系统(对象)相关方法，会造成<strong>调用过程混乱</strong>，没有清晰的过程</p>
</li>
<li><p><strong>不利于</strong>在 ClientTest 中，去<strong>维护对子系统的操作</strong></p>
</li>
<li><p>解决思路：<strong>定义一个高层接口</strong>，给子系统中的一组接口提供一个一致的界面(比如在高层接口提供四个方法ready, play, pause, end )，用来访问子系统中的一群接口</p>
</li>
<li><p>也就是说：就是通过定义一个一致的接口(界面类)，用以屏蔽内部子系统的细节（既使子系统之间互相调用），使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节 =&gt; 外观模式</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/113.png" alt="image-20210416004046940"></p>
</li>
</ol>
<h4 id="13-3-2、使用外观模式解决需求"><a href="#13-3-2、使用外观模式解决需求" class="headerlink" title="13.3.2、使用外观模式解决需求"></a>13.3.2、使用外观模式解决需求</h4><p>传统方式解决影院管理说明：</p>
<ol>
<li>外观模式可以理解为<strong>转换一群接口</strong>，客户只要<strong>调用一个接口</strong>，而不用调用多个接口才能达到目的。比如：在 pc 上安装软件的时候经常有一键安装选项（省去选择安装目录、安装的组件等等），还有就是手机的重启功能（把关机和启动合为一个操作）。</li>
<li>外观模式就是<strong>解决多个复杂接口带来的使用困难，起到简化用户操作</strong>的作用</li>
</ol>
<p>思路解析（类图）：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/114.png" alt="image-20210416004253007"></p>
<p>代码实现：</p>
<p>Screen：显示器。<strong>子系统（Sub System）</strong>角色，使用<strong>单例模式</strong>实现子系统角色的创建。（其他子系统角色类似）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Screen</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 构造器私有化, 外部不能new </span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Screen</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">//2.本类内部创建对象实例</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Screen instance = <span class="keyword">new</span> Screen();</span><br><span class="line">	<span class="comment">//3. 提供一个公有的静态方法，返回实例对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Screen <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 显示器相关操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; Screen up &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; Screen down &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HomeTheaterFacade：家庭电影院外观控制器。<strong>外观（Facade）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeTheaterFacade</span> </span>&#123;</span><br><span class="line">	<span class="comment">//定义各个子系统对象</span></span><br><span class="line">	<span class="keyword">private</span> TheaterLight theaterLight;</span><br><span class="line">	<span class="keyword">private</span> Popcorn popcorn;</span><br><span class="line">	<span class="keyword">private</span> Stereo stereo;</span><br><span class="line">	<span class="keyword">private</span> Projector projector;</span><br><span class="line">	<span class="keyword">private</span> Screen screen;</span><br><span class="line">	<span class="keyword">private</span> DVDPlayer dVDPlayer;</span><br><span class="line">	<span class="comment">//构造器（单例模式）</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HomeTheaterFacade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.theaterLight = TheaterLight.getInstance();</span><br><span class="line">		<span class="keyword">this</span>.popcorn = Popcorn.getInstance();</span><br><span class="line">		<span class="keyword">this</span>.stereo = Stereo.getInstance();</span><br><span class="line">		<span class="keyword">this</span>.projector = Projector.getInstance();</span><br><span class="line">		<span class="keyword">this</span>.screen = Screen.getInstance();</span><br><span class="line">		<span class="keyword">this</span>.dVDPlayer = DVDPlayer.getInstanc();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//操作分成 4 步</span></span><br><span class="line">	<span class="comment">// 开始</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		popcorn.on();</span><br><span class="line">		popcorn.pop();</span><br><span class="line">		screen.down();</span><br><span class="line">		projector.on();</span><br><span class="line">		stereo.on();</span><br><span class="line">		dVDPlayer.on();</span><br><span class="line">		theaterLight.dim();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 播放</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		dVDPlayer.play();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 暂停</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		dVDPlayer.pause();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 结束</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		popcorn.off();</span><br><span class="line">		theaterLight.bright();</span><br><span class="line">		screen.up();</span><br><span class="line">		projector.off();</span><br><span class="line">		stereo.off();</span><br><span class="line">		dVDPlayer.off();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：客户端。<strong>客户（Client）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		HomeTheaterFacade homeTheaterFacade = <span class="keyword">new</span> HomeTheaterFacade();</span><br><span class="line">         <span class="comment">// 开始</span></span><br><span class="line">		homeTheaterFacade.ready();</span><br><span class="line">         <span class="comment">// 播放</span></span><br><span class="line">		homeTheaterFacade.play();</span><br><span class="line">         <span class="comment">// 暂停</span></span><br><span class="line">         homeTheaterFacade.pause();</span><br><span class="line">         <span class="comment">// 结束</span></span><br><span class="line">		homeTheaterFacade.end();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-4、外观模式在Mybatis的应用与源码"><a href="#13-4、外观模式在Mybatis的应用与源码" class="headerlink" title="13.4、外观模式在Mybatis的应用与源码"></a>13.4、外观模式在Mybatis的应用与源码</h3><p><strong>MyBatis</strong> 中的 <strong>Configuration</strong> 去创建 <strong>MetaObject</strong>  对象使用到外观模式</p>
<p>代码分析+Debug 源码+示意图</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/115.png" alt="image-20210416005522209"></p>
<p>对源码中使用到的外观模式的角色类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/121.png" alt="image-20210416010838982"></p>
<p>Mybatis的Configuration：(Facade外观)</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/116.png" alt="image-20210416005648774"></p>
<p>Configuration中组合的三个工厂对象：（子系统Sub System）</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/117.png" alt="image-20210416010052394"></p>
<p>Configuration中的newMetaObject()方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/118.png" alt="image-20210416010317177"></p>
<p>MetaObject：Client借助Mybatis的Configuration生成的对象</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/119.png" alt="image-20210416010527422"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/120.png" alt="image-20210416010710795"></p>
<h3 id="13-5、外观模式总结"><a href="#13-5、外观模式总结" class="headerlink" title="13.5、外观模式总结"></a>13.5、外观模式总结</h3><p>外观（Facade）模式是“迪米特法则”的典型应用</p>
<p>主要优点：</p>
<ol>
<li><strong>降低了子系统与客户端之间的耦合度</strong>，使得子系统的变化不会影响调用它的客户类。</li>
<li>对客户<strong>屏蔽了子系统组件</strong>，减少了客户处理的对象数目，并使得<strong>子系统使用起来更加容易</strong>。</li>
<li><strong>降低了大型软件系统中的编译依赖性</strong>，<strong>简化了系统在不同平台之间的移植过程</strong>，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。</li>
</ol>
<p>主要缺点：</p>
<ol>
<li><strong>不能很好地限制客户使用子系统类</strong>，很容易带来未知风险。</li>
<li>增加新的子系统可能需要<strong>修改外观类或客户端的源代码</strong>，<strong>违背了“开闭原则”</strong>，继承重写都不合适。</li>
</ol>
<p>外观模式的应用场景：</p>
<ol>
<li>对<strong>分层结构系统构建</strong>时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。</li>
<li>当<strong>一个复杂系统的子系统很多</strong>时，外观模式可以为系统设计一个简单的接口供外界访问。</li>
<li>当<strong>客户端与多个子系统</strong>之间存在很大的联系时，引入外观模式可将它们<strong>分离</strong>，从而<strong>提高子系统的独立性和可移植性。</strong></li>
</ol>
<p>外观模式应用实例：</p>
<ol>
<li>去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供<strong>接待人员</strong>，只让接待人员来处理，就很方便</li>
<li><strong>JAVA 的三层开发模式：Controller、Service、Dao</strong></li>
<li>很多Web程序，内部有多个子系统提供服务，经常使用一个统一的Facade入口，例如一个<code>RestApiController</code>，使得外部用户调用的时候，只关心Facade提供的接口，不用管内部到底是哪个子系统处理的。</li>
<li>更复杂的Web程序，会有多个Web服务，这个时候，经常会使用一个<strong>统一的网关入口</strong>来自动转发到不同的Web服务，这种提供统一入口的网关就是Gateway，它本质上也是一个Facade，但可以附加一些用户认证、限流限速的额外服务。</li>
</ol>
<h3 id="13-6、外观模式扩展"><a href="#13-6、外观模式扩展" class="headerlink" title="13.6、外观模式扩展"></a>13.6、外观模式扩展</h3><p>在外观模式中，当增加或移除子系统时需要修改外观类，这违背了“开闭原则”。如果<strong>引入抽象外观类</strong>，则在一定程度上解决了该问题，其结构图如图所示：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/110.png" alt="image-20210416002803095"></p>
<h3 id="13-7、进阶阅读"><a href="#13-7、进阶阅读" class="headerlink" title="13.7、进阶阅读"></a>13.7、进阶阅读</h3><p>如果您想了解外观模式的实际应用，可猛击阅读<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8467.html">《使用外观模式整合调用已知API》</a>一节。</p>
<h3 id="13-8、相关设计模式"><a href="#13-8、相关设计模式" class="headerlink" title="13.8、相关设计模式"></a>13.8、相关设计模式</h3><ul>
<li><p>Abstract Factory 模式</p>
<p>可以将AbstractFactory模式看作生成复杂实例时的Facade模式。 因为它提供了 “要想生成这个实例只需要调用这个方法就OK了＂ 的简单接口。</p>
</li>
<li><p>Singleton 模式</p>
<p>有时会使用Singleton模式创建Facade角色。</p>
</li>
<li><p>Mediator 模式</p>
<p>在Facade模式中，Facade角色单方面地使用其他角色来提供高层接口(API)。</p>
<p>而在Mediator模式中，Mediator角色作为Colleague角色间的仲裁者负责调停。 可以说， <strong>Facade模式是单向的， 而Mediator角色是双向的。</strong></p>
</li>
</ul>
<h3 id="13-9、外观模式的注意事项与细节"><a href="#13-9、外观模式的注意事项与细节" class="headerlink" title="13.9、外观模式的注意事项与细节"></a>13.9、外观模式的注意事项与细节</h3><ol>
<li>外观模式<strong>对外屏蔽了子系统的细节</strong>，因此外观模式降低了客户端对子系统使用的复杂性</li>
<li>外观模式对<strong>客户端与子系统的耦合关系 - 解耦</strong>，让子系统内部的模块更易维护和扩展</li>
<li>通过合理的使用外观模式，可以帮我们<strong>更好的划分访问的层次</strong></li>
<li>当系统需要进行<strong>分层设计</strong>时，可以考虑使用 Facade 模式</li>
<li>在<strong>维护一个遗留的大型系统</strong>时，可能这个系统已经变得<strong>非常难以维护和扩展</strong>，此时可以考虑为新系统开发一个Facade 类，来<strong>提供遗留系统的比较清晰简单的接口，让新系统与 Facade 类交互，提高复用性</strong></li>
<li>不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好。要以<strong>让系统有层次</strong>，<strong>利于维护</strong>为目的。</li>
</ol>
<h2 id="14、享元模式Flyweight（结构型模式）"><a href="#14、享元模式Flyweight（结构型模式）" class="headerlink" title="14、享元模式Flyweight（结构型模式）"></a>14、享元模式Flyweight（结构型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/122.png" alt="image-20210416011234518"></p>
<h3 id="14-1、基本介绍"><a href="#14-1、基本介绍" class="headerlink" title="14.1、基本介绍"></a>14.1、基本介绍</h3><ol>
<li><p>享元模式（Flyweight Pattern） 也叫 <strong>蝇量模式</strong>: 运用<strong>共享技术有效地支持大量细粒度的对象</strong>。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。</p>
</li>
<li><p>享元模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式</p>
</li>
<li><p>常用于<strong>系统底层开发</strong>，解决<strong>系统的性能</strong>问题。像<strong>数据库连接池</strong>，里面都是创建好的连接对象，在这些连接对象中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个。</p>
</li>
<li><p>享元模式能够解决<strong>重复对象的内存浪费</strong>的问题，当系统中有大量相似对象，需要缓冲池时。不需总是创建新对象，可以从缓冲池里拿。这样可以<strong>降低系统内存，同时提高效率</strong></p>
</li>
<li><p>享元模式的核心思想：如果<strong>一个对象实例一经创建就不可变</strong>，那么反复创建相同的实例就没有必要，直接向<strong>调用方返回一个共享的实例</strong>就行，这样即<strong>节省内存</strong>，又可以<strong>减少创建对象的过程</strong>，<strong>提高运行速度</strong>。（注意区别单例模式）</p>
<p>一言蔽之：<strong>通过尽量共享实例来避免new出实例</strong>。</p>
</li>
<li><p>享元模式经典的应用场景就是<strong>池技术</strong>了，<strong>String 常量池</strong>、<strong>数据库连接池</strong>、<strong>缓冲池</strong>等等都是享元模式的应用，享元模式是池技术的重要实现方式</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/123.png" alt="image-20210416020802732"></p>
</li>
</ol>
<h3 id="14-2、享元模式的原理结构图-uml类图"><a href="#14-2、享元模式的原理结构图-uml类图" class="headerlink" title="14.2、享元模式的原理结构图-uml类图"></a>14.2、享元模式的原理结构图-uml类图</h3><h4 id="14-2-1、内部状态与外部状态"><a href="#14-2-1、内部状态与外部状态" class="headerlink" title="14.2.1、内部状态与外部状态"></a>14.2.1、内部状态与外部状态</h4><p>享元模式的定义提出了两个要求，<strong>细粒度</strong>和<strong>共享对象</strong>。因为要求细粒度，所以不可避免地会<strong>使对象数量多且性质相近</strong>，此时我们就将这些对象的信息分为两个部分：内部状态和外部状态。</p>
<ul>
<li>内部状态指<strong>对象共享出来的信息</strong>，存储在<strong>享元信息内部</strong>，并且<strong>不会随环境的改变而改变</strong>；</li>
<li>外部状态指<strong>对象得以依赖的一个标记</strong>，<strong>随环境的改变而改变，不可共享</strong>。</li>
</ul>
<p>比如围棋、五子棋、跳棋，它们都有大量的棋子对象，围棋和五子棋只有黑白两色，跳棋颜色多一点，所以<strong>棋子颜色</strong>就是棋子的<strong>内部状态</strong>；而各个棋子之间的差别就是<strong>位置的不同</strong>，当我们落子后，落子颜色是定的，但位置是变化的，所以<strong>棋子坐标</strong>就是棋子的<strong>外部状态</strong>。</p>
<p>又比如，<strong>连接池中的连接对象</strong>，保存在连接对象中的<strong>用户名</strong>、<strong>密码</strong>、<strong>连接URL等信息</strong>，在创建对象的时候就设置好了，<strong>不会随环境的改变而改变</strong>，这些为<strong>内部状态</strong>。而当<strong>每个连接要被回收利用</strong>时，我们需要<strong>将它标记为可用状态</strong>，这些为<strong>外部状态</strong>。</p>
<p>享元模式的本质是缓存共享对象，降低内存消耗。</p>
<p>举个例子：围棋理论上有 361 个空位可以放棋子，每盘棋都有可能有两三百个棋子对象产生，因为内存空间有限，一台服务器很难支持更多的玩家玩围棋游戏，如果用享元模式来处理棋子，那么棋子对象就可以减少到只有两个实例，这样就很好的解决了对象的开销问题</p>
<h4 id="14-2-2、模式的结构"><a href="#14-2-2、模式的结构" class="headerlink" title="14.2.2、模式的结构"></a>14.2.2、模式的结构</h4><p>享元模式的主要角色有如下。</p>
<ol>
<li><strong>抽象享元角色（Flyweight）</strong>（轻量级）：是所有的<strong>具体享元类的基类</strong>，为具体享元规范需要实现的<strong>公共接口</strong>，<strong>非享元的外部状态</strong>以<strong>参数</strong>的形式<strong>通过方法传入</strong>。</li>
<li><strong>具体享元（Concrete Flyweight）角色</strong>：<strong>实现抽象享元角色</strong>中所规定的<strong>接口</strong>。</li>
<li><strong>非享元（Unsharable Flyweight)角色</strong>：是<strong>不可以共享的外部状态</strong>，它<strong>以参数的形式注入具体享元的相关方法</strong>中。一般<strong>不会出现在享元工厂</strong>。</li>
<li><strong>享元工厂（Flyweight Factory）角色</strong>（轻量级）：负责<strong>创建和管理享元角色</strong>。用于构建一个池容器(集合)， 同时提供从池中获取对象方法（池技术）。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。</li>
</ol>
<p>享元模式的结构图，其中：</p>
<ul>
<li>UnsharedConcreteFlyweight 是非享元角色，里面包含了非共享的外部状态信息 info；</li>
<li>Flyweight 是抽象享元角色，里面包含了享元方法 operation(UnsharedConcreteFlyweight state)，非享元的外部状态以参数的形式通过该方法传入；</li>
<li>ConcreteFlyweight 是具体享元角色，包含了关键字 key，它实现了抽象享元接口；</li>
<li>FlyweightFactory 是享元工厂角色，它是关键字 key 来管理具体享元；</li>
<li>客户角色通过享元工厂获取具体享元，并访问具体享元的相关方法。</li>
</ul>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/124.png" alt="image-20210416021500116"></p>
<h4 id="14-2-3、代码实现"><a href="#14-2-3、代码实现" class="headerlink" title="14.2.3、代码实现"></a>14.2.3、代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyweightPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FlyweightFactory factory = <span class="keyword">new</span> FlyweightFactory();</span><br><span class="line">        Flyweight f01 = factory.getFlyweight(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        Flyweight f02 = factory.getFlyweight(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        Flyweight f03 = factory.getFlyweight(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        Flyweight f11 = factory.getFlyweight(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        Flyweight f12 = factory.getFlyweight(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        f01.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">&quot;第1次调用a。&quot;</span>));</span><br><span class="line">        f02.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">&quot;第2次调用a。&quot;</span>));</span><br><span class="line">        f03.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">&quot;第3次调用a。&quot;</span>));</span><br><span class="line">        f11.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">&quot;第1次调用b。&quot;</span>));</span><br><span class="line">        f12.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">&quot;第2次调用b。&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非享元角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsharedConcreteFlyweight</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String info;</span><br><span class="line">    UnsharedConcreteFlyweight(String info) &#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInfo</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象享元角色</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyweight</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(UnsharedConcreteFlyweight state)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体享元角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFlyweight</span> <span class="keyword">implements</span> <span class="title">Flyweight</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    ConcreteFlyweight(String key) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体享元&quot;</span> + key + <span class="string">&quot;被创建！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(UnsharedConcreteFlyweight outState)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;具体享元&quot;</span> + key + <span class="string">&quot;被调用，&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;非享元信息是:&quot;</span> + outState.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//享元工厂角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用HashMap作池</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Flyweight&gt; flyweights = <span class="keyword">new</span> HashMap&lt;String, Flyweight&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flyweight <span class="title">getFlyweight</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Flyweight flyweight = (Flyweight) flyweights.get(key);</span><br><span class="line">        <span class="keyword">if</span> (flyweight != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体享元&quot;</span> + key + <span class="string">&quot;已经存在，被成功获取！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            flyweight = <span class="keyword">new</span> ConcreteFlyweight(key);</span><br><span class="line">            flyweights.put(key, flyweight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flyweight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14-3、应用举例"><a href="#14-3、应用举例" class="headerlink" title="14.3、应用举例"></a>14.3、应用举例</h3><p>展示网站项目需求：</p>
<p>小型的外包项目，给客户 A 做一个产品展示网站，客户 A 的朋友感觉效果不错，也希望做这样的产品展示网站，但是要求都有些不同：</p>
<ul>
<li>有客户要求以新闻的形式发布</li>
<li>有客户人要求以博客的形式发布</li>
<li>有客户希望以微信公众号的形式发布</li>
</ul>
<h4 id="14-3-1、使用传统方式解决需求"><a href="#14-3-1、使用传统方式解决需求" class="headerlink" title="14.3.1、使用传统方式解决需求"></a>14.3.1、使用传统方式解决需求</h4><ol>
<li>直接复制粘贴一份，然后根据客户不同要求，进行定制修改</li>
<li>给每个网站租用一个空间</li>
</ol>
<p>思路分析（类图）：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/127.png" alt="image-20210416024816721"></p>
<p>传统方案解决网站展现项目问题分析：</p>
<ol>
<li>需要的网站结构相似度很高，而且都不是高访问量网站，如果分成多个虚拟空间来处理，相当于一个相同网站的实例对象很多，<strong>造成服务器的资源浪费</strong></li>
<li>解决思路：整合到一个网站中，共享其相关的代码和数据，对于硬盘、内存、CPU、数据库空间等服务器资源都可以达成共享，减少服务器资源</li>
<li>对于代码来说，由于是一份实例，维护和扩展都更加容易</li>
<li>上面的解决思路就可以使用享元模式来解决</li>
</ol>
<h4 id="14-3-2、使用享元模式解决需求"><a href="#14-3-2、使用享元模式解决需求" class="headerlink" title="14.3.2、使用享元模式解决需求"></a>14.3.2、使用享元模式解决需求</h4><p>思路分析和图解(类图)：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/128.png" alt="image-20210416025317394"></p>
<p>代码实现：</p>
<p>WebSite：网站，当中的use方法传入外部状态User。<strong>抽象享元角色（Flyweight）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSite</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">(User user)</span></span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConcreteWebSite：具体网站，继承WebSite，包含有内部状态type。<strong>具体享元（Concrete Flyweight）角色</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体网站</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteWebSite</span> <span class="keyword">extends</span> <span class="title">WebSite</span> </span>&#123;</span><br><span class="line">	<span class="comment">//共享的部分，内部状态</span></span><br><span class="line">	<span class="keyword">private</span> String type = <span class="string">&quot;&quot;</span>; <span class="comment">//网站发布的形式(类型)</span></span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ConcreteWebSite</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.type = type;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;网站的发布形式为:&quot;</span> + type + <span class="string">&quot; 在使用中 .. 使用者是&quot;</span> + user.getName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>User：用户，不同的用户的构建网站的类型不同，属于外部状态，通过方法参数传入。<strong>非享元（Unsharable Flyweight)角色</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WebSiteFactory：网站工厂类，根据需要返回一个网站。<strong>享元工厂（Flyweight Factory）角色</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 网站工厂类，根据需要返回一个网站</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSiteFactory</span> </span>&#123;</span><br><span class="line">	<span class="comment">//集合， 充当池的作用</span></span><br><span class="line">	<span class="keyword">private</span> HashMap&lt;String, ConcreteWebSite&gt; pool = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	<span class="comment">//根据网站的类型，返回一个网站, 如果没有就创建一个网站，并放入到池中,并返回</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> WebSite <span class="title">getWebSiteCategory</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!pool.containsKey(type)) &#123;</span><br><span class="line">			<span class="comment">//就创建一个网站，并放入到池中</span></span><br><span class="line">			pool.put(type, <span class="keyword">new</span> ConcreteWebSite(type));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> (WebSite)pool.get(type);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取网站分类的总数 (池中有多少个网站类型)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWebSiteCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> pool.size();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：客户端调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建一个工厂类</span></span><br><span class="line">		WebSiteFactory factory = <span class="keyword">new</span> WebSiteFactory();</span><br><span class="line">		<span class="comment">// 客户tom要一个以新闻形式发布的网站</span></span><br><span class="line">		WebSite webSite1 = factory.getWebSiteCategory(<span class="string">&quot;新闻&quot;</span>);</span><br><span class="line">		webSite1.use(<span class="keyword">new</span> User(<span class="string">&quot;tom&quot;</span>));</span><br><span class="line">		<span class="comment">// 客户jack要一个以博客形式发布的网站</span></span><br><span class="line">		WebSite webSite2 = factory.getWebSiteCategory(<span class="string">&quot;博客&quot;</span>);</span><br><span class="line">		webSite2.use(<span class="keyword">new</span> User(<span class="string">&quot;jack&quot;</span>));</span><br><span class="line">		<span class="comment">// 客户smith要一个以博客形式发布的网站</span></span><br><span class="line">		WebSite webSite3 = factory.getWebSiteCategory(<span class="string">&quot;博客&quot;</span>);</span><br><span class="line">		webSite3.use(<span class="keyword">new</span> User(<span class="string">&quot;smith&quot;</span>));</span><br><span class="line">		<span class="comment">// 客户king要一个以博客形式发布的网站</span></span><br><span class="line">		WebSite webSite4 = factory.getWebSiteCategory(<span class="string">&quot;博客&quot;</span>);</span><br><span class="line">		webSite4.use(<span class="keyword">new</span> User(<span class="string">&quot;king&quot;</span>));</span><br><span class="line">         <span class="comment">// 网站的分类共=2</span></span><br><span class="line">		System.out.println(<span class="string">&quot;网站的分类共=&quot;</span> + factory.getWebSiteCount());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14-4、享元模式在JDK-Integer的应用与源码"><a href="#14-4、享元模式在JDK-Integer的应用与源码" class="headerlink" title="14.4、享元模式在JDK-Integer的应用与源码"></a>14.4、享元模式在JDK-Integer的应用与源码</h3><p>Integer 中的享元模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyWeight</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Integer x = Integer.valueOf(<span class="number">127</span>); <span class="comment">// 得到 x实例，类型 Integer</span></span><br><span class="line">		Integer y = <span class="keyword">new</span> Integer(<span class="number">127</span>); <span class="comment">// 得到 y 实例，类型 Integer</span></span><br><span class="line">		Integer z = Integer.valueOf(<span class="number">127</span>);<span class="comment">//..</span></span><br><span class="line">		Integer w = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">	</span><br><span class="line">		System.out.println(x.equals(y)); <span class="comment">// 大小，true</span></span><br><span class="line">		System.out.println(x == y ); <span class="comment">//  false</span></span><br><span class="line">		System.out.println(x == z ); <span class="comment">// true</span></span><br><span class="line">		System.out.println(w == x ); <span class="comment">// false</span></span><br><span class="line">		System.out.println(w == y ); <span class="comment">// false</span></span><br><span class="line">	</span><br><span class="line">		Integer x1 = Integer.valueOf(<span class="number">200</span>);</span><br><span class="line">		Integer x2 = Integer.valueOf(<span class="number">200</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;x1==x2&quot;</span> + (x1 == x2)); <span class="comment">// false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<ul>
<li>如果 Integer.valueOf(x)的参数 x 在  -128 — 127 之间，就是使用享元模式返回,如果不在范围内，则仍然 new 一个Integer对象</li>
<li>在valueOf 方法中，先判断值是否在 IntegerCache 中，如果不在，就创建新的Integer(new)；否则，就直接从缓存池返回</li>
<li>valueOf 方法，就使用到享元模式</li>
<li>如果使用valueOf 方法得到一个Integer 实例，<strong>范围在 -128 - 127 ，执行速度比 new 快</strong></li>
</ul>
<p>为什么使用Integer.valueOf(x)并且其参数 x 的范围在  -128 — 127 之间就是同一个对象，看源码：</p>
<p>Debug 源码+说明：</p>
<p>Integer：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/129.png" alt="image-20210416031357474"></p>
<p>Integer当中的IntegerCache：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/130.png" alt="image-20210416031820357"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/131.png" alt="image-20210416032125850"></p>
<h3 id="14-5、享元模式总结"><a href="#14-5、享元模式总结" class="headerlink" title="14.5、享元模式总结"></a>14.5、享元模式总结</h3><p>主要优点是</p>
<ul>
<li><strong>相同对象只要保存一份</strong>，这<strong>降低了系统中对象的数量</strong>，从而<strong>降低了系统中细粒度对象给内存带来的压力</strong>。</li>
</ul>
<p>主要缺点是：</p>
<ul>
<li>为了使对象可以共享，需要<strong>将一些不能共享的状态外部化</strong>，这将<strong>增加程序的复杂性</strong>。</li>
<li>享元模式<strong>提高了系统的复杂度</strong>。需要<strong>分离出内部状态和外部状态</strong>，而<strong>外部状态具有固有化的性质，不应该随着内部状态的变化而变化</strong>，否则会造成系统的混乱。这是我们使用享元模式需要注意的地方。</li>
<li><strong>读取享元模式的外部状态会使得运行时间稍微变长</strong>。</li>
</ul>
<p>享元模式的应用场景：</p>
<p>当系统中<strong>多处需要同一组信息</strong>时，可以<strong>把这些信息封装到一个对象</strong>中，然后<strong>对该对象进行缓存</strong>，这样，一个对象就可以提供给多出需要使用的地方，<strong>避免大量同一对象的多次创建</strong>，<strong>降低大量内存空间的消耗</strong>。</p>
<p>享元模式其实是<strong>工厂方法模式的一个改进机制</strong>，<strong>享元模式同样要求创建一个或一组对象</strong>，并且<strong>就是通过工厂方法模式生成对象</strong>的，只不过享元模式为工厂方法模式<strong>增加了缓存</strong>这一功能。</p>
<p>享元模式是<strong>通过减少内存中对象的数量来节省内存空间</strong>的，所以以下几种情形适合采用享元模式。</p>
<ol>
<li>系统中<strong>存在大量相同或相似的对象</strong>，这些对象耗费大量的内存资源。</li>
<li>大部分的对象<strong>可以按照内部状态进行分组，且可将不同部分外部化</strong>，这样<strong>每一个组只需保存一个内部状态</strong>。</li>
<li>由于享元模式需要<strong>额外维护一个保存享元的数据结构（多为HashMap\HashTable）</strong>，所以应当在<strong>有足够多的享元实例</strong>时才值得使用享元模式。</li>
</ol>
<h3 id="14-6、享元模式扩展"><a href="#14-6、享元模式扩展" class="headerlink" title="14.6、享元模式扩展"></a>14.6、享元模式扩展</h3><p>在前面介绍的享元模式中，其结构图通常包含<strong>可以共享的部分</strong>和<strong>不可以共享的部分</strong>。在实际使用过程中，有时候会稍加改变，即存在两种特殊的享元模式：<strong>单纯享元模式</strong>和<strong>复合享元模式</strong></p>
<h4 id="14-6-1、单纯享元模式"><a href="#14-6-1、单纯享元模式" class="headerlink" title="14.6.1、单纯享元模式"></a>14.6.1、单纯享元模式</h4><p>这种享元模式中的所有的具体享元类都是可以共享的，不存在非共享的具体享元类。如类图所示：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/125.png" alt="image-20210416024136156"></p>
<h4 id="14-6-2、复合享元模式"><a href="#14-6-2、复合享元模式" class="headerlink" title="14.6.2、复合享元模式"></a>14.6.2、复合享元模式</h4><p>这种享元模式中的有些享元对象是<strong>由一些单纯享元对象组合而成的</strong>，它们就是<strong>复合享元对象</strong>。虽然复合享元对象<strong>本身不能共享</strong>，但它们<strong>可以分解成单纯享元对象再被共享</strong>。如类图所示：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/126.png" alt="image-20210416024246399"></p>
<h3 id="14-7、进阶阅读"><a href="#14-7、进阶阅读" class="headerlink" title="14.7、进阶阅读"></a>14.7、进阶阅读</h3><p>如果您想深入了解享元模式，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8468.html">《使用享元模式实现资源共享池》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8469.html">《使用享元模式实现数据库连接池》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8471.html">《String中的享元模式》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8472.html">《Integer中的享元模式》</a></li>
</ul>
<h3 id="14-8、相关设计模式"><a href="#14-8、相关设计模式" class="headerlink" title="14.8、相关设计模式"></a>14.8、相关设计模式</h3><ul>
<li><p>Proxy 模式</p>
<p>如果生成实例的处理需要花费较长时间， 那么使用 Flyweight 模式可以提高程序的处理速度。</p>
<p>而 Proxy 模式则是通过设置代理提高程序的处理速度。</p>
</li>
<li><p>Composite 模式</p>
<p>有时可以使用 Flyweight 模式共享 Composite 模式中的 Leaf 角色。</p>
</li>
<li><p>Singleton 模式</p>
<p>在 FlyweightFactory 角色中有时会使用 Singleton 模式。</p>
<p>此外如果使用了 Singleton 模式，由于只会生成一个 Singleton 角色，因此所有使用该实例的地方都共享同一个实例。 在 Singleton 角色的实例中只持有内部（固有）信息。</p>
</li>
</ul>
<h3 id="14-9、享元模式的注意事项与细节"><a href="#14-9、享元模式的注意事项与细节" class="headerlink" title="14.9、享元模式的注意事项与细节"></a>14.9、享元模式的注意事项与细节</h3><ol>
<li>在享元模式这样理解，<strong>“享”就表示共享</strong>，<strong>“元”表示对象</strong></li>
<li>系统中有大量对象，这些对象消耗大量内存，并且<strong>对象的状态大部分可以外部化</strong>时，我们就可以考虑选用享元模式</li>
<li>用<strong>唯一标识码</strong>判断，如果在内存中有，则<strong>返回这个唯一标识码所标识的对象</strong>，用 <strong>HashMap/HashTable</strong> 存储</li>
<li>享元模式大大<strong>减少了对象的创建</strong>，<strong>降低了程序内存的占用</strong>，<strong>提高效率</strong></li>
<li>享元模式<strong>提高了系统的复杂度</strong>。需要<strong>分离出内部状态和外部状态</strong>，而<strong>外部状态具有固有化的性质，不应该随着内部状态的变化而变化</strong>，否则会造成系统的混乱。这是我们使用享元模式需要注意的地方。</li>
<li>使用享元模式时，<strong>注意划分内部状态和外部状态</strong>，并且<strong>需要有一个工厂类加以控制</strong>。</li>
<li>在使用享元模式的时候要注意：<strong>不要让被共享的实例被垃圾回收机制（GC）回收了</strong>。</li>
<li>享元模式经典的应用场景是<strong>需要缓冲池的场景</strong>，比如 String 常量池、数据库连接池。</li>
</ol>
<h3 id="14-10、享元模式与单例模式的区别"><a href="#14-10、享元模式与单例模式的区别" class="headerlink" title="14.10、享元模式与单例模式的区别"></a>14.10、享元模式与单例模式的区别</h3><ol>
<li><p>单例模式是<strong>整个应用系统共用一个实例对象</strong>。</p>
<p>享元模式是<strong>整个系统共用好几个同类型对象</strong>。</p>
</li>
<li><p><strong>连接池本身是单例模式</strong>，连接池里的<strong>多个连接对象是享元模式</strong>。</p>
</li>
<li><p>而且<strong>享元模式的共享对象是按需分配</strong>的，如果<strong>不够还会再创建</strong>！</p>
<p>而<strong>单例模式绝对不会重复创建第二个对象</strong>，这是<strong>本质不同</strong>！</p>
</li>
<li><p><strong>享元模式里的共享对象</strong>在使用时一定是<strong>线程私有的</strong>。</p>
<p>就比如共享单车，虽然是共享的，但在使用时一定是只属于你的</p>
</li>
<li><p>享元模式的<strong>共享对象</strong>是<strong>有借有还</strong>的，在<strong>宏观上是共享</strong>的。</p>
</li>
</ol>
<h2 id="15、代理模式Proxy（结构型模式）"><a href="#15、代理模式Proxy（结构型模式）" class="headerlink" title="15、代理模式Proxy（结构型模式）"></a>15、代理模式Proxy（结构型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/100.png" alt="image-20210416084620231"></p>
<h3 id="15-1、基本介绍"><a href="#15-1、基本介绍" class="headerlink" title="15.1、基本介绍"></a>15.1、基本介绍</h3><ol>
<li><p>代理模式：为一个对象提供一个替身，以控制对这个对象的访问。即<strong>通过代理对象访问目标对象</strong>。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p>
</li>
<li><p>这样做的好处是：可以在目标对象实现的基础上，<strong>增强额外的功能操作</strong>，即<strong>扩展目标对象的功能</strong>。</p>
</li>
<li><p>被代理的对象可以是<strong>远程对象</strong>、<strong>创建开销大的对象</strong>或<strong>需要安全控制的对象</strong></p>
</li>
<li><p>代理模式有不同的形式, 主要有三种：</p>
<ul>
<li>静态代理模式：<ul>
<li>静态代理在使用时，需要<strong>定义接口或者父类</strong>,<strong>被代理对象(即目标对象)与代理对象一起实现相同的接口或者是继承相同父类。</strong></li>
</ul>
</li>
<li>动态代理模式 (JDK 代理、接口代理)：<ul>
<li><strong>代理对象不需要实现接口</strong>，但是<strong>目标对象要实现接口</strong>，否则不能用动态代理</li>
<li>代理对象的生成，是利用 <strong>JDK 的 API （反射）</strong>，<strong>动态的在内存中构建代理对象</strong></li>
<li>动态代理也叫做：<strong>JDK 代理</strong>、<strong>接口代理</strong></li>
<li>JDK 中生成代理对象的 API：<ul>
<li>代理类所在包:java.lang.reflect.Proxy</li>
<li>JDK 实现代理只需要使用 <strong>newProxyInstance</strong> 方法,但是该方法需要接收三个参数,完整的写法是:</li>
<li>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h )<ol>
<li>ClassLoader loader ： 指定当前目标对象使用的类加载器, 获取加载器的方法固定</li>
<li>Class&lt;?&gt;[] interfaces: 目标对象实现的接口类型，使用泛型方法确认类型</li>
<li>InvocationHandler h : 事情处理，执行目标对象的方法时，会触发事情处理器方法, 会把当前执行的目标对象方法作为参数传入</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>Cglib</strong> 代理模式(可以在内存动态的创建对象，而不需要实现接口， 他是属于动态代理的范畴) ：<ul>
<li>静态代理和 JDK 代理模式<strong>都要求目标对象是实现一个接口</strong>，但是有时候<strong>目标对象只是一个单独的对象</strong>，<strong>并没有实现任何的接口</strong>，这个时候可使用目标对象子类来实现代理-这就是 <strong>Cglib</strong> 代理。</li>
<li>Cglib 代理也叫作<strong>子类代理**</strong>,<strong>它是</strong>在内存中构建一个子类对象从而实现对目标对象功能扩展**, 有些书也将Cglib 代理归属到动态代理。</li>
<li>Cglib 是<strong>一个强大的高性能的代码生成包</strong>,它可以<strong>在运行期扩展 java 类与实现 java 接口</strong>。它广泛的被许多 <strong>AOP 的框架使用</strong>,例如 <strong>Spring AOP</strong>，实现方法拦截</li>
<li>在 AOP 编程中如何选择代理模式：<ul>
<li><strong>目标对象需要实现接口，用 JDK 代理</strong></li>
<li><strong>目标对象不需要实现接口，用 Cglib 代理</strong></li>
</ul>
</li>
<li>Cglib 包的底层是<strong>通过使用<code>字节码处理框架 ASM</code> 来转换字节码并生成新的类</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>代理模式总的类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/52.png" alt="image-20210416132054743"></p>
</li>
</ol>
<h3 id="15-2、代理模式的原理结构图-uml类图"><a href="#15-2、代理模式的原理结构图-uml类图" class="headerlink" title="15.2、代理模式的原理结构图-uml类图"></a>15.2、代理模式的原理结构图-uml类图</h3><p>代理模式的主要角色如下：</p>
<ol>
<li><strong>抽象主题（Subject）</strong>类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li>
<li><strong>真实主题（Real Subject）</strong>类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li>
<li><strong>代理（Proxy）</strong>类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li>
</ol>
<h4 id="15-2-1、静态代理模式"><a href="#15-2-1、静态代理模式" class="headerlink" title="15.2.1、静态代理模式"></a>15.2.1、静态代理模式</h4><p>相关类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/132.png" alt="image-20210416132423219"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Proxy proxy = <span class="keyword">new</span> Proxy();</span><br><span class="line">        proxy.Request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象主题</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真实主题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问真实主题方法...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RealSubject realSubject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (realSubject == <span class="keyword">null</span>) &#123;</span><br><span class="line">            realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        &#125;</span><br><span class="line">        preRequest();</span><br><span class="line">        realSubject.Request();</span><br><span class="line">        postRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问真实主题之前的预处理。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问真实主题之后的后续处理。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="15-2-2、JDK动态代理模式"><a href="#15-2-2、JDK动态代理模式" class="headerlink" title="15.2.2、JDK动态代理模式"></a>15.2.2、JDK动态代理模式</h4><p>相关类图：<br><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/134.png" alt="image-20210416134249061"></p>
<p>执行原理：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/137.png" alt="preview"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建目标对象</span></span><br><span class="line">		Subject target = <span class="keyword">new</span> RealSubject();</span><br><span class="line">		<span class="comment">//给目标对象，创建代理对象, 可以转成 ITeacherDao</span></span><br><span class="line">		Subject proxyInstance = (Subject)<span class="keyword">new</span> ProxyFactory(target).getProxyInstance();</span><br><span class="line">		<span class="comment">// proxyInstance=class com.sun.proxy.$Proxy0 内存中动态生成了代理对象</span></span><br><span class="line">		System.out.println(<span class="string">&quot;proxyInstance=&quot;</span> + proxyInstance.getClass());</span><br><span class="line">		<span class="comment">//通过代理对象，调用目标对象的方法</span></span><br><span class="line">		proxyInstance.Request();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象主题</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真实主题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问真实主题方法...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代理工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line">	<span class="comment">//维护一个目标对象 , Object</span></span><br><span class="line">	<span class="keyword">private</span> Object target;</span><br><span class="line">	<span class="comment">//构造器 ， 对target 进行初始化</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123;	</span><br><span class="line">		<span class="keyword">this</span>.target = target;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">//给目标对象 生成一个代理对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//说明</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 *  public static Object newProxyInstance(ClassLoader loader,</span></span><br><span class="line"><span class="comment">                                          Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="comment">                                          InvocationHandler h)</span></span><br><span class="line"><span class="comment">                                          </span></span><br><span class="line"><span class="comment">            //1. ClassLoader loader ： 指定当前目标对象使用的类加载器, 获取加载器的方法固定</span></span><br><span class="line"><span class="comment">            //2. Class&lt;?&gt;[] interfaces: 目标对象实现的接口类型，使用泛型方法确认类型</span></span><br><span class="line"><span class="comment">            //3. InvocationHandler h : 事情处理，执行目标对象的方法时，会触发事情处理器方法, 会把当前执行的目标对象方法作为参数传入</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), </span><br><span class="line">				target.getClass().getInterfaces(), </span><br><span class="line">				<span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">						System.out.println(<span class="string">&quot;JDK代理开始~~&quot;</span>);</span><br><span class="line">						<span class="comment">//反射机制调用目标对象的方法</span></span><br><span class="line">						Object returnVal = method.invoke(target, args);</span><br><span class="line">						System.out.println(<span class="string">&quot;JDK代理提交&quot;</span>);</span><br><span class="line">						<span class="keyword">return</span> returnVal;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="15-2-3、Cglib代理模式"><a href="#15-2-3、Cglib代理模式" class="headerlink" title="15.2.3、Cglib代理模式"></a>15.2.3、Cglib代理模式</h4><p>相关类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/135.png" alt="image-20210416135654386"></p>
<p>执行原理：<br><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/138.png" alt="preview"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建目标对象</span></span><br><span class="line">		RealSubject target = <span class="keyword">new</span> RealSubject();</span><br><span class="line">		<span class="comment">//获取到代理对象，并且将目标对象传递给代理对象</span></span><br><span class="line">		RealSubject proxyInstance = (RealSubject)<span class="keyword">new</span> ProxyFactory(target).getProxyInstance();</span><br><span class="line">		<span class="comment">//执行代理对象的方法，触发intecept 方法，从而实现 对目标对象的调用</span></span><br><span class="line">		String res = proxyInstance.Request();</span><br><span class="line">		System.out.println(<span class="string">&quot;res=&quot;</span> + res);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真实主题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问真实主题方法...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代理工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">	<span class="comment">//维护一个目标对象</span></span><br><span class="line">	<span class="keyword">private</span> Object target;</span><br><span class="line">	<span class="comment">//构造器，传入一个被代理的对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.target = target;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//返回一个代理对象:  是 target 对象的代理对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//1. 创建一个工具类</span></span><br><span class="line">		Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">		<span class="comment">//2. 设置父类</span></span><br><span class="line">		enhancer.setSuperclass(target.getClass());</span><br><span class="line">		<span class="comment">//3. 设置回调函数</span></span><br><span class="line">		enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">		<span class="comment">//4. 创建子类对象，即代理对象</span></span><br><span class="line">		<span class="keyword">return</span> enhancer.create();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重写  intercept 方法，会调用目标对象的方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object arg0, Method method, Object[] args, MethodProxy arg3)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Cglib代理模式 ~~ 开始&quot;</span>);</span><br><span class="line">		Object returnVal = method.invoke(target, args);</span><br><span class="line">		System.out.println(<span class="string">&quot;Cglib代理模式 ~~ 提交&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> returnVal;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-3、应用举例"><a href="#15-3、应用举例" class="headerlink" title="15.3、应用举例"></a>15.3、应用举例</h3><p>具体要求：</p>
<ol>
<li>定义一个接口:ITeacherDao</li>
<li>目标对象 TeacherDAO 实现接口 ITeacherDAO</li>
<li>使用静态代理方式,就需要在代理对象 TeacherDAOProxy 中也实现 ITeacherDAO</li>
<li>调用的时候通过调用代理对象的方法来调用目标对象.</li>
</ol>
<h4 id="15-3-1、使用静态代理模式解决需求"><a href="#15-3-1、使用静态代理模式解决需求" class="headerlink" title="15.3.1、使用静态代理模式解决需求"></a>15.3.1、使用静态代理模式解决需求</h4><p>思路分析图解(类图)：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/133.png" alt="image-20210416132715029"></p>
<p>实现代码：</p>
<p>ITeacherDao：教师操作接口。抽象主题（Subject）类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITeacherDao</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">teach</span><span class="params">()</span></span>; <span class="comment">// 授课的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TeacherDao：教师操作接口实现类。真实主题（Real Subject）类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDao</span> <span class="keyword">implements</span> <span class="title">ITeacherDao</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">teach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; 老师授课中  。。。。。&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TeacherDaoProxy：教师操作代理对象。代理（Proxy）类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代理对象,静态代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDaoProxy</span> <span class="keyword">implements</span> <span class="title">ITeacherDao</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ITeacherDao target; <span class="comment">// 目标对象，通过接口来组合</span></span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TeacherDaoProxy</span><span class="params">(ITeacherDao target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.target = target;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">teach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;开始代理  完成某些操作。。。。。 &quot;</span>);<span class="comment">//方法</span></span><br><span class="line">		target.teach();</span><br><span class="line">		System.out.println(<span class="string">&quot;提交。。。。。&quot;</span>);<span class="comment">//方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：调用方。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建目标对象(被代理对象)</span></span><br><span class="line">		TeacherDao teacherDao = <span class="keyword">new</span> TeacherDao();</span><br><span class="line">		<span class="comment">//创建代理对象, 同时将被代理对象传递给代理对象</span></span><br><span class="line">		TeacherDaoProxy teacherDaoProxy = <span class="keyword">new</span> TeacherDaoProxy(teacherDao);</span><br><span class="line">		<span class="comment">//通过代理对象，调用到被代理对象的方法</span></span><br><span class="line">		<span class="comment">//即：执行的是代理对象的方法，代理对象再去调用目标对象的方法 </span></span><br><span class="line">		teacherDaoProxy.teach();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="15-3-2、使用动态代理模式解决需求"><a href="#15-3-2、使用动态代理模式解决需求" class="headerlink" title="15.3.2、使用动态代理模式解决需求"></a>15.3.2、使用动态代理模式解决需求</h4><p>思路分析图解(类图)：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/136.png" alt="image-20210416141108093"></p>
<p>代码实现：</p>
<p>ITeacherDao：教师操作接口。抽象主题（Subject）类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITeacherDao</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">teach</span><span class="params">()</span></span>; <span class="comment">// 授课方法</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TeacherDao：教师操作接口实现类。真实主题（Real Subject）类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDao</span> <span class="keyword">implements</span> <span class="title">ITeacherDao</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">teach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; 老师授课中.... &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;hello &quot;</span> + name);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ProxyFactory：代理工厂，用来生成代理对象。生成的对象：代理（Proxy）类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="comment">// 代理工厂，用来生成代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line">	<span class="comment">//维护一个目标对象 , Object</span></span><br><span class="line">	<span class="keyword">private</span> Object target;</span><br><span class="line">	<span class="comment">//构造器 ， 对target 进行初始化</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.target = target;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">//给目标对象 生成一个代理对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//说明</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 *  public static Object newProxyInstance(ClassLoader loader,</span></span><br><span class="line"><span class="comment">                                          Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="comment">                                          InvocationHandler h)</span></span><br><span class="line"><span class="comment">                                          </span></span><br><span class="line"><span class="comment">            //1. ClassLoader loader ： 指定当前目标对象使用的类加载器, 获取加载器的方法固定</span></span><br><span class="line"><span class="comment">            //2. Class&lt;?&gt;[] interfaces: 目标对象实现的接口类型，使用泛型方法确认类型</span></span><br><span class="line"><span class="comment">            //3. InvocationHandler h : 事情处理，执行目标对象的方法时，会触发事情处理器方法, 会把当前执行的目标对象方法作为参数传入</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), </span><br><span class="line">				target.getClass().getInterfaces(), </span><br><span class="line">				<span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">						System.out.println(<span class="string">&quot;JDK代理开始~~&quot;</span>);</span><br><span class="line">						<span class="comment">//反射机制调用目标对象的方法</span></span><br><span class="line">						Object returnVal = method.invoke(target, args);</span><br><span class="line">						System.out.println(<span class="string">&quot;JDK代理提交&quot;</span>);</span><br><span class="line">						<span class="keyword">return</span> returnVal;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：调用方。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建目标对象</span></span><br><span class="line">		ITeacherDao target = <span class="keyword">new</span> TeacherDao();</span><br><span class="line">		<span class="comment">//给目标对象，创建代理对象, 可以转成 ITeacherDao</span></span><br><span class="line">		ITeacherDao proxyInstance = (ITeacherDao)<span class="keyword">new</span> ProxyFactory(target).getProxyInstance();</span><br><span class="line">		<span class="comment">// proxyInstance=class com.sun.proxy.$Proxy0 内存中动态生成了代理对象</span></span><br><span class="line">		System.out.println(<span class="string">&quot;proxyInstance=&quot;</span> + proxyInstance.getClass());</span><br><span class="line">		<span class="comment">//通过代理对象，调用目标对象的方法</span></span><br><span class="line">		proxyInstance.teach();</span><br><span class="line">		proxyInstance.sayHello(<span class="string">&quot; tom &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="15-3-3、使用cglib代理模式解决需求"><a href="#15-3-3、使用cglib代理模式解决需求" class="headerlink" title="15.3.3、使用cglib代理模式解决需求"></a>15.3.3、使用cglib代理模式解决需求</h4><p>思路分析图解(类图)：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/140.png" alt="image-20210416143133820"></p>
<p>代码实现：</p>
<p>TeacherDao：教师操作类。真实主题（Real Subject）类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDao</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">teach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; 老师授课中  ， 我是cglib代理，不需要实现接口 &quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ProxyFactory：代理工厂，实现cglib的MethodInterceptor接口，用来生成代理对象。生成的对象：代理（Proxy）类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="comment">// ProxyFactory：代理工厂，实现cglib的MethodInterceptor接口，用来生成代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">	<span class="comment">//维护一个目标对象</span></span><br><span class="line">	<span class="keyword">private</span> Object target;</span><br><span class="line">	<span class="comment">//构造器，传入一个被代理的对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.target = target;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//返回一个代理对象:  是 target 对象的代理对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//1. 创建一个工具类</span></span><br><span class="line">		Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">		<span class="comment">//2. 设置父类</span></span><br><span class="line">		enhancer.setSuperclass(target.getClass());</span><br><span class="line">		<span class="comment">//3. 设置回调函数</span></span><br><span class="line">		enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">		<span class="comment">//4. 创建子类对象，即代理对象</span></span><br><span class="line">		<span class="keyword">return</span> enhancer.create();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重写  intercept 方法，会调用目标对象的方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object arg0, Method method, Object[] args, MethodProxy arg3)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Cglib代理模式 ~~ 开始&quot;</span>);</span><br><span class="line">		Object returnVal = method.invoke(target, args);</span><br><span class="line">		System.out.println(<span class="string">&quot;Cglib代理模式 ~~ 提交&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> returnVal;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：调用方。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建目标对象</span></span><br><span class="line">		TeacherDao target = <span class="keyword">new</span> TeacherDao();</span><br><span class="line">		<span class="comment">//获取到代理对象，并且将目标对象传递给代理对象</span></span><br><span class="line">		TeacherDao proxyInstance = (TeacherDao)<span class="keyword">new</span> ProxyFactory(target).getProxyInstance();</span><br><span class="line">		<span class="comment">//执行代理对象的方法，触发intecept 方法，从而实现 对目标对象的调用</span></span><br><span class="line">		String res = proxyInstance.teach();</span><br><span class="line">		System.out.println(<span class="string">&quot;res=&quot;</span> + res);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-4、代理模式总结"><a href="#15-4、代理模式总结" class="headerlink" title="15.4、代理模式总结"></a>15.4、代理模式总结</h3><h4 id="15-4-1、静态代理优缺点"><a href="#15-4-1、静态代理优缺点" class="headerlink" title="15.4.1、静态代理优缺点"></a>15.4.1、静态代理优缺点</h4><ul>
<li>优点：<ul>
<li>在不修改目标对象的功能前提下, 能<strong>通过代理对象对目标功能扩展</strong></li>
</ul>
</li>
<li>缺点：<ul>
<li>因为<strong>代理对象需要与目标对象实现一样的接口</strong>，所以会<strong>有很多代理类</strong></li>
<li>一旦<strong>接口增加方法</strong>,<strong>目标对象与代理对象都要维护</strong></li>
</ul>
</li>
</ul>
<h4 id="15-4-2、JDK动态代理优缺点"><a href="#15-4-2、JDK动态代理优缺点" class="headerlink" title="15.4.2、JDK动态代理优缺点"></a>15.4.2、JDK动态代理优缺点</h4><ul>
<li>优点：<ul>
<li>JDK原声动态代理时java原声支持的、不需要任何外部依赖</li>
</ul>
</li>
<li>缺点：<ul>
<li>但是它只能基于接口进行代理（因为它已经继承了proxy了，java不支持多继承）</li>
</ul>
</li>
</ul>
<h4 id="15-4-3、Cglib动态代理优缺点"><a href="#15-4-3、Cglib动态代理优缺点" class="headerlink" title="15.4.3、Cglib动态代理优缺点"></a>15.4.3、Cglib动态代理优缺点</h4><p>优点：</p>
<ul>
<li>CGLIB通过继承的方式进行代理、无论目标对象没有没实现接口都可以代理</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>需要引入 cglib 的 jar 文件</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/139.png" alt="image-20210416143100693"></p>
</li>
<li><p>在内存中动态构建子类，注意代理的类不能为 final，否则报错java.lang.IllegalArgumentException:</p>
</li>
<li><p>目标对象的方法如果为 final/static,那么就不会被拦截,即不会执行目标对象额外的业务方法。（final修饰的方法不能被覆写）</p>
</li>
</ul>
<h4 id="15-4-4、两种动态代理模式的对比（JDK-VS-CGLIB）"><a href="#15-4-4、两种动态代理模式的对比（JDK-VS-CGLIB）" class="headerlink" title="15.4.4、两种动态代理模式的对比（JDK VS CGLIB）"></a>15.4.4、两种动态代理模式的对比（JDK VS CGLIB）</h4><table>
<thead>
<tr>
<th></th>
<th>JDK原生动态代理</th>
<th>CGLB动态代理</th>
</tr>
</thead>
<tbody><tr>
<td>核心原理</td>
<td>基于”接口实现”方式</td>
<td>基于类集成方式</td>
</tr>
<tr>
<td>优点</td>
<td>Java原生支持的，不需要任何依赖</td>
<td>对与代理的目标对象无限制，无需实现接口</td>
</tr>
<tr>
<td>不足之处</td>
<td>只能基于接口进行实现</td>
<td>无法处理final方法</td>
</tr>
<tr>
<td>实现方式</td>
<td>Java原生支持，不需要任何依赖</td>
<td>需要引用JAR包cglib-nodep-3.2.5.jar和asm.jar</td>
</tr>
</tbody></table>
<h4 id="15-4-5、代理模式总结"><a href="#15-4-5、代理模式总结" class="headerlink" title="15.4.5、代理模式总结"></a>15.4.5、代理模式总结</h4><p>主要优点有：</p>
<ul>
<li>代理模式在客户端与目标对象之间起到一个<strong>中介作用和保护目标对象</strong>的作用；</li>
<li>代理对象可以<strong>扩展目标对象的功能</strong>；</li>
<li>代理模式能将<strong>客户端与目标对象分离</strong>，在一定程度上<strong>降低了系统的耦合度</strong>，<strong>增加了程序的可扩展性</strong></li>
</ul>
<p>主要缺点是（有些缺点可通过动态代理解决）：</p>
<ul>
<li>代理模式会造成系统设计中<strong>类的数量增加</strong></li>
<li>在客户端和目标对象之间增加一个代理对象，会造成<strong>请求处理速度变慢</strong>；</li>
<li><strong>增加了系统的复杂度</strong>；</li>
</ul>
<p>应用场景：</p>
<p>当<strong>无法或不想直接引用某个对象</strong>或<strong>访问某个对象存在困难</strong>时，可以<strong>通过代理对象来间接访问</strong>。使用代理模式主要有两个目的：一是<strong>保护目标对象</strong>，二是<strong>增强目标对象</strong>。</p>
<ol>
<li><p>远程代理：</p>
<ul>
<li>远程代理即<strong>Remote Proxy</strong>，<strong>本地的调用者持有的接口实际上是一个代理</strong>，这个代理负责把对接口的方法访问转换成远程调用，然后返回结果。</li>
<li>这种方式通常是为了<strong>隐藏目标对象存在于不同地址空间的事实</strong>，方便客户端访问。例如，用户申请某些网盘空间时，会在用户的文件系统中建立一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间。</li>
<li>Java内置的RMI机制就是一个完整的远程代理模式。</li>
</ul>
</li>
<li><p>虚拟代理：</p>
<ul>
<li>虚代理即<strong>Virtual Proxy</strong>，它让调用者<strong>先持有一个代理对象</strong>，但<strong>真正的对象尚未创建</strong>。如果<strong>没有必要</strong>，这个<strong>真正的对象是不会被创建</strong>的，直到客户端需要<strong>真的必须调用</strong>时，<strong>才创建</strong>真正的对象。</li>
<li>这种方式通常用于<strong>要创建的目标对象开销很大</strong>时。例如，下载一幅很大的图像需要很长时间，因某种计算比较复杂而短时间无法完成，这时可以先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉。</li>
<li>JDBC的连接池返回的JDBC连接（Connection对象）就可以是一个虚代理，即获取连接时根本没有任何实际的数据库连接，直到第一次执行JDBC查询或更新操作时，才真正创建实际的JDBC连接。</li>
</ul>
</li>
<li><p>保护代理：</p>
<ul>
<li>保护代理即<strong>Protection Proxy</strong>，它用代理对象控制对原始对象的访问，常用于鉴权。</li>
<li>这种方式通常用于控制不同种类客户对真实对象的访问权限。</li>
</ul>
</li>
<li><p>智能引用：</p>
<ul>
<li>智能引用即<strong>Smart Reference</strong>，它也是一种代理对象，如果有很多客户端对它进行访问，通过<strong>内部的计数器可以在外部调用者都不使用后自动释放它</strong>。</li>
<li>主要用于调用目标对象时，<strong>代理附加一些额外的处理功能</strong>。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以自动释放它。</li>
</ul>
</li>
<li><p>延迟加载：</p>
<ul>
<li>延迟加载即<strong>Cache缓存代理</strong>。指为了提高系统的性能，延迟对目标的加载。例如，Hibernate 中就存在属性的延迟加载和关联表的延时加载。</li>
<li>当请求图片文件等资源时，先到缓存代理取，如果取到资源则 ok,如果取不到资源，再到公网或者数据库取，然后缓存。</li>
</ul>
</li>
<li><p>防火墙（Firewall）代理：内网通过代理穿透防火墙，实现对公网的访问。</p>
</li>
<li><p>同步化（Synchronization）代理：主要使用在多线程编程中，完成多线程间同步工作</p>
</li>
<li><p>Copy-on-Write 代理：它是虚拟代理的一种，把复制（克隆）操作延迟到只有在客户端真正需要时才执行。一般来说，对象的深克隆是一个开销较大的操作，Copy-on-Write代理可以让这个操作延迟，只有对象被用到的时候才被克隆。</p>
<p>Immer提供了一种更方便的不可变状态操作方式。详情：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/147164121">Copy-on-write + Proxy = ?</a></p>
<p>其<strong>方便之处</strong>主要体现在：</p>
<ul>
<li>只有一个（核心）API：<code>produce(currentState, producer: (draftState) =&gt; void): nextState</code></li>
<li>不引入额外的数据结构：没有 List、Map、Set 等任何自定义数据结构，因此也不需要特殊的相等性比较方法</li>
<li>数据操作完全基于类型：用纯原生 API 操作数据，符合直觉</li>
</ul>
</li>
</ol>
<p>应用实际：</p>
<ul>
<li>spring aop</li>
<li>我们实际使用的DataSource，例如HikariCP，都是基于代理模式实现的，原理同上，但增加了更多的如动态伸缩的功能（一个连接空闲一段时间后自动关闭）。</li>
<li>买火车票不一定在火车站买，也可以去代售点。</li>
<li>一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。</li>
</ul>
<h3 id="15-5、代理模式扩展"><a href="#15-5、代理模式扩展" class="headerlink" title="15.5、代理模式扩展"></a>15.5、代理模式扩展</h3><p>动态代理的一种实现类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/141.png" alt="image-20210416145841201"></p>
<h3 id="15-6、进阶阅读"><a href="#15-6、进阶阅读" class="headerlink" title="15.6、进阶阅读"></a>15.6、进阶阅读</h3><p>如果您想深入了解代理模式，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/8424.html">《静态代理和动态代理》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8427.html">《使用代理模式切换数据源》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8429.html">《彻底搞懂JDK动态代理核心原理》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8433.html">《代理模式在Spring源码中的应用》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8435.html">《代理模式在MyBatis源码中的应用》</a></li>
</ul>
<h3 id="15-7、相关设计模式"><a href="#15-7、相关设计模式" class="headerlink" title="15.7、相关设计模式"></a>15.7、相关设计模式</h3><ul>
<li><p>Adapter 模式：</p>
<p>Adapter 模式适配了两种具有不同接口 (API) 的对象，以使它们可以一同工作。而在 Proxy 模式中，Proxy 角色与Rea)Subject 角色的接口 (API) 是相同的（透明性）。</p>
</li>
<li><p>Decorator 模式：</p>
<p>Decorator 模式与 Proxy 模式在实现上很相似．不过它们的使用目的不同。</p>
<p>Decorator 模式的目的在于增加新的功能。而在 Proxy 模式中，与增加新功能相比，它更注重通过设置代理人的方式来减轻本人的工作负担。</p>
</li>
</ul>
<h3 id="15-8、代理模式与其他模式的区别"><a href="#15-8、代理模式与其他模式的区别" class="headerlink" title="15.8、代理模式与其他模式的区别"></a>15.8、代理模式与其他模式的区别</h3><h4 id="15-8-1、Proxy模式VSDecorator模式"><a href="#15-8-1、Proxy模式VSDecorator模式" class="headerlink" title="15.8.1、Proxy模式VSDecorator模式"></a>15.8.1、Proxy模式VSDecorator模式</h4><ul>
<li>Decorator模式让调用者自己创建核心类，然后组合各种功能</li>
<li>Proxy模式决不能让调用者自己创建再组合，否则就失去了代理的功能</li>
<li>Proxy模式让调用者认为获取到的是核心类接口，但实际上是代理类。</li>
<li>装饰器模式为了增强功能，而代理模式是为了加以控制。</li>
</ul>
<h4 id="15-8-2、Proxy模式VSAdapter模式"><a href="#15-8-2、Proxy模式VSAdapter模式" class="headerlink" title="15.8.2、Proxy模式VSAdapter模式"></a>15.8.2、Proxy模式VSAdapter模式</h4><ul>
<li>适配器模式主要改变所考虑对象的接口</li>
<li>代理模式不能改变所代理类的接口</li>
</ul>
<h3 id="15-9、代理模式的注意事项与细节"><a href="#15-9、代理模式的注意事项与细节" class="headerlink" title="15.9、代理模式的注意事项与细节"></a>15.9、代理模式的注意事项与细节</h3><ol>
<li>代理模式通过封装一个已有接口，并向调用方返回相同的接口类型，能让调用方在不改变任何代码的前提下增强某些功能（例如，鉴权、延迟加载、连接池复用等）。</li>
<li>静态代理模式：代理对象与目标对象（被代理对象）都实现同一个接口或者继承同一个抽象类</li>
<li>JDK动态代理模式：目标对象（被代理对象）需要实现接口或继承抽象类，而代理对象不用，它由一个代理工厂来生产</li>
<li>CGLIB动态代模式：目标对象（被代理对象）不需要实现接口或继承抽象类，但是用来生产代理对象的代理工厂需要实现cglib的MethodInterceptor接口。</li>
</ol>
<h2 id="16、模板方法模式Template-Method（行为型模式）"><a href="#16、模板方法模式Template-Method（行为型模式）" class="headerlink" title="16、模板方法模式Template Method（行为型模式）"></a>16、模板方法模式Template Method（行为型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/74.PNG"></p>
<h3 id="16-1、基本介绍"><a href="#16-1、基本介绍" class="headerlink" title="16.1、基本介绍"></a>16.1、基本介绍</h3><ol>
<li>模板方法模式（Template Method Pattern），又叫<strong>模板模式(Template Pattern)**，</strong>在一个抽象类公开定义了执行它的方法的模板<strong>。它的</strong>子类可以按需要重写方法实现<strong>，但</strong>调用将以抽象类中定义的方式进行**。</li>
<li>简单说，模板方法模式<strong>定义一个操作中的算法的骨架</strong>，而将一些步骤延迟到子类中，使得<strong>子类可以不改变一个算法的结构</strong>，就可以<strong>重定义该算法的某些特定步骤</strong></li>
<li>模板方法的核心思想是：<strong>父类定义骨架</strong>，<strong>子类实现某些细节</strong>。</li>
<li>这种类型的设计模式属于<strong>行为型模式</strong>。</li>
</ol>
<h3 id="16-2、模板方法模式的原理结构图-uml类图"><a href="#16-2、模板方法模式的原理结构图-uml类图" class="headerlink" title="16.2、模板方法模式的原理结构图-uml类图"></a>16.2、模板方法模式的原理结构图-uml类图</h3><p>模板方法模式需要注意抽象类与具体子类之间的协作。它用到了<strong>虚函数的多态性技术</strong>以及“不用调用我，让我来调用你”的<strong>反向控制技术</strong>。</p>
<h4 id="16-2-1、模式的结构"><a href="#16-2-1、模式的结构" class="headerlink" title="16.2.1、模式的结构"></a>16.2.1、模式的结构</h4><p>模板方法模式包含以下主要角色：</p>
<ul>
<li>抽象类/抽象模板（Abstract Class）<ul>
<li>抽象模板类，负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下：<ul>
<li>模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。</li>
<li>基本方法：是整个算法中的一个步骤，包含以下几种类型：<ul>
<li>抽象方法：在抽象类中声明，由具体子类实现。</li>
<li>具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。</li>
<li>钩子方法：在抽象类中已经实现，我们可以定义一个方法，它默认不做任何事，子类可以视情况要不要覆盖它。包括用于判断的逻辑方法和需要子类重写的空方法两种。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>具体子类/具体实现（Concrete Class）：具体实现类，实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤。</li>
</ul>
<p>相关类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/142.png" alt="image-20210416200400531"></p>
<h4 id="16-2-2、模式的实现"><a href="#16-2-2、模式的实现" class="headerlink" title="16.2.2、模式的实现"></a>16.2.2、模式的实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateMethodPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractClass tm = <span class="keyword">new</span> ConcreteClass();</span><br><span class="line">        tm.TemplateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">//模板方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TemplateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SpecificMethod();</span><br><span class="line">        abstractMethod1();</span><br><span class="line">        abstractMethod2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//具体方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SpecificMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象类中的具体方法被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//抽象方法1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abstractMethod1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//抽象方法2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abstractMethod2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abstractMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象方法1的实现被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abstractMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象方法2的实现被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-3、应用举例"><a href="#16-3、应用举例" class="headerlink" title="16.3、应用举例"></a>16.3、应用举例</h3><p>豆浆制作问题：</p>
<p>编写制作豆浆的程序，说明如下:</p>
<ol>
<li>制作豆浆的流程 选材—&gt;添加配料—&gt;浸泡—&gt;放到豆浆机打碎</li>
<li>通过添加不同的配料，可以制作出不同口味的豆浆</li>
<li>也可以不添加配料，制作纯豆浆（钩子方法）</li>
<li>选材、浸泡和放到豆浆机打碎这几个步骤对于制作每种口味的豆浆都是一样的</li>
<li>请使用模板方法模式完成 </li>
</ol>
<p>思路分析和图解(类图)：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Users\风间&琉璃\AppData\Roaming\Typora\typora-user-images\image-20210416200834855.png" alt="image-20210416200834855"></p>
<p>代码实现：</p>
<p>SoyaMilk：制作豆浆的抽象类。抽象类/抽象模板（Abstract Class）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象类，表示豆浆</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SoyaMilk</span> </span>&#123;</span><br><span class="line">	<span class="comment">//模板方法, make , 模板方法可以做成final , 不让子类去覆盖.</span></span><br><span class="line">	<span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		select(); </span><br><span class="line">		<span class="keyword">if</span>(customerWantCondiments()) &#123;</span><br><span class="line">			addCondiments();</span><br><span class="line">		&#125;</span><br><span class="line">		soak();</span><br><span class="line">		beat();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//选材料</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;第一步：选择好的新鲜黄豆  &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//添加不同的配料， 抽象方法, 子类具体实现</span></span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//浸泡</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">soak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;第三步， 黄豆和配料开始浸泡， 需要3小时 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//打碎</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">beat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;第四步：黄豆和配料放到豆浆机去打碎  &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//钩子方法，决定是否需要添加配料</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">customerWantCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RedBeanSoyaMilk：红豆豆浆。具体子类/具体实现（Concrete Class）（PeanutSoyaMilk等等其他豆浆类似）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedBeanSoyaMilk</span> <span class="keyword">extends</span> <span class="title">SoyaMilk</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; 加入上好的红豆 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PureSoyaMilk：纯豆浆。具体子类/具体实现（Concrete Class）（钩子方法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PureSoyaMilk</span> <span class="keyword">extends</span> <span class="title">SoyaMilk</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//空实现</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">customerWantCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：调用制作豆浆。客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//制作红豆豆浆</span></span><br><span class="line">		System.out.println(<span class="string">&quot;----制作红豆豆浆----&quot;</span>);</span><br><span class="line">		SoyaMilk redBeanSoyaMilk = <span class="keyword">new</span> RedBeanSoyaMilk();</span><br><span class="line">		redBeanSoyaMilk.make();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;----制作花生豆浆----&quot;</span>);</span><br><span class="line">		SoyaMilk peanutSoyaMilk = <span class="keyword">new</span> PeanutSoyaMilk();</span><br><span class="line">		peanutSoyaMilk.make();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;----制作纯豆浆----&quot;</span>);</span><br><span class="line">		SoyaMilk pureSoyaMilk = <span class="keyword">new</span> PureSoyaMilk();</span><br><span class="line">		pureSoyaMilk.make();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-4、模板方法模式在Spring框架的应用与源码"><a href="#16-4、模板方法模式在Spring框架的应用与源码" class="headerlink" title="16.4、模板方法模式在Spring框架的应用与源码"></a>16.4、模板方法模式在Spring框架的应用与源码</h3><p><strong>Spring IOC 容器初始化</strong>时运用到的模板方法模式</p>
<p>代码分析+角色分析+说明类图：</p>
<h4 id="16-4-1、说明类图"><a href="#16-4-1、说明类图" class="headerlink" title="16.4.1、说明类图"></a>16.4.1、说明类图</h4><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/144.png" alt="image-20210416204002753"></p>
<h4 id="16-4-2、角色分析"><a href="#16-4-2、角色分析" class="headerlink" title="16.4.2、角色分析"></a>16.4.2、角色分析</h4><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/145.png" alt="image-20210416204322032"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/146.png" alt="image-20210416204443297"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/147.png" alt="image-20210416204542192"></p>
<h4 id="16-4-3、代码分析"><a href="#16-4-3、代码分析" class="headerlink" title="16.4.3、代码分析"></a>16.4.3、代码分析</h4><p>ConfigurableApplicationContext接口与refresh()抽象模板方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/148.png" alt="image-20210416204750043"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/149.png" alt="image-20210416204918844"></p>
<p>AbstractApplicationContext抽象类实现了ConfigurableApplicationContext接口，并对refresh()模板方法进行了重写</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/150.png" alt="image-20210416204959220"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/151.png" alt="image-20210416205223899"></p>
<p>refresh()模板方法：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/152.png" alt="image-20210416205621834"></p>
<p>refresh()模板方法当中的obtainFreshBeanFactory()方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/153.png" alt="image-20210416205735418"></p>
<p>refresh()模板方法当中的钩子方法postProcessBeanFactory()与onRefresh()</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/155.png" alt="image-20210416210548820"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/154.png" alt="image-20210416210318005"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/156.png" alt="image-20210416210706001"></p>
<p>GenericApplicationContext类继承了AbstractApplicationContext抽象类，对父类的getBeanFactory()与refreshBeanFactory()抽象方法进行重写</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/157.png" alt="image-20210416211006295"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/158.png" alt="image-20210416211737520"></p>
<p>XmlWebApplicationContext类、ClassPathXmlApplicationContext类等等子类继承了各自的父类。最好按照父类定义好的模板去实现对应的需求。</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/159.png" alt="image-20210416212050470"></p>
<h3 id="16-5、模板方法模式总结"><a href="#16-5、模板方法模式总结" class="headerlink" title="16.5、模板方法模式总结"></a>16.5、模板方法模式总结</h3><p>主要优点：</p>
<ol>
<li>它<strong>封装了不变部分</strong>，<strong>扩展可变部分</strong>。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。</li>
<li>它在<strong>父类中提取了公共的部分代码</strong>，便于代码复用。</li>
<li><strong>部分方法是由子类实现</strong>的，因此子类可以<strong>通过扩展方式增加相应的功能</strong>，<strong>符合开闭原则</strong>。</li>
</ol>
<p>主要缺点：</p>
<ol>
<li>对<strong>每个不同的实现都需要定义一个子类，这会导致类的个数增加</strong>，系统更加庞大，设计也更加抽象，间接地增加了系统实现的复杂度。</li>
<li>父类中的抽象方法由子类实现，<strong>子类执行的结果会影响父类的结果</strong>，这导致一种<strong>反向的控制结构</strong>，它<strong>提高了代码阅读的难度</strong>。</li>
<li>由于<strong>继承关系自身的缺点</strong>，如果<strong>父类添加新的抽象方法，则所有子类都要改一遍</strong>。</li>
</ol>
<p>模式的应用场景：</p>
<ol>
<li>算法的<strong>整体步骤很固定，但其中个别部分易变</strong>时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。</li>
<li>当<strong>多个子类存在公共的行为</strong>时，可以将其提取出来并集中到一个公共父类中以避免代码重复。首先，要识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。</li>
<li>当<strong>需要控制子类的扩展</strong>时，模板方法<strong>只在特定点调用钩子操作</strong>，这样就<strong>只允许在这些点进行扩展</strong>。</li>
</ol>
<p>应用实例：</p>
<ol>
<li>在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异</li>
<li>spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。</li>
</ol>
<h3 id="16-6、模板方法模式扩展"><a href="#16-6、模板方法模式扩展" class="headerlink" title="16.6、模板方法模式扩展"></a>16.6、模板方法模式扩展</h3><p>在模板方法模式中，基本方法包含：抽象方法、具体方法和钩子方法，正确使用“钩子方法”可以使得子类控制父类的行为。如下面例子中，可以通过在具体子类中重写钩子方法 HookMethod1() 和 HookMethod2() 来改变抽象父类中的运行结果，其结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/143.png" alt="image-20210416203027578"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HookTemplateMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HookAbstractClass tm = <span class="keyword">new</span> HookConcreteClass();</span><br><span class="line">        tm.TemplateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//含钩子方法的抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HookAbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">//模板方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TemplateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        abstractMethod1();</span><br><span class="line">        HookMethod1();</span><br><span class="line">        <span class="keyword">if</span> (HookMethod2()) &#123;</span><br><span class="line">            SpecificMethod();</span><br><span class="line">        &#125;</span><br><span class="line">        abstractMethod2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//具体方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SpecificMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象类中的具体方法被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//钩子方法1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HookMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//钩子方法2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HookMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//抽象方法1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abstractMethod1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//抽象方法2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abstractMethod2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//含钩子方法的具体子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HookConcreteClass</span> <span class="keyword">extends</span> <span class="title">HookAbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abstractMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象方法1的实现被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abstractMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象方法2的实现被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HookMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;钩子方法1被重写...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HookMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果钩子方法 HookMethod1() 和钩子方法 HookMethod2() 的代码改变，则程序的运行结果也会改变。</p>
<h3 id="16-7、进阶阅读"><a href="#16-7、进阶阅读" class="headerlink" title="16.7、进阶阅读"></a>16.7、进阶阅读</h3><p>如果您想深入了解模板方法模式，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8477.html">《使用模板模式实现课程基本流程》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8478.html">《使用模板方法模式重构JDBC业务操作》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8479.html">《模板方法模式在Servlet中的应用》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8480.html">《模板方法模式在MyBatis源码中的应用》</a></li>
</ul>
<h3 id="16-8、相关设计模式"><a href="#16-8、相关设计模式" class="headerlink" title="16.8、相关设计模式"></a>16.8、相关设计模式</h3><ul>
<li><p>Factory Method 模式</p>
<p>Factory Method模式是将Template Method模式用于生成实例的一个典型例子。</p>
</li>
<li><p>Strategy 模式</p>
<p>在Template Method模式中， 可以<strong>使用继承改变程序的行为</strong>。 这是因为Template Method模式在父类中定义程序行为的框架．在子类中决定具体的处理。</p>
<p>与此相对的是Strategy模式 ， 它可以<strong>使用委托改变程序的行为</strong>。 与Template Method模式中改 变部分程序行为不同的是，Strategy模式<strong>用于替换整个算法</strong>。</p>
</li>
</ul>
<h3 id="16-9、模板方法模式的注意事项与细节"><a href="#16-9、模板方法模式的注意事项与细节" class="headerlink" title="16.9、模板方法模式的注意事项与细节"></a>16.9、模板方法模式的注意事项与细节</h3><ol>
<li>基本思想是：<strong>算法只存在</strong>于一个地方，也就是在<strong>父类中</strong>，<strong>容易修改</strong>。需要修改算法时，只要修改父类的模板方法或者已经实现的某些步骤，子类就会继承这些修改。</li>
<li>实现了<strong>最大化代码复用</strong>。<strong>父类的模板方法和已实现的某些步骤会被子类继承而直接使用</strong>。</li>
<li>既<strong>统一了算法</strong>，也<strong>提供了很大的灵活性</strong>。父类的模板方法确保了算法的结构保持不变，同时由子类提供部分步骤的实现。</li>
<li>该模式的不足之处：<strong>每一个不同的实现都需要一个子类实现</strong>，导致<strong>类的个数增加</strong>，使得系统更加庞大</li>
<li>一般<strong>模板方法都加上 <code>final</code> 关键字</strong>， <strong>防止子类重写模板方法</strong>。</li>
<li>模板方法模式使用场景：当要<strong>完成在某个过程，该过程要执行一系列步骤</strong> ，<strong>这一系列的步骤基本相同</strong>，但其<strong>个别步骤在实现时可能不同</strong>，通常考虑用模板方法模式来处理</li>
<li>模板方法是一种<strong>高层定义骨架</strong>，<strong>底层实现细节的设计模式</strong>，适用于<strong>流程固定</strong>，<strong>但某些步骤不确定或可替换</strong>的情况。</li>
</ol>
<h2 id="17、命令模式Command（行为型模式）"><a href="#17、命令模式Command（行为型模式）" class="headerlink" title="17、命令模式Command（行为型模式）"></a>17、命令模式Command（行为型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/160.png" alt="image-20210416212741618"></p>
<h3 id="17-1、基本介绍"><a href="#17-1、基本介绍" class="headerlink" title="17.1、基本介绍"></a>17.1、基本介绍</h3><ol>
<li>命令（Command）模式的定义如下：将<strong>一个请求封装为一个对象</strong>，使<strong>发出请求的责任和执行请求的责任分割开</strong>。这样两者之间通过命令对象进行沟通，这样方便将<strong>命令对象进行储存、传递、调用、增加与管理</strong>。</li>
<li>命令模式（Command Pattern）：在软件设计中，我们经常需要<strong>向某些对象发送请求</strong>，但是并<strong>不知道请求的接收者</strong>是谁，<strong>也不知道被请求的操作</strong>是哪个，我们<strong>只需在程序运行时指定具体的请求接收者</strong>即可，此时，可以使用命令模式来进行设计</li>
<li>命名模式使得<strong>请求发送者与请求接收者消除彼此之间的耦合</strong>，让对象之间的调用关系更加灵活，实现解耦。</li>
<li>在命名模式中，会<strong>将一个请求封装为一个对象</strong>，以便<strong>使用不同参数来表示不同的请求(即命名)**，同时命令模式也</strong>支持可撤销**的操作。</li>
<li>通俗易懂的理解：将军发布命令，士兵去执行。其中有几个角色：将军（命令发布者）、士兵（命令的具体执行者）、命令(连接将军和士兵)。Invoker 是调用者（将军），Receiver 是被调用者（士兵），MyCommand 是命令，实现了 Command 接口，持有接收对象</li>
</ol>
<h3 id="17-2、命令模式的原理结构图-uml类图"><a href="#17-2、命令模式的原理结构图-uml类图" class="headerlink" title="17.2、命令模式的原理结构图-uml类图"></a>17.2、命令模式的原理结构图-uml类图</h3><h4 id="17-2-1、模式的结构"><a href="#17-2-1、模式的结构" class="headerlink" title="17.2.1、模式的结构"></a>17.2.1、模式的结构</h4><p>命令模式包含以下主要角色。</p>
<ol>
<li>抽象命令类（Command）角色：是命令角色，需要执行的所有命令都在这里，拥有执行命令的抽象方法 execute()，可以是接口或抽象类</li>
<li>具体命令类（Concrete Command）角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。将一个接受者对象与一个动作绑定，调用接受者相应的操作，实现 execute</li>
<li>实现者/接收者（Receiver）角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者。</li>
<li>调用者/请求者（Invoker）角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。</li>
</ol>
<p>其结构图如图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/161.png" alt="image-20210417005514313"></p>
<h4 id="173-2-2、模式的实现"><a href="#173-2-2、模式的实现" class="headerlink" title="173.2.2、模式的实现"></a>173.2.2、模式的实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> command;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Command cmd = <span class="keyword">new</span> ConcreteCommand();</span><br><span class="line">        Invoker ir = <span class="keyword">new</span> Invoker(cmd);</span><br><span class="line">        System.out.println(<span class="string">&quot;客户访问调用者的call()方法...&quot;</span>);</span><br><span class="line">        ir.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Invoker</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用者执行命令command...&quot;</span>);</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象命令</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体命令</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line">    ConcreteCommand() &#123;</span><br><span class="line">        receiver = <span class="keyword">new</span> Receiver();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver.action();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;命令被撤销...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接收者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收者的action()方法被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-3、应用举例"><a href="#17-3、应用举例" class="headerlink" title="17.3、应用举例"></a>17.3、应用举例</h3><p>17.1   智能生活项目需求</p>
<ol>
<li>我们买了一套智能家电，有照明灯、风扇、冰箱、洗衣机，我们只要在手机上安装 app 就可以控制对这些家电工作。</li>
<li>这些智能家电来自不同的厂家，我们不想针对每一种家电都安装一个 App，分别控制，我们希望只要一个app就可以控制全部智能家电。</li>
<li>要实现一个 app 控制所有智能家电的需要，则<strong>每个智能家电厂家</strong>都要<strong>提供一个统一的接口给 app 调用</strong>，这时 就可以考虑使用命令模式。</li>
<li>命令模式可将“动作的请求者”从“动作的执行者”对象中解耦出来.</li>
<li>在我们的例子中，动作的请求者是手机 app，动作的执行者是每个厂商的一个家电产</li>
<li>编写程序，使用命令模式完成前面的智能家电项目</li>
</ol>
<p>思路分析和图解</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/162.png" alt="image-20210417010355805"></p>
<p>代码实现：</p>
<p>Command：命令接口。抽象命令类（Command）角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建命令接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">	<span class="comment">//执行动作(操作)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//撤销动作(操作)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LightReceiver：电灯接受者。实现者/接收者（Receiver）角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightReceiver</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; 电灯打开了.. &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; 电灯关闭了.. &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LightOnCommand：打开电灯的操作。具体命令类（Concrete Command）角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOnCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">	<span class="comment">//聚合LightReceiver</span></span><br><span class="line">	LightReceiver light;</span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LightOnCommand</span><span class="params">(LightReceiver light)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.light = light;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//调用接收者的方法</span></span><br><span class="line">		light.on();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//调用接收者的方法</span></span><br><span class="line">		light.off();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LightOffCommand：关闭电灯的操作。具体命令类（Concrete Command）角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOffCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 聚合LightReceiver</span></span><br><span class="line">	LightReceiver light;</span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LightOffCommand</span><span class="params">(LightReceiver light)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 调用接收者的方法</span></span><br><span class="line">		light.off();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 调用接收者的方法</span></span><br><span class="line">		light.on();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NoCommand：空命令。具体命令类（Concrete Command）角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 没有任何命令，即空执行: 用于初始化每个按钮, 当调用空命令时，对象什么都不做</span></span><br><span class="line"><span class="comment"> * 其实，这样是一种设计模式, 可以省掉对空判断</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RemoteController：遥控器。调用者/请求者（Invoker）角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteController</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 开 按钮的命令数组</span></span><br><span class="line">	Command[] onCommands;</span><br><span class="line">	Command[] offCommands;</span><br><span class="line">	<span class="comment">// 执行撤销的命令</span></span><br><span class="line">	Command undoCommand;</span><br><span class="line">	<span class="comment">// 构造器，完成对按钮初始化</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">RemoteController</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		onCommands = <span class="keyword">new</span> Command[<span class="number">5</span>];</span><br><span class="line">		offCommands = <span class="keyword">new</span> Command[<span class="number">5</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">			onCommands[i] = <span class="keyword">new</span> NoCommand();</span><br><span class="line">			offCommands[i] = <span class="keyword">new</span> NoCommand();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 给我们的按钮设置你需要的命令</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(<span class="keyword">int</span> no, Command onCommand, Command offCommand)</span> </span>&#123;</span><br><span class="line">		onCommands[no] = onCommand;</span><br><span class="line">		offCommands[no] = offCommand;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 按下开按钮</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onButtonWasPushed</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123; <span class="comment">// no 0</span></span><br><span class="line">		<span class="comment">// 找到你按下的开的按钮， 并调用对应方法</span></span><br><span class="line">		onCommands[no].execute();</span><br><span class="line">		<span class="comment">// 记录这次的操作，用于撤销</span></span><br><span class="line">		undoCommand = onCommands[no];</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 按下关按钮</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offButtonWasPushed</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123; <span class="comment">// no 0</span></span><br><span class="line">		<span class="comment">// 找到你按下的关的按钮， 并调用对应方法</span></span><br><span class="line">		offCommands[no].execute();</span><br><span class="line">		<span class="comment">// 记录这次的操作，用于撤销</span></span><br><span class="line">		undoCommand = offCommands[no];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 按下撤销按钮</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undoButtonWasPushed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		undoCommand.undo();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：客户端。调用遥控器RemoteController</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;	</span><br><span class="line">		<span class="comment">//使用命令设计模式，完成通过遥控器，对电灯的操作</span></span><br><span class="line">		<span class="comment">//创建电灯的对象(接受者)</span></span><br><span class="line">		LightReceiver lightReceiver = <span class="keyword">new</span> LightReceiver();</span><br><span class="line">		<span class="comment">//创建电灯相关的开关命令</span></span><br><span class="line">		LightOnCommand lightOnCommand = <span class="keyword">new</span> LightOnCommand(lightReceiver);</span><br><span class="line">		LightOffCommand lightOffCommand = <span class="keyword">new</span> LightOffCommand(lightReceiver);</span><br><span class="line">		<span class="comment">//需要一个遥控器</span></span><br><span class="line">		RemoteController remoteController = <span class="keyword">new</span> RemoteController();</span><br><span class="line">		<span class="comment">//给我们的遥控器设置命令, 比如 no = 0 是电灯的开和关的操作</span></span><br><span class="line">		remoteController.setCommand(<span class="number">0</span>, lightOnCommand, lightOffCommand);</span><br><span class="line">		System.out.println(<span class="string">&quot;--------按下灯的开按钮-----------&quot;</span>);</span><br><span class="line">		remoteController.onButtonWasPushed(<span class="number">0</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;--------按下灯的关按钮-----------&quot;</span>);</span><br><span class="line">		remoteController.offButtonWasPushed(<span class="number">0</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;--------按下撤销按钮-----------&quot;</span>);</span><br><span class="line">		remoteController.undoButtonWasPushed();</span><br><span class="line">	</span><br><span class="line">		System.out.println(<span class="string">&quot;=========使用遥控器操作电视机==========&quot;</span>);</span><br><span class="line">		TVReceiver tvReceiver = <span class="keyword">new</span> TVReceiver();</span><br><span class="line">		TVOffCommand tvOffCommand = <span class="keyword">new</span> TVOffCommand(tvReceiver);</span><br><span class="line">		TVOnCommand tvOnCommand = <span class="keyword">new</span> TVOnCommand(tvReceiver);</span><br><span class="line">		<span class="comment">//给我们的遥控器设置命令, 比如 no = 1 是电视机的开和关的操作</span></span><br><span class="line">		remoteController.setCommand(<span class="number">1</span>, tvOnCommand, tvOffCommand);</span><br><span class="line">		System.out.println(<span class="string">&quot;--------按下电视机的开按钮-----------&quot;</span>);</span><br><span class="line">		remoteController.onButtonWasPushed(<span class="number">1</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;--------按下电视机的关按钮-----------&quot;</span>);</span><br><span class="line">		remoteController.offButtonWasPushed(<span class="number">1</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;--------按下撤销按钮-----------&quot;</span>);</span><br><span class="line">		remoteController.undoButtonWasPushed();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-4、命令模式在Spring框架的应用与源码"><a href="#17-4、命令模式在Spring框架的应用与源码" class="headerlink" title="17.4、命令模式在Spring框架的应用与源码"></a>17.4、命令模式在Spring框架的应用与源码</h3><p>Spring 框架的 JdbcTemplate 就使用到了命令模式</p>
<p>代码分析：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/164.png" alt="image-20210417014539023"></p>
<p>具体代码：</p>
<p>JdbcTemplate类的query方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/165.png" alt="image-20210417021850007"></p>
<p>在query方法使用递归调用了query方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/166.png" alt="image-20210417022006816"></p>
<p>query方法：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/167.png" alt="image-20210417022151453"></p>
<p>StatementCallback接口，里面有doInstatement抽象方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/168.png" alt="image-20210417022235885"></p>
<p>QueryStatementCallback这个静态内部类实现了StatementCallback接口，在里面实现了doInstatement抽象方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/169.png" alt="image-20210417022649537"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/170.png" alt="image-20210417022952614"></p>
<p>同时，QueryStatementCallback又作为实现者/接收者(Receiver) 角色执行execute方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/171.png" alt="image-20210417023039518"></p>
<p>StatementCallback接口的其他实现类：ExecuteStatementCallback</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/173.png" alt="image-20210417023427416"></p>
<p>ExecuteStatementCallback的excute方法：最后调用了JdbcTemplate的excute方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/172.png" alt="image-20210417023156907"></p>
<p>JdbcTemplate的excute方法：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/174.png" alt="image-20210417023635405"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/175.png" alt="image-20210417023940383"></p>
<h3 id="17-5、命令模式总结"><a href="#17-5、命令模式总结" class="headerlink" title="17.5、命令模式总结"></a>17.5、命令模式总结</h3><p>主要优点：</p>
<ol>
<li>通过<strong>引入中间件（抽象接口）降低系统的耦合度</strong>。</li>
<li><strong>扩展性良好</strong>，<strong>增加或删除命令非常方便</strong>。采用命令模式增加与删除命令不会影响其他类，且<strong>满足“开闭原则”</strong>。</li>
<li>可以实现宏命令。<strong>命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令</strong>。</li>
<li><strong>方便实现 Undo 和 Redo 操作</strong>。命令模式可以与后面介绍的<strong>备忘录模式结合，实现命令的撤销与恢复</strong>。</li>
<li>可以在现有命令的基础上，<strong>增加额外功能</strong>。比如<strong>日志记录，结合装饰器模式会更加灵活</strong>。</li>
</ol>
<p>缺点是：</p>
<ol>
<li>可能产生<strong>大量具体的命令类</strong>。因为<strong>每一个具体操作都需要设计一个具体命令类</strong>，这会增加系统的复杂性。</li>
<li>命令模式的结果其实就是<strong>接收方的执行结果</strong>，但是为了以命令的形式进行架构、解耦请求与实现，引入了额外类型结构（引入了请求方与抽象命令接口），增加了理解上的困难。不过这也是设计模式的通病，抽象必然会额外增加类的数量，代码抽离肯定比代码聚合更加难理解。</li>
</ol>
<p>命令模式的应用场景：</p>
<p>当系统的<strong>某项操作具备命令语义</strong>，且<strong>命令实现不稳定（变化）</strong>时，可以通过命令模式解耦请求与实现。使用抽象命令接口使请求方的代码架构稳定，封装接收方具体命令的实现细节。<strong>接收方与抽象命令呈现弱耦合</strong>（内部方法无需一致），具备良好的扩展性。</p>
<p>命令模式通常适用于以下场景：</p>
<ol>
<li><strong>请求调用者需要与请求接收者解耦</strong>时，命令模式可以使调用者和接收者不直接交互。</li>
<li>系统<strong>随机请求命令或经常增加、删除命令</strong>时，命令模式可以方便地实现这些功能。</li>
<li>当系统需要<strong>执行一组操作</strong>时，命令模式可以定义宏命令来实现该功能。</li>
<li>当系统需要<strong>支持命令的撤销（Undo）操作和恢复（Redo）操作</strong>时，可以<strong>将命令对象存储起来</strong>，采用<strong>备忘录模式</strong>来实现。</li>
<li>界面的一个按钮都是一条命令、模拟 CMD（DOS 命令）订单的撤销/恢复、触发- 反馈机制</li>
</ol>
<h3 id="17-6、命令模式扩展"><a href="#17-6、命令模式扩展" class="headerlink" title="17.6、命令模式扩展"></a>17.6、命令模式扩展</h3><p>在软件开发中，有时将命令模式与前面学的<strong>组合模式</strong>联合使用，这就构成了<strong>宏命令模式</strong>，也叫<strong>组合命令模式</strong>。<strong>宏命令包含了一组命令，它充当了具体命令与调用者的双重角色</strong>，执行它时将<strong>递归调用它所包含的所有命令</strong>，其具体结构图如图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/163.png" alt="image-20210417013804833"></p>
<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> command;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositeCommandPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractCommand cmd1 = <span class="keyword">new</span> ConcreteCommand1();</span><br><span class="line">        AbstractCommand cmd2 = <span class="keyword">new</span> ConcreteCommand2();</span><br><span class="line">        CompositeInvoker ir = <span class="keyword">new</span> CompositeInvoker();</span><br><span class="line">        ir.add(cmd1);</span><br><span class="line">        ir.add(cmd2);</span><br><span class="line">        System.out.println(<span class="string">&quot;客户访问调用者的execute()方法...&quot;</span>);</span><br><span class="line">        ir.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象命令</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AbstractCommand</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树叶构件: 具体命令1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand1</span> <span class="keyword">implements</span> <span class="title">AbstractCommand</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CompositeReceiver receiver;</span><br><span class="line">    ConcreteCommand1() &#123;</span><br><span class="line">        receiver = <span class="keyword">new</span> CompositeReceiver();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver.action1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树叶构件: 具体命令2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand2</span> <span class="keyword">implements</span> <span class="title">AbstractCommand</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CompositeReceiver receiver;</span><br><span class="line">    ConcreteCommand2() &#123;</span><br><span class="line">        receiver = <span class="keyword">new</span> CompositeReceiver();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver.action2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树枝构件: 调用者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompositeInvoker</span> <span class="keyword">implements</span> <span class="title">AbstractCommand</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;AbstractCommand&gt; children = <span class="keyword">new</span> ArrayList&lt;AbstractCommand&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(AbstractCommand c)</span> </span>&#123;</span><br><span class="line">        children.add(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(AbstractCommand c)</span> </span>&#123;</span><br><span class="line">        children.remove(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractCommand <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> children.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Object obj : children) &#123;</span><br><span class="line">            ((AbstractCommand) obj).execute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接收者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompositeReceiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收者的action1()方法被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收者的action2()方法被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-7、进阶阅读"><a href="#17-7、进阶阅读" class="headerlink" title="17.7、进阶阅读"></a>17.7、进阶阅读</h3><p>如果您想深入了解命令模式，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8485.html">《使用命令模式实现播放器功能》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8486.html">《命令模式在框架（JDK和JUnit）源码中的应用》</a></li>
</ul>
<h3 id="17-8、相关设计模式"><a href="#17-8、相关设计模式" class="headerlink" title="17.8、相关设计模式"></a>17.8、相关设计模式</h3><ul>
<li><p>Composite 模式</p>
<p>有时会使用Composite模式实现宏命令(macrocommand)。</p>
</li>
<li><p>Memento 模式</p>
<p>有时会使用Memento模式来保存Command角色的历史记录。</p>
</li>
<li><p>Protype 模式</p>
<p>有时会使用Protype模式复制发生的事件（生成的命令）。</p>
</li>
</ul>
<h3 id="17-9、命令模式的注意事项与细节"><a href="#17-9、命令模式的注意事项与细节" class="headerlink" title="17.9、命令模式的注意事项与细节"></a>17.9、命令模式的注意事项与细节</h3><ol>
<li>将发起请求的对象与执行请求的对象解耦。发起请求的对象是调用者，调用者只要调用命令对象的 execute()方法就可以让接收者工作，而不必知道具体的接收者对象是谁、是如何实现的，命令对象会负责让接收者执行请求的动作，也就是说：<strong>”请求发起者”和“请求执行者”之间的解耦是通过命令对象实现的，命令对象起到了纽带桥梁的作用</strong>。</li>
<li>容易设计一个<strong>命令队列</strong>。只要把命令对象放到列队，就可以<strong>多线程的执行命令</strong></li>
<li>容易实现<strong>对请求的撤销和重做</strong></li>
<li>命令模式不足：可能导致某些系统有<strong>过多的具体命令类</strong>，增加了系统的复杂度，这点在在使用的时候要注意</li>
<li><strong>空命令也是一种设计模式</strong>，它为我们<strong>省去了判空的操作</strong>。在上面的实例中，如果没有用空命令，我们每按下一个按键都要判空，这给我们编码带来一定的麻烦。</li>
<li>命令模式经典的应用场景：<strong>界面的一个按钮都是一条命令</strong>、<strong>模拟 CMD（DOS 命令）订单的撤销/恢复</strong>、<strong>触发- 反馈机制</strong></li>
</ol>
<h2 id="18、访问者模式Visitor（行为型模式）"><a href="#18、访问者模式Visitor（行为型模式）" class="headerlink" title="18、访问者模式Visitor（行为型模式）"></a>18、访问者模式Visitor（行为型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/blog\XGH-blog\source_posts\设计模式\176.png" alt="image-20210417141823535"></p>
<h3 id="18-1、基本介绍"><a href="#18-1、基本介绍" class="headerlink" title="18.1、基本介绍"></a>18.1、基本介绍</h3><ol>
<li>访问者模式（Visitor Pattern），<strong>封装一些作用于某种数据结构的各元素的操作</strong>，它可以在<strong>不改变数据结构</strong>的前提下定义作用于这些元素的<strong>新的操作</strong>。为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。</li>
<li>主要将<strong>数据结构与数据操作分离</strong>，<strong>解决数据结构和操作耦合</strong>性问题</li>
<li>访问者模式的基本工作原理是：在<strong>被访问的类里面加一个对外提供接待访问者的接口</strong></li>
<li>访问者模式主要应用场景是：需要<strong>对一个对象结构中的对象进行很多不同操作(这些操作彼此没有关联)**，同时需要</strong>避免让这些操作”污染”这些对象的类**，可以选用访问者模式解决</li>
</ol>
<h3 id="18-2、访问者模式的原理结构图-uml类图"><a href="#18-2、访问者模式的原理结构图-uml类图" class="headerlink" title="18.2、访问者模式的原理结构图-uml类图"></a>18.2、访问者模式的原理结构图-uml类图</h3><p>访问者（Visitor）模式实现的关键是<strong>如何将作用于元素的操作分离出来封装成独立的类</strong></p>
<h4 id="18-2-1、模式的结构"><a href="#18-2-1、模式的结构" class="headerlink" title="18.2.1、模式的结构"></a>18.2.1、模式的结构</h4><p>访问者模式包含以下主要角色。</p>
<ol>
<li><strong>抽象访问者（Visitor）</strong>角色：<strong>定义一个访问具体元素的接口</strong>，为<strong>每个具体元素类对应一个访问操作 visit()</strong> ，该操作中的**参数类型标识了被访问的<code>具体元素</code>**。即：为该对象结构中的 ConcreteElement 的每一个类声明一个 visit 操作。</li>
<li><strong>具体访问者（ConcreteVisitor）</strong>角色：<strong>实现抽象访问者角色</strong>中声明的<strong>各个访问操作</strong>，确定访问者访问一个元素时该做什么。</li>
<li><strong>抽象元素（Element）</strong>角色：声明<strong>一个包含接受操作 accept() 的接口</strong>，<strong>被接受的访问者对象作为 accept() 方法的参数</strong>。即：定义一个 accept 方法，接收一个访问者对象。（与<strong>抽象访问者（Visitor）</strong>角色实现互相关联（但相关联的抽象元素的具体实现类））</li>
<li><strong>具体元素（ConcreteElement）</strong>角色：实现抽象元素角色提供的 accept() 操作，其<strong>方法体通常都是 visitor.visit(this)</strong> （<strong>双分派</strong>），另外具体元素中可能还包含本身业务逻辑的相关操作。</li>
<li><strong>对象结构（Object Structure）</strong>角色：是<strong>一个包含元素角色的容器</strong>，提供让访问者对象遍历容器中的所有元素的方法，通常由 <code>List</code>、<code>Set</code>、<code>Map</code> 等聚合类实现。</li>
</ol>
<p>其结构图类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/177.png" alt="img"></p>
<h4 id="18-2-2、代码实现"><a href="#18-2-2、代码实现" class="headerlink" title="18.2.2、代码实现"></a>18.2.2、代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.c.visitor;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VisitorPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ObjectStructure os = <span class="keyword">new</span> ObjectStructure();</span><br><span class="line">        os.add(<span class="keyword">new</span> ConcreteElementA());</span><br><span class="line">        os.add(<span class="keyword">new</span> ConcreteElementB());</span><br><span class="line">        Visitor visitor = <span class="keyword">new</span> ConcreteVisitorA();</span><br><span class="line">        os.accept(visitor);</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line">        visitor = <span class="keyword">new</span> ConcreteVisitorB();</span><br><span class="line">        os.accept(visitor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象访问者</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数是具体的元素类</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB element)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体访问者A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteVisitorA</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体访问者A访问--&gt;&quot;</span> + element.operationA());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB element)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体访问者A访问--&gt;&quot;</span> + element.operationB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体访问者B类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteVisitorB</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体访问者B访问--&gt;&quot;</span> + element.operationA());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB element)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体访问者B访问--&gt;&quot;</span> + element.operationB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象元素类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数是Visitor访问类</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体元素A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteElementA</span> <span class="keyword">implements</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过visit(this)实现双分派</span></span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operationA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;具体元素A的操作。&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体元素B类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteElementB</span> <span class="keyword">implements</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operationB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;具体元素B的操作。&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对象结构角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectStructure</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Element&gt; list = <span class="keyword">new</span> ArrayList&lt;Element&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        Iterator&lt;Element&gt; i = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            ((Element) i.next()).accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">        list.add(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">        list.remove(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18-3、应用举例"><a href="#18-3、应用举例" class="headerlink" title="18.3、应用举例"></a>18.3、应用举例</h3><p>测评系统的需求</p>
<p>将观众分为男人和女人，对歌手进行测评，当看完某个歌手表演后，得到他们对该歌手不同的评价(评价有不同的种类，比如 成功、失败等，之后会增加一种状态“待定”以测试程序的扩展性)</p>
<h4 id="18-3-1、使用传统方式解决需求"><a href="#18-3-1、使用传统方式解决需求" class="headerlink" title="18.3.1、使用传统方式解决需求"></a>18.3.1、使用传统方式解决需求</h4><p>思路分析：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/178.png" alt="image-20210417144957917"></p>
<p>传统方式的问题分析：</p>
<ol>
<li>如果系统比较小，还是 ok 的，但是考虑<strong>系统增加越来越多新的功能</strong>时，对代码改动较大，<strong>违反了 ocp 原则</strong>， 不利于维护</li>
<li>扩展性不好，比如增加了新的人员类型，或者管理方法，都不好做</li>
<li>引出我们会使用新的设计模式 – 访问者模式</li>
</ol>
<h4 id="18-3-2、使用访问者模式解决需求"><a href="#18-3-2、使用访问者模式解决需求" class="headerlink" title="18.3.2、使用访问者模式解决需求"></a>18.3.2、使用访问者模式解决需求</h4><p>思路分析（类图）：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/179.png" alt="image-20210417145718031"></p>
<p>代码实现：</p>
<p>Action：行为抽象类，在里面的方法将<strong>具体元素作为参数传入</strong>。<strong>抽象访问者（Visitor）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">	<span class="comment">//得到男性 的测评</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getManResult</span><span class="params">(Man man)</span></span>;</span><br><span class="line">	<span class="comment">//得到女的 测评</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getWomanResult</span><span class="params">(Woman woman)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Success：成功的行为。<strong>具体访问者（ConcreteVisitor）</strong>角色（Fail失败与Wait待定等等行为类似）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Success</span> <span class="keyword">extends</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getManResult</span><span class="params">(Man man)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; 男人给的评价该歌手很成功 !&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getWomanResult</span><span class="params">(Woman woman)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; 女人给的评价该歌手很成功 !&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Person：人类，<strong>将访问者Visitor作为参数传入accept()方法</strong>。<strong>抽象元素（Element）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="comment">//提供一个方法，让访问者可以访问</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Action action)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Man：男人，重写父类的accept方法，并在accept方法里调用<strong>访问者的方法并将this作为参数</strong>传入，以此实现双分派。<strong>具体元素（ConcreteElement）</strong>角色（Woman女人类类似）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//说明</span></span><br><span class="line"><span class="comment">//1. 这里我们使用到了双分派, 即首先在客户端程序中，将具体状态作为参数传递Woman中(第一次分派)</span></span><br><span class="line"><span class="comment">//2. 然后Man类调用作为参数的 &quot;具体方法&quot; 中方法getWomanResult, 同时将自己(this)作为参数</span></span><br><span class="line"><span class="comment">//   传入，完成第二次的分派</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Action action)</span> </span>&#123;</span><br><span class="line">		action.getManResult(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ObjectStructure：<strong>对象结构（Object Structure）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据结构，管理很多人（Man , Woman）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectStructure</span> </span>&#123;</span><br><span class="line">	<span class="comment">//维护了一个集合</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;Person&gt; persons = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	<span class="comment">//增加到list</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">		persons.add(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//移除</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">		persons.remove(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//显示测评情况</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Action action)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(Person p: persons) &#123;</span><br><span class="line">			p.accept(action);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：客户端，用来进行调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建ObjectStructure</span></span><br><span class="line">		ObjectStructure objectStructure = <span class="keyword">new</span> ObjectStructure();</span><br><span class="line">		objectStructure.attach(<span class="keyword">new</span> Man());</span><br><span class="line">		objectStructure.attach(<span class="keyword">new</span> Woman());</span><br><span class="line">		<span class="comment">// 成功</span></span><br><span class="line">		Success success = <span class="keyword">new</span> Success();</span><br><span class="line">		objectStructure.display(success);</span><br><span class="line">		<span class="comment">// 失败</span></span><br><span class="line">		System.out.println(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line">		Fail fail = <span class="keyword">new</span> Fail();</span><br><span class="line">		objectStructure.display(fail);</span><br><span class="line">  		<span class="comment">// 待定</span></span><br><span class="line">		System.out.println(<span class="string">&quot;=======给的是待定的测评========&quot;</span>);	</span><br><span class="line">		Wait wait = <span class="keyword">new</span> Wait();</span><br><span class="line">		objectStructure.display(wait);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18-4、双分派"><a href="#18-4、双分派" class="headerlink" title="18.4、双分派"></a>18.4、双分派</h3><p>整理一下 Visitor 模式中方法的调用关系：</p>
<ul>
<li><p>accept（接受）方法的调用方式如下：</p>
<p>element.accept(visitor); </p>
</li>
<li><p>visit（访问）方法的调用方式如下：</p>
</li>
<li><p> visitor.visit(element); </p>
</li>
</ul>
<p>对比一下这两个方法会发现， 它们是相反的关系。 <strong>element 接受 visitor, 而 visitor 又访问 element</strong>。</p>
<p>在 Visitor 模式中， ConcreteElement 和 ConcreteVisitor 这两个角色<strong>共同决定了实际进行的处理</strong>。这种消息分发的方式一般被称为双重分发 (double dispatch)。</p>
<p>访问者模式为了实现所谓的“双重分派”，设计了<strong>一个回调再回调的机制</strong>。因为Java只支持基于多态的单分派模式，这里强行模拟出“双重分派”反而加大了代码的复杂性。</p>
<p>所谓双分派是指<strong>不管类怎么变化</strong>，我们<strong>都能找到期望的方法运行</strong>。双分派意味着<strong>得到执行的操作取决于请求的种类和两个接收者的类型</strong></p>
<p>上述实例为例，假设我们要添加一个 <strong>Wait</strong> 的状态类，考察 <strong>Man</strong> 类和 <strong>Woman</strong> 类的反应，由于使用了双分派，只需增加一个 Action 子类即可在客户端调用即可，不需要改动任何其他类的代码。</p>
<h3 id="18-5、访问者模式总结"><a href="#18-5、访问者模式总结" class="headerlink" title="18.5、访问者模式总结"></a>18.5、访问者模式总结</h3><p>主要优点如下：</p>
<ol>
<li><strong>扩展性好</strong>。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。</li>
<li><strong>复用性好</strong>。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。</li>
<li><strong>灵活性好</strong>。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。</li>
<li><strong>符合单一职责原则</strong>。访问者模式<strong>把相关的行为封装在一起，构成一个访问者</strong>，使每一个访问者的功能都比较单一。可以做报表、UI、拦截器与过滤器，适用于数据结构相对稳定的系统</li>
</ol>
<p>主要缺点如下：</p>
<ol>
<li><strong>增加新的元素类很困难</strong>。在访问者模式中，每增加一个新的元素类，都要在<strong>每一个具体访问者类中增加相应的具体操作</strong>，这<strong>违背了“开闭原则”</strong>。</li>
<li><strong>破坏封装</strong>。访问者模式中<strong>具体元素对访问者公布细节</strong>，这破坏了对象的封装性。</li>
<li><strong>违反了依赖倒置原则</strong>。访问者模式<strong>依赖了具体类，而没有依赖抽象类</strong>。</li>
<li>具体元素对访问者公布细节，<strong>违反了迪米特原则</strong></li>
</ol>
<p>总结一下就是：易于增加的ConcreteVisitor角色，难以增加的ConcreteElement角色</p>
<p>模式的应用场景：</p>
<p>当系统中存在<strong>类型数量稳定（固定）的一类数据结构</strong>时，可以使用访问者模式方便地实现对该类型所有数据结构的不同操作，而又不会对数据产生任何副作用（脏数据）。</p>
<p>简而言之，就是<strong>当对集合中的不同类型数据（类型数量稳定）进行多种操作</strong>时，使用访问者模式。</p>
<p>通常在以下情况可以考虑使用访问者（Visitor）模式：</p>
<ol>
<li><strong>对象结构相对稳定</strong>，但其<strong>操作算法经常变化</strong>的程序。</li>
<li>对象结构中的对象<strong>需要提供多种不同且不相关的操作</strong>，而且要<strong>避免让这些操作的变化影响对象</strong>的结构。</li>
<li><strong>对象结构包含很多类型的对象</strong>，希望对这些对象实施一些依赖于其具体类型的操作。</li>
</ol>
<h3 id="18-6、访问者模式扩展"><a href="#18-6、访问者模式扩展" class="headerlink" title="18.6、访问者模式扩展"></a>18.6、访问者模式扩展</h3><p>访问者（Visitor）模式是使用频率较高的一种设计模式，它<strong>常常同以下两种设计模式联用</strong>。</p>
<ul>
<li>与“<strong>迭代器模式</strong>”联用。因为访问者模式中的“<strong>对象结构</strong>”是一个<strong>包含元素角色的容器</strong>，当<strong>访问者遍历容器中的所有元素时，常常要用迭代器</strong>。如应用举例中的对象结构是用 List 实现的，它通过 List 对象的 Iterator() 方法获取迭代器。如果对象结构中的聚合类没有提供迭代器，也可以用迭代器模式自定义一个。</li>
<li><strong>访问者（Visitor）模式</strong>同“<strong>组合模式</strong>”联用。因为访问者（Visitor）模式中的“<strong>元素对象</strong>”<strong>可能是叶子对象或者是容器对象</strong>，如果<strong>元素对象包含容器对象，就必须用到组合模式</strong>，其结构图如图：</li>
</ul>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/180.png" alt="image-20210417153952680"></p>
<h3 id="18-7、进阶阅读"><a href="#18-7、进阶阅读" class="headerlink" title="18.7、进阶阅读"></a>18.7、进阶阅读</h3><p>如果您想深入了解访问者模式，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8499.html">《访问者模式的伪动态双分派》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8501.html">《访问者模式在JDK源码中的应用》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8502.html">《访问者模式在Spring源码中的应用》</a></li>
</ul>
<h3 id="18-8、相关设计模式"><a href="#18-8、相关设计模式" class="headerlink" title="18.8、相关设计模式"></a>18.8、相关设计模式</h3><ul>
<li><p>Iterator模式</p>
<p>Iterator模式和Visitor模式都是在某种数据结构上进行处理。 </p>
<p>Iterator模式用于逐个遍历保存在数据结构中的元素。</p>
<p>Visitor模式用于对保存在数据结构中的元素进行某种特定的处理。</p>
</li>
<li><p>Composite模式</p>
<p>有时访问者所访问的数据结构会使用Composite模式。</p>
</li>
<li><p>Interpreter模式</p>
<p>在Interpreter模式中， 有时会使用Visitor模式。 例如， 在生成了语法树后， 可能会使用Visitor 模式访问语法树的各个节点进行处理。</p>
</li>
</ul>
<h2 id="19、迭代器模式Iterator（行为型模式）"><a href="#19、迭代器模式Iterator（行为型模式）" class="headerlink" title="19、迭代器模式Iterator（行为型模式）"></a>19、迭代器模式Iterator（行为型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/181.png" alt="image-20210417155331998"></p>
<h3 id="19-1、基本介绍"><a href="#19-1、基本介绍" class="headerlink" title="19.1、基本介绍"></a>19.1、基本介绍</h3><ol>
<li>迭代器模式（Iterator Pattern）是常用的设计模式，属于<strong>行为型模式</strong></li>
<li>如果我们的<strong>集合元素是用不同的方式实现</strong>的，有数组，还有 java 的集合类，或者还有其他方式，当客户端<strong>要遍历</strong>这些集合元素的时候<strong>就要使用多种遍历方式</strong>，而且还<strong>会暴露元素的内部结构</strong>，可以考虑使用迭代器模式解决。</li>
<li>迭代器模式，<strong>提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素</strong>，不需要知道集合对象的底层表示，即：<strong>不暴露其内部的结构</strong>。</li>
<li>迭代器模式在客户访问类与聚合类之间插入一个迭代器，这<strong>分离了聚合对象与其遍历行为</strong>，对客户也隐藏了其内部细节，且满足“单一职责原则”和“开闭原则”</li>
</ol>
<h3 id="19-2、迭代器模式的原理结构图-uml类图"><a href="#19-2、迭代器模式的原理结构图-uml类图" class="headerlink" title="19.2、迭代器模式的原理结构图-uml类图"></a>19.2、迭代器模式的原理结构图-uml类图</h3><p>迭代器模式是通过将<strong>聚合对象的遍历行为分离出来，抽象成迭代器类</strong>来实现的，其目的是<strong>在不暴露聚合对象的内部结构的</strong>情况下，<strong>让外部代码透明地访问聚合的内部数据</strong>。现在我们来分析其基本结构与实现方法。</p>
<h4 id="19-2-1、-模式的结构"><a href="#19-2-1、-模式的结构" class="headerlink" title="19.2.1、 模式的结构"></a>19.2.1、 模式的结构</h4><p>迭代器模式主要包含以下角色：</p>
<ol>
<li><strong>抽象聚合（Aggregate）</strong>角色：一个统一的聚合接口， 将客户端和具体聚合解耦。定义存储、添加、删除聚合对象以及创建迭代器对象的接口。</li>
<li><strong>具体聚合（ConcreteAggregate）</strong>角色：实现抽象聚合类，并提供一个方法，返回一个具体迭代器的实例。该迭代器可以正确遍历集合</li>
<li><strong>抽象迭代器（Iterator）</strong>角色：<strong>定义访问和遍历聚合元素的接口</strong>，是java系统提供的，通常包含 <strong>hasNext()、remove()、next()</strong> 等方法。</li>
<li><strong>具体迭代器（Concretelterator）</strong>角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。</li>
<li><strong>Client</strong> :客户端，  通过 Iterator 和   Aggregate 依赖子类</li>
</ol>
<p>其结构图类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/183.png" alt="image-20210417182430431"></p>
<h4 id="19-2-2、代码实现"><a href="#19-2-2、代码实现" class="headerlink" title="19.2.2、代码实现"></a>19.2.2、代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.c.iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Aggregate ag = <span class="keyword">new</span> ConcreteAggregate();</span><br><span class="line">        ag.add(<span class="string">&quot;中山大学&quot;</span>);</span><br><span class="line">        ag.add(<span class="string">&quot;华南理工&quot;</span>);</span><br><span class="line">        ag.add(<span class="string">&quot;韶关学院&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;聚合的内容有：&quot;</span>);</span><br><span class="line">        Iterator it = ag.getIterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            Object ob = it.next();</span><br><span class="line">            System.out.print(ob.toString() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Object ob = it.first();</span><br><span class="line">        System.out.println(<span class="string">&quot;\nFirst：&quot;</span> + ob.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象聚合</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体聚合</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteAggregate</span> <span class="keyword">implements</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        list.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        list.remove(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> ConcreteIterator(list));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象迭代器</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">first</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体迭代器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; list = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteIterator</span><span class="params">(List&lt;Object&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; list.size() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        Object obj = list.get(index);</span><br><span class="line">        ;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hasNext()) &#123;</span><br><span class="line">            obj = list.get(++index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="19-3、应用举例"><a href="#19-3、应用举例" class="headerlink" title="19.3、应用举例"></a>19.3、应用举例</h3><p>编写程序展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院， 一个学院有多个系。如图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/184.png" alt="image-20210417183413954"></p>
<h4 id="19-3-1、使用传统方式解决需求"><a href="#19-3-1、使用传统方式解决需求" class="headerlink" title="19.3.1、使用传统方式解决需求"></a>19.3.1、使用传统方式解决需求</h4><p>思路解析（类图）</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/97.png" alt="image-20210415205605144"></p>
<p>传统的方式的问题分析：</p>
<ol>
<li>将学院看做是学校的子类，系是学院的子类，这样实际上是站在组织大小来进行分层次的</li>
<li>实际上我们的要求是 ：在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系， 因此这种方案，不能很好实现的遍历的操作</li>
<li>解决方案：=&gt; 迭代器模式</li>
</ol>
<h4 id="19-3-2、使用迭代器模式解决需求"><a href="#19-3-2、使用迭代器模式解决需求" class="headerlink" title="19.3.2、使用迭代器模式解决需求"></a>19.3.2、使用迭代器模式解决需求</h4><p>原理类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/186.png" alt="image-20210417184732598"></p>
<p>代码实现：</p>
<p>Department：专业。元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> String desc;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Department</span><span class="params">(String name, String desc)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.desc = desc;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> desc;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.desc = desc;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>抽象迭代器（Iterator）</strong>角色：java自带的Iterator迭代器接口</p>
<p>ComputerCollegeIterator：计算机学院迭代器，实现了迭代器接口里的hasNext()与next()方法，<strong>具体迭代器（Concretelterator）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerCollegeIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">	<span class="comment">//这里我们需要Department 是以怎样的方式存放=&gt;数组</span></span><br><span class="line">	Department[] departments;</span><br><span class="line">	<span class="keyword">int</span> position = <span class="number">0</span>; <span class="comment">//遍历的位置</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ComputerCollegeIterator</span><span class="params">(Department[] departments)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.departments = departments;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断是否还有下一个元素</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">if</span>(position &gt;= departments.length || departments[position] == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Department department = departments[position];</span><br><span class="line">		position += <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> department;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//删除的方法，默认空实现</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>InfoColleageIterator：信息学院迭代器，实现了迭代器接口里的hasNext()与next()方法，<strong>具体迭代器（Concretelterator）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InfoColleageIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">	List&lt;Department&gt; departmentList; <span class="comment">// 信息工程学院是以List方式存放系</span></span><br><span class="line">	<span class="keyword">int</span> index = -<span class="number">1</span>;<span class="comment">//索引</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">InfoColleageIterator</span><span class="params">(List&lt;Department&gt; departmentList)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.departmentList = departmentList;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断list中还有没有下一个元素</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">if</span>(index &gt;= departmentList.size() - <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			index += <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> departmentList.get(index);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//空实现remove</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>College：学院接口，里面有createIterator()方法返回一个迭代器。<strong>抽象聚合（Aggregate）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">College</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//增加系的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDepartment</span><span class="params">(String name, String desc)</span></span>;</span><br><span class="line">	<span class="comment">//返回一个迭代器,遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Iterator <span class="title">createIterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ComputerCollege：计算机学院，实现学院接口，里面对专业这个元素<strong>采用数组方式</strong>存储。<strong>具体聚合（ConcreteAggregate）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerCollege</span> <span class="keyword">implements</span> <span class="title">College</span> </span>&#123;</span><br><span class="line">	Department[] departments;</span><br><span class="line">	<span class="keyword">int</span> numOfDepartment = <span class="number">0</span> ;<span class="comment">// 保存当前数组的对象个数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ComputerCollege</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		departments = <span class="keyword">new</span> Department[<span class="number">5</span>];</span><br><span class="line">		addDepartment(<span class="string">&quot;Java专业&quot;</span>, <span class="string">&quot; Java专业 &quot;</span>);</span><br><span class="line">		addDepartment(<span class="string">&quot;PHP专业&quot;</span>, <span class="string">&quot; PHP专业 &quot;</span>);</span><br><span class="line">		addDepartment(<span class="string">&quot;大数据专业&quot;</span>, <span class="string">&quot; 大数据专业 &quot;</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;计算机学院&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDepartment</span><span class="params">(String name, String desc)</span> </span>&#123;</span><br><span class="line">		Department department = <span class="keyword">new</span> Department(name, desc);</span><br><span class="line">		departments[numOfDepartment] = department;</span><br><span class="line">		numOfDepartment += <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Iterator <span class="title">createIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ComputerCollegeIterator(departments);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>InfoCollege：信息学院，实现学院接口，里面对专业这个元素<strong>采用集合</strong>方式存储。<strong>具体聚合（ConcreteAggregate）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InfoCollege</span> <span class="keyword">implements</span> <span class="title">College</span> </span>&#123;</span><br><span class="line">	List&lt;Department&gt; departmentList;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">InfoCollege</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		departmentList = <span class="keyword">new</span> ArrayList&lt;Department&gt;();</span><br><span class="line">		addDepartment(<span class="string">&quot;信息安全专业&quot;</span>, <span class="string">&quot; 信息安全专业 &quot;</span>);</span><br><span class="line">		addDepartment(<span class="string">&quot;网络安全专业&quot;</span>, <span class="string">&quot; 网络安全专业 &quot;</span>);</span><br><span class="line">		addDepartment(<span class="string">&quot;服务器安全专业&quot;</span>, <span class="string">&quot; 服务器安全专业 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;信息工程学院&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDepartment</span><span class="params">(String name, String desc)</span> </span>&#123;</span><br><span class="line">		Department department = <span class="keyword">new</span> Department(name, desc);</span><br><span class="line">		departmentList.add(department);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Iterator <span class="title">createIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> InfoColleageIterator(departmentList);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OutPutImpl：遍历实现对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutPutImpl</span> </span>&#123;</span><br><span class="line">	<span class="comment">//学院集合</span></span><br><span class="line">	List&lt;College&gt; collegeList;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">OutPutImpl</span><span class="params">(List&lt;College&gt; collegeList)</span> </span>&#123;	</span><br><span class="line">		<span class="keyword">this</span>.collegeList = collegeList;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//遍历所有学院,然后调用printDepartment 输出各个学院的系</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printCollege</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//从collegeList 取出所有学院, Java 中的 List 已经实现Iterator</span></span><br><span class="line">		Iterator&lt;College&gt; iterator = collegeList.iterator();</span><br><span class="line">		<span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">			<span class="comment">//取出一个学院</span></span><br><span class="line">			College college = iterator.next();</span><br><span class="line">			System.out.println(<span class="string">&quot;=== &quot;</span>+college.getName() +<span class="string">&quot;=====&quot;</span> );</span><br><span class="line">			printDepartment(college.createIterator()); <span class="comment">//得到对应迭代器</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//输出 学院输出 系</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printDepartment</span><span class="params">(Iterator iterator)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">			Department d = (Department)iterator.next();</span><br><span class="line">			System.out.println(d.getName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建学院</span></span><br><span class="line">		List&lt;College&gt; collegeList = <span class="keyword">new</span> ArrayList&lt;College&gt;();</span><br><span class="line">		ComputerCollege computerCollege = <span class="keyword">new</span> ComputerCollege();</span><br><span class="line">		InfoCollege infoCollege = <span class="keyword">new</span> InfoCollege();</span><br><span class="line">        </span><br><span class="line">		collegeList.add(computerCollege);</span><br><span class="line">		collegeList.add(infoCollege);</span><br><span class="line">        </span><br><span class="line">		OutPutImpl outPutImpl = <span class="keyword">new</span> OutPutImpl(collegeList);</span><br><span class="line">		outPutImpl.printCollege();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="19-4、迭代器模式在JDK的应用与源码"><a href="#19-4、迭代器模式在JDK的应用与源码" class="headerlink" title="19.4、迭代器模式在JDK的应用与源码"></a>19.4、迭代器模式在JDK的应用与源码</h3><p>JDK 的 <strong>ArrayList</strong> 集合中就使用了迭代器模式</p>
<p>类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/189.png" alt="image-20210417202305992"></p>
<p>角色说明：</p>
<ul>
<li>内部类 Itr 充当具体实现迭代器 Iterator 的类， 作为 ArrayList 内部类</li>
<li>List 就是充当了聚合接口，含有一个 iterator() 方法，返回一个迭代器对象</li>
<li>ArrayList 是实现聚合接口 List 的子类，实现了 iterator()</li>
<li>Iterator 接口系统提供</li>
<li>迭代器模式解决了 不同集合(ArrayList ,LinkedList) 统一遍历问题</li>
</ul>
<p>代码分析：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/188.png" alt="image-20210417200928815"></p>
<p>List接口，其中有获取迭代器Iterator的抽象方法，交给实现类去实现</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/191.png" alt="image-20210417203037908"></p>
<p>ArrayList实现了List接口，并实现了List接口的Iterator方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/190.png" alt="image-20210417202736654"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/192.png" alt="image-20210417203908088"></p>
<p>在ArrayList中把元素对象存进了数组里面</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/193.png" alt="image-20210417204155507"></p>
<p>Itr为ArrayList的内部类，实现了Iterator接口，并实现了接口的next()方法与hasNext()方法，由于元素是定义在ArrayList当中的，直接使用即可。</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/194.png" alt="image-20210417204819687"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/195.png" alt="image-20210417205056646"></p>
<p>另外实现List接口的实现类的LinkedList类</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/196.png" alt="image-20210417210006152"></p>
<p>LinkedList继承了AbstractSequentialList类实现了AbstractSequentialList类当中的Iterator迭代器方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/197.png" alt="image-20210417210011958"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/198.png" alt="image-20210417211542896"></p>
<p>Enumerator实现了Iterator接口</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/200.png" alt="image-20210417224627356"></p>
<h3 id="19-5、迭代器模式总结"><a href="#19-5、迭代器模式总结" class="headerlink" title="19.5、迭代器模式总结"></a>19.5、迭代器模式总结</h3><p>主要优点如下：</p>
<ol>
<li><strong>访问一个聚合对象的内容而无须暴露它的内部</strong>表示。</li>
<li><strong>遍历任务交由迭代器完成</strong>，这简化了聚合类。</li>
<li>它<strong>支持以不同方式遍历一个聚合</strong>，甚至可以<strong>自定义迭代器的子类以支持新的遍历</strong>。</li>
<li><strong>增加新的聚合类和迭代器类</strong>都很方便，<strong>无须修改原有代码</strong>。</li>
<li><strong>封装性良好</strong>，为遍历不同的聚合结构提供一个统一的接口。</li>
</ol>
<p>其主要缺点是：<strong>增加了类的个数</strong>，这在一定程度上增加了系统的复杂性。</p>
<p>在日常开发中，我们<strong>几乎不会自己写迭代器</strong>。除非需要定制一个自己实现的数据结构对应的迭代器，否则，<strong>开源框架提供的 API 完全够用</strong>。</p>
<p>应用场景：</p>
<ol>
<li>当<strong>需要为聚合对象提供多种遍历方式</strong>时。</li>
<li>当<strong>需要为遍历不同的聚合结构提供一个统一的接口</strong>时。</li>
<li>当<strong>访问一个聚合对象的内容而无须暴露其内部细节的表示</strong>时。</li>
<li>当要<strong>展示一组相似对象，或者遍历一组相同对象</strong>时。</li>
</ol>
<p>由于<strong>聚合与迭代器的关系非常密切</strong>，所以大多数语言在实现聚合类时都提供了迭代器类，因此大数情况下使用语言中已有的聚合类的迭代器就已经够了。</p>
<h3 id="19-6、迭代器模式扩展"><a href="#19-6、迭代器模式扩展" class="headerlink" title="19.6、迭代器模式扩展"></a>19.6、迭代器模式扩展</h3><p><strong>迭代器模式常常与组合模式结合起来使用</strong>，在<strong>对组合模式中的容器构件进行访问</strong>时，经常<strong>将迭代器潜藏在组合模式的容器构成类</strong>中。当然也<strong>可以构造一个外部迭代器来对容器构件进行访问</strong>，其结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/187.png" alt="image-20210417200821530"></p>
<h3 id="19-7、进阶阅读"><a href="#19-7、进阶阅读" class="headerlink" title="19.7、进阶阅读"></a>19.7、进阶阅读</h3><p>如果您想了解迭代器模式在框架源码中的应用，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8497.html">《迭代器模式在JDK源码中的应用》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8498.html">《迭代器模式在MyBatis源码中的应用》</a></li>
</ul>
<h3 id="19-8、相关设计模式"><a href="#19-8、相关设计模式" class="headerlink" title="19.8、相关设计模式"></a>19.8、相关设计模式</h3><ul>
<li><p>Visitor 模式</p>
<p>Iterator模式是从集合中一个一个取出元素进行遍历， 但是并没有在Iterator接口中声明对取出的元素进行何种处理。</p>
<p>Visitor模式则是在遍历元素集合的过程中， 对元素进行相同的处理。</p>
<p>在遍历集合的过程中对元素进行固定的处理是常有的需求。 Visitor模式正是为了应对这种需求而出现的。 在访问元素集合的过程中对元素进行相同的处理， 这种模式就是Visitor模式。</p>
</li>
<li><p>Composite 模式</p>
<p>Composite模式是具有递归结构的模式， 在其中使用Iterator模式比较困难。</p>
</li>
<li><p>Factory Method 模式</p>
<p>在iterator方法中生成Iterator的实例时可能会使用Factory Method模式。</p>
</li>
</ul>
<h3 id="19-9、迭代器模式的注意事项与细节"><a href="#19-9、迭代器模式的注意事项与细节" class="headerlink" title="19.9、迭代器模式的注意事项与细节"></a>19.9、迭代器模式的注意事项与细节</h3><p>提供了一种设计思想，就是一个类应该只有一个引起变化的原因（叫做单一责任原则）。在聚合类中，我们把迭代器分开，就是要把管理对象集合和遍历对象集合的责任分开，这样一来集合改变的话，只影响到聚合对象。而如果遍历方式改变的话，只影响到了迭代器。</p>
<h2 id="20、观察者模式Observer（行为型模式）"><a href="#20、观察者模式Observer（行为型模式）" class="headerlink" title="20、观察者模式Observer（行为型模式）"></a>20、观察者模式Observer（行为型模式）</h2><h3 id="20-1、基本介绍"><a href="#20-1、基本介绍" class="headerlink" title="20.1、基本介绍"></a>20.1、基本介绍</h3><ol>
<li><p>观察者（Observer）模式的定义：指<strong>多个对象间存在一对多的依赖关系</strong>，当<strong>一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新</strong>。这种模式有时又称作<strong>发布-订阅模式</strong>、<strong>模型-视图模式</strong>，它是<strong>对象行为型模式</strong>。</p>
</li>
<li><p>观察者模式类似订牛奶业务</p>
</li>
<li><p>奶站/气象局：Subject 用户/第三方网站：Observer</p>
</li>
<li><p>Subject：登记注册、移除和通知</p>
<ul>
<li>registerObserver 注 册</li>
<li>removeObserver 移 除</li>
<li>notifyObservers() 通知所有的注册的用户，根据不同需求，可以是更新数据，让用户来取，也可能是实施推送， 看具体需求定</li>
<li>Observer：接收输入</li>
</ul>
<p>观察者模式：对象之间多对一依赖的一种设计方案，被依赖的对象为 Subject，依赖的对象为 Observer，Subject</p>
<p>通知 Observer 变化,比如这里的奶站是 Subject，是 1 的一方。用户时 Observer，是多的一方。</p>
</li>
</ol>
<h3 id="20-2、观察者模式的原理结构图-uml类图"><a href="#20-2、观察者模式的原理结构图-uml类图" class="headerlink" title="20.2、观察者模式的原理结构图-uml类图"></a>20.2、观察者模式的原理结构图-uml类图</h3><p>实现观察者模式时要注意<strong>具体目标对象</strong>和<strong>具体观察者对象之间不能直接调用</strong>，否则<strong>将使两者之间紧密耦合起来</strong>，这<strong>违反了面向对象的设计原则</strong>。</p>
<h4 id="20-2-1、模式的结构"><a href="#20-2-1、模式的结构" class="headerlink" title="20.2.1、模式的结构"></a>20.2.1、模式的结构</h4><p>观察者模式的主要角色如下：</p>
<ol>
<li><strong>抽象主题（Subject）</strong>角色：也叫<strong>抽象目标类</strong>，它提供了一个<strong>用于保存观察者对象的聚集类和增加、删除观察者对象的方法</strong>，以及<strong>通知所有观察者的抽象方法</strong>。</li>
<li><strong>具体主题（Concrete Subject）</strong>角色：也叫<strong>具体目标类</strong>，它<strong>实现抽象目标中的通知方法</strong>，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。</li>
<li><strong>抽象观察者（Observer）</strong>角色：它是<strong>一个抽象类或接口</strong>，它<strong>包含了一个更新自己的抽象方法</strong>，当接到具体主题的更改通知时被调用。</li>
<li><strong>具体观察者（Concrete Observer）</strong>角色：<strong>实现抽象观察者中定义的抽象方法</strong>，以便在得到目标的更改通知时更新自身的状态。</li>
</ol>
<p>观察者模式的结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/199.png" alt="image-20210417224339045"></p>
<h4 id="20-2-2、代码实现"><a href="#20-2-2、代码实现" class="headerlink" title="20.2.2、代码实现"></a>20.2.2、代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.c.observer;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject subject = <span class="keyword">new</span> ConcreteSubject();</span><br><span class="line">        Observer obs1 = <span class="keyword">new</span> ConcreteObserver1();</span><br><span class="line">        Observer obs2 = <span class="keyword">new</span> ConcreteObserver2();</span><br><span class="line">        subject.add(obs1);</span><br><span class="line">        subject.add(obs2);</span><br><span class="line">        subject.notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象目标</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line">    <span class="comment">//增加观察者方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除观察者方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>; <span class="comment">//通知观察者方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体目标</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体目标发生改变...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object obs : observers) &#123;</span><br><span class="line">            ((Observer) obs).response();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象观察者</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">response</span><span class="params">()</span></span>; <span class="comment">//反应</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体观察者1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver1</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体观察者1作出反应！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体观察者1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver2</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体观察者2作出反应！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="20-3、应用举例"><a href="#20-3、应用举例" class="headerlink" title="20.3、应用举例"></a>20.3、应用举例</h3><p>天气预报项目需求，具体要求如下：</p>
<ol>
<li>气象站可以将每天测量到的温度，湿度，气压等等以公告的形式发布出去(比如发布到自己的网站或第三方)。</li>
<li>需要设计开放型 <strong>API</strong>，便于其他第三方也能接入气象站获取数据。</li>
<li>提供温度、气压和湿度的接口</li>
<li>测量数据更新时，要能实时的通知给第三方</li>
</ol>
<h4 id="20-3-1、使用传统方法解决需求"><a href="#20-3-1、使用传统方法解决需求" class="headerlink" title="20.3.1、使用传统方法解决需求"></a>20.3.1、使用传统方法解决需求</h4><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418001550797.png" alt="image-20210418001550797"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418001617106.png" alt="image-20210418001617106"></p>
<p>实现代码：</p>
<p>WeatherData：天气情况</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418002547098.png" alt="image-20210418002547098"></p>
<p>CurrentConditions</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418002701455.png" alt="image-20210418002701455"></p>
<p>Client</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418002801559.png" alt="image-20210418002801559"></p>
<p>问题分析：</p>
<ol>
<li>其他第三方接入气象站获取数据的问题</li>
<li>无法在运行时动态的添加第三方 (新浪网站)</li>
<li>违反 ocp 原则=&gt;观察者模式</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在 WeatherData 中，当增加一个第三方，都需要创建一个对应的第三方的公告板对象，并加入到 dataChange, 不利于维护，也不是动态加入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dataChange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    currentConditions.update(getTemperature(), getPressure(), getHumidity());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="20-3-2、使用观察者模式解决需求"><a href="#20-3-2、使用观察者模式解决需求" class="headerlink" title="20.3.2、使用观察者模式解决需求"></a>20.3.2、使用观察者模式解决需求</h4><p>类图说明：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418002150098.png" alt="image-20210418002150098"></p>
<p>代码实现：</p>
<p>Subject：<strong>抽象主题（Subject）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口, 让WeatherData 来实现 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WeatherData：包含最新的天气情况信息。<strong>具体主题（Concrete Subject）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类是核心</span></span><br><span class="line"><span class="comment"> * 1. 包含最新的天气情况信息 </span></span><br><span class="line"><span class="comment"> * 2. 含有 观察者集合，使用ArrayList管理</span></span><br><span class="line"><span class="comment"> * 3. 当数据有更新时，就主动的调用   ArrayList, 通知所有的（接入方）就看到最新的信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">float</span> temperatrue;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">float</span> pressure;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line">	<span class="comment">//观察者集合</span></span><br><span class="line">	<span class="keyword">private</span> ArrayList&lt;Observer&gt; observers;</span><br><span class="line">	<span class="comment">//加入新的第三方</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">WeatherData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		observers = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getTemperature</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> temperatrue;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPressure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> pressure;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getHumidity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> humidity;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dataChange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//调用 接入方的 update</span></span><br><span class="line">		notifyObservers();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//当数据有更新时，就调用 setData</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> pressure, <span class="keyword">float</span> humidity)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.temperatrue = temperature;</span><br><span class="line">		<span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">		<span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">		<span class="comment">//调用dataChange， 将最新的信息 推送给 接入方 currentConditions</span></span><br><span class="line">		dataChange();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//注册一个观察者</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		observers.add(o);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//移除一个观察者</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(observers.contains(o)) &#123;</span><br><span class="line">			observers.remove(o);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//遍历所有的观察者，并通知</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; observers.size(); i++) &#123;</span><br><span class="line">			observers.get(i).update(<span class="keyword">this</span>.temperatrue, <span class="keyword">this</span>.pressure, <span class="keyword">this</span>.humidity);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Observer：观察者接口，由观察者来实现。<strong>抽象观察者（Observer）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//观察者接口，由观察者来实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> pressure, <span class="keyword">float</span> humidity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CurrentConditions：当前环境。<strong>具体观察者（Concrete Observer）</strong>角色（百度、新浪等等第三方类似）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentConditions</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 温度，气压，湿度</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">float</span> pressure;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line">	<span class="comment">// 更新 天气情况，是由 WeatherData 来调用，我使用推送模式</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> pressure, <span class="keyword">float</span> humidity)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">		<span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">		<span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">		display();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 显示</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;***Today mTemperature: &quot;</span> + temperature + <span class="string">&quot;***&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;***Today mPressure: &quot;</span> + pressure + <span class="string">&quot;***&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;***Today mHumidity: &quot;</span> + humidity + <span class="string">&quot;***&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建一个WeatherData</span></span><br><span class="line">		WeatherData weatherData = <span class="keyword">new</span> WeatherData();</span><br><span class="line">		<span class="comment">//创建观察者</span></span><br><span class="line">		CurrentConditions currentConditions = <span class="keyword">new</span> CurrentConditions();</span><br><span class="line">		BaiduSite baiduSite = <span class="keyword">new</span> BaiduSite();</span><br><span class="line">		<span class="comment">//注册到weatherData</span></span><br><span class="line">		weatherData.registerObserver(currentConditions);</span><br><span class="line">		weatherData.registerObserver(baiduSite);</span><br><span class="line">		<span class="comment">//测试</span></span><br><span class="line">		System.out.println(<span class="string">&quot;通知各个注册的观察者, 看看信息&quot;</span>);</span><br><span class="line">		weatherData.setData(<span class="number">10f</span>, <span class="number">100f</span>, <span class="number">30.3f</span>);</span><br><span class="line">		weatherData.removeObserver(currentConditions);</span><br><span class="line">		<span class="comment">//测试</span></span><br><span class="line">		System.out.println();</span><br><span class="line">		System.out.println(<span class="string">&quot;通知各个注册的观察者, 看看信息&quot;</span>);</span><br><span class="line">		weatherData.setData(<span class="number">10f</span>, <span class="number">100f</span>, <span class="number">30.3f</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="20-4、观察者模式在JDK的应用与源码"><a href="#20-4、观察者模式在JDK的应用与源码" class="headerlink" title="20.4、观察者模式在JDK的应用与源码"></a>20.4、观察者模式在JDK的应用与源码</h3><p>Jdk 的 Observable 类就使用了观察者模式</p>
<p>角色分析：</p>
<ul>
<li>Observable  的作用和地位等价于 我们前面讲过 Subject</li>
<li>Observable 是类，不是接口，类中已经实现了核心的方法 ,即管理 Observer 的方法 add.. delete .. notify…</li>
<li>Observer 的作用和地位等价于我们前面讲过的 Observer, 有 update</li>
<li>Observable 和 Observer 的使用方法和前面讲过的一样，只是 Observable 是类，通过继承来实现观察者模式</li>
</ul>
<p>代码分析</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418015159710.png" alt="image-20210418015159710"></p>
<p>Observable：相当于Subject接口，但是Observable为一个普通的类</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418015442922.png" alt="image-20210418015442922"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418015737148.png" alt="image-20210418015737148"></p>
<p>Observe接口：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418015636229.png" alt="image-20210418015636229"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418020018759.png" alt="image-20210418020018759"></p>
<h3 id="20-5、观察者模式总结"><a href="#20-5、观察者模式总结" class="headerlink" title="20.5、观察者模式总结"></a>20.5、观察者模式总结</h3><p>主要优点如下：</p>
<ol>
<li><strong>降低了目标与观察者之间的耦合关系</strong>，两者之间是抽象耦合关系。<strong>符合依赖倒置原则</strong>。</li>
<li><strong>目标与观察者之间建立了一套触发机制</strong>。</li>
</ol>
<p>主要缺点如下：</p>
<ol>
<li><p>如果在<strong>观察者和观察目标之间有循环依赖</strong>的话，<strong>观察目标会触发它们之间进行循环调用，可能导致系统崩溃</strong></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418011458744.png" alt="image-20210418011458744"></p>
</li>
<li><p>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</p>
</li>
<li><p>当<strong>观察者对象很多</strong>时，<strong>通知的发布会花费很多时间，影响程序的效率</strong>。</p>
</li>
</ol>
<p>在软件系统中，当系统一方行为依赖另一方行为的变动时，可使用观察者模式松耦合联动双方，使得一方的变动可以通知到感兴趣的另一方对象，从而让另一方对象对此做出响应。</p>
<p>观察者模式的应用情景：</p>
<ol>
<li>对象间<strong>存在一对多关系</strong>，<strong>一个对象的改变将导致其他一个或多个对象也发生改变</strong>，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li>
<li>一个对象必须通知其他对象，而并不知道这些对象是谁</li>
<li>当<strong>一个抽象模型有两个方面</strong>，其中<strong>一个方面依赖于另一方面时，可将这二者封装在独立的对象中以使它们可以各自独立地改变和复用</strong>。</li>
<li><strong>实现类似广播机制的功能</strong>，不需要知道具体收听者，只需分发广播，系统中感兴趣的对象会自动接收该广播。</li>
<li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，<strong>多层级嵌套使用，形成一种链式触发机制，使得事件具备跨域（跨越两种观察者类型）通知。</strong></li>
</ol>
<h3 id="20-6、观察者模式扩展"><a href="#20-6、观察者模式扩展" class="headerlink" title="20.6、观察者模式扩展"></a>20.6、观察者模式扩展</h3><p>在 Java 中，通过 <code>java.util.Observable</code> 类和 <code>java.util.Observer</code> 接口<strong>定义了观察者模式</strong>，只要实现它们的子类就可以编写观察者模式实例。</p>
<h4 id="20-6-1、-Observable类"><a href="#20-6-1、-Observable类" class="headerlink" title="20.6.1、 Observable类"></a>20.6.1、 Observable类</h4><p>Observable 类是<strong>抽象目标类</strong>，它<strong>有一个 Vector 向量</strong>，<strong>用于保存所有要通知的观察者对象</strong>，下面来介绍它最重要的 3 个方法：</p>
<ol>
<li>void addObserver(Observer o) 方法：用于将新的观察者对象添加到向量中。</li>
<li>void notifyObservers(Object arg) 方法：调用向量中的所有观察者对象的 update() 方法，通知它们数据发生改变。<strong>通常越晚加入向量的观察者越先得到通知</strong>。（类似于栈结构）</li>
<li>void setChange() 方法：用来设置一个 boolean 类型的内部标志位，注明目标对象发生了变化。当它为真时，notifyObservers() 才会通知观察者。</li>
</ol>
<h4 id="20-6-2、-Observer-接口"><a href="#20-6-2、-Observer-接口" class="headerlink" title="20.6.2、 Observer 接口"></a>20.6.2、 Observer 接口</h4><p>Observer 接口是<strong>抽象观察者</strong>，它<strong>监视目标对象的变化</strong>，当目标对象发生变化时，观察者得到通知，并调用 void update(Observable o,Object arg) 方法，进行相应的工作。</p>
<h4 id="20-6-3、对应例子"><a href="#20-6-3、对应例子" class="headerlink" title="20.6.3、对应例子"></a>20.6.3、对应例子</h4><p>利用 Observable 类和 Observer 接口实现原油期货的观察者模式实例。</p>
<p>分析：当原油价格上涨时，空方伤心，多方局兴；当油价下跌时，空方局兴，多方伤心。本实例中的抽象目标（Observable）类在 Java 中已经定义，可以直接定义其子类，即原油期货（OilFutures）类，它是具体目标类，该类中定义一个 SetPriCe(float price) 方法，当原油数据发生变化时调用其父类的 notifyObservers(Object arg) 方法来通知所有观察者；另外，本实例中的抽象观察者接口（Observer）在 Java 中已经定义，只要定义其子类，即具体观察者类（包括多方类 Bull 和空方类 Bear），并实现 update(Observable o,Object arg) 方法即可。</p>
<p>相关类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418010916983.png" alt="image-20210418010916983"></p>
<h4 id="20-6-4、java-util-Observer接口和java-util-Observable类的相关解析"><a href="#20-6-4、java-util-Observer接口和java-util-Observable类的相关解析" class="headerlink" title="20.6.4、java. util.Observer接口和java. util . Observable类的相关解析"></a>20.6.4、java. util.Observer接口和java. util . Observable类的相关解析</h4><p>话虽如此，但是java. util.Observer接口和java. util . Observable类并不好用。理由很简单，传递给java. util . Observer接口的Subject角色必须是java . util. Observable类型(或者它的子类型)的。但Java只能单继承， 也就说如果Subject角色已经是某个类的子类了，那么它将无法继承java . util . Observable类。</p>
<h3 id="20-7、进阶阅读"><a href="#20-7、进阶阅读" class="headerlink" title="20.7、进阶阅读"></a>20.7、进阶阅读</h3><p>如果您想了解观察者模式在实际项目中的应用，可猛击阅读<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8494.html">《基于Java API实现通知机制》</a>文章。</p>
<h3 id="20-8、相关设计模式"><a href="#20-8、相关设计模式" class="headerlink" title="20.8、相关设计模式"></a>20.8、相关设计模式</h3><p>Mediator模式</p>
<ul>
<li>在Mediator模式中，有时会使用Observer模式来实现Mediator角色与Colleague角色之间的通信。</li>
<li>就“发送状态变化通知”这一- 点而言，Mediator 模式与Observer模式是类似的。不过，两种模式中，通知的目的和视角不同。</li>
<li>在Mediator模式中，虽然也会发送通知，不过那不过是为了对Colleague角色进行仲裁而已。</li>
<li>而在Observer模式中，将Subject角色的状态变化通知给Observer 角色的目的则主要是为了使Subject角色和Observer角色同步。</li>
</ul>
<h3 id="20-9、观察者模式的注意事项与细节"><a href="#20-9、观察者模式的注意事项与细节" class="headerlink" title="20.9、观察者模式的注意事项与细节"></a>20.9、观察者模式的注意事项与细节</h3><ol>
<li>观察者模式，又称<strong>发布-订阅模式</strong>，是一种一对多的通知机制，使得双方无需关心对方，只关心通知本身</li>
<li>JAVA 中已经有了对观察者模式的支持类，但一般不支持使用。</li>
<li><strong>避免循环引用</strong>。</li>
<li>各个观察者是<strong>依次获得的同步通知</strong>，如果上一个观察者处理太慢，会导致下一个观察者不能及时获得通知。此外，如果观察者在处理通知的时候，发生了异常，还需要被观察者处理异常，才能保证继续通知下一个观察者。</li>
<li>如果顺序执行，某一观察者错误会导致系统卡壳，<strong>一般采用异步方式</strong>。</li>
</ol>
<h2 id="21、中介者模式Mediator（行为型模式）"><a href="#21、中介者模式Mediator（行为型模式）" class="headerlink" title="21、中介者模式Mediator（行为型模式）"></a>21、中介者模式Mediator（行为型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418021014591.png" alt="image-20210418021014591"></p>
<h3 id="21-1、基本介绍"><a href="#21-1、基本介绍" class="headerlink" title="21.1、基本介绍"></a>21.1、基本介绍</h3><ol>
<li><p>中介者模式（Mediator Pattern），又称调停者模式，是迪米特法则的典型应用。用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。它的目的是把多方会谈变成双方会谈，从而实现多方的松耦合。</p>
</li>
<li><p>中介者模式属于行为型模式，使代码易于维护</p>
</li>
<li><p>比如 MVC 模式，C（Controller 控制器）是 M（Model 模型）和 V（View 视图）的中介者，在前后端交互时起到了中间人的作用</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418141702195.png" alt="image-20210418141702195"></p>
</li>
</ol>
<h3 id="21-2、中介者模式的原理结构图-uml类图"><a href="#21-2、中介者模式的原理结构图-uml类图" class="headerlink" title="21.2、中介者模式的原理结构图-uml类图"></a>21.2、中介者模式的原理结构图-uml类图</h3><p>中介者模式实现的关键是找出“中介者”，下面对它的结构和实现进行分析。</p>
<h4 id="21-2-1、模式的结构"><a href="#21-2-1、模式的结构" class="headerlink" title="21.2.1、模式的结构"></a>21.2.1、模式的结构</h4><p>中介者模式包含以下主要角色。</p>
<ol>
<li><strong>抽象中介者（Mediator）</strong>角色：它是中介者的接口，<strong>提供了同事对象注册与转发同事对象信息</strong>的抽象方法。</li>
<li><strong>具体中介者（Concrete Mediator）</strong>角色：实现中介者接口，定义一个 List 来管理同事对象，<strong>协调各个同事角色之间的交互关系</strong>，因此<strong>它依赖于同事角色</strong>。</li>
<li><strong>抽象同事类（Colleague）</strong>角色：定义同事类的接口，<strong>保存中介者对象</strong>，<strong>提供同事对象交互的抽象方法</strong>，<strong>实现所有相互影响的同事类的公共功能</strong>。</li>
<li><strong>具体同事类（Concrete Colleague）</strong>角色：是抽象同事类的实现者，当需要与其他同事对象交互时，<strong>由中介者对象负责后续的交互。</strong></li>
</ol>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418141912987.png" alt="image-20210418141912987"></p>
<p>中介者模式的结构图如图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418141852365.png" alt="image-20210418141852365"></p>
<h4 id="21-2-2、代码实现"><a href="#21-2-2、代码实现" class="headerlink" title="21.2.2、代码实现"></a>21.2.2、代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.c.mediator;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediatorPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mediator md = <span class="keyword">new</span> ConcreteMediator();</span><br><span class="line">        Colleague c1, c2;</span><br><span class="line">        c1 = <span class="keyword">new</span> ConcreteColleague1();</span><br><span class="line">        c2 = <span class="keyword">new</span> ConcreteColleague2();</span><br><span class="line">        md.register(c1);</span><br><span class="line">        md.register(c2);</span><br><span class="line">        c1.send();</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line">        c2.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象中介者</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Colleague colleague)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">relay</span><span class="params">(Colleague cl)</span></span>; <span class="comment">//转发</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体中介者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Colleague&gt; colleagues = <span class="keyword">new</span> ArrayList&lt;Colleague&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Colleague colleague)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!colleagues.contains(colleague)) &#123;</span><br><span class="line">            colleagues.add(colleague);</span><br><span class="line">            colleague.setMedium(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">relay</span><span class="params">(Colleague cl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Colleague ob : colleagues) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ob.equals(cl)) &#123;</span><br><span class="line">                ((Colleague) ob).receive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象同事类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Mediator mediator;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMedium</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体同事类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteColleague1</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体同事类1收到请求。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体同事类1发出请求。&quot;</span>);</span><br><span class="line">        mediator.relay(<span class="keyword">this</span>); <span class="comment">//请中介者转发</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体同事类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteColleague2</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体同事类2收到请求。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体同事类2发出请求。&quot;</span>);</span><br><span class="line">        mediator.relay(<span class="keyword">this</span>); <span class="comment">//请中介者转发</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="21-3、应用举例"><a href="#21-3、应用举例" class="headerlink" title="21.3、应用举例"></a>21.3、应用举例</h3><p>智能家庭项目：</p>
<ol>
<li>智能家庭包括各种设备，闹钟、咖啡机、电视机、窗帘 等</li>
<li>主人要看电视时，各个设备可以协同工作，自动完成看电视的准备工作</li>
<li>比如流程为：闹铃响起-&gt;咖啡机开始做咖啡-&gt;窗帘自动落下-&gt;电视机开始播放</li>
</ol>
<h4 id="21-3-1、使用传统方式解决需求"><a href="#21-3-1、使用传统方式解决需求" class="headerlink" title="21.3.1、使用传统方式解决需求"></a>21.3.1、使用传统方式解决需求</h4><p>思路分析（类图）</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418142259490.png" alt="image-20210418142259490"></p>
<p>传统的方式的问题分析： </p>
<ol>
<li>当各电器对象有多种状态改变时，相互之间的调用关系会比较复杂</li>
<li><strong>各个电器对象彼此联系，你中有我，我中有你，不利于松耦合</strong>.</li>
<li>各个电器对象之间所传递的消息(参数)，容易混乱当系统增加一个新的电器对象时，或者执行流程改变时，代码的可维护性、扩展性都不理想 =》 考虑中介者模式</li>
</ol>
<h4 id="21-3-2、使用中介者模式解决需求"><a href="#21-3-2、使用中介者模式解决需求" class="headerlink" title="21.3.2、使用中介者模式解决需求"></a>21.3.2、使用中介者模式解决需求</h4><p>思路分析（类图）：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418142556064.png" alt="image-20210418142556064"></p>
<p>代码实现：</p>
<p>Mediator：中介者。<strong>抽象中介者（Mediator）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">	<span class="comment">//将给中介者对象，加入到集合中</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Register</span><span class="params">(String colleagueName, Colleague colleague)</span></span>;</span><br><span class="line">	<span class="comment">//接收消息, 具体的同事对象发出</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">GetMessage</span><span class="params">(<span class="keyword">int</span> stateChange, String colleagueName)</span></span>;</span><br><span class="line">    <span class="comment">//发送消息</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Colleague：<strong>抽象同事类（Colleague）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同事抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Mediator mediator;</span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Colleague</span><span class="params">(Mediator mediator, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Mediator <span class="title">GetMediator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.mediator;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(<span class="keyword">int</span> stateChange)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConcreteMediator：<strong>具体中介者（Concrete Mediator）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体的中介者类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">	<span class="comment">//集合，放入所有的同事对象</span></span><br><span class="line">	<span class="keyword">private</span> HashMap&lt;String, Colleague&gt; colleagueMap;</span><br><span class="line">	<span class="keyword">private</span> HashMap&lt;String, String&gt; interMap;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ConcreteMediator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		colleagueMap = <span class="keyword">new</span> HashMap&lt;String, Colleague&gt;();</span><br><span class="line">		interMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Register</span><span class="params">(String colleagueName, Colleague colleague)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 将具体的同事类放入集合中</span></span><br><span class="line">		colleagueMap.put(colleagueName, colleague);</span><br><span class="line">		<span class="keyword">if</span> (colleague <span class="keyword">instanceof</span> Alarm) &#123;</span><br><span class="line">			interMap.put(<span class="string">&quot;Alarm&quot;</span>, colleagueName);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleague <span class="keyword">instanceof</span> CoffeeMachine) &#123;</span><br><span class="line">			interMap.put(<span class="string">&quot;CoffeeMachine&quot;</span>, colleagueName);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleague <span class="keyword">instanceof</span> TV) &#123;</span><br><span class="line">			interMap.put(<span class="string">&quot;TV&quot;</span>, colleagueName);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleague <span class="keyword">instanceof</span> Curtains) &#123;</span><br><span class="line">			interMap.put(<span class="string">&quot;Curtains&quot;</span>, colleagueName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//具体中介者的核心方法</span></span><br><span class="line">	<span class="comment">//1. 根据得到消息，完成对应任务</span></span><br><span class="line">	<span class="comment">//2. 中介者在这个方法，协调各个具体的同事对象，完成任务</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetMessage</span><span class="params">(<span class="keyword">int</span> stateChange, String colleagueName)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//处理闹钟发出的消息</span></span><br><span class="line">		<span class="keyword">if</span> (colleagueMap.get(colleagueName) <span class="keyword">instanceof</span> Alarm) &#123;</span><br><span class="line">			<span class="keyword">if</span> (stateChange == <span class="number">0</span>) &#123;</span><br><span class="line">				((CoffeeMachine) (colleagueMap.get(interMap</span><br><span class="line">						.get(<span class="string">&quot;CoffeeMachine&quot;</span>)))).StartCoffee();</span><br><span class="line">				((TV) (colleagueMap.get(interMap.get(<span class="string">&quot;TV&quot;</span>)))).StartTv();</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (stateChange == <span class="number">1</span>) &#123;</span><br><span class="line">				((TV) (colleagueMap.get(interMap.get(<span class="string">&quot;TV&quot;</span>)))).StopTv();</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="comment">//处理咖啡机发出的消息</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleagueMap.get(colleagueName) <span class="keyword">instanceof</span> CoffeeMachine) &#123;</span><br><span class="line">			((Curtains) (colleagueMap.get(interMap.get(<span class="string">&quot;Curtains&quot;</span>))))</span><br><span class="line">					.UpCurtains();</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleagueMap.get(colleagueName) <span class="keyword">instanceof</span> TV) &#123;<span class="comment">//如果TV发现消息</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleagueMap.get(colleagueName) <span class="keyword">instanceof</span> Curtains) &#123;</span><br><span class="line">			<span class="comment">//如果是以窗帘发出的消息，这里处理...</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>具体同事类（Concrete Colleague）</strong>角色：</p>
<p>Alarm：闹钟同事类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体的同事类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Alarm</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Alarm</span><span class="params">(Mediator mediator, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(mediator, name);</span><br><span class="line">		<span class="comment">//在创建Alarm 同事对象时，将自己放入到ConcreteMediator 对象中[集合]</span></span><br><span class="line">		mediator.Register(name, <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendAlarm</span><span class="params">(<span class="keyword">int</span> stateChange)</span> </span>&#123;</span><br><span class="line">		SendMessage(stateChange);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(<span class="keyword">int</span> stateChange)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//调用的中介者对象的getMessage</span></span><br><span class="line">		<span class="keyword">this</span>.GetMediator().GetMessage(stateChange, <span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CoffeeMachine：咖啡机</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeMachine</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CoffeeMachine</span><span class="params">(Mediator mediator, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(mediator, name);</span><br><span class="line">		mediator.Register(name, <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(<span class="keyword">int</span> stateChange)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.GetMediator().GetMessage(stateChange, <span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StartCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;It&#x27;s time to startcoffee!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FinishCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;After 5 minutes!&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;Coffee is ok!&quot;</span>);</span><br><span class="line">		SendMessage(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TV：电视机、Curtains：窗帘类似</p>
<p>Client：客户端。负责调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建一个中介者对象</span></span><br><span class="line">		Mediator mediator = <span class="keyword">new</span> ConcreteMediator();</span><br><span class="line">		<span class="comment">//创建Alarm 并且加入到  ConcreteMediator 对象的HashMap</span></span><br><span class="line">		Alarm alarm = <span class="keyword">new</span> Alarm(mediator, <span class="string">&quot;alarm&quot;</span>);</span><br><span class="line">		<span class="comment">//创建了CoffeeMachine 对象，并且加入到ConcreteMediator对象的HashMap</span></span><br><span class="line">		CoffeeMachine coffeeMachine = <span class="keyword">new</span> CoffeeMachine(mediator,<span class="string">&quot;coffeeMachine&quot;</span>);</span><br><span class="line">		<span class="comment">//创建 Curtains , 并且加入到ConcreteMediator对象的HashMap</span></span><br><span class="line">		Curtains curtains = <span class="keyword">new</span> Curtains(mediator, <span class="string">&quot;curtains&quot;</span>);</span><br><span class="line">		TV tV = <span class="keyword">new</span> TV(mediator, <span class="string">&quot;TV&quot;</span>);</span><br><span class="line">		<span class="comment">//让闹钟发出消息</span></span><br><span class="line">		alarm.SendAlarm(<span class="number">0</span>);</span><br><span class="line">		coffeeMachine.FinishCoffee();</span><br><span class="line">		alarm.SendAlarm(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="21-4、中介者模式总结"><a href="#21-4、中介者模式总结" class="headerlink" title="21.4、中介者模式总结"></a>21.4、中介者模式总结</h3><p>主要优点如下：</p>
<ol>
<li><strong>类之间各司其职，符合迪米特法则。</strong></li>
<li><strong>降低了对象之间的耦合性</strong>，使得对象易于独立地被复用。</li>
<li>将<strong>对象间的一对多关联转变为一对一的关联</strong>，把<strong>多边关系变成多个双边关系</strong>，提高系统的灵活性，使得系统易于维护和扩展。</li>
</ol>
<p>其主要缺点是：</p>
<ol>
<li>中介者模式将原本<strong>多个对象直接的相互依赖</strong>变成了<strong>中介者和多个同事类的依赖关系</strong>。</li>
<li>当<strong>同事类越多</strong>时，<strong>中介者就会越臃肿</strong>，变得复杂且难以维护。</li>
</ol>
<p>中介者模式的应用场景：</p>
<ul>
<li>当<strong>对象之间存在复杂的网状结构关系</strong>而导致依赖关系混乱且难以复用时。</li>
<li>当想<strong>创建一个运行于多个类之间的对象，又不想生成新的子类</strong>时。</li>
</ul>
<h3 id="21-5、中介者模式扩展"><a href="#21-5、中介者模式扩展" class="headerlink" title="21.5、中介者模式扩展"></a>21.5、中介者模式扩展</h3><p>在实际开发中，通常采用以下两种方法来简化中介者模式，使开发变得更简单。</p>
<ol>
<li><strong>不定义中介者接口</strong>，把<strong>具体中介者对象实现成为单例</strong>。</li>
<li><strong>同事对象不持有中介者</strong>，而是<strong>在需要的时候直接获取中介者对象并调用</strong>。</li>
</ol>
<p>简化中介者模式的结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418143949322.png" alt="image-20210418143949322"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.c.mediator;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMediatorPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleColleague c1, c2;</span><br><span class="line">        c1 = <span class="keyword">new</span> SimpleConcreteColleague1();</span><br><span class="line">        c2 = <span class="keyword">new</span> SimpleConcreteColleague2();</span><br><span class="line">        c1.send();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">        c2.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简单单例中介者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleMediator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SimpleMediator smd = <span class="keyword">new</span> SimpleMediator();</span><br><span class="line">    <span class="keyword">private</span> List&lt;SimpleColleague&gt; colleagues = <span class="keyword">new</span> ArrayList&lt;SimpleColleague&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SimpleMediator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SimpleMediator <span class="title">getMedium</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (smd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(SimpleColleague colleague)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!colleagues.contains(colleague)) &#123;</span><br><span class="line">            colleagues.add(colleague);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">relay</span><span class="params">(SimpleColleague scl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (SimpleColleague ob : colleagues) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ob.equals(scl)) &#123;</span><br><span class="line">                ((SimpleColleague) ob).receive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象同事类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SimpleColleague</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体同事类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleConcreteColleague1</span> <span class="keyword">implements</span> <span class="title">SimpleColleague</span> </span>&#123;</span><br><span class="line">    SimpleConcreteColleague1() &#123;</span><br><span class="line">        SimpleMediator smd = SimpleMediator.getMedium();</span><br><span class="line">        smd.register(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体同事类1：收到请求。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleMediator smd = SimpleMediator.getMedium();</span><br><span class="line">        System.out.println(<span class="string">&quot;具体同事类1：发出请求...&quot;</span>);</span><br><span class="line">        smd.relay(<span class="keyword">this</span>); <span class="comment">//请中介者转发</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体同事类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleConcreteColleague2</span> <span class="keyword">implements</span> <span class="title">SimpleColleague</span> </span>&#123;</span><br><span class="line">    SimpleConcreteColleague2() &#123;</span><br><span class="line">        SimpleMediator smd = SimpleMediator.getMedium();</span><br><span class="line">        smd.register(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体同事类2：收到请求。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleMediator smd = SimpleMediator.getMedium();</span><br><span class="line">        System.out.println(<span class="string">&quot;具体同事类2：发出请求...&quot;</span>);</span><br><span class="line">        smd.relay(<span class="keyword">this</span>); <span class="comment">//请中介者转发</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="21-6、进阶阅读"><a href="#21-6、进阶阅读" class="headerlink" title="21.6、进阶阅读"></a>21.6、进阶阅读</h3><p>如果您想了解中介者模式在JDK源码中的应用，可猛击阅读<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8496.html">《中介者模式在JDK源码中的应用》</a>文章。</p>
<h3 id="21-7、相关设计模式"><a href="#21-7、相关设计模式" class="headerlink" title="21.7、相关设计模式"></a>21.7、相关设计模式</h3><ul>
<li><p>Facade模式</p>
<p>在Mediator模式中，Mediator 角色与Colleague角色进行交互。</p>
<p>而在Facade模式中，Facade 角色单方面地使用其他角色来对外提供高层接口( API)。因此，可以说Mediator模式是双向的，而Facade模式是单向的。</p>
</li>
<li><p>Observer模式</p>
<p>有时会使用Observer模式来实现Mediator角色与Colleague 角色之间的通信。</p>
</li>
</ul>
<h3 id="21-8、中介者模式的注意事项与细节"><a href="#21-8、中介者模式的注意事项与细节" class="headerlink" title="21.8、中介者模式的注意事项与细节"></a>21.8、中介者模式的注意事项与细节</h3><ol>
<li><strong>多个类相互耦合，会形成网状结构</strong>，使用<strong>中介者模式</strong>将网状结构分离为<strong>星型结构</strong>，<strong>进行解耦</strong></li>
<li><strong>减少类间依赖</strong>，降低了耦合，<strong>符合迪米特原则</strong></li>
<li><strong>中介者</strong>承担了较多的责任，一旦中介者出现了问题，整个系统就会受到影响</li>
<li>如果设计不当，<strong>中介者对象本身变得过于复杂</strong>，这点在实际使用时，要特别注意</li>
</ol>
<h2 id="22、备忘录模式Memento（行为型模式）"><a href="#22、备忘录模式Memento（行为型模式）" class="headerlink" title="22、备忘录模式Memento（行为型模式）"></a>22、备忘录模式Memento（行为型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418145233471.png" alt="image-20210418145233471"></p>
<h3 id="22-1、基本介绍"><a href="#22-1、基本介绍" class="headerlink" title="22.1、基本介绍"></a>22.1、基本介绍</h3><ol>
<li>备忘录模式（Memento Pattern）,该模式又叫<strong>快照模式</strong>。在<strong>不破坏封装性</strong>的前提下，<strong>捕获一个对象的内部状态</strong>，并<strong>在该对象之外保存这个状态</strong>。这样以后就可将该对象恢复到原先保存的状态。</li>
<li>可以这里理解备忘录模式：现实生活中的备忘录是用来记录某些要去做的事情，或者是记录已经达成的共同意见的事情，以防忘记了。而在软件层面，备忘录模式有着相同的含义，备忘录对象主要用来记录一个对象的某种状态，或者某些数据，当用户后悔时能撤销当前操作，使数据恢复到它原先的状态。</li>
<li>备忘录模式属于行为型模式。</li>
</ol>
<h3 id="22-2、备忘录模式的原理结构图-uml类图"><a href="#22-2、备忘录模式的原理结构图-uml类图" class="headerlink" title="22.2、备忘录模式的原理结构图-uml类图"></a>22.2、备忘录模式的原理结构图-uml类图</h3><p>备忘录模式的核心是设计备忘录类以及用于管理备忘录的管理者类。</p>
<h4 id="22-2-1、模式的结构"><a href="#22-2-1、模式的结构" class="headerlink" title="22.2.1、模式的结构"></a>22.2.1、模式的结构</h4><p>备忘录模式的主要角色如下：</p>
<ol>
<li><p><strong>发起人（Originator）</strong>角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。</p>
</li>
<li><p><strong>备忘录（Memento）</strong>角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。</p>
<p>Memento角色有以下两种按口( API )：</p>
<ol>
<li><p>wide interface - 宽接口( API )：</p>
<p>Memento角色提供的“宽接口( API)”是指所有用于获取恢复对象状态信息的方法的集合。由于宽接口( API)会暴露所有Memento角色的内部信息，因此能够使用宽接口( API)的只有Originator角色。</p>
</li>
<li><p>narrowinterface - 窄接口 ( API )：</p>
<p>Memento角色为外部的Caretaker角色提供了“窄接口( API)”。可以通过窄接口( API)获取的Memento角色的内部信息非常有限，因此可以有效地防止信息泄露。</p>
</li>
</ol>
<p>通过对外提供以上两种接口( API),可以有效地防止对象的封装性被破坏。</p>
</li>
<li><p><strong>守护者（Caretaker）</strong>角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。</p>
</li>
</ol>
<p>说明：如果希望保存多个 originator 对象的不同时间的状态也可以，只需要在守护者Caretaker当中使用 HashMap &lt;String, 集合&gt;进行保存就行。</p>
<p>备忘录模式的结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418152450078.png" alt="image-20210418152450078"></p>
<h4 id="22-2-2、代码实现"><a href="#22-2-2、代码实现" class="headerlink" title="22.2.2、代码实现"></a>22.2.2、代码实现</h4><p><strong>发起人（Originator）</strong>角色：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Originator</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String state;<span class="comment">//状态信息</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> state;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.state = state;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//编写一个方法，可以保存一个状态对象 Memento</span></span><br><span class="line">	<span class="comment">//因此编写一个方法，返回 Memento</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Memento <span class="title">saveStateMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Memento(state);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//通过备忘录对象，恢复状态</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStateFromMemento</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">		state = memento.getState();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>备忘录（Memento）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String state;</span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.state = state;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> state;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>守护者（Caretaker）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caretaker</span> </span>&#123;</span><br><span class="line">	<span class="comment">//在List 集合中会有很多的备忘录对象</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;Memento&gt; mementoList = <span class="keyword">new</span> ArrayList&lt;Memento&gt;();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">		mementoList.add(memento);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取到第index个Originator 的 备忘录对象(即保存状态)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Memento <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> mementoList.get(index);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Originator originator = <span class="keyword">new</span> Originator();</span><br><span class="line">		Caretaker caretaker = <span class="keyword">new</span> Caretaker();</span><br><span class="line">         <span class="comment">// 状态#1</span></span><br><span class="line">		originator.setState(<span class="string">&quot; 状态#1 攻击力 100 &quot;</span>);</span><br><span class="line">		<span class="comment">//保存了当前的状态</span></span><br><span class="line">		caretaker.add(originator.saveStateMemento());</span><br><span class="line">         <span class="comment">// 状态#2</span></span><br><span class="line">		originator.setState(<span class="string">&quot; 状态#2 攻击力 80 &quot;</span>);</span><br><span class="line">		caretaker.add(originator.saveStateMemento());</span><br><span class="line">         <span class="comment">// 状态#3</span></span><br><span class="line">		originator.setState(<span class="string">&quot; 状态#3 攻击力 50 &quot;</span>);</span><br><span class="line">		caretaker.add(originator.saveStateMemento());		</span><br><span class="line">        </span><br><span class="line">		System.out.println(<span class="string">&quot;当前的状态是 =&quot;</span> + originator.getState());	</span><br><span class="line">		<span class="comment">//希望得到状态 1, 将 originator 恢复到状态1	</span></span><br><span class="line">		originator.getStateFromMemento(caretaker.get(<span class="number">0</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;恢复到状态1 , 当前的状态是&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;当前的状态是 =&quot;</span> + originator.getState());	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="22-3、应用举例"><a href="#22-3、应用举例" class="headerlink" title="22.3、应用举例"></a>22.3、应用举例</h3><p>游戏角色状态恢复问题：</p>
<p>游戏角色有攻击力和防御力，在大战 Boss 前保存自身的状态(攻击力和防御力)，当大战 Boss 后攻击力和防御力下降，从备忘录对象恢复到大战前的状态。</p>
<h4 id="22-3-1、使用传统模式解决需求"><a href="#22-3-1、使用传统模式解决需求" class="headerlink" title="22.3.1、使用传统模式解决需求"></a>22.3.1、使用传统模式解决需求</h4><p>思路分析（类图）：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418153109616.png" alt="image-20210418153109616"></p>
<p>传统的方式的问题分析： </p>
<ol>
<li>一个对象，就对应一个保存对象状态的对象， 这样当我们游戏的对象很多时，不利于管理，开销也很大。</li>
<li>传统的方式是简单地做备份，new 出另外一个对象出来，再把需要备份的数据放到这个新对象，但这就暴露了对象内部的细节</li>
<li>解决方案： =&gt; 备忘录模式</li>
</ol>
<h4 id="22-3-2、使用备忘录模式解决需求"><a href="#22-3-2、使用备忘录模式解决需求" class="headerlink" title="22.3.2、使用备忘录模式解决需求"></a>22.3.2、使用备忘录模式解决需求</h4><p>思路分析和图解(类图)：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418153258446.png" alt="image-20210418153258446"></p>
<p>代码实现：</p>
<p>GameRole：游戏角色。<strong>发起人（Originator）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameRole</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> vit;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> def;</span><br><span class="line">	<span class="comment">//创建Memento ,即根据当前的状态得到Memento</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Memento <span class="title">createMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Memento(vit, def);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//从备忘录对象，恢复GameRole的状态</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverGameRoleFromMemento</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.vit = memento.getVit();</span><br><span class="line">		<span class="keyword">this</span>.def = memento.getDef();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//显示当前游戏角色的状态</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;游戏角色当前的攻击力：&quot;</span> + <span class="keyword">this</span>.vit + <span class="string">&quot; 防御力: &quot;</span> + <span class="keyword">this</span>.def);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> vit;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVit</span><span class="params">(<span class="keyword">int</span> vit)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.vit = vit;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> def;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDef</span><span class="params">(<span class="keyword">int</span> def)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.def = def;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Memento：<strong>备忘录（Memento）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line">	<span class="comment">//攻击力</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> vit;</span><br><span class="line">	<span class="comment">//防御力</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> def;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(<span class="keyword">int</span> vit, <span class="keyword">int</span> def)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.vit = vit;</span><br><span class="line">		<span class="keyword">this</span>.def = def;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> vit;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVit</span><span class="params">(<span class="keyword">int</span> vit)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.vit = vit;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> def;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDef</span><span class="params">(<span class="keyword">int</span> def)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.def = def;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Caretaker：<strong>守护者（Caretaker）</strong>角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="comment">//守护者对象, 保存游戏角色的状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caretaker</span> </span>&#123;</span><br><span class="line">	<span class="comment">//如果只保存一次状态</span></span><br><span class="line">	<span class="keyword">private</span> Memento  memento;</span><br><span class="line">	<span class="comment">//对GameRole 保存多次状态</span></span><br><span class="line">	<span class="comment">//private ArrayList&lt;Memento&gt; mementos;</span></span><br><span class="line">	<span class="comment">//对多个游戏角色保存多个状态</span></span><br><span class="line">	<span class="comment">//private HashMap&lt;String, ArrayList&lt;Memento&gt;&gt; rolesMementos;</span></span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> Memento <span class="title">getMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> memento;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemento</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.memento = memento;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：客户端，负责调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建游戏角色</span></span><br><span class="line">		GameRole gameRole = <span class="keyword">new</span> GameRole();</span><br><span class="line">		gameRole.setVit(<span class="number">100</span>);</span><br><span class="line">		gameRole.setDef(<span class="number">100</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;和boss大战前的状态&quot;</span>);</span><br><span class="line">		gameRole.display();	</span><br><span class="line">		<span class="comment">//把当前状态保存caretaker</span></span><br><span class="line">		Caretaker caretaker = <span class="keyword">new</span> Caretaker();</span><br><span class="line">		caretaker.setMemento(gameRole.createMemento());	</span><br><span class="line">		System.out.println(<span class="string">&quot;和boss大战~~~&quot;</span>);</span><br><span class="line">		gameRole.setDef(<span class="number">30</span>);</span><br><span class="line">		gameRole.setVit(<span class="number">30</span>);	</span><br><span class="line">		gameRole.display();</span><br><span class="line">		System.out.println(<span class="string">&quot;大战后，使用备忘录对象恢复到大战前&quot;</span>);		</span><br><span class="line">		gameRole.recoverGameRoleFromMemento(caretaker.getMemento());</span><br><span class="line">		System.out.println(<span class="string">&quot;恢复后的状态&quot;</span>);</span><br><span class="line">		gameRole.display();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="22-4、备忘录模式总结"><a href="#22-4、备忘录模式总结" class="headerlink" title="22.4、备忘录模式总结"></a>22.4、备忘录模式总结</h3><p>主要优点如下：</p>
<ul>
<li>提供了一种<strong>可以恢复状态</strong>的机制。当用户需要时能够比较<strong>方便地将数据恢复到某个历史的状态</strong>。</li>
<li><strong>实现了内部状态的封装</strong>。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。</li>
<li>简化了发起人（Originator）类。<strong>发起人不需要管理和保存其内部状态的各个备份</strong>，所有状态信息都保存在备忘录中，并由管理者进行管理，这<strong>符合单一职责原则</strong>。</li>
</ul>
<p>主要缺点是：</p>
<ul>
<li><strong>资源消耗大</strong>。如果要保存的<strong>内部状态信息过多</strong>或者<strong>特别频繁</strong>，将会<strong>占用比较大的内存资源</strong>。而且每一次保存都会消耗一定的内存</li>
</ul>
<p>备忘录模式应用场景：</p>
<ol>
<li><strong>需要保存与恢复数据的场景</strong>，如玩游戏时的中间结果的存档功能。</li>
<li>需要<strong>提供一个可回滚操作</strong>的场景，如 Word、记事本、Photoshop，Eclipse 等软件在编辑时按 Ctrl+Z 组合键，还有数据库中事务操作。</li>
</ol>
<p>备忘录模式应用实例：</p>
<ul>
<li>后悔药</li>
<li>打游戏时的存档</li>
<li>Windows 里的 ctri + z</li>
<li>IE 中的后退</li>
<li>数据库的事务管理</li>
<li>编辑过程中的Undo（撤销）、Redo（重做）、History（历史记录）、Snapshot (快照）都是备忘录模式的应用</li>
</ul>
<h3 id="22-5、备忘录模式扩展"><a href="#22-5、备忘录模式扩展" class="headerlink" title="22.5、备忘录模式扩展"></a>22.5、备忘录模式扩展</h3><h4 id="22-5-1、备忘录模式-原型模式"><a href="#22-5-1、备忘录模式-原型模式" class="headerlink" title="22.5.1、备忘录模式 + 原型模式"></a>22.5.1、备忘录模式 + 原型模式</h4><p>备忘录模式如何同原型模式混合使用。在备忘录模式中，通过定义“备忘录”来备份“发起人”的信息，而原型模式的 clone() 方法具有自备份功能，所以，如果让发起人实现 Cloneable 接口就有备份自己的功能，这时可以删除备忘录类，其结构图</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418154508695.png" alt="image-20210418154508695"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.c.memento;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypeMemento</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OriginatorPrototype or = <span class="keyword">new</span> OriginatorPrototype();</span><br><span class="line">        PrototypeCaretaker cr = <span class="keyword">new</span> PrototypeCaretaker();</span><br><span class="line">        or.setState(<span class="string">&quot;S0&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;初始状态:&quot;</span> + or.getState());</span><br><span class="line">        cr.setMemento(or.createMemento()); <span class="comment">//保存状态</span></span><br><span class="line">        or.setState(<span class="string">&quot;S1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;新的状态:&quot;</span> + or.getState());</span><br><span class="line">        or.restoreMemento(cr.getMemento()); <span class="comment">//恢复状态</span></span><br><span class="line">        System.out.println(<span class="string">&quot;恢复状态:&quot;</span> + or.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//发起人原型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OriginatorPrototype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> OriginatorPrototype <span class="title">createMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreMemento</span><span class="params">(OriginatorPrototype opt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(opt.getState());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> OriginatorPrototype <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (OriginatorPrototype) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原型管理者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrototypeCaretaker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> OriginatorPrototype opt;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemento</span><span class="params">(OriginatorPrototype opt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.opt = opt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> OriginatorPrototype <span class="title">getMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> opt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="22-5-2、关于备忘录模式在源码当中的应用"><a href="#22-5-2、关于备忘录模式在源码当中的应用" class="headerlink" title="22.5.2、关于备忘录模式在源码当中的应用"></a>22.5.2、关于备忘录模式在源码当中的应用</h4><p>由于 JDK、Spring、Mybatis 中很少有备忘录模式，所以该设计模式不做典型应用源码分析。</p>
<p>Spring Webflow 中 DefaultMessageContext 类实现了 StateManageableMessageContext 接口，查看其源码可以发现其主要逻辑就相当于给 Message 备份</p>
<h3 id="22-6、进阶阅读"><a href="#22-6、进阶阅读" class="headerlink" title="22.6、进阶阅读"></a>22.6、进阶阅读</h3><p>如果您想了解备忘录模式在实际项目中的应用，可猛击阅读<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8504.html">《使用备忘录模式实现草稿箱功能》</a>文章。</p>
<h3 id="22-7、相关设计模式"><a href="#22-7、相关设计模式" class="headerlink" title="22.7、相关设计模式"></a>22.7、相关设计模式</h3><ul>
<li><p>Command模式</p>
<p>在使用Command模式处理命令时，可以使用Memento模式实现撤销功能。</p>
</li>
<li><p>Protype模式</p>
<p>在Memento模式中，为了能够实现快照和撤销功能，保存了对象当前的状态。保存的信息只是在恢复状态时所需要的那部分信息。</p>
<p>而在Protype模式中，会生成- 一个与当前实例完全相同的另外一个实例。 这两个实例的内容完全一样。</p>
</li>
<li><p>State 模式</p>
<p>在Memento模式中，是用“实例”表示状态。</p>
<p>而在State模式中，则是用“类”表示状态。</p>
</li>
</ul>
<h3 id="22-8、备忘录模式的注意事项与细节"><a href="#22-8、备忘录模式的注意事项与细节" class="headerlink" title="22.8、备忘录模式的注意事项与细节"></a>22.8、备忘录模式的注意事项与细节</h3><ol>
<li><p>给用户提供了一种<strong>可以恢复状态</strong>的机制，可以使用户能够比较方便地回到某个历史的状态</p>
</li>
<li><p><strong>实现了信息的封装</strong>，使得用户不需要关心状态的保存细节</p>
</li>
<li><p>如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存, 这个需要注意</p>
</li>
<li><p>为了节约内存，<strong>备忘录模式可以和原型模式配合使用</strong></p>
</li>
<li><p>在守护者当中的不同情况：</p>
<ol>
<li><p>如果只保存一次状态Memento</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Memento memento;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对发起人（Originator）对象保存多次状态Memento</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ArrayList&lt;Memento&gt; mementos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对多个发起人（Originator）角色保存多个状态Memento</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> HashMap&lt;String, ArrayList&lt;Memento&gt;&gt; rolesMementos;</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
<h2 id="23、解释器模式Interpreter（行为型模式）"><a href="#23、解释器模式Interpreter（行为型模式）" class="headerlink" title="23、解释器模式Interpreter（行为型模式）"></a>23、解释器模式Interpreter（行为型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418162744613.png" alt="image-20210418162744613"></p>
<h3 id="23-1、基本介绍"><a href="#23-1、基本介绍" class="headerlink" title="23.1、基本介绍"></a>23.1、基本介绍</h3><ol>
<li>在编译原理中，一个算术表达式通过词法分析器形成词法单元，而后这些词法单元再通过语法分析器构建语法分析树，最终形成一颗抽象的语法分析树。这里的词法分析器和语法分析器都可以看做是解释器</li>
<li>解释器模式（Interpreter Pattern）：是指给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子(表达式)。也就是说，用编译语言的方式来分析应用中的实例。</li>
<li>这种模式实现了文法表达式处理的接口，该接口解释一个特定的上下文。</li>
<li>这里提到的文法和句子的概念同编译原理中的描述相同，“文法”指语言的语法规则，而“句子”是语言集中的元素。</li>
</ol>
<h3 id="23-2、编译原理中的“文法、句子、语法树”等相关概念"><a href="#23-2、编译原理中的“文法、句子、语法树”等相关概念" class="headerlink" title="23.2、编译原理中的“文法、句子、语法树”等相关概念"></a>23.2、编译原理中的“文法、句子、语法树”等相关概念</h3><h4 id="23-2-1、文法"><a href="#23-2-1、文法" class="headerlink" title="23.2.1、文法"></a>23.2.1、文法</h4><p>文法是用于描述语言的语法结构的形式规则。没有规矩不成方圆，例如，有些人认为完美爱情的准则是“相互吸引、感情专一、任何一方都没有恋爱经历”，虽然最后一条准则较苛刻，但任何事情都要有规则，语言也一样，不管它是机器语言还是自然语言，都有它自己的文法规则。</p>
<p>例如，中文中的“句子”的文法如下：</p>
<p>注：这里的符号“::=”表示“定义为”的意思，用“〈”和“〉”括住的是非终结符，没有括住的是终结符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">〈句子〉::&#x3D;〈主语〉〈谓语〉〈宾语〉</span><br><span class="line">〈主语〉::&#x3D;〈代词〉|〈名词〉</span><br><span class="line">〈谓语〉::&#x3D;〈动词〉</span><br><span class="line">〈宾语〉::&#x3D;〈代词〉|〈名词〉</span><br><span class="line">〈代词〉你|我|他</span><br><span class="line">〈名词〉7大学生I筱霞I英语</span><br><span class="line">〈动词〉::&#x3D;是|学习</span><br></pre></td></tr></table></figure>

<h4 id="23-2-2、句子"><a href="#23-2-2、句子" class="headerlink" title="23.2.2、句子"></a>23.2.2、句子</h4><p>句子是语言的基本单位，是语言集中的一个元素，它由终结符构成，能由“文法”推导出。</p>
<p>例如，上述文法可以推出“我是大学生”，所以它是句子。</p>
<h4 id="23-2-3、语法树"><a href="#23-2-3、语法树" class="headerlink" title="23.2.3、语法树"></a>23.2.3、语法树</h4><p>语法树是句子结构的一种树型表示，它代表了句子的推导结果，它有利于理解句子语法结构的层次。</p>
<p>下图所示是“我是大学生”的语法树：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418180415987.png" alt="image-20210418180415987"></p>
<p>解释器模式的结构与组合模式相似，不过其包含的组成元素比组合模式多，而且组合模式是对象结构型模式，而解释器模式是类行为型模式。</p>
<h3 id="23-3、解释器模式的原理结构图-uml类图"><a href="#23-3、解释器模式的原理结构图-uml类图" class="headerlink" title="23.3、解释器模式的原理结构图-uml类图"></a>23.3、解释器模式的原理结构图-uml类图</h3><h4 id="23-3-1、模式的结构"><a href="#23-3-1、模式的结构" class="headerlink" title="23.3.1、模式的结构"></a>23.3.1、模式的结构</h4><p>解释器模式包含以下主要角色：</p>
<ol>
<li><strong>抽象表达式（Abstract Expression）</strong>角色：定义解释器的接口，约定解释器的解释操作，主要**包含解释方法 interpret()**，这个方法为抽象语法树中所有的节点所共享。</li>
<li><strong>终结符表达式（Terminal Expression）</strong>角色：是抽象表达式的子类，用来<strong>实现文法中与终结符相关</strong>的操作，文法中的<strong>每一个终结符都有一个具体终结表达式与之相对应</strong>。</li>
<li><strong>非终结符表达式（Nonterminal Expression）</strong>角色：也是抽象表达式的子类，用来<strong>实现文法中与非终结符相关</strong>的操作，文法中的<strong>每条规则都对应于一个非终结符表达式</strong>。</li>
<li><strong>环境（Context）</strong>角色：通常包含<strong>各个解释器需要的数据或是公共的功能</strong>，一般用来传递被所有解释器共享的数据，后面的<strong>解释器可以从这里获取这些值</strong>。</li>
<li><strong>客户端（Client）</strong>：主要任务是<strong>将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树</strong>，然后<strong>调用解释器的解释方法</strong>，当然也可以通过环境角色间接访问解释器的解释方法。</li>
</ol>
<p>解释器模式的结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418180640123.png" alt="image-20210418180640123"></p>
<h4 id="23-3-2、代码实现"><a href="#23-3-2、代码实现" class="headerlink" title="23.3.2、代码实现"></a>23.3.2、代码实现</h4><p>解释器模式实现的关键是定义文法规则、设计终结符类与非终结符类、画出结构图，必要时构建语法树，其代码结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.c.interpreter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象表达式类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interpret</span><span class="params">(String info)</span></span>;    <span class="comment">//解释方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//终结符表达式类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TerminalExpression</span> <span class="keyword">implements</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interpret</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对终结符表达式的处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非终结符表达式类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonterminalExpression</span> <span class="keyword">implements</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AbstractExpression exp1;</span><br><span class="line">    <span class="keyword">private</span> AbstractExpression exp2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interpret</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//非对终结符表达式的处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//环境类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AbstractExpression exp;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//数据初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用相关表达式类的解释方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="23-4、应用举例"><a href="#23-4、应用举例" class="headerlink" title="23.4、应用举例"></a>23.4、应用举例</h3><p>四则运算问题：</p>
<p>通过解释器模式来实现四则运算，如计算 a+b-c 的值，具体要求：</p>
<ol>
<li><p>先输入表达式的形式，比如 a+b+c-d+e, 要求表达式的字母不能重复</p>
</li>
<li><p>在分别输入 a ,b, c, d, e 的值</p>
</li>
<li><p>最后求出结果：如图</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418181009303.png" alt="image-20210418181009303"></p>
</li>
</ol>
<h4 id="23-4-1、使用传统方式解决需求"><a href="#23-4-1、使用传统方式解决需求" class="headerlink" title="23.4.1、使用传统方式解决需求"></a>23.4.1、使用传统方式解决需求</h4><p>传统方案解决四则运算问题分析：</p>
<ol>
<li>编写一个方法，接收表达式的形式，然后根据用户输入的数值进行解析，得到结果</li>
<li>问题分析：如果加入新的运算符，比如<code>*</code>(乘)<code>/</code>(除) 等等，不利于扩展，另外让一个方法来解析会造成程序结构混乱，不够清晰。</li>
<li>解决方案：可以考虑使用解释器模式，即：  表达式  -&gt; 解释器(可以有多种) -&gt; 结果</li>
</ol>
<h4 id="23-4-2、使用解释器模式解决需求"><a href="#23-4-2、使用解释器模式解决需求" class="headerlink" title="23.4.2、使用解释器模式解决需求"></a>23.4.2、使用解释器模式解决需求</h4><p>思路分析和图解(类图)：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418181353124.png" alt="image-20210418181353124"></p>
<p>代码实现：</p>
<p>Expression：<strong>抽象表达式（Abstract Expression）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象类表达式，通过HashMap 键值对, 可以获取到变量的值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">	<span class="comment">// a + b - c</span></span><br><span class="line">	<span class="comment">// 解释公式和数值, key 就是公式(表达式) 参数[a,b,c], value就是就是具体值</span></span><br><span class="line">	<span class="comment">// HashMap &#123;a=10, b=20&#125;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">interpreter</span><span class="params">(HashMap&lt;String, Integer&gt; <span class="keyword">var</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>VarExpression：变量的解释器。<strong>终结符表达式（Terminal Expression）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 变量的解释器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VarExpression</span> <span class="keyword">extends</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String key; <span class="comment">// key=a,key=b,key=c</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">VarExpression</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.key = key;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// var 就是&#123;a=10, b=20&#125;</span></span><br><span class="line">	<span class="comment">// interpreter 根据 变量名称，返回对应值</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpreter</span><span class="params">(HashMap&lt;String, Integer&gt; <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">var</span>.get(<span class="keyword">this</span>.key);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SymbolExpression：抽象运算符号解析器。<strong>非终结符表达式（Nonterminal Expression）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象运算符号解析器 这里，每个运算符号，都只和自己左右两个数字有关系，</span></span><br><span class="line"><span class="comment"> * 但左右两个数字有可能也是一个解析的结果，无论何种类型，都是Expression类的实现类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SymbolExpression</span> <span class="keyword">extends</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> Expression left;</span><br><span class="line">	<span class="keyword">protected</span> Expression right;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SymbolExpression</span><span class="params">(Expression left, Expression right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.left = left;</span><br><span class="line">		<span class="keyword">this</span>.right = right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//因为 SymbolExpression 是让其子类来实现，因此 interpreter 是一个默认实现</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpreter</span><span class="params">(HashMap&lt;String, Integer&gt; <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AddExpression：加法解释器（减法解释器SubExpression类似）继承了SymbolExpression</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加法解释器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddExpression</span> <span class="keyword">extends</span> <span class="title">SymbolExpression</span>  </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AddExpression</span><span class="params">(Expression left, Expression right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(left, right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//处理相加</span></span><br><span class="line">	<span class="comment">//var 仍然是 &#123;a=10,b=20&#125;..</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpreter</span><span class="params">(HashMap&lt;String, Integer&gt; <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//super.left.interpreter(var) ： 返回 left 表达式对应的值 a = 10</span></span><br><span class="line">		<span class="comment">//super.right.interpreter(var): 返回right 表达式对应值 b = 20</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.left.interpreter(<span class="keyword">var</span>) + <span class="keyword">super</span>.right.interpreter(<span class="keyword">var</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Calculator：计算器。环境（Context）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 定义表达式</span></span><br><span class="line">	<span class="keyword">private</span> Expression expression;</span><br><span class="line">	<span class="comment">// 构造函数传参，并解析</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Calculator</span><span class="params">(String expStr)</span> </span>&#123; <span class="comment">// expStr = a+b</span></span><br><span class="line">		<span class="comment">// 安排运算先后顺序</span></span><br><span class="line">		Stack&lt;Expression&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		<span class="comment">// 表达式拆分成字符数组 </span></span><br><span class="line">		<span class="keyword">char</span>[] charArray = expStr.toCharArray();<span class="comment">// [a, +, b]</span></span><br><span class="line">		Expression left = <span class="keyword">null</span>;</span><br><span class="line">		Expression right = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">//遍历我们的字符数组， 即遍历  [a, +, b]</span></span><br><span class="line">		<span class="comment">//针对不同的情况，做处理</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; charArray.length; i++) &#123;</span><br><span class="line">			<span class="keyword">switch</span> (charArray[i]) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="comment">// &#x27;+&#x27;号</span></span><br><span class="line">				left = stack.pop();<span class="comment">// 从stack取出left =&gt; &quot;a&quot;</span></span><br><span class="line">				right = <span class="keyword">new</span> VarExpression(String.valueOf(charArray[++i]));<span class="comment">// 取出右表达式 &quot;b&quot;</span></span><br><span class="line">				stack.push(<span class="keyword">new</span> AddExpression(left, right));<span class="comment">// 然后根据得到left 和 right 构建 AddExpresson加入stack</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="comment">// &#x27;-&#x27;号</span></span><br><span class="line">				left = stack.pop();</span><br><span class="line">				right = <span class="keyword">new</span> VarExpression(String.valueOf(charArray[++i]));</span><br><span class="line">				stack.push(<span class="keyword">new</span> SubExpression(left, right));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>: </span><br><span class="line">				<span class="comment">//如果是一个 Var 就创建要给 VarExpression 对象，并push到 stack</span></span><br><span class="line">				stack.push(<span class="keyword">new</span> VarExpression(String.valueOf(charArray[i])));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//当遍历完整个 charArray 数组后，stack 就得到最后Expression</span></span><br><span class="line">		<span class="keyword">this</span>.expression = stack.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(HashMap&lt;String, Integer&gt; <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//最后将表达式a+b和 var = &#123;a=10,b=20&#125;</span></span><br><span class="line">		<span class="comment">//然后传递给expression的interpreter进行解释执行</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.expression.interpreter(<span class="keyword">var</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：客户端。负责调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		String expStr = getExpStr(); <span class="comment">// a+b</span></span><br><span class="line">		HashMap&lt;String, Integer&gt; <span class="keyword">var</span> = getValue(expStr);<span class="comment">// var &#123;a=10, b=20&#125;</span></span><br><span class="line">		Calculator calculator = <span class="keyword">new</span> Calculator(expStr);</span><br><span class="line">		System.out.println(<span class="string">&quot;运算结果：&quot;</span> + expStr + <span class="string">&quot;=&quot;</span> + calculator.run(<span class="keyword">var</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获得表达式</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getExpStr</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		System.out.print(<span class="string">&quot;请输入表达式：&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in))).readLine();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获得值映射</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;String, Integer&gt; <span class="title">getValue</span><span class="params">(String expStr)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">char</span> ch : expStr.toCharArray()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ch != <span class="string">&#x27;+&#x27;</span> &amp;&amp; ch != <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!map.containsKey(String.valueOf(ch))) &#123;</span><br><span class="line">					System.out.print(<span class="string">&quot;请输入&quot;</span> + String.valueOf(ch) + <span class="string">&quot;的值：&quot;</span>);</span><br><span class="line">					String in = (<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in))).readLine();</span><br><span class="line">					map.put(String.valueOf(ch), Integer.valueOf(in));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> map;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="23-5、解释器模式在Spring框架的应用与源码"><a href="#23-5、解释器模式在Spring框架的应用与源码" class="headerlink" title="23.5、解释器模式在Spring框架的应用与源码"></a>23.5、解释器模式在Spring框架的应用与源码</h3><p>Spring 框架中 SpelExpressionParser 就使用到解释器模式</p>
<p>代码分析+Debug源码：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418194307766.png" alt="image-20210418194307766"></p>
<p>main：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418194430819.png" alt="image-20210418194430819"></p>
<p>Expression接口：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418194613016.png" alt="image-20210418194613016"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418194717484.png" alt="image-20210418194717484"></p>
<p>SpelExpressionParser的parseExpression()方法是继承了其父类TemplateAwareExpressionParser的parseExpression()方法，而TemplateAwareExpressionParser又实现了ExpressionParser接口</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418194936179.png" alt="image-20210418194936179"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418195208607.png" alt="image-20210418195208607"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418195226794.png" alt="image-20210418195226794"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418195314345.png" alt="image-20210418195314345"></p>
<p>TemplateAwareExpressionParser的parseExpression()方法：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418195658830.png" alt="image-20210418195658830"></p>
<p>其中的parseTemplate()方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418195826923.png" alt="image-20210418195826923"></p>
<p>其中的doParseTemplate()方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/blog\XGH-blog\source_posts\设计模式\image-20210418200021479.png" alt="image-20210418200021479"></p>
<p>子类SpelExpressionParser实现了父类TemplateAwareExpressionParser的doParseTemplate()方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418200257640.png" alt="image-20210418200257640"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418200553239.png" alt="image-20210418200553239"></p>
<p>说明：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418194009115.png" alt="image-20210418194009115"></p>
<h3 id="23-6、解释器模式总结"><a href="#23-6、解释器模式总结" class="headerlink" title="23.6、解释器模式总结"></a>23.6、解释器模式总结</h3><p>主要优点如下：</p>
<ol>
<li><strong>扩展性好</strong>。由于在解释器模式中使用类来表示语言的文法规则，因此可以<strong>通过继承等机制来改变或扩展文法</strong>。</li>
<li><strong>容易实现</strong>。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。</li>
</ol>
<p>主要缺点如下：</p>
<ol>
<li><strong>执行效率较低</strong>。解释器模式中通常使用<strong>大量的循环和递归调用</strong>，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。</li>
<li><strong>会引起类膨胀</strong>。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护。</li>
<li><strong>可应用的场景比较少</strong>。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。</li>
</ol>
<p>应用场景：</p>
<ol>
<li>当<strong>语言的文法较为简单</strong>，且<strong>执行效率不是关键</strong>问题时。</li>
<li>当<strong>问题重复出现</strong>，且<strong>可以用一种简单的语言来进行表达</strong>时。</li>
<li>当<strong>一个语言需要解释执行</strong>，并且<strong>语言中的句子可以表示为一个抽象语法树</strong>的时候，如 <strong>XML 文档解释</strong>。</li>
</ol>
<p>应用实例：编译器、运算表达式计算、正则表达式、机器人等</p>
<p>注意：解释器模式在实际的软件开发中使用比较少，因为它会引起效率、性能以及维护等问题。如果碰到对表达式的解释，在 Java 中可以用 Expression4J 或 Jep 等来设计。</p>
<h3 id="23-7、解释器模式扩展"><a href="#23-7、解释器模式扩展" class="headerlink" title="23.7、解释器模式扩展"></a>23.7、解释器模式扩展</h3><p>在项目开发中，如果要对数据表达式进行分析与计算，无须再用解释器模式进行设计了，Java 提供了以下强大的数学公式解析器：Expression4J、MESP(Math Expression String Parser) 和 Jep 等，它们可以解释一些复杂的文法，功能强大，使用简单。</p>
<p>现在以 Jep 为例来介绍该工具包的使用方法。Jep 是 Java expression parser 的简称，即 Java 表达式分析器，它是一个用来转换和计算数学表达式的 Java 库。通过这个程序库，用户可以以字符串的形式输入一个任意的公式，然后快速地计算出其结果。而且 Jep 支持用户自定义变量、常量和函数，它包括许多常用的数学函数和常量。</p>
<p>下面以计算存款利息为例来介绍。存款利息的计算公式是：本金x利率x时间=利息，其相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.c.interpreter;</span><br><span class="line"><span class="keyword">import</span> com.singularsys.jep.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JepDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JepException </span>&#123;</span><br><span class="line">        Jep jep = <span class="keyword">new</span> Jep();</span><br><span class="line">        <span class="comment">//定义要计算的数据表达式</span></span><br><span class="line">        String 存款利息 = <span class="string">&quot;本金*利率*时间&quot;</span>;</span><br><span class="line">        <span class="comment">//给相关变量赋值</span></span><br><span class="line">        jep.addVariable(<span class="string">&quot;本金&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">        jep.addVariable(<span class="string">&quot;利率&quot;</span>, <span class="number">0.038</span>);</span><br><span class="line">        jep.addVariable(<span class="string">&quot;时间&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        jep.parse(存款利息);    <span class="comment">//解析表达式</span></span><br><span class="line">        Object accrual = jep.evaluate();    <span class="comment">//计算</span></span><br><span class="line">        System.out.println(<span class="string">&quot;存款利息：&quot;</span> + accrual);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="23-8、进阶阅读"><a href="#23-8、进阶阅读" class="headerlink" title="23.8、进阶阅读"></a>23.8、进阶阅读</h3><p>如果您想了解解释器模式在框架源码中的应用，可猛击阅读<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8505.html">《解释器模式在JDK和Spring源码中的应用》</a>文章。</p>
<h3 id="23-9、相关设计模式"><a href="#23-9、相关设计模式" class="headerlink" title="23.9、相关设计模式"></a>23.9、相关设计模式</h3><ul>
<li><p>Composite模式</p>
<p>NonterminalExpression角色多是递归结构，因此常会使用Composite模式来实现NonterminalExpression角色</p>
</li>
<li><p>Flyweight 模式</p>
<p>有时会使用Flyweight模式来共享TerminalExpression角色。</p>
</li>
<li><p>Visitor 模式</p>
<p>在推导出语法树后，有时会使用Visitor模式来访问语法树的各个节点。</p>
</li>
</ul>
<h3 id="23-10、解释器模式的注意事项与细节"><a href="#23-10、解释器模式的注意事项与细节" class="headerlink" title="23.10、解释器模式的注意事项与细节"></a>23.10、解释器模式的注意事项与细节</h3><ol>
<li>当有一个语言需要解释执行，可将该语言中的句子表示为一个抽象语法树，就可以考虑使用解释器模式，让程序具有良好的扩展</li>
<li>使用解释器可能带来的问题：解释器模式会引起类膨胀、解释器模式采用递归调用方法，将会导致调试非常复杂、效率可能降低。</li>
<li>解释器模式通过抽象语法树实现对用户输入的解释执行。</li>
<li>解释器模式的实现通常非常复杂，且一般只能解决一类特定问题。</li>
</ol>
<h2 id="24、状态模式State（行为型模式）"><a href="#24、状态模式State（行为型模式）" class="headerlink" title="24、状态模式State（行为型模式）"></a>24、状态模式State（行为型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418201124106.png" alt="image-20210418201124106"></p>
<h3 id="24-1、基本介绍"><a href="#24-1、基本介绍" class="headerlink" title="24.1、基本介绍"></a>24.1、基本介绍</h3><ol>
<li>状态模式（<strong>State Pattern</strong>）：它主要用来解决<strong>对象在多种状态转换时，需要对外输出不同的行为的</strong>问题。<strong>状态和行为是一一对应的，状态之间可以相互转换</strong></li>
<li>对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。</li>
<li>当一个对象的内在状态改变时，允许改变其行为，这个对象看起来像是改变了其类</li>
<li><strong>替代了使用if-else解决问题</strong></li>
</ol>
<h3 id="24-2、状态模式的原理结构图-uml类图"><a href="#24-2、状态模式的原理结构图-uml类图" class="headerlink" title="24.2、状态模式的原理结构图-uml类图"></a>24.2、状态模式的原理结构图-uml类图</h3><p>状态模式把<strong>受环境改变的对象行为包装在不同的状态对象</strong>里，其意图是<strong>让一个对象在其内部状态改变的时候</strong>，其<strong>行为也随之改变</strong>。</p>
<h4 id="24-2-1、模式的结构"><a href="#24-2-1、模式的结构" class="headerlink" title="24.2.1、模式的结构"></a>24.2.1、模式的结构</h4><p>状态模式包含以下主要角色：</p>
<ol>
<li><strong>环境类（Context）</strong>角色：也称为<strong>上下文</strong>，它<strong>定义了客户端需要的接口</strong>，<strong>内部维护一个当前状态</strong>，并<strong>负责具体状态的切换</strong>。</li>
<li><strong>抽象状态（State）</strong>角色：定义一个接口，用以<strong>封装环境对象中的特定状态所对应的行为</strong>，可以有<strong>一个或多个</strong>行为。</li>
<li><strong>具体状态（Concrete State）</strong>角色：实现抽象状态所对应的行为，并且<strong>在需要的情况下进行状态切换</strong>。</li>
</ol>
<p>其结构图类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418205430235.png" alt="image-20210418205430235"></p>
<h4 id="24-2-2、代码实现"><a href="#24-2-2、代码实现" class="headerlink" title="24.2.2、代码实现"></a>24.2.2、代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatePatternClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context context = <span class="keyword">new</span> Context();    <span class="comment">//创建环境      </span></span><br><span class="line">        context.Handle();    <span class="comment">//处理请求</span></span><br><span class="line">        context.Handle();</span><br><span class="line">        context.Handle();</span><br><span class="line">        context.Handle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//环境类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line">    <span class="comment">//定义环境类的初始状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="keyword">new</span> ConcreteStateA();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置新状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对请求做处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state.Handle(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象状态类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Handle</span><span class="params">(Context context)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体状态A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStateA</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前状态是 A.&quot;</span>);</span><br><span class="line">        context.setState(<span class="keyword">new</span> ConcreteStateB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体状态B类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStateB</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前状态是 B.&quot;</span>);</span><br><span class="line">        context.setState(<span class="keyword">new</span> ConcreteStateA());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="24-3、应用举例"><a href="#24-3、应用举例" class="headerlink" title="24.3、应用举例"></a>24.3、应用举例</h3><p>APP 抽奖活动问题：</p>
<p>请编写程序完成 APP 抽奖活动 具体要求如下:</p>
<ol>
<li><p>假如每参加一次这个活动要扣除用户 50 积分，中奖概率是 10%</p>
</li>
<li><p>奖品数量固定，抽完就不能抽奖</p>
</li>
<li><p>活动有四个状态: </p>
<ul>
<li>可以抽奖</li>
<li>不能抽奖</li>
<li>发放奖品</li>
<li>奖品领完</li>
</ul>
</li>
<li><p>活动的四个状态转换关系图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418205732564.png" alt="image-20210418205732564"></p>
</li>
</ol>
<h4 id="24-3-1、使用传统方式解决需求"><a href="#24-3-1、使用传统方式解决需求" class="headerlink" title="24.3.1、使用传统方式解决需求"></a>24.3.1、使用传统方式解决需求</h4><p>通常通过if/else判断抽奖的状态，从而实现不同的逻辑，伪代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(不能抽奖)&#123;</span><br><span class="line">    <span class="comment">//代码逻辑</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(可以抽奖)&#123;</span><br><span class="line">    <span class="comment">//代码逻辑</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(发放奖品)&#123;</span><br><span class="line">    <span class="comment">//代码逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>传统的方式的问题分析： </p>
<ul>
<li>这类代码难以应对变化，在添加一种状态时，我们需要手动添加if/else</li>
<li>在添加一种功能时，要对所有的状态进行判断。</li>
<li>因此代码会变得越来越臃肿，并且一旦没有处理某个状态，便会发生极其严重的BUG，难以维护</li>
<li>不符合开闭原则</li>
</ul>
<h4 id="24-3-2、使用状态模式解决需求"><a href="#24-3-2、使用状态模式解决需求" class="headerlink" title="24.3.2、使用状态模式解决需求"></a>24.3.2、使用状态模式解决需求</h4><p>思路分析和图解(类图)</p>
<ul>
<li>定义出一个接口叫状态接口，每个状态都实现它。</li>
<li>接口有扣除积分方法、抽奖方法、发放奖品方法</li>
</ul>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418210441898.png" alt="image-20210418210441898"></p>
<p>代码实现：</p>
<p>State：<strong>抽象状态（State）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 状态抽象类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 扣除积分 - 50</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">deductMoney</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 是否抽中奖品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">raffle</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 发放奖品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span>  <span class="keyword">void</span> <span class="title">dispensePrize</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>具体状态（Concrete State）</strong>：四种状态：</p>
<p>NoRaffleState：不能抽奖状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不能抽奖状态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoRaffleState</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">	 <span class="comment">// 初始化时传入活动引用，扣除积分后改变其状态</span></span><br><span class="line">    RaffleActivity activity;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NoRaffleState</span><span class="params">(RaffleActivity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.activity = activity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前状态可以扣积分 , 扣除后，将状态设置成可以抽奖状态</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deductMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;扣除50积分成功，您可以抽奖了&quot;</span>);</span><br><span class="line">        activity.setState(activity.getCanRaffleState());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前状态不能抽奖</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">raffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;扣了积分才能抽奖喔！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前状态不能发奖品</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispensePrize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不能发放奖品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CanRaffleState：可以抽奖的状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以抽奖的状态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanRaffleState</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    RaffleActivity activity;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CanRaffleState</span><span class="params">(RaffleActivity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.activity = activity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//已经扣除了积分，不能再扣</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deductMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;已经扣取过了积分&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可以抽奖, 抽完奖后，根据实际情况，改成新的状态</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">raffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在抽奖，请稍等！&quot;</span>);</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> num = r.nextInt(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 10%中奖机会</span></span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 改变活动状态为发放奖品 context</span></span><br><span class="line">            activity.setState(activity.getDispenseState());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;很遗憾没有抽中奖品！&quot;</span>);</span><br><span class="line">            <span class="comment">// 改变状态为不能抽奖</span></span><br><span class="line">            activity.setState(activity.getNoRafflleState());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不能发放奖品</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispensePrize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;没中奖，不能发放奖品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DispenseState：发放奖品的状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发放奖品的状态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispenseState</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 初始化时传入活动引用，发放奖品后改变其状态</span></span><br><span class="line">    RaffleActivity activity;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DispenseState</span><span class="params">(RaffleActivity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.activity = activity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deductMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不能扣除积分&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">raffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不能抽奖&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发放奖品</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispensePrize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(activity.getCount() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;恭喜中奖了&quot;</span>);</span><br><span class="line">            <span class="comment">// 改变状态为不能抽奖</span></span><br><span class="line">            activity.setState(activity.getNoRafflleState());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;很遗憾，奖品发送完了&quot;</span>);</span><br><span class="line">            <span class="comment">// 改变状态为奖品发送完毕, 后面我们就不可以抽奖</span></span><br><span class="line">            activity.setState(activity.getDispensOutState());</span><br><span class="line">            <span class="comment">//System.out.println(&quot;抽奖活动结束&quot;);</span></span><br><span class="line">            <span class="comment">//System.exit(0);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DispenseOutState：奖品发放完毕状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 奖品发放完毕状态</span></span><br><span class="line"><span class="comment"> * 说明，当我们activity 改变成 DispenseOutState， 抽奖活动结束</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispenseOutState</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 初始化时传入活动引用</span></span><br><span class="line">    RaffleActivity activity;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DispenseOutState</span><span class="params">(RaffleActivity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.activity = activity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deductMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;奖品发送完了，请下次再参加&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">raffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;奖品发送完了，请下次再参加&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispensePrize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;奖品发送完了，请下次再参加&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Activity：抽奖活动。<strong>环境类（Context）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽奖活动</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">	<span class="comment">// state 表示活动当前的状态，是变化</span></span><br><span class="line">    State state = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 奖品数量</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 四个属性，表示四种状态</span></span><br><span class="line">    State noRafflleState = <span class="keyword">new</span> NoRaffleState(<span class="keyword">this</span>);</span><br><span class="line">    State canRaffleState = <span class="keyword">new</span> CanRaffleState(<span class="keyword">this</span>);</span><br><span class="line">    State dispenseState =   <span class="keyword">new</span> DispenseState(<span class="keyword">this</span>);</span><br><span class="line">    State dispensOutState = <span class="keyword">new</span> DispenseOutState(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="comment">//1. 初始化当前的状态为 noRafflleState（即不能抽奖的状态）</span></span><br><span class="line">    <span class="comment">//2. 初始化奖品的数量 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RaffleActivity</span><span class="params">( <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = getNoRafflleState();</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扣分, 调用当前状态的 deductMoney</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debuctMoney</span><span class="params">()</span></span>&#123;</span><br><span class="line">        state.deductMoney();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//抽奖 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">raffle</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="comment">// 如果当前的状态是抽奖成功</span></span><br><span class="line">        <span class="keyword">if</span>(state.raffle())&#123;</span><br><span class="line">        	<span class="comment">//领取奖品</span></span><br><span class="line">            state.dispensePrize();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里请大家注意，每领取一次奖品，count--</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> curCount = count; </span><br><span class="line">    	count--;</span><br><span class="line">        <span class="keyword">return</span> curCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCount</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getNoRafflleState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> noRafflleState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNoRafflleState</span><span class="params">(State noRafflleState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.noRafflleState = noRafflleState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getCanRaffleState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> canRaffleState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCanRaffleState</span><span class="params">(State canRaffleState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.canRaffleState = canRaffleState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getDispenseState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dispenseState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDispenseState</span><span class="params">(State dispenseState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dispenseState = dispenseState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getDispensOutState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dispensOutState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDispensOutState</span><span class="params">(State dispensOutState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dispensOutState = dispensOutState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：客户端，调用者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 状态模式测试类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建活动对象，奖品有1个奖品</span></span><br><span class="line">        RaffleActivity activity = <span class="keyword">new</span> RaffleActivity(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 我们连续抽30次奖</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;--------第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;次抽奖----------&quot;</span>);</span><br><span class="line">            <span class="comment">// 参加抽奖，第一步点击扣除积分</span></span><br><span class="line">            activity.debuctMoney();</span><br><span class="line">            <span class="comment">// 第二步抽奖</span></span><br><span class="line">            activity.raffle();</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="24-4、状态模式在实际项目-借贷平台源码分析"><a href="#24-4、状态模式在实际项目-借贷平台源码分析" class="headerlink" title="24.4、状态模式在实际项目-借贷平台源码分析"></a>24.4、状态模式在实际项目-借贷平台源码分析</h3><p>借贷平台的订单，有审核-发布-抢单 等等 步骤，随着操作的不同，会改变订单的状态, 项目中的这个模块实现就会使用到状态模式：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418213432465.png" alt="image-20210418213432465"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418213517578.png" alt="image-20210418213517578"></p>
<p>实现类图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418213541498.png" alt="image-20210418213541498"></p>
<p>代码实现：</p>
<p>State：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 状态接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 电审</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkEvent</span><span class="params">(Context context)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 电审失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkFailEvent</span><span class="params">(Context context)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定价发布</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makePriceEvent</span><span class="params">(Context context)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">acceptOrderEvent</span><span class="params">(Context context)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无人接单失效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notPeopleAcceptEvent</span><span class="params">(Context context)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 付款</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">payOrderEvent</span><span class="params">(Context context)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接单有人支付失效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">orderFailureEvent</span><span class="params">(Context context)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反馈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">feedBackEvent</span><span class="params">(Context context)</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getCurrentState</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractState：实现State接口方法的默认实现。子类通过自己的需求进行重写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">	rotected <span class="keyword">static</span> <span class="keyword">final</span> RuntimeException EXCEPTION = <span class="keyword">new</span> RuntimeException(<span class="string">&quot;操作流程不允许&quot;</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> EXCEPTION;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkFailEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> EXCEPTION;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makePriceEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> EXCEPTION;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acceptOrderEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> EXCEPTION;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notPeopleAcceptEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> EXCEPTION;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">payOrderEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> EXCEPTION;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">orderFailureEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> EXCEPTION;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">feedBackEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> EXCEPTION;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>各种具体状态类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//各种具体状态类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeedBackState</span> <span class="keyword">extends</span> <span class="title">AbstractState</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> StateEnum.FEED_BACKED.getValue();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenerateState</span> <span class="keyword">extends</span> <span class="title">AbstractState</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">		context.setState(<span class="keyword">new</span> ReviewState());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkFailEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">		context.setState(<span class="keyword">new</span> FeedBackState());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> StateEnum.GENERATE.getValue();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotPayState</span> <span class="keyword">extends</span> <span class="title">AbstractState</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">payOrderEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">		context.setState(<span class="keyword">new</span> PaidState());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">feedBackEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">		context.setState(<span class="keyword">new</span> FeedBackState());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> StateEnum.NOT_PAY.getValue();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaidState</span> <span class="keyword">extends</span> <span class="title">AbstractState</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">feedBackEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">		context.setState(<span class="keyword">new</span> FeedBackState());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> StateEnum.PAID.getValue();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PublishState</span> <span class="keyword">extends</span> <span class="title">AbstractState</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acceptOrderEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">		context.setState(<span class="keyword">new</span> NotPayState());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notPeopleAcceptEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">		context.setState(<span class="keyword">new</span> FeedBackState());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> StateEnum.PUBLISHED.getValue();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReviewState</span> <span class="keyword">extends</span> <span class="title">AbstractState</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makePriceEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">		context.setState(<span class="keyword">new</span> PublishState());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> StateEnum.REVIEWED.getValue();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StateEnum：状态枚举类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 状态枚举类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">StateEnum</span> </span>&#123;</span><br><span class="line">	 <span class="comment">//订单生成</span></span><br><span class="line">    GENERATE(<span class="number">1</span>, <span class="string">&quot;GENERATE&quot;</span>),</span><br><span class="line">    <span class="comment">//已审核</span></span><br><span class="line">    REVIEWED(<span class="number">2</span>, <span class="string">&quot;REVIEWED&quot;</span>),</span><br><span class="line">    <span class="comment">//已发布</span></span><br><span class="line">    PUBLISHED(<span class="number">3</span>, <span class="string">&quot;PUBLISHED&quot;</span>),</span><br><span class="line">    <span class="comment">//待付款</span></span><br><span class="line">    NOT_PAY(<span class="number">4</span>, <span class="string">&quot;NOT_PAY&quot;</span>),</span><br><span class="line">    <span class="comment">//已付款</span></span><br><span class="line">    PAID(<span class="number">5</span>, <span class="string">&quot;PAID&quot;</span>),</span><br><span class="line">    <span class="comment">//已完结</span></span><br><span class="line">    FEED_BACKED(<span class="number">6</span>, <span class="string">&quot;FEED_BACKED&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    StateEnum(<span class="keyword">int</span> key, String value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getKey</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> key;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> value;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Context：环境上下文</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//环境上下文</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> <span class="keyword">extends</span> <span class="title">AbstractState</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> State state;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        state.checkEvent(<span class="keyword">this</span>);</span><br><span class="line">        getCurrentState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkFailEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        state.checkFailEvent(<span class="keyword">this</span>);</span><br><span class="line">        getCurrentState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makePriceEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        state.makePriceEvent(<span class="keyword">this</span>);</span><br><span class="line">        getCurrentState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acceptOrderEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        state.acceptOrderEvent(<span class="keyword">this</span>);</span><br><span class="line">        getCurrentState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notPeopleAcceptEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        state.notPeopleAcceptEvent(<span class="keyword">this</span>);</span><br><span class="line">        getCurrentState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">payOrderEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        state.payOrderEvent(<span class="keyword">this</span>);</span><br><span class="line">        getCurrentState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">orderFailureEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        state.orderFailureEvent(<span class="keyword">this</span>);</span><br><span class="line">        getCurrentState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">feedBackEvent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        state.feedBackEvent(<span class="keyword">this</span>);</span><br><span class="line">        getCurrentState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前状态 : &quot;</span> + state.getCurrentState());</span><br><span class="line">        <span class="keyword">return</span> state.getCurrentState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ClientTest：测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**测试类*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Context context = <span class="keyword">new</span> Context();</span><br><span class="line">        context.setState(<span class="keyword">new</span> PublishState());</span><br><span class="line">        <span class="comment">//然后可以根据操作变化状态.</span></span><br><span class="line">        <span class="comment">//publish --&gt; not pay</span></span><br><span class="line">       context.acceptOrderEvent(context);</span><br><span class="line">        <span class="comment">//not pay --&gt; paid</span></span><br><span class="line">        context.payOrderEvent(context);</span><br><span class="line">        <span class="comment">// 失败, 检测失败时，会抛出异常</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	context.checkFailEvent(context);</span><br><span class="line">        	System.out.println(<span class="string">&quot;流程正常..&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			System.out.println(e.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="24-5、状态模式总结"><a href="#24-5、状态模式总结" class="headerlink" title="24.5、状态模式总结"></a>24.5、状态模式总结</h3><p>主要优点如下：</p>
<ol>
<li><strong>结构清晰</strong>，状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，<strong>满足“单一职责原则”</strong>。</li>
<li><strong>枚举可能的状态</strong>，在枚举状态之前需要确定状态种类。</li>
<li><strong>将状态转换显示化，减少对象间的相互依赖</strong>。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。</li>
<li><strong>允许状态转换逻辑与状态对象合成一体</strong>，而不是某一个巨大的条件语句块。</li>
<li>将<strong>所有与某个状态有关的行为放到一个类中</strong>，并且<strong>可以方便地增加新的状态</strong>，只需要改变对象状态即可改变对象的行为。 </li>
<li>可以让多个环境对象共享一个状态对象，从而<strong>减少系统中对象的个数</strong></li>
<li><strong>状态类职责明确，有利于程序的扩展</strong>。通过定义新的子类很容易地增加新的状态和转换。</li>
</ol>
<p>状态模式的主要缺点如下：</p>
<ol>
<li>状态模式的使用必然会<strong>增加系统的类与对象的个数</strong>。</li>
<li>状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。</li>
<li><strong>状态模式对开闭原则的支持并不太好</strong>，对于可以切换状态的状态模式，增加新的状态类<strong>需要修改那些负责状态转换的源码，否则无法切换到新增状态</strong>，而且修改某个状态类的行为也需要修改对应类的源码。</li>
</ol>
<p>状态模式的应用场景：</p>
<ul>
<li>当一个对象的<strong>行为取决于它的状态</strong>，并且它必须<strong>在运行时根据状态改变它的行为</strong>时，就可以考虑使用状态模式。</li>
<li><strong>一个操作中含有庞大的分支结构</strong>，并且这些<strong>分支决定于对象的状态</strong>时。</li>
<li>当<strong>一个事件或者对象有很多种状态</strong>，<strong>状态之间会相互转换</strong>，对<strong>不同的状态要求有不同的行为</strong>的时候， 可以考虑使用状态模式</li>
</ul>
<h3 id="24-6、状态模式扩展"><a href="#24-6、状态模式扩展" class="headerlink" title="24.6、状态模式扩展"></a>24.6、状态模式扩展</h3><h4 id="24-6-1、状态模式-享元模式"><a href="#24-6-1、状态模式-享元模式" class="headerlink" title="24.6.1、状态模式 + 享元模式"></a>24.6.1、状态模式 + 享元模式</h4><p>在有些情况下，可能有<strong>多个环境对象需要共享一组状态</strong>，这时需要引入<strong>享元模式</strong>，将这些具体状态对象放在集合中供程序共享，其结构图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418212557965.png" alt="image-20210418212557965"></p>
<p>分析：共享状态模式的不同之处是在环境类中增加了一个 HashMap 来保存相关状态，当需要某种状态时可以从中获取，其程序代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> state;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyweightStatePattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShareContext context = <span class="keyword">new</span> ShareContext(); <span class="comment">//创建环境      </span></span><br><span class="line">        context.Handle(); <span class="comment">//处理请求</span></span><br><span class="line">        context.Handle();</span><br><span class="line">        context.Handle();</span><br><span class="line">        context.Handle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//环境类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ShareState state;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, ShareState&gt; stateSet = <span class="keyword">new</span> HashMap&lt;String, ShareState&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShareContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state = <span class="keyword">new</span> ConcreteState1();</span><br><span class="line">        stateSet.put(<span class="string">&quot;1&quot;</span>, state);</span><br><span class="line">        state = <span class="keyword">new</span> ConcreteState2();</span><br><span class="line">        stateSet.put(<span class="string">&quot;2&quot;</span>, state);</span><br><span class="line">        state = getState(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置新状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(ShareState state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ShareState <span class="title">getState</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        ShareState s = (ShareState) stateSet.get(key);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对请求做处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state.Handle(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象状态类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ShareState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Handle</span><span class="params">(ShareContext context)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体状态1类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteState1</span> <span class="keyword">extends</span> <span class="title">ShareState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span><span class="params">(ShareContext context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前状态是： 状态1&quot;</span>);</span><br><span class="line">        context.setState(context.getState(<span class="string">&quot;2&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体状态2类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteState2</span> <span class="keyword">extends</span> <span class="title">ShareState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span><span class="params">(ShareContext context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前状态是： 状态2&quot;</span>);</span><br><span class="line">        context.setState(context.getState(<span class="string">&quot;1&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="24-6-2、状态模式与责任链模式的区别"><a href="#24-6-2、状态模式与责任链模式的区别" class="headerlink" title="24.6.2、状态模式与责任链模式的区别"></a>24.6.2、状态模式与责任链模式的区别</h4><ol>
<li><strong>状态模式和责任链模式都能消除 if-else 分支过多的问题</strong>。但在某些情况下，<strong>状态模式中的状态可以理解为责任</strong>，那么在这种情况下，<strong>两种模式都可以使用</strong>。</li>
<li>从<strong>定义</strong>来看，<strong>状态模式强调的是一个对象内在状态的改变</strong>，而<strong>责任链模式强调的是外部节点对象间的改变</strong>。</li>
<li>从<strong>代码实现</strong>上来看，两者最大的区别就是<strong>状态模式的各个状态对象知道自己要进入的下一个状态对象</strong>，而<strong>责任链模式并不清楚其下一个节点处理对象</strong>，因为<strong>链式组装由客户端负责</strong>。</li>
</ol>
<h4 id="24-6-3、状态模式与策略模式的区别"><a href="#24-6-3、状态模式与策略模式的区别" class="headerlink" title="24.6.3、状态模式与策略模式的区别"></a>24.6.3、状态模式与策略模式的区别</h4><p><strong>状态模式和策略模式的 UML 类图架构几乎完全一样，但两者的应用场景是不一样的</strong>。<strong>策略模式的多种算法行为择其一都能满足，彼此之间是独立的</strong>，<strong>用户可自行更换策略算法</strong>，而<strong>状态模式的各个状态间存在相互关系，彼此之间在一定条件下存在自动切换状态的效果</strong>，并且<strong>用户无法指定状态，只能设置初始状态</strong>。</p>
<h3 id="24-7、进阶阅读"><a href="#24-7、进阶阅读" class="headerlink" title="24.7、进阶阅读"></a>24.7、进阶阅读</h3><p>如果您想深入了解状态模式，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8490.html">《使用状态模式自由切换登录状态》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8492.html">《使用状态机实现订单状态流转控制》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8493.html">《状态模式在JSF源码中的应用》</a></li>
</ul>
<h3 id="24-8、相关设计模式"><a href="#24-8、相关设计模式" class="headerlink" title="24.8、相关设计模式"></a>24.8、相关设计模式</h3><ul>
<li><p>Singleton 模式</p>
<p>Singleton模式常常会出现在ConcreteState角色中。这是因为在表示状态的类中并没有定义任何实例字段(即表示实例的状态的字段)。</p>
</li>
<li><p>Flyweight 模式</p>
<p>在表示状态的类中并没有定义任何实例字段。因此，有时我们可以使用Flyweight模式在多个Context角色之间共享ConcreteState角色。</p>
</li>
</ul>
<h3 id="24-9、状态模式的注意事项与细节"><a href="#24-9、状态模式的注意事项与细节" class="headerlink" title="24.9、状态模式的注意事项与细节"></a>24.9、状态模式的注意事项与细节</h3><ol>
<li>代码有<strong>很强的可读性</strong>。状态模式将<strong>每个状态的行为封装到对应的一个类</strong>中</li>
<li><strong>方便维护</strong>。将<strong>容易产生问题的 if-else 语句删除</strong>了，如果把每个状态的行为都放到一个类中，每次调用方法时都要判断当前是什么状态，不但会产出很多 if-else 语句，而且容易出错</li>
<li>会产生很多类。<strong>每个状态都要一个对应的类，当状态过多时会产生很多类，加大维护难度</strong></li>
</ol>
<h2 id="25、策略模式Strategy（行为型模式）"><a href="#25、策略模式Strategy（行为型模式）" class="headerlink" title="25、策略模式Strategy（行为型模式）"></a>25、策略模式Strategy（行为型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418214750299.png" alt="image-20210418214750299"></p>
<h3 id="25-1、基本介绍"><a href="#25-1、基本介绍" class="headerlink" title="25.1、基本介绍"></a>25.1、基本介绍</h3><ol>
<li>策略模式（Strategy Pattern）中，<strong>定义算法族（策略组），分别封装起来，让他们之间可以互相替换</strong>，此模式让<strong>算法的变化独立于使用算法的客户</strong></li>
<li>策略模式属于对象行为模式，它通过<strong>对算法进行封装</strong>，把<strong>使用算法的责任和算法的实现分割开来</strong>，并<strong>委派给不同的对象对这些算法进行管理</strong>。</li>
<li>在策略模式中，我们创建表示<strong>各种策略的对象和一个行为随着策略对象改变而改变的 context 对象</strong>。策略对象改变 context 对象的执行算法。</li>
<li>策略模式的核心思想是<strong>在一个计算方法中把容易变化的算法抽出来作为“策略”参数传进去</strong>，从而使得<strong>新增策略不必修改原有逻辑</strong>。</li>
<li>这算法体现了几个设计原则：<ol>
<li>把变化的代码从不变的代码中分离出来</li>
<li>第二、针对接口编程而不是具体类（定义了策略接口）</li>
<li>第三、多用组合/聚合，少用继承（客户通过组合方式使用策略）。</li>
</ol>
</li>
</ol>
<h3 id="25-2、策略模式的原理结构图-uml类图"><a href="#25-2、策略模式的原理结构图-uml类图" class="headerlink" title="25.2、策略模式的原理结构图-uml类图"></a>25.2、策略模式的原理结构图-uml类图</h3><p>策略模式是准备一组算法，并将这组算法封装到一系列的策略类里面，作为一个抽象策略类的子类。策略模式的<strong>重心</strong>不是如何实现算法，而<strong>是如何组织这些算法</strong>，从而让程序结构更加灵活，具有更好的维护性和扩展性。</p>
<h4 id="25-2-1、模式的结构"><a href="#25-2-1、模式的结构" class="headerlink" title="25.2.1、模式的结构"></a>25.2.1、模式的结构</h4><p>策略模式的主要角色如下：</p>
<ol>
<li><strong>抽象策略（Strategy）</strong>类：定义了一个<strong>公共接口</strong>，<strong>各种不同的算法以不同的方式实现这个接口</strong>，<strong>环境角色使用这个接口调用不同的算法</strong>，一般使用<strong>接口或抽象类</strong>实现。</li>
<li><strong>具体策略（Concrete Strategy）</strong>类：实现了抽象策略定义的接口，提供具体的算法实现。</li>
<li><strong>环境（Context）</strong>类：<strong>持有一个策略类的引用</strong>，最终给客户端调用。</li>
</ol>
<p>其结构图如图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418225857983.png" alt="image-20210418225857983"></p>
<h4 id="25-3-2、代码实现"><a href="#25-3-2、代码实现" class="headerlink" title="25.3.2、代码实现"></a>25.3.2、代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context c = <span class="keyword">new</span> Context();</span><br><span class="line">        Strategy s = <span class="keyword">new</span> ConcreteStrategyA();</span><br><span class="line">        c.setStrategy(s);</span><br><span class="line">        c.strategyMethod();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">        s = <span class="keyword">new</span> ConcreteStrategyB();</span><br><span class="line">        c.setStrategy(s);</span><br><span class="line">        c.strategyMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象策略类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyMethod</span><span class="params">()</span></span>;    <span class="comment">//策略方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体策略类A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体策略A的策略方法被访问！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体策略类B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体策略B的策略方法被访问！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象策略类1</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Strategy1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyMethod</span><span class="params">()</span></span>;    <span class="comment">//策略方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体策略类C</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyC</span> <span class="keyword">implements</span> <span class="title">Strategy1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体策略C的策略方法被访问！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体策略类D</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyD</span> <span class="keyword">implements</span> <span class="title">Strategy1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体策略D的策略方法被访问！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//环境类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line">    <span class="keyword">private</span> Strategy1 strategy1;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Strategy <span class="title">getStrategy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrategy</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        strategy.strategyMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="25-3、应用举例"><a href="#25-3、应用举例" class="headerlink" title="25.3、应用举例"></a>25.3、应用举例</h3><p>编写鸭子项目，具体要求如下:</p>
<ol>
<li>有各种鸭子(比如 野鸭、北京鸭、水鸭等， 鸭子有各种行为，比如 叫、飞行等)</li>
<li>显示鸭子的信息</li>
</ol>
<h4 id="25-3-1、使用传统方式解决需求"><a href="#25-3-1、使用传统方式解决需求" class="headerlink" title="25.3.1、使用传统方式解决需求"></a>25.3.1、使用传统方式解决需求</h4><p>传统的设计方案(类图)：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418230442078.png" alt="image-20210418230442078"></p>
<p>传统的方式实现的问题分析和解决方案：</p>
<ol>
<li>其它鸭子，都继承了 Duck 类，所以 fly 让所有子类都会飞了，这是不正确的</li>
<li>上面说的 1 的问题，其实是继承带来的问题：对类的局部改动，尤其超类的局部改动，会影响其他部分。会有溢出效应</li>
<li>为了改进 1 问题，我们可以通过覆盖 fly 方法来解决 =&gt; 覆盖解决</li>
<li>问题又来了，如果我们有一个玩具鸭子 ToyDuck, 这样就需要 <strong>ToyDuck</strong> 去覆盖 <strong>Duck</strong> 的所有实现的方法 =&gt; 解决思路 -》 策略模式 (strategy pattern)</li>
</ol>
<h4 id="25-3-2、使用策略模式解决需求"><a href="#25-3-2、使用策略模式解决需求" class="headerlink" title="25.3.2、使用策略模式解决需求"></a>25.3.2、使用策略模式解决需求</h4><p>思路分析(类图)：</p>
<p>策略模式：分别封装行为接口，实现算法族，超类里放行为接口对象，在子类里具体设定行为对象。</p>
<p>原则就是： 分离变化部分，封装接口，基于接口编程各种功能。此模式让行为的变化独立于算法的使用者。</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418230737776.png" alt="image-20210418230737776"></p>
<p>代码实现：</p>
<p>FlyBehavior：飞行。（QuackBehavior：叫行为。等等其它抽象策略与其具体实现类类似）<strong>抽象策略（Strategy）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FlyBehavior</span> </span>&#123;	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>; <span class="comment">// 子类具体实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GoodFlyBehavior：飞行技术高超。（BadFlyBehavior：飞行技术一般、NoFlyBehavior：不会飞行等等类似）<strong>具体策略（Concrete Strategy）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodFlyBehavior</span> <span class="keyword">implements</span> <span class="title">FlyBehavior</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; 飞翔技术高超 ~~~&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Duck：鸭子抽象类。<strong>环境（Context）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">	<span class="comment">//属性, 策略接口</span></span><br><span class="line">	FlyBehavior flyBehavior;</span><br><span class="line">	<span class="comment">//其它属性&lt;-&gt;策略接口</span></span><br><span class="line">	QuackBehavior quackBehavior;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Duck</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;<span class="comment">//显示鸭子信息</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;鸭子嘎嘎叫~~&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;鸭子会游泳~~&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//改进</span></span><br><span class="line">		<span class="keyword">if</span>(flyBehavior != <span class="keyword">null</span>) &#123;</span><br><span class="line">			flyBehavior.fly();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlyBehavior</span><span class="params">(FlyBehavior flyBehavior)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.flyBehavior = flyBehavior;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setQuackBehavior</span><span class="params">(QuackBehavior quackBehavior)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.quackBehavior = quackBehavior;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WildDuck：野鸭具体类，继承了鸭子抽象类。（PekingDuck：北京鸭，飞行技术一般、ToyDuck：玩具鸭，不会飞行类似）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WildDuck</span> <span class="keyword">extends</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">	<span class="comment">//构造器，传入FlyBehavor 的对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span>  <span class="title">WildDuck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		flyBehavior = <span class="keyword">new</span> GoodFlyBehavior();</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; 这是野鸭 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：客户端，负责调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		WildDuck wildDuck = <span class="keyword">new</span> WildDuck();</span><br><span class="line">		wildDuck.fly();</span><br><span class="line">		ToyDuck toyDuck = <span class="keyword">new</span> ToyDuck();</span><br><span class="line">		toyDuck.fly();</span><br><span class="line">		PekingDuck pekingDuck = <span class="keyword">new</span> PekingDuck();</span><br><span class="line">		pekingDuck.fly();</span><br><span class="line">		<span class="comment">//动态改变某个对象的行为, 北京鸭 不能飞</span></span><br><span class="line">		pekingDuck.setFlyBehavior(<span class="keyword">new</span> NoFlyBehavior());</span><br><span class="line">		System.out.println(<span class="string">&quot;北京鸭的实际飞翔能力&quot;</span>);</span><br><span class="line">		pekingDuck.fly();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="25-4、策略模式在JDK的应用与源码"><a href="#25-4、策略模式在JDK的应用与源码" class="headerlink" title="25.4、策略模式在JDK的应用与源码"></a>25.4、策略模式在JDK的应用与源码</h3><p>JDK 的 Arrays 的 Comparator 就使用了策略模式</p>
<p>代码分析+Debug 源码：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419001920044.png" alt="image-20210419001920044"></p>
<p>main：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//数组</span></span><br><span class="line">		Integer[] data = &#123; <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">3</span> &#125;;</span><br><span class="line">		<span class="comment">// 实现降序排序，返回-1放左边，1放右边，0保持不变</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 说明</span></span><br><span class="line">		<span class="comment">// 1. 实现了 Comparator 接口（策略接口） , 匿名类 对象 new Comparator&lt;Integer&gt;()&#123;..&#125;</span></span><br><span class="line">		<span class="comment">// 2. 对象 new Comparator&lt;Integer&gt;()&#123;..&#125; 就是实现了 策略接口 的对象</span></span><br><span class="line">		<span class="comment">// 3. public int compare(Integer o1, Integer o2)&#123;&#125; 指定具体的处理方式</span></span><br><span class="line">		Comparator&lt;Integer&gt; comparator = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">if</span> (o1 &gt; o2) &#123;</span><br><span class="line">					<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">// 说明</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) &#123;</span></span><br><span class="line"><span class="comment">		        if (c == null) &#123;</span></span><br><span class="line"><span class="comment">		            sort(a); //默认方法</span></span><br><span class="line"><span class="comment">		        &#125; else &#123; </span></span><br><span class="line"><span class="comment">		            if (LegacyMergeSort.userRequested)</span></span><br><span class="line"><span class="comment">		                legacyMergeSort(a, c); //使用策略对象c</span></span><br><span class="line"><span class="comment">		            else</span></span><br><span class="line"><span class="comment">		            	// 使用策略对象c</span></span><br><span class="line"><span class="comment">		                TimSort.sort(a, 0, a.length, c, null, 0, 0);</span></span><br><span class="line"><span class="comment">		        &#125;</span></span><br><span class="line"><span class="comment">		    &#125;</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//方式1 </span></span><br><span class="line">		Arrays.sort(data, comparator);</span><br><span class="line">		System.out.println(Arrays.toString(data)); <span class="comment">// 降序排序</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//方式2- 同时lambda 表达式实现 策略模式</span></span><br><span class="line">		Integer[] data2 = &#123; <span class="number">19</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">18</span>, <span class="number">14</span>, <span class="number">13</span> &#125;;</span><br><span class="line">		</span><br><span class="line">		Arrays.sort(data2, (var1, var2) -&gt; &#123;</span><br><span class="line">			<span class="keyword">if</span>(var1.compareTo(var2) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);	</span><br><span class="line">		System.out.println(<span class="string">&quot;data2=&quot;</span> + Arrays.toString(data2));	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Comparator<T>：是一个接口，其中有一个compare的核心方法：告诉代码应该怎么去比较两个实例，然后根据比较结果进行排序</T></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419000512228.png" alt="image-20210419000512228"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419001129754.png" alt="image-20210419001129754"></p>
<p>Array的sort排序方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419001333373.png" alt="image-20210419001333373"></p>
<h3 id="25-5、-策略模式总结"><a href="#25-5、-策略模式总结" class="headerlink" title="25.5、 策略模式总结"></a>25.5、 策略模式总结</h3><p>主要优点如下：</p>
<ol>
<li>多重条件语句不易维护，而<strong>使用策略模式可以避免使用多重条件语句</strong>，如 if…else 语句、switch…case 语句。</li>
<li>策略模式提供了<strong>一系列的可供重用的算法族</strong>，<strong>恰当使用继承可以把算法族的公共代码转移到父类里面</strong>，从而避免重复的代码。</li>
<li>策略模式可以<strong>提供相同行为的不同实现</strong>，<strong>客户可以根据不同时间或空间要求选择不同的实现</strong>。</li>
<li>策略模式提供了<strong>对开闭原则的完美支持</strong>，可以在不修改原代码的情况下，灵活增加新算法。</li>
<li>策略模式把<strong>算法的使用放到环境类</strong>中，而<strong>算法的实现移到具体策略类</strong>中，<strong>实现了二者的分离</strong>。</li>
</ol>
<p>其主要缺点如下：</p>
<ol>
<li>所有策略类都需要对外暴露。<strong>客户端必须理解所有策略算法的区别</strong>，以便适时选择恰当的算法类。</li>
<li>策略模式造成<strong>很多的策略类，增加维护难度</strong>。</li>
</ol>
<p>策略模式的应用场景：</p>
<p>策略模式在很多地方用到，如 <strong>Java SE 中的容器布局管理</strong>就是一个典型的实例，Java SE 中的每个容器都存在多种布局供用户选择。在程序设计中，通常在以下几种情况中使用策略模式较多。</p>
<ol>
<li><strong>一个系统需要动态地在几种算法中选择一种</strong>时，可将每个算法封装到策略类中。</li>
<li>一个类定义了<strong>多种行为</strong>，并且<strong>这些行为在这个类的操作中以多个条件语句的形式出现</strong>，可<strong>将每个条件分支移入它们各自的策略类中以代替这些条件语句</strong>。</li>
<li>系统中<strong>各算法彼此完全独立</strong>，且<strong>要求对客户隐藏具体算法的实现细节</strong>时。</li>
<li>系统要求<strong>使用算法的客户不应该知道其操作的数据</strong>时，可使用策略模式来隐藏与算法相关的数据结构。</li>
<li><strong>多个类只区别在表现行为不同</strong>，可以使用策略模式，在运行时动态选择具体要执行的行为。</li>
</ol>
<h3 id="25-6、策略模式扩展（策略模式-工厂模式）"><a href="#25-6、策略模式扩展（策略模式-工厂模式）" class="headerlink" title="25.6、策略模式扩展（策略模式+工厂模式）"></a>25.6、策略模式扩展（策略模式+工厂模式）</h3><p>在一个使用策略模式的系统中，当存在的策略很多时，客户端管理所有策略算法将变得很复杂，如果<strong>在环境类中使用策略工厂模式来管理这些策略类</strong>将大大减少客户端的工作复杂度，其结构图如图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210418232858259.png" alt="image-20210418232858259"></p>
<h3 id="25-7、进阶阅读"><a href="#25-7、进阶阅读" class="headerlink" title="25.7、进阶阅读"></a>25.7、进阶阅读</h3><p>如果您想深入了解策略模式，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8481.html">《使用策略模式实现电商多种促销优惠方案选择》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8482.html">《使用策略模式实现支付方式选择场景》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8483.html">《策略模式在JDK源码中的应用》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8484.html">《策略模式在Spring源码中的应用》</a></li>
</ul>
<h3 id="25-8、相关设计模式"><a href="#25-8、相关设计模式" class="headerlink" title="25.8、相关设计模式"></a>25.8、相关设计模式</h3><ul>
<li><p>Flyweight模式</p>
<p>有时会使用Flyweight模式让多个地方可以共用ConcreteStrategy角色。</p>
</li>
<li><p>Abstract Factory模式</p>
<p>使用Strategy模式可以整体地替换算法。</p>
<p>使用Abstract Factory模式则可以整体地替换具体工厂、零件和产品。</p>
</li>
<li><p>State 模式</p>
<p>使用Strategy模式和State模式都可以替换被委托对象，而且它们的类之间的关系也很相似。但是两种模式的目的不同。</p>
<p>在Strategy模式中，ConcreteStrategy 角色是表示算法的类。在Strategy模式中，可以替换被委托对象的类。当然如果没有必要，也可以不替换。</p>
<p>而在State模式中，ConcreteState角色是表示“状态”的类。在State模式中，每次状态变化时，被委托对象的类都必定会被替换。</p>
</li>
</ul>
<h3 id="25-9、策略模式的注意事项与细节"><a href="#25-9、策略模式的注意事项与细节" class="headerlink" title="25.9、策略模式的注意事项与细节"></a>25.9、策略模式的注意事项与细节</h3><ol>
<li>策略模式的关键是：<strong>分析项目中变化部分与不变部分</strong></li>
<li>策略模式的核心思想是：<strong>多用组合/聚合 少用继承；用行为类组合，而不是行为的继承。更有弹性</strong></li>
<li><strong>体现了“对修改关闭，对扩展开放”原则</strong>，客户端增加行为不用修改原有代码，只要添加一种策略（或者行为） 即可，<strong>避免了使用多重转移语句（if..else if..else）</strong></li>
<li>提供了可以<strong>替换继承关系</strong>的办法： 策略模式将算法封装在独立的 Strategy 类中使得你可以独立于其 Context 改变它，使它易于切换、易于理解、易于扩展</li>
<li>需要注意的是：每添加一个策略就要增加一个类，当<strong>策略过多是会导致类数目庞大</strong></li>
<li>如果一个系统的策略多于四个，就需要考虑<strong>使用混合模式（策略模式+工厂模式）</strong>，解决策略类膨胀的问题。</li>
</ol>
<h2 id="26、职责链模式Chain-of-Responsibility（行为型模式）"><a href="#26、职责链模式Chain-of-Responsibility（行为型模式）" class="headerlink" title="26、职责链模式Chain of Responsibility（行为型模式）"></a>26、职责链模式Chain of Responsibility（行为型模式）</h2><p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419002157100.png" alt="image-20210419002157100"></p>
<h3 id="26-1、基本介绍"><a href="#26-1、基本介绍" class="headerlink" title="26.1、基本介绍"></a>26.1、基本介绍</h3><ol>
<li>职责链模式（Chain of Responsibility Pattern）, 又叫<strong>责任链模式</strong>，为<strong>请求创建了一个接收者对象的链</strong>。这种模式对<strong>请求的发送者和接收者进行解耦</strong>。</li>
<li>为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</li>
<li>职责链模式通常<strong>每个接收者都包含对另一个接收者的引用（形成闭环）</strong>。如果<strong>一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者</strong>，依此类推。</li>
<li>在责任链模式中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，请求会自动进行传递。所以责任链将请求的发送者和请求的处理者解耦了。</li>
<li>这种类型的设计模式属于<strong>行为型模式</strong></li>
</ol>
<h3 id="26-2、职责链模式的原理结构图-uml类图"><a href="#26-2、职责链模式的原理结构图-uml类图" class="headerlink" title="26.2、职责链模式的原理结构图-uml类图"></a>26.2、职责链模式的原理结构图-uml类图</h3><p>通常情况下，可以通过数据链表来实现职责链模式的数据结构。</p>
<h4 id="26-2-1、模式的结构"><a href="#26-2-1、模式的结构" class="headerlink" title="26.2.1、模式的结构"></a>26.2.1、模式的结构</h4><p>职责链模式主要包含以下角色：</p>
<ol>
<li><strong>抽象处理者（Handler）</strong>角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接Handler对象。</li>
<li><strong>具体处理者（Concrete Handler）</strong>角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。从而形成一个职责链。</li>
<li><strong>请求类（Request）</strong>角色 ， 含义很多属性，表示一个请求</li>
<li><strong>客户类（Client）</strong>角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</li>
</ol>
<p>责任链模式的本质是解耦请求与处理，让请求在处理链中能进行传递与被处理；理解责任链模式应当理解其模式，而不是其具体实现。责任链模式的独到之处是将其节点处理者组合成了链式结构，并允许节点自身决定是否进行请求处理或转发，相当于让请求流动起来。</p>
<p>其结构图如图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419020914621.png" alt="image-20210419020914621"></p>
<p>客户端可按下图所示设置责任链：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419021241297.png" alt="image-20210419021241297"></p>
<h4 id="26-2-2、代码实现"><a href="#26-2-2、代码实现" class="headerlink" title="26.2.2、代码实现"></a>26.2.2、代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chainOfResponsibility;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainOfResponsibilityPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//组装责任链</span></span><br><span class="line">        Handler handler1 = <span class="keyword">new</span> ConcreteHandler1();</span><br><span class="line">        Handler handler2 = <span class="keyword">new</span> ConcreteHandler2();</span><br><span class="line">        handler1.setNext(handler2);</span><br><span class="line">        <span class="comment">//提交请求</span></span><br><span class="line">        handler1.handleRequest(<span class="string">&quot;two&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象处理者角色</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Handler next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Handler next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Handler <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理请求的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(String request)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体处理者角色1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandler1</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(String request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.equals(<span class="string">&quot;one&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体处理者1负责处理该请求！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (getNext() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                getNext().handleRequest(request);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;没有人处理该请求！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体处理者角色2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandler2</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(String request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.equals(<span class="string">&quot;two&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体处理者2负责处理该请求！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (getNext() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                getNext().handleRequest(request);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;没有人处理该请求！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面代码中，我们把消息硬编码为 String 类型，而在真实业务中，消息是具备多样性的，可以是 int、String 或者自定义类型。因此，在上面代码的基础上，可以<strong>对消息类型进行抽象 Request，增强了消息的兼容性</strong>。</p>
<h3 id="26-3、应用举例"><a href="#26-3、应用举例" class="headerlink" title="26.3、应用举例"></a>26.3、应用举例</h3><p>学校 OA 系统的采购审批项目：需求是</p>
<p>采购员采购教学器材</p>
<ol>
<li>如果金额 小于等于 5000, 由教学主任审批 （0&lt;=x&lt;=5000）</li>
<li>如果金额 小于等于 10000, 由院长审批 (5000&lt;x&lt;=10000)</li>
<li>如果金额 小于等于 30000, 由副校长审批 (10000&lt;x&lt;=30000)</li>
<li>如果金额 超过 30000 以上，有校长审批 ( 30000&lt;x)</li>
</ol>
<p>请设计程序完成采购审批项目</p>
<h4 id="26-3-1、使用传统方法解决需求"><a href="#26-3-1、使用传统方法解决需求" class="headerlink" title="26.3.1、使用传统方法解决需求"></a>26.3.1、使用传统方法解决需求</h4><p>思路分析（类图）：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419022414374.png" alt="image-20210419022414374"></p>
<p>传统方案解决 OA 系统审批问题分析：</p>
<p>传统方式是：接收到一个采购请求后，根据采购金额来调用对应的 Approver (审批人)完成审批。</p>
<p>传统方式的问题分析 : </p>
<ol>
<li>客户端这里会<strong>使用到分支判断(比如 switch) 来对不同的采购请求处理</strong>， 这样就存在如下问题：<ol>
<li> 如果各个级别的人员审批金额发生变化，在客户端的也需要变化</li>
<li>客户端必须明确的知道 有多少个审批级别和访问</li>
</ol>
</li>
<li>这样 对一个采购请求进行处理 和 Approver (审批人) 就存在强耦合关系，不利于代码的扩展和维护</li>
<li>解决方案 =》 职责链模式</li>
</ol>
<h4 id="26-3-2、使用职责链模式解决需求"><a href="#26-3-2、使用职责链模式解决需求" class="headerlink" title="26.3.2、使用职责链模式解决需求"></a>26.3.2、使用职责链模式解决需求</h4><p>思路分析和图解(类图)：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419022837598.png" alt="image-20210419022837598"></p>
<p>代码实现：</p>
<p>PurchaseRequest：采购请求。<strong>请求类（Request）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PurchaseRequest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> type = <span class="number">0</span>; <span class="comment">//请求类型</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">float</span> price = <span class="number">0.0f</span>; <span class="comment">//请求金额</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">PurchaseRequest</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">float</span> price, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.type = type;</span><br><span class="line">		<span class="keyword">this</span>.price = price;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> type;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> price;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Approver：<strong>抽象处理者（Handler）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Approver</span> </span>&#123;</span><br><span class="line">	Approver approver;  <span class="comment">//下一个处理者</span></span><br><span class="line">	String name; <span class="comment">// 名字	</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Approver</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//下一个处理者</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApprover</span><span class="params">(Approver approver)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.approver = approver;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//处理审批请求的方法，得到一个请求, 处理是子类完成，因此该方法做成抽象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(PurchaseRequest purchaseRequest)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DepartmentApprover：教学主任处理类。（其中CollegeApprover：院长处理类（5000&lt;x&lt;=10000）、ViceSchoolMasterApprover：副校长处理类（10000&lt;x&lt;=30000）、SchoolMasterApprover：院长处理类（30000&lt;x）类似）<strong>具体处理者（Concrete Handler）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepartmentApprover</span> <span class="keyword">extends</span> <span class="title">Approver</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DepartmentApprover</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(PurchaseRequest purchaseRequest)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(purchaseRequest.getPrice() &lt;= <span class="number">5000</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot; 请求编号 id= &quot;</span> + purchaseRequest.getId() + <span class="string">&quot; 被 &quot;</span> + <span class="keyword">this</span>.name + <span class="string">&quot; 处理&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			approver.processRequest(purchaseRequest);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：<strong>客户类（Client）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建一个请求</span></span><br><span class="line">		PurchaseRequest purchaseRequest = <span class="keyword">new</span> PurchaseRequest(<span class="number">1</span>, <span class="number">31000</span>, <span class="number">1</span>);</span><br><span class="line">		<span class="comment">//创建相关的审批人</span></span><br><span class="line">		DepartmentApprover departmentApprover = <span class="keyword">new</span> DepartmentApprover(<span class="string">&quot;张主任&quot;</span>);</span><br><span class="line">		CollegeApprover collegeApprover = <span class="keyword">new</span> CollegeApprover(<span class="string">&quot;李院长&quot;</span>);</span><br><span class="line">		ViceSchoolMasterApprover viceSchoolMasterApprover = <span class="keyword">new</span> ViceSchoolMasterApprover(<span class="string">&quot;王副校&quot;</span>);</span><br><span class="line">		SchoolMasterApprover schoolMasterApprover = <span class="keyword">new</span> SchoolMasterApprover(<span class="string">&quot;佟校长&quot;</span>);</span><br><span class="line">		<span class="comment">//需要将各个审批级别的下一个设置好 (处理人构成环形: )</span></span><br><span class="line">		departmentApprover.setApprover(collegeApprover);</span><br><span class="line">		collegeApprover.setApprover(viceSchoolMasterApprover);</span><br><span class="line">		viceSchoolMasterApprover.setApprover(schoolMasterApprover);</span><br><span class="line">		schoolMasterApprover.setApprover(departmentApprover);</span><br><span class="line">		</span><br><span class="line">		departmentApprover.processRequest(purchaseRequest);</span><br><span class="line">		viceSchoolMasterApprover.processRequest(purchaseRequest);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="26-4、职责链模式在SpringMVC框架的应用与源码"><a href="#26-4、职责链模式在SpringMVC框架的应用与源码" class="headerlink" title="26.4、职责链模式在SpringMVC框架的应用与源码"></a>26.4、职责链模式在SpringMVC框架的应用与源码</h3><p>SpringMVC-HandlerExecutionChain 类就使用到职责链模式</p>
<p>SpringMVC 请求流程简图：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419011833309.png" alt="image-20210419011833309"></p>
<p>代码分析+Debug 源码：</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419012005876.png" alt="image-20210419012005876"></p>
<p>main：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerExecutionChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponsibilityChain</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// DispatcherServlet 	</span></span><br><span class="line">		<span class="comment">//说明</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 *  protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span></span><br><span class="line"><span class="comment">		 *   HandlerExecutionChain mappedHandler = null; </span></span><br><span class="line"><span class="comment">		 *   mappedHandler = getHandler(processedRequest);//获取到HandlerExecutionChain对象</span></span><br><span class="line"><span class="comment">		 *    //在 mappedHandler.applyPreHandle 内部 得到啦 HandlerInterceptor interceptor</span></span><br><span class="line"><span class="comment">		 *    //调用了拦截器的  interceptor.preHandle</span></span><br><span class="line"><span class="comment">		 *   if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span></span><br><span class="line"><span class="comment">					return;</span></span><br><span class="line"><span class="comment">				&#125;</span></span><br><span class="line"><span class="comment">				</span></span><br><span class="line"><span class="comment">			  //说明：mappedHandler.applyPostHandle 方法内部获取到拦截器，并调用 </span></span><br><span class="line"><span class="comment">			  //拦截器的  interceptor.postHandle(request, response, this.handler, mv);</span></span><br><span class="line"><span class="comment">			 mappedHandler.applyPostHandle(processedRequest, response, mv);</span></span><br><span class="line"><span class="comment">		 *  &#125;</span></span><br><span class="line"><span class="comment">		 *  </span></span><br><span class="line"><span class="comment">		 *  </span></span><br><span class="line"><span class="comment">		 *  //说明：在  mappedHandler.applyPreHandle内部中，</span></span><br><span class="line"><span class="comment">		 *  还调用了  triggerAfterCompletion 方法，该方法中调用了  </span></span><br><span class="line"><span class="comment">		 *  HandlerInterceptor interceptor = getInterceptors()[i];</span></span><br><span class="line"><span class="comment">			try &#123;</span></span><br><span class="line"><span class="comment">				interceptor.afterCompletion(request, response, this.handler, ex);</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">			catch (Throwable ex2) &#123;</span></span><br><span class="line"><span class="comment">				logger.error(&quot;HandlerInterceptor.afterCompletion threw exception&quot;, ex2);</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SpringMVC中的最重要的DispatcherServlet类，当中有一个核心方法：doDispatcher方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419012029050.png" alt="image-20210419012029050"></p>
<p>在doDispatcher方法中一开始就获取了HandlerExecutionChain对象</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419012220314.png" alt="image-20210419012220314"></p>
<p>调用preHandle方法：</p>
<p>在得到HandlerExecutionChain对象后调用了其applyPreHandle()方法，在其内部得到了HandlerInterceptor interceptor拦截器并调用了拦截器的interceptor.preHandle方法。调用成功就返回。</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419012326046.png" alt="image-20210419012326046"></p>
<p>在applyPreHandle()中通过getInterceptors( ) [i] ;方法从拦截器数组当中获取对应的拦截器，并调用了拦截器的preHandle方法。</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419012558289.png" alt="image-20210419012558289"></p>
<p>调用postHandle方法：</p>
<p>在doDispatcher方法的applyPreHandle()下面：HandlerExecutionChain对象还调用了其applyPostHandle()方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/blog\XGH-blog\source_posts\设计模式\image-20210419013424983.png" alt="image-20210419013424983"></p>
<p>在applyPostHandle()中通过getInterceptors() [i] ;方法从拦截器数组当中获取对应的拦截器，并调用了拦截器的postHandle方法。</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419013555142.png" alt="image-20210419013555142"></p>
<p>调用afterCompletion方法：</p>
<p>triggerAfterCompletion方法中得到了拦截器HandlerInterceptor并调用了拦截器的interceptor.afterCompletion方法</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419014131628.png" alt="image-20210419014131628"></p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419014819146.png" alt="image-20210419014819146"></p>
<p>对源码总结</p>
<ol>
<li>springmvc 请求的流程图中，执行了 拦截器相关方法 interceptor.preHandler 等等</li>
<li>在处理 SpringMvc 请求时，使用到职责链模式还使用到适配器模式</li>
<li>HandlerExecutionChain 主要负责的是请求拦截器的执行和请求处理,但是他本身不处理请求，只是将请求分配给链上注册处理器执行，这是职责链实现方式,减少职责链本身与处理逻辑之间的耦合,规范了处理流程</li>
<li>HandlerExecutionChain 维护了 HandlerInterceptor 的集合， 可以向其中注册相应的拦截器.</li>
</ol>
<h3 id="26-5、职责链模式总结"><a href="#26-5、职责链模式总结" class="headerlink" title="26.5、职责链模式总结"></a>26.5、职责链模式总结</h3><p>主要优点如下：</p>
<ol>
<li><strong>降低了对象之间的耦合度</strong>。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。</li>
<li><strong>增强了系统的可扩展性</strong>。可以根据需要增加新的请求处理类，<strong>满足开闭原则</strong>。</li>
<li><strong>增强了给对象指派职责的灵活性</strong>。当工作流程发生变化，可以<strong>动态地改变链内的成员或者调动它们的次序</strong>，也可<strong>动态地新增或者删除责任</strong>。</li>
<li><strong>责任链简化了对象之间的连接</strong>。<strong>每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用</strong>，这<strong>避免了使用众多的 if 或者 if···else 语句</strong>。</li>
<li><strong>责任分担</strong>。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，<strong>符合类的单一职责原则</strong>。</li>
</ol>
<p>主要缺点如下：</p>
<ol>
<li><strong>不能保证每个请求一定被处理</strong>。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，<strong>该请求可能一直传到链的末端都得不到处理</strong>。所以最好形成闭环调用，保证请求一定可以得到调用。</li>
<li>对比较长的职责链，<strong>请求的处理可能涉及多个处理对象</strong>，<strong>系统性能将受到一定影响</strong>。</li>
<li>职责链建立的合理性<strong>要靠客户端来保证，增加了客户端的复杂性</strong>，可能会由于职责链的<strong>错误设置而导致系统出错</strong>，如可能会造成<strong>循环调用</strong>。</li>
<li>可能不容易观察运行时的特征，有碍于除错。</li>
</ol>
<p>模式的应用场景：</p>
<ol>
<li><strong>多个对象可以处理一个请求</strong>，但具体由哪个对象处理该请求在运行时自动确定。</li>
<li>可<strong>动态指定一组对象处理请求</strong>，或<strong>添加新的处理者</strong>。</li>
<li>需要<strong>在不明确指定请求处理者的情况下，向多个处理者中的一个提交请求</strong>。</li>
</ol>
<p>应用实例：</p>
<ol>
<li>JS 中的事件冒泡。</li>
<li>JAVA WEB 中 Apache Tomcat 对 Encoding 的处理</li>
<li>Struts2 的拦截器</li>
<li>jsp servlet 的 Filter</li>
<li>责任链模式经常用在拦截、预处理请求等。</li>
</ol>
<h3 id="26-6、职责链模式扩展"><a href="#26-6、职责链模式扩展" class="headerlink" title="26.6、职责链模式扩展"></a>26.6、职责链模式扩展</h3><p>职责链模式存在以下两种情况：</p>
<ol>
<li><strong>纯的职责链模式</strong>：一个请求必须被某一个处理者对象所接收，且一个具体处理者对某个请求的处理只能采用以下两种行为之一：自己处理（承担责任）；把责任推给下家处理。</li>
<li><strong>不纯的职责链模式</strong>：允许出现某一个具体处理者对象<strong>在承担了请求的一部分责任后又将剩余的责任传给下家</strong>的情况，且<strong>一个请求可以最终不被任何接收端对象所接收</strong>。</li>
</ol>
<h3 id="26-7、进阶阅读"><a href="#26-7、进阶阅读" class="headerlink" title="26.7、进阶阅读"></a>26.7、进阶阅读</h3><p>如果您想深入了解责任链模式，可猛击阅读以下文章。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8487.html">《使用责任链模式实现热插拔权限控制》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_8488.html">《责任链模式和建造者模式结合使用》</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/8489.html">《责任链模式在JDK源码中的应用》</a></li>
</ul>
<h3 id="26-8、相关设计模式"><a href="#26-8、相关设计模式" class="headerlink" title="26.8、相关设计模式"></a>26.8、相关设计模式</h3><ul>
<li><p>Composite模式</p>
<p>Handler角色经常会使用Composite模式。</p>
</li>
<li><p>Command模式</p>
<p>有时会使用Command模式向Handler角色发送请求。</p>
</li>
</ul>
<h3 id="26-9、职责链模式的注意事项与细节"><a href="#26-9、职责链模式的注意事项与细节" class="headerlink" title="26.9、职责链模式的注意事项与细节"></a>26.9、职责链模式的注意事项与细节</h3><ol>
<li>将请求和处理分开，实现解耦，提高系统的灵活性</li>
<li>简化了对象，使对象不需要知道链的结构</li>
<li>性能会受到影响，特别是在链比较长的时候，因此<strong>需控制链中最大节点数量，一般通过在 Handler 中设置一个最大节点数量</strong>，<strong>在 setNext()方法中判断是否已经超过阀值，超过则不允许该链建立，避免出现超长链无意识地破坏系统性能</strong></li>
<li>调试不方便。采用了类似递归的方式，调试时逻辑可能比较复杂</li>
<li>最佳应用场景：有多个对象可以处理同一个请求时，比如：多级请求、请假/加薪等审批流程、Java Web 中 Tomcat对 Encoding 的处理、拦截器</li>
</ol>
<h2 id="27、创建型模式的特点和分类"><a href="#27、创建型模式的特点和分类" class="headerlink" title="27、创建型模式的特点和分类"></a>27、创建型模式的特点和分类</h2><p>创建型模式的主要关注点是“<strong>怎样创建对象</strong>？”，它的主要特点是“<strong>将对象的创建与使用分离</strong>”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。就像我们去商场购买商品时，不需要知道商品是怎么生产出来一样，因为它们由专门的厂商生产。</p>
<p>创建型模式分为以下几种：</p>
<ul>
<li>单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</li>
<li>原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</li>
<li>工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</li>
<li>抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</li>
<li>建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</li>
</ul>
<p>以上 5 种创建型模式，除了工厂方法模式属于类创建型模式，其他的全部属于对象创建型模式</p>
<h2 id="28、结构型模式概述（结构型模式的分类）"><a href="#28、结构型模式概述（结构型模式的分类）" class="headerlink" title="28、结构型模式概述（结构型模式的分类）"></a>28、结构型模式概述（结构型模式的分类）</h2><p>结构型模式描述<strong>如何将类或对象按某种布局组成更大的结构</strong>。它分为<strong>类结构型模式</strong>和<strong>对象结构型模式</strong>，<strong>前者采用继承机制来组织接口和类</strong>，<strong>后者釆用组合或聚合来组合对象</strong>。</p>
<p><strong>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性</strong>。</p>
<p>结构型模式分为以下 7 种：</p>
<ol>
<li>代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</li>
<li>适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</li>
<li>桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。</li>
<li>装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。</li>
<li>外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</li>
<li>享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。</li>
<li>组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</li>
</ol>
<p>以上 7 种结构型模式，除了<strong>适配器模式分为类结构型模式和对象结构型模式两种</strong>，<strong>其他的全部属于对象结构型模式</strong>。</p>
<h2 id="29、行为型模式概述（行为型模式的分类）"><a href="#29、行为型模式概述（行为型模式的分类）" class="headerlink" title="29、行为型模式概述（行为型模式的分类）"></a>29、行为型模式概述（行为型模式的分类）</h2><p>行为型模式用于<strong>描述程序在运行时复杂的流程控制</strong>，即<strong>描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务</strong>，它涉及算法与对象间职责的分配。</p>
<p><strong>行为型模式分为类行为模式和对象行为模式</strong>，<strong>前者采用继承机制来在类间分派行为</strong>，<strong>后者采用组合或聚合在对象间分配行为</strong>。</p>
<p><strong>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。</strong></p>
<p>行为型模式是 GoF 设计模式中最为庞大的一类，它包含以下 11 种模式。</p>
<ol>
<li>模板方法（Template Method）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</li>
<li>策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</li>
<li>命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</li>
<li>职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</li>
<li>状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。</li>
<li>观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</li>
<li>中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</li>
<li>迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</li>
<li>访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</li>
<li>备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</li>
<li>解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</li>
</ol>
<p>以上 11 种行为型模式，除了<strong>模板方法模式和解释器模式是类行为型模式</strong>，<strong>其他的全部属于对象行为型模式</strong>。</p>
<h2 id="30、一句话归纳设计模式"><a href="#30、一句话归纳设计模式" class="headerlink" title="30、一句话归纳设计模式"></a>30、一句话归纳设计模式</h2><table>
<thead>
<tr>
<th>分类</th>
<th>设计模式</th>
<th>简述</th>
<th>一句话归纳</th>
<th>目的</th>
<th>生活案例</th>
</tr>
</thead>
<tbody><tr>
<td>创建型设计模式 （简单来说就是用来创建对象的）</td>
<td>工厂模式（Factory Pattern）</td>
<td>不同条件下创建不同实例</td>
<td>产品标准化，生产更高效</td>
<td>封装创建细节</td>
<td>实体工厂</td>
</tr>
<tr>
<td>单例模式（Singleton Pattern）</td>
<td>保证一个类仅有一个实例，并且提供一个全局访问点</td>
<td>世上只有一个我</td>
<td>保证独一无二</td>
<td>CEO</td>
<td></td>
</tr>
<tr>
<td>原型模式（Prototype Pattern）</td>
<td>通过拷贝原型创建新的对象</td>
<td>拔一根猴毛，吹出千万个</td>
<td>高效创建对象</td>
<td>克隆</td>
<td></td>
</tr>
<tr>
<td>建造者模式（Builder Pattern）</td>
<td>用来创建复杂的复合对象</td>
<td>高配中配和低配，想选哪配就哪配</td>
<td>开放个性配置步骤</td>
<td>选配</td>
<td></td>
</tr>
<tr>
<td>结构型设计模式 （关注类和对象的组合）</td>
<td>代理模式（Proxy Pattern）</td>
<td>为其他对象提供一种代理以控制对这个对象的访问</td>
<td>没有资源没时间，得找别人来帮忙</td>
<td>增强职责</td>
<td>媒婆</td>
</tr>
<tr>
<td>外观模式（Facade Pattern）</td>
<td>对外提供一个统一的接口用来访问子系统</td>
<td>打开一扇门，通向全世界</td>
<td>统一访问入口</td>
<td>前台</td>
<td></td>
</tr>
<tr>
<td>装饰器模式（Decorator Pattern）</td>
<td>为对象添加新功能</td>
<td>他大舅他二舅都是他舅</td>
<td>灵活扩展、同宗同源</td>
<td>煎饼</td>
<td></td>
</tr>
<tr>
<td>享元模式（Flyweight Pattern）</td>
<td>使用对象池来减少重复对象的创建</td>
<td>优化资源配置，减少重复浪费</td>
<td>共享资源池</td>
<td>全国社保联网</td>
<td></td>
</tr>
<tr>
<td>组合模式（Composite Pattern）</td>
<td>将整体与局部（树形结构）进行递归组合，让客户端能够以一种的方式对其进行处理</td>
<td>人在一起叫团伙，心在一起叫团队</td>
<td>统一整体和个体</td>
<td>组织架构树</td>
<td></td>
</tr>
<tr>
<td>适配器模式（Adapter Pattern）</td>
<td>将原来不兼容的两个类融合在一起</td>
<td>万能充电器</td>
<td>兼容转换</td>
<td>电源适配</td>
<td></td>
</tr>
<tr>
<td>桥接模式（Bridge Pattern）</td>
<td>将两个能够独立变化的部分分离开来</td>
<td>约定优于配置</td>
<td>不允许用继承</td>
<td>桥</td>
<td></td>
</tr>
<tr>
<td>行为型设计模式 （关注对象之间的通信）</td>
<td>模板模式（Template Pattern）</td>
<td>定义一套流程模板，根据需要实现模板中的操作</td>
<td>流程全部标准化，需要微调请覆盖</td>
<td>逻辑复用</td>
<td>把大象装进冰箱</td>
</tr>
<tr>
<td>策略模式（Strategy Pattern）</td>
<td>封装不同的算法，算法之间能互相替换</td>
<td>条条大道通罗马，具体哪条你来定</td>
<td>把选择权交给用户</td>
<td>选择支付方式</td>
<td></td>
</tr>
<tr>
<td>责任链模式（Chain of Responsibility Pattern）</td>
<td>拦截的类都实现统一接口，每个接收者都包含对下一个接收者的引用。将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</td>
<td>各人自扫门前雪，莫管他们瓦上霜</td>
<td>解耦处理逻辑</td>
<td>踢皮球</td>
<td></td>
</tr>
<tr>
<td>迭代器模式（Iterator Pattern）</td>
<td>提供一种方法顺序访问一个聚合对象中的各个元素</td>
<td>流水线上坐一天，每个包裹扫一遍</td>
<td>统一对集合的访问方式</td>
<td>逐个检票进站</td>
<td></td>
</tr>
<tr>
<td>命令模式（Command Pattern）</td>
<td>将请求封装成命令，并记录下来，能够撤销与重做</td>
<td>运筹帷幄之中，决胜千里之外</td>
<td>解耦请求和处理</td>
<td>遥控器</td>
<td></td>
</tr>
<tr>
<td>状态模式（State Pattern）</td>
<td>根据不同的状态做出不同的行为</td>
<td>状态驱动行为，行为决定状态</td>
<td>绑定状态和行为</td>
<td>订单状态跟踪</td>
<td></td>
</tr>
<tr>
<td>备忘录模式（Memento Pattern）</td>
<td>保存对象的状态，在需要时进行恢复</td>
<td>失足不成千古恨，想重来时就重来</td>
<td>备份、后悔机制</td>
<td>草稿箱</td>
<td></td>
</tr>
<tr>
<td>中介者模式（Mediator Pattern）</td>
<td>将对象之间的通信关联关系封装到一个中介类中单独处理，从而使其耦合松散</td>
<td>联系方式我给你，怎么搞定我不管</td>
<td>统一管理网状资源</td>
<td>朋友圈</td>
<td></td>
</tr>
<tr>
<td>解释器模式（Interpreter Pattern）</td>
<td>给定一个语言，定义它的语法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子</td>
<td>我想说”方言“，一切解释权都归我</td>
<td>实现特定语法解析</td>
<td>摩斯密码</td>
<td></td>
</tr>
<tr>
<td>观察者模式（Observer Pattern）</td>
<td>状态发生改变时通知观察者，一对多的关系</td>
<td>到点就通知我</td>
<td>解耦观察者与被观察者</td>
<td>闹钟</td>
<td></td>
</tr>
<tr>
<td>访问者模式（Visitor Pattern）</td>
<td>稳定数据结构，定义新的操作行为</td>
<td>横看成岭侧成峰，远近高低各不同</td>
<td>解耦数据结构和数据操作</td>
<td>KPI考核</td>
<td></td>
</tr>
<tr>
<td></td>
<td>委派模式（Delegate Pattern）</td>
<td>允许对象组合实现与继承相同的代码重用，负责任务的调用和分配</td>
<td>这个需求很简单，怎么实现我不管</td>
<td>只对结果负责</td>
<td>授权委托书</td>
</tr>
</tbody></table>
<h2 id="31、其他设计模式（不属于23种）"><a href="#31、其他设计模式（不属于23种）" class="headerlink" title="31、其他设计模式（不属于23种）"></a>31、其他设计模式（不属于23种）</h2><ol>
<li><p>MVC 模式：Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。</p>
<ul>
<li><p><strong>Model（模型）</strong> - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。</p>
</li>
<li><p><strong>View（视图）</strong> - 视图代表模型包含的数据的可视化。</p>
</li>
<li><p><strong>Controller（控制器）</strong> - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。</p>
<p><img src="/2021/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20210419025540539.png" alt="image-20210419025540539"></p>
</li>
</ul>
</li>
<li><p>业务代表模式（Business Delegate Pattern）：用于对表示层和业务层解耦。它基本上是用来减少通信或对表示层代码中的业务层代码的远程查询功能。在业务层中我们有以下实体：</p>
<ul>
<li><strong>客户端（Client）</strong> - 表示层代码可以是 JSP、servlet 或 UI java 代码。</li>
<li><strong>业务代表（Business Delegate）</strong> - 一个为客户端实体提供的入口类，它提供了对业务服务方法的访问。</li>
<li><strong>查询服务（LookUp Service）</strong> - 查找服务对象负责获取相关的业务实现，并提供业务对象对业务代表对象的访问。</li>
<li><strong>业务服务（Business Service）</strong> - 业务服务接口。实现了该业务服务的实体类，提供了实际的业务实现逻辑。</li>
</ul>
</li>
<li><p>组合实体模式（Composite Entity Pattern）：用在 EJB 持久化机制中。一个组合实体是一个 EJB 实体 bean，代表了对象的图解。当更新一个组合实体时，内部依赖对象 beans 会自动更新，因为它们是由 EJB 实体 bean 管理的。以下是组合实体 bean 的参与者：</p>
<ul>
<li><strong>组合实体（Composite Entity）</strong> - 它是主要的实体 bean。它可以是粗粒的，或者可以包含一个粗粒度对象，用于持续生命周期。</li>
<li><strong>粗粒度对象（Coarse-Grained Object）</strong> - 该对象包含依赖对象。它有自己的生命周期，也能管理依赖对象的生命周期。</li>
<li><strong>依赖对象（Dependent Object）</strong> - 依赖对象是一个持续生命周期依赖于粗粒度对象的对象。</li>
<li><strong>策略（Strategies）</strong> - 策略表示如何实现组合实体。</li>
</ul>
</li>
<li><p>数据访问对象模式（Data Access Object Pattern）或 DAO 模式：用于把低级的数据访问 API 或操作从高级的业务服务中分离出来。以下是数据访问对象模式的参与者：</p>
<ul>
<li><strong>数据访问对象接口（Data Access Object Interface）</strong> - 该接口定义了在一个模型对象上要执行的标准操作。</li>
<li><strong>数据访问对象实体类（Data Access Object concrete class）</strong> - 该类实现了上述的接口。该类负责从数据源获取数据，数据源可以是数据库，也可以是 xml，或者是其他的存储机制。</li>
<li><strong>模型对象/数值对象（Model Object/Value Object）</strong> - 该对象是简单的 POJO，包含了 get/set 方法来存储通过使用 DAO 类检索到的数据。</li>
</ul>
</li>
<li><p>前端控制器模式（Front Controller Pattern）：是用来提供一个集中的请求处理机制，所有的请求都将由一个单一的处理程序处理。该处理程序可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体：</p>
<ul>
<li><strong>前端控制器（Front Controller）</strong> - 处理应用程序所有类型请求的单个处理程序，应用程序可以是基于 web 的应用程序，也可以是基于桌面的应用程序。</li>
<li><strong>调度器（Dispatcher）</strong> - 前端控制器可能使用一个调度器对象来调度请求到相应的具体处理程序。</li>
<li><strong>视图（View）</strong> - 视图是为请求而创建的对象。</li>
</ul>
</li>
<li><p>拦截过滤器模式（Intercepting Filter Pattern）：用于对应用程序的请求或响应做一些预处理/后处理。定义过滤器，并在把请求传给实际目标应用程序之前应用在请求上。过滤器可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体：</p>
<ul>
<li><strong>过滤器（Filter）</strong> - 过滤器在请求处理程序执行请求之前或之后，执行某些任务。</li>
<li><strong>过滤器链（Filter Chain）</strong> - 过滤器链带有多个过滤器，并在 Target 上按照定义的顺序执行这些过滤器。</li>
<li><strong>Target</strong> - Target 对象是请求处理程序。</li>
<li><strong>过滤管理器（Filter Manager）</strong> - 过滤管理器管理过滤器和过滤器链。</li>
<li><strong>客户端（Client）</strong> - Client 是向 Target 对象发送请求的对象。</li>
</ul>
</li>
<li><p>服务定位器模式（Service Locator Pattern）：用在我们想使用 JNDI 查询定位各种服务的时候。考虑到为某个服务查找 JNDI 的代价很高，服务定位器模式充分利用了缓存技术。在首次请求某个服务时，服务定位器在 JNDI 中查找服务，并缓存该服务对象。当再次请求相同的服务时，服务定位器会在它的缓存中查找，这样可以在很大程度上提高应用程序的性能。以下是这种设计模式的实体：</p>
<ul>
<li><strong>服务（Service）</strong> - 实际处理请求的服务。对这种服务的引用可以在 JNDI 服务器中查找到。</li>
<li><strong>Context / 初始的 Context</strong> - JNDI Context 带有对要查找的服务的引用。</li>
<li><strong>服务定位器（Service Locator）</strong> - 服务定位器是通过 JNDI 查找和缓存服务来获取服务的单点接触。</li>
<li><strong>缓存（Cache）</strong> - 缓存存储服务的引用，以便复用它们。</li>
<li><strong>客户端（Client）</strong> - Client 是通过 ServiceLocator 调用服务的对象。</li>
</ul>
</li>
<li><p>传输对象模式（Transfer Object Pattern）：用于从客户端向服务器一次性传递带有多个属性的数据。传输对象也被称为数值对象。传输对象是一个具有 getter/setter 方法的简单的 POJO 类，它是可序列化的，所以它可以通过网络传输。它没有任何的行为。服务器端的业务类通常从数据库读取数据，然后填充 POJO，并把它发送到客户端或按值传递它。对于客户端，传输对象是只读的。客户端可以创建自己的传输对象，并把它传递给服务器，以便一次性更新数据库中的数值。以下是这种设计模式的实体：</p>
<ul>
<li><strong>业务对象（Business Object）</strong> - 为传输对象填充数据的业务服务。</li>
<li><strong>传输对象（Transfer Object）</strong> - 简单的 POJO，只有设置/获取属性的方法。</li>
<li><strong>客户端（Client）</strong> - 客户端可以发送请求或者发送传输对象到业务对象。</li>
</ul>
</li>
<li><p>在空对象模式（Null Object Pattern）中，一个空对象取代 NULL 对象实例的检查。Null 对象不是检查空值，而是反应一个不做任何动作的关系。这样的 Null 对象也可以在数据不可用的时候提供默认的行为。</p>
<p>在空对象模式中，我们创建一个指定各种要执行的操作的抽象类和扩展该类的实体类，还创建一个未对该类做任何实现的空对象类，该空对象类将无缝地使用在需要检查空值的地方。</p>
</li>
</ol>
<h2 id="32、设计模式相关的网站"><a href="#32、设计模式相关的网站" class="headerlink" title="32、设计模式相关的网站"></a>32、设计模式相关的网站</h2><ul>
<li><a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Design_pattern_(computer_science)">Wiki Page for Design Patterns</a> - 以一种非常通用的方式检查设计模式。</li>
<li><a target="_blank" rel="noopener" href="http://en.wikibooks.org/wiki/Java_Programming/Design_Patterns">Java Programming/Design Patterns</a> - 一篇关于设计模式的好文章。</li>
<li><a target="_blank" rel="noopener" href="http://java.sun.com/docs/books/tutorial/index.html">The JavaTM Tutorials</a> - 该 Java 教程是为那些想用 Java 编程语言创建应用程序的编程人员提供的实用指南。</li>
<li><a target="_blank" rel="noopener" href="http://java.sun.com/j2se/1.4.2/docs/index.html">JavaTM 2 SDK, Standard Edition </a>- JavaTM 2 SDK, Standard Edition 的官网。</li>
</ul>
<h2 id="0、延伸"><a href="#0、延伸" class="headerlink" title="0、延伸"></a>0、延伸</h2><h3 id="1、各种生成实例的方法的介绍"><a href="#1、各种生成实例的方法的介绍" class="headerlink" title="1、各种生成实例的方法的介绍"></a>1、各种生成实例的方法的介绍</h3><p>在Java中可以使用下面这些方法生成实例。</p>
<h4 id="1、new"><a href="#1、new" class="headerlink" title="1、new"></a>1、new</h4><p>一般我们使用Java关键字new生成实例。</p>
<p>可以像下面这样生成Something类的实例并将其保存在obj变量中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Something obj = <span class="keyword">new</span> Something(); </span><br></pre></td></tr></table></figure>

<p>这时， 类名（此处的Something)会出现在代码中 。（即形成强耦合关系）</p>
<h4 id="2、clone"><a href="#2、clone" class="headerlink" title="2、clone"></a>2、clone</h4><p>我们也可以使用在Prototype模式中学习过的clone方法， 根据现有 的实例复制出一个新的实例。</p>
<p>我们可以像下面这样根据自身来复制出新的实例（不过不会调用构造函数）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123; </span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Something <span class="title">createClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Something obj = <span class="keyword">null</span>; </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            obj = (Something) clone(); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、new-Instance"><a href="#3、new-Instance" class="headerlink" title="3、new Instance"></a>3、new Instance</h4><p>使用java.lang.Class类的newinstance方法可以通过Class类的实例生成出Class类所表示的类0的实例（会调用无参构造函数）。</p>
<p>下面我们再看一个例子。 假设我们现在已经有了Something类的实例someobj， 通过下面的表达式可以生成另外一个 Something类的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someobj.getClass().newinstance() </span><br></pre></td></tr></table></figure>

<p>实际上， 调用newinstance方法可能会导致抛出InstantiationException异常或是 illegalAccessException异常， 因此需要将其置千try…catch语句块中或是用throws关键字指定调用newinstance方法的方法可能会抛出的异常。</p>
<h3 id="2、类名是束缚吗"><a href="#2、类名是束缚吗" class="headerlink" title="2、类名是束缚吗"></a>2、类名是束缚吗</h3><p>话说回来， 在源程序中使用类名到底会有什么问题呢？在代码中出现要使用的类的名字不是理 所当然的吗？</p>
<p>这里， 让我们再回忆一下面向对象编程的目标之一，即“作为组件复用” 。</p>
<p>在代码中出现要使用的类的名字并非总是坏事。 不过 ，<strong>—旦在代码中出现要使用的类的名字， 就无法与该类分离开来， 也就无法实现复用</strong>。</p>
<p>当然 ， 可以通过替换源代码或是改变类名来解决这个问题。 但是， 此处说的“作为组件复用”中不包含替换源代码。 以Java来说， 重要的是当手边只有class文件(.class)时， 该类能否被复用。 <strong>即使没有Java文件(.java)也能复用该类才是关键。</strong></p>
<p>当多个类必须紧密结合时， 代码中出现这些类的名字是没有问题的。但是如果那些需要被独立 出来作为组件复用的类的名字出现在代码中， 那就有问题了。</p>
<h3 id="3、类的层次与抽象类"><a href="#3、类的层次与抽象类" class="headerlink" title="3、类的层次与抽象类"></a>3、类的层次与抽象类</h3><p>父类对子类的要求：</p>
<p>我们在理解类的层次时 ， 通常是站在子类的角度进行思考的。也就是说 ， 很容易着眼千以 下几点：</p>
<ul>
<li>在子类中可以使用父类中定义的方法</li>
<li>可以通过在子类中增加方法以实现新的功能</li>
<li>在子类中重写父类的方法可以改变程序的行为</li>
</ul>
<p>现在 ， 让我们稍微改变一下立场 ， 站在父类的角度进行思考。在父类中， 我们声明了抽象方法、而将该方法的实现交给了子类。换言之 ， 就程序而言，声明抽象方法是希望达到以下目的：</p>
<ul>
<li>期待子类去实现抽象方法</li>
<li>要求子类去实现抽象方法</li>
</ul>
<p>也就是说 ，子类具有实现在父类中所声明的抽象方法的责任。因此，这种责任被称为 “子类责任”(subclass responsibility）。</p>
<h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a target="_blank" rel="noopener" href="http://c.biancheng.net/design_pattern/">Java设计模式：23种设计模式全面解析</a></p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/design-pattern/design-pattern-tutorial.html">菜鸟驿站-设计模式</a></p>
<p><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1264742167474528">廖雪峰-设计模式</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f64b7b86a3ee">面向对象的七大设计原则</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24614363">设计模式之七大基本原则</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenssy/p/6393321.html">happens-before规则相关</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhangjg_blog/article/details/18369201">详解Java中的clone方法 – 原型模式</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/chenssy/article/details/12952063">java提高篇（五）—–使用序列化实现对象的拷贝</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/149775781">动态代理的几种实现方式及优缺点</a></p>
<p>有关于Copy-on-write代理：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/147164121">Copy-on-write + Proxy = ?</a></p>
<p>相关书籍：</p>
<p>《图解设计模式》</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xgh-user.github.io/2021/04/19/JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_little-star_">
      <meta itemprop="description" content="记录个人在平时学习的过程中的一些笔记、感受与遇到的坑,例如：java、计算机考研四件套等等。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_little-star_">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/19/JVM/" class="post-title-link" itemprop="url">JVM</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-19 03:10:19" itemprop="dateCreated datePublished" datetime="2021-04-19T03:10:19+08:00">2021-04-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-29 15:54:21" itemprop="dateModified" datetime="2021-09-29T15:54:21+08:00">2021-09-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%90%8E%E5%8F%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">java后台学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%90%8E%E5%8F%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="上篇：内存与垃圾回收"><a href="#上篇：内存与垃圾回收" class="headerlink" title="上篇：内存与垃圾回收"></a>上篇：内存与垃圾回收</h2><h3 id="1、JVM与Java体系结构"><a href="#1、JVM与Java体系结构" class="headerlink" title="1、JVM与Java体系结构"></a>1、JVM与Java体系结构</h3><h4 id="1、关于Java与JVM"><a href="#1、关于Java与JVM" class="headerlink" title="1、关于Java与JVM"></a>1、关于Java与JVM</h4><p>Java：跨平台的语言</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%80%A7.jpg" alt="第01章_Java语言的跨平台性"></p>
<p>JVM：跨语言的平台</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC01%E7%AB%A0_JVM%E8%B7%A8%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B9%B3%E5%8F%B0.jpg" alt="第01章_JVM跨语言的平台"></p>
<h4 id="2、字节码"><a href="#2、字节码" class="headerlink" title="2、字节码"></a>2、字节码</h4><p>随着JDK7.0的正式发布，JVM平台上运行非Java语言编写的程序。</p>
<p>JVM根本不关心运行在其内部的程序到底是使用何种编程语言编写的，<strong>它只关心“字节码”文件</strong>。也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，只要其他编程语言的编译结果满足并包含JVM的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。</p>
<p>我们平时说的java字节码，指的是用java语言编译成的字节码。准确的说任何能在jvm平台上执行的字节码格式都是一样的。所以应该统称为：<strong>jvm字节码</strong>。</p>
<p>不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行。</p>
<p>Java虚拟机与Java语言并没有必然的联系，它只与特定的二进制文件格式——Class文件格式所关联， Class文件中包含了JVM指令集(或者称为字节码、Bytecodes)和符号表，还有一些其他辅助信息。</p>
<h4 id="3、多语言混合编程"><a href="#3、多语言混合编程" class="headerlink" title="3、多语言混合编程"></a>3、多语言混合编程</h4><p><strong>Java平台上的多语言混合编程</strong>正成为主流，<strong>通过特定领域的语言去解决特定领域的问题</strong>是当前软件开发应对日趋复杂的项目需求的一个方向。</p>
<p>例如：在一个项目之中，并行处理用Clojure语言编写，展示层使用JRuby/Rails，中间层则是Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，<strong>各种语言之间的交互不存在任何困难，就像使用自己语言的原生API一样方便，因为它们最终都运行在一个虚拟机之上</strong>。</p>
<p>对这些运行于Java虚拟机之上、Java之外的语言，来自系统级的、底层的支持正在迅速增强，以JSR-292为核心的一系列项目和功能改进(如DaVinci Machine项目、 Nashorn引擎、InvokeDynamic指令、java. lang. invoke包等)，<strong>推动Java虚拟机从“Java语言的虚拟机”向“多语言虚拟机”的方向发展</strong>。</p>
<h4 id="4、虚拟机与JVM（java虚拟机）"><a href="#4、虚拟机与JVM（java虚拟机）" class="headerlink" title="4、虚拟机与JVM（java虚拟机）"></a>4、虚拟机与JVM（java虚拟机）</h4><h5 id="1、什么是虚拟机"><a href="#1、什么是虚拟机" class="headerlink" title="1、什么是虚拟机"></a>1、什么是虚拟机</h5><p>所谓虚拟机(Virtual Machine)，就是一台虚拟的计算机，它是<strong>一款软件</strong>，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为<strong>系统虚拟机</strong>和<strong>程序虚拟机</strong>。</p>
<ul>
<li>大名鼎鼎的Visual Box, VMware就属于系统虚拟机，它们<strong>完全是对物理计算机的仿真</strong>，提供了一个可运行完整操作系统的软件平台。</li>
<li>程序虚拟机的典型代表就是Java虚拟机，它<strong>专门为执行单个计算机程序而设计</strong>，在Java虛拟机中执行的指令我们称为Java字节码指令。</li>
</ul>
<p>但无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。</p>
<h5 id="2、JVM（java虚拟机）"><a href="#2、JVM（java虚拟机）" class="headerlink" title="2、JVM（java虚拟机）"></a>2、JVM（java虚拟机）</h5><p>JVM是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。</p>
<p>JVM平台的各种语言可以共享JVM带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。</p>
<p><strong>Java技术的核心就是Java虚拟机</strong>(JVM，Java Virtual Machine) ,因为所有的Java程序都运行在JVM内部。</p>
<h5 id="3、JVM的作用"><a href="#3、JVM的作用" class="headerlink" title="3、JVM的作用"></a>3、JVM的作用</h5><p><strong>JVM就是二进制字节码的运行环境</strong>，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。</p>
<h5 id="4、JVM的特点"><a href="#4、JVM的特点" class="headerlink" title="4、JVM的特点"></a>4、JVM的特点</h5><ul>
<li>一次编译，到处运行</li>
<li>自动内存管理</li>
<li>自动垃圾回收功能</li>
</ul>
<p>带来的好处：</p>
<ul>
<li>从代码层面：降低了内存泄漏与内存溢出的风险</li>
<li>从程序员层面：让程序员将自己对重心放在业务层面，不用再去手动地进行垃圾回收</li>
</ul>
<p>带来的坏处：</p>
<ul>
<li>降低了对程序员对要求，当出现内存方面的问题时不能有效解决。</li>
</ul>
<h5 id="5、JVM的位置"><a href="#5、JVM的位置" class="headerlink" title="5、JVM的位置"></a>5、JVM的位置</h5><p><img src="/2021/04/19/JVM/%E7%AC%AC01%E7%AB%A0_JVM%E6%89%80%E5%A4%84%E4%BD%8D%E7%BD%AE.jpg" alt="第01章_JVM所处位置"></p>
<p><strong>JVM是运行在操作系统之上的，它与硬件没有直接的交互。</strong></p>
<p><strong>JVM模拟的是系统</strong>，在不同系统之上，构建了一个统一的系统平台。所以在安装JDK的时候要关注JDK是安装在哪个操作系统上，因为不同的操作系统上安装的JVM是不同的。</p>
<p>JDK的构成：下图来自JDK8官网。</p>
<p><img src="/2021/04/19/JVM/image-20210420004314261.png" alt="image-20210420004314261"></p>
<p>java程序想要正确运行需要经历两个过程：</p>
<ul>
<li>java文件 –(编译)–&gt; class字节码文件：使用的编译器为：前端编译器。典型：javac</li>
<li>class字节码文件–(解释)–&gt; 二进制文件：运行。解释会用到：Java SE API 还有后端编译器（将class字节码文件编译为二进制文件）（后端编译器在JVM当中）</li>
</ul>
<h4 id="5、JVM的整体结构"><a href="#5、JVM的整体结构" class="headerlink" title="5、JVM的整体结构"></a>5、JVM的整体结构</h4><p>HotSpotVM是目前市面上高性能虚拟机的代表作之一。</p>
<p>它采用<strong>解释器与即时编译器并存的架构</strong>。</p>
<p>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C+ +程序一较高下的地步。</p>
<p>JVM的架构简图：程序的解释运行图</p>
<p><img src="/2021/04/19/JVM/image-20210420010019562.png" alt="第02章_JVM架构-简图"></p>
<p>其中将其分成三层：</p>
<ol>
<li><p>上层：class字节码文件进入类装载器子系统（Class loader），将class字节码文件加载到内存当中，生成一个大的class对象。这个过程中会涉及到：</p>
<ol>
<li>加载</li>
<li>链接（分成三步）</li>
<li>初始化</li>
</ol>
</li>
<li><p>中层：</p>
<ul>
<li><strong>方法区和栈是多线程共享</strong></li>
<li><strong>（Java栈（本地方法栈），本地方法栈，程序计数器是每个线程独有一份</strong></li>
</ul>
</li>
<li><p>下层：把字节码文件加载到内存以后，就可以进行解释运行了。执行引擎（Execution Engine），有三部分内容：</p>
<ol>
<li><p>解释器（Interpreter）：<strong>负责字节码文件的解释运行</strong>。<strong>主要保证程序执行的响应时间</strong></p>
</li>
<li><p>及时编译器（JIT Compiler）：对于反复运行的热点代码进行提前的<strong>编译缓存</strong>。及时编译器又叫做<strong>后端编译器</strong>，用来<strong>将字节码文件字节码指令编译成操作系统能读懂的机器指令</strong>。（高级语言-&gt;机器语言）<strong>主要负责程序的执行性能</strong>。</p>
</li>
<li><p>垃圾回收器（Garbage Collection，简称GC）：实现<strong>垃圾的自动回收</strong></p>
<p><img src="/2021/04/19/JVM/image-20210420011524768.png" alt="image-20210420011524768"></p>
</li>
</ol>
</li>
</ol>
<h4 id="6、Java代码的执行流程"><a href="#6、Java代码的执行流程" class="headerlink" title="6、Java代码的执行流程"></a>6、Java代码的执行流程</h4><p><img src="/2021/04/19/JVM/image-20210420013453679.png" alt="image-20210420013453679"></p>
<h4 id="7、JVM的架构模型"><a href="#7、JVM的架构模型" class="headerlink" title="7、JVM的架构模型"></a>7、JVM的架构模型</h4><p>Java编译器输入的指令流基本上分为两种：</p>
<ul>
<li>是一种<strong>基于栈的指令集架构</strong></li>
<li>另外一种指令集架构则是<strong>基于寄存器的指令集架构</strong>。</li>
</ul>
<p>两种架构的区别：</p>
<ul>
<li>基于栈式架构的特点：<ul>
<li>设计和实现更简单，<strong>适用于资源受限的系统</strong>；</li>
<li>避开了寄存器的分配难题：使用<strong>零地址指令方式分配</strong>;</li>
<li>指令流中的指令<strong>大部分是零地址指令</strong>，其执行过程依赖于操作栈。<strong>指令集更小</strong>，编译器容易实现。</li>
<li><strong>不需要硬件支持，可移植性更好，更好实现跨平台</strong></li>
</ul>
</li>
<li>基于寄存器架构的特点<ul>
<li>典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虛拟机；</li>
<li>指令集架构则<strong>完全依赖硬件，可移植性差</strong></li>
<li><strong>性能优秀</strong>和<strong>执行更高效</strong>;</li>
<li>花费<strong>更少的指令去完成一项操作</strong>。</li>
<li>在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主。</li>
</ul>
</li>
</ul>
<p>总结：</p>
<ul>
<li><strong>由于跨平台性的设计，Java的指令都是根据栈来设计的</strong>。不同平台CPU架构不同，所以不能设计为基于寄存器的。<ul>
<li>优点是<strong>跨平台， 指令集小，编译器容易实现</strong></li>
<li>缺点是<strong>性能下降，实现同样的功能需要更多的指令</strong></li>
</ul>
</li>
<li>时至今日，尽管嵌入式平台已经不是Java程序的主流运行平台了(准确来说应该是HotSpotVM的宿主环境已经不局限于嵌入式平台了)，那么为什么不将架构更换为基于寄存器的架构呢?<ol>
<li>基于栈式的架构<strong>在设计与实现上</strong>比基于寄存器架构的设计要<strong>简单</strong></li>
<li>基于栈式的架构<strong>在非资源受限的场景当中也是可以使用</strong>的</li>
<li>主要还是因为<strong>栈式架构可以实现跨平台</strong>，而基于寄存器架构由于与硬件的耦合度太高，不能实现跨平台。</li>
</ol>
</li>
</ul>
<h4 id="8、JVM的生命周期"><a href="#8、JVM的生命周期" class="headerlink" title="8、JVM的生命周期"></a>8、JVM的生命周期</h4><h5 id="1、虚拟机的启动"><a href="#1、虚拟机的启动" class="headerlink" title="1、虚拟机的启动"></a>1、虚拟机的启动</h5><p>Java虛拟机的启动是通过<strong>引导类加载器(bootstrap class loader) 创建一个初始类(initial class) 来完成</strong>的，这个类是由虚拟机的具体实现指定的。</p>
<p>程序的执行：主方法（main）所在类加载到内存当中。而自定义的类的加载是通过系统类加载器（应用类加载器）实现的。由于<strong>父类的加载要早于子类</strong>，这就导致了java虚拟机的启动，创建一个初始类(initial class) ,然后调用初始类（initial class）当中的main方法，在这main方法当中使用其他的一些类来相继地加载后继的所有类。</p>
<p>类加载器分成：</p>
<ul>
<li>引导类加载器（负责超类的加载（如Object））</li>
<li>扩展类加载器</li>
<li>系统类加载器（负责自定义类的类加载）</li>
<li>启动类加载器</li>
<li>用户自定义的类加载器</li>
</ul>
<h5 id="2、虚拟机的执行"><a href="#2、虚拟机的执行" class="headerlink" title="2、虚拟机的执行"></a>2、虚拟机的执行</h5><ul>
<li>一个运行中的Java虚拟机有着一个清晰的任务：<strong>执行Java程序</strong>。</li>
<li><strong>程序开始执行</strong>时他才<strong>运行</strong>，<strong>程序结束</strong>时他就<strong>停止</strong>。</li>
<li>执行一个所谓的Java程序的时候，真真正正在<strong>执行的是一个叫做Java虛拟机的进程</strong>。</li>
</ul>
<h5 id="3、虚拟机的退出"><a href="#3、虚拟机的退出" class="headerlink" title="3、虚拟机的退出"></a>3、虚拟机的退出</h5><p>有如下的几种情况：</p>
<ul>
<li>程序<strong>正常执行结束</strong></li>
<li>程序<strong>在执行过程中遇到了异常或错误</strong>而异常终止</li>
<li>由于<strong>操作系统出现错误而导致Java虛拟机进程终止</strong></li>
<li><strong>某线程调用Runtime类或System类的exit方法</strong>，或<strong>Runtime类的halt方法</strong>，并且<strong>Java安全管理器也允许这次exit或halt操作</strong>。</li>
<li>除此之外，JNI ( Java Native Interface) 规范描述了<strong>用JNI Invocation API来加载或卸载Java虚拟机</strong>时，Java虚拟机的退出情况。</li>
</ul>
<h4 id="9、JVM的发展历程"><a href="#9、JVM的发展历程" class="headerlink" title="9、JVM的发展历程"></a>9、JVM的发展历程</h4><h5 id="1、Sun-Classic-VM（SUN）"><a href="#1、Sun-Classic-VM（SUN）" class="headerlink" title="1、Sun Classic VM（SUN）"></a>1、Sun Classic VM（SUN）</h5><p>Sun公司发布的<strong>世界上第一款商用Java虚拟机</strong>，在JDK1.4时被完全淘汰。</p>
<p>这款虚拟机内部<strong>只提供解释器</strong>。</p>
<p>如果使用JIT编译器，就需要进行外挂。但是一旦使用了JIT编译器，JIT就会接管虚拟机的执行系统。解释器就不再工作。解释器和编译器不能配合工作。（<strong>两者只能存一</strong>）</p>
<ul>
<li>只使用解释器：当代码中重复的代码多（如循环等等）的时候执行效率低</li>
<li>只使用JIT编译器：由于将字节码文件当中字节码指令编译成机器指令进行缓存也是需要时间的。这就导致了程序启动时间过长，加上占用的缓存空间有限。</li>
</ul>
<p>现在<strong>hotspot内置了此虚拟机</strong>。</p>
<h5 id="2、Exact-VM（SUN）"><a href="#2、Exact-VM（SUN）" class="headerlink" title="2、Exact VM（SUN）"></a>2、Exact VM（SUN）</h5><p>为了解决上一个虚拟机问题，JDK1.2时， sun提供了此虚拟机。</p>
<p>Exact Memory Management：<strong>准确式内存管理</strong></p>
<ul>
<li>也可以叫Non-Conservative/ Accurate Memory Management</li>
<li><strong>虚拟机可以知道内存中某个位置的数据具体是什么类型。</strong></li>
</ul>
<p>具备现代高性能虚拟机的雏形</p>
<ul>
<li><strong>热点探测</strong></li>
<li><strong>编译器与解释器混合工作模式</strong></li>
</ul>
<p>只在Solaris平台短暂使用，其他平台上还是classic vm。最终被Hotspot虚拟机替代</p>
<h5 id="3、Hotspot虚拟机（三大虚拟机之一）（Longview-Technologies-SUN-Oracle）"><a href="#3、Hotspot虚拟机（三大虚拟机之一）（Longview-Technologies-SUN-Oracle）" class="headerlink" title="3、Hotspot虚拟机（三大虚拟机之一）（Longview Technologies\SUN\Oracle）"></a>3、Hotspot虚拟机（三大虚拟机之一）（Longview Technologies\SUN\Oracle）</h5><p>JDK1.3时，HotSpot VM成为默认虚拟机</p>
<p>目前<strong>Hotspot占有绝对的市场地位</strong>：</p>
<ul>
<li>不管是现在仍在广泛使用的JDK6，还是使用比例较多的JDK8中，默认的虚拟机都是<br>HotSpot</li>
<li>Sun/Oracle JDK和OpenJDK的默认虚拟机</li>
<li>因此本课程中默认介绍的虛拟机都是HotSpot，相关机制也主要是指<strong>HotSpot的GC机</strong><br><strong>制</strong>。(比如<strong>其他两个商用虚拟机都没有方法区的概念</strong>)</li>
</ul>
<p>从服务器、桌面到移动端、嵌入式都有应用。</p>
<p>名称中的HotSpot指的就是它的热点代码探测技术。</p>
<ul>
<li><strong>通过计数器找到最具编译价值代码，触发即时编译或栈上替换</strong></li>
<li>通过<strong>编译器与解释器协同工作</strong>，<strong>在最优化的程序响应时间与最佳执行性能中取得平衡</strong></li>
</ul>
<h5 id="4、JRockit（三大虚拟机之一）（BEA-Oracle）"><a href="#4、JRockit（三大虚拟机之一）（BEA-Oracle）" class="headerlink" title="4、JRockit（三大虚拟机之一）（BEA\Oracle）"></a>4、JRockit（三大虚拟机之一）（BEA\Oracle）</h5><p><strong>专注于服务器端应用</strong></p>
<ul>
<li>它可以不太关注程序启动速度，因此<strong>JRockit内部不包含解析器实现</strong>，全部代码<strong>都靠即时编译器编译</strong>后执行。</li>
</ul>
<p>大量的行业基准测试显示，<strong>JRockit JVM是 世界上最快的JVM</strong>。</p>
<ul>
<li>使用JRockit产品，客户已经体验到了显著的性能提高(一些超过了70号)和硬件成本的减少(达50号)</li>
</ul>
<p>优势：<strong>全面的Java运行时解决方案组合</strong></p>
<ul>
<li>JRockit面向延迟敏感型应用的解决方案：<strong>JRockit Real Time</strong>提供以毫秒或微秒级的JVM响应时间，适合财务、军事指挥、电信网络的需要</li>
<li><strong>MissionControl服务套件</strong>：它是一组以极低的开销来监控、管理和分析生产<br>环境中的应用程序的工具。<ul>
<li>JDK Mission Control（JMC）（Oracle公司整合）(主要是用来监控内存泄漏)<ul>
<li>内存泄漏监测器</li>
<li>JVM运行时分析器</li>
<li>管理的控制台</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>2008年，BEA被Oracle收购。</p>
<p>Oracle表达了整合两大优秀虚拟机的工作，大致在JDK 8中完成。整合的方式是在HotSpot的基础上，移植JRockit的优秀特性。</p>
<h5 id="5、J9（三大虚拟机之一）（IBM）"><a href="#5、J9（三大虚拟机之一）（IBM）" class="headerlink" title="5、J9（三大虚拟机之一）（IBM）"></a>5、J9（三大虚拟机之一）（IBM）</h5><p>全称: IBM Technology for Java Virtual Machine， 简称IT4J，内部代号: J9</p>
<p>市场定位与HotSpot接近，服务器端、桌面应用、嵌入式等<strong>多用途VM</strong>，广泛用于IBM的各种Java产品。</p>
<p>目前，<strong>有影响力的三大商用服务器之一</strong>，也号称是世界上最快的Java虚拟机（在使用自己家产品时）。</p>
<p>2017年左右，IBM发布了开源J9 VM，命名为openJ9，交给Eclipse基金会管理，也称为Ecilpse OpenJ9</p>
<h5 id="6、KVM和CDC-CLDC-Hotspot"><a href="#6、KVM和CDC-CLDC-Hotspot" class="headerlink" title="6、KVM和CDC/ CLDC Hotspot"></a>6、KVM和CDC/ CLDC Hotspot</h5><p>Oracle在Java ME产品线上的两款虚拟机为: CDC/CLDC HotSpot Implementation VM</p>
<p>KVM (Kilobyte)是CLDC- HI早期产品</p>
<p>目前移动领域地位尴尬，智能手机被Android和iOS二分天下。</p>
<p>KVM简单、轻量、高度可移植，而向更低端的设备上还维持自己的一片市场</p>
<ul>
<li>智能控制器、传感器</li>
<li>老人手机、经济欠发达地区的功能手机</li>
</ul>
<p><strong>所有的虚拟机的原则：一次编译，到处运行</strong>。</p>
<h5 id="7、Azul-VM（Azul-Systems）"><a href="#7、Azul-VM（Azul-Systems）" class="headerlink" title="7、Azul VM（Azul Systems）"></a>7、Azul VM（Azul Systems）</h5><p>前而三大“高性能Java虚拟机”使用在<strong>通用硬件平台</strong>上</p>
<p>这里Azul VM和BEA Liquid VM是与<strong>特定硬件平台绑定、软硬件配合的专有虚拟机</strong>（高性能Java虚拟机中的战斗机）<br>Azul VM是Azul Systems 公司在HotSpot基础上进行大量改进，运行于Azul Systems 公司的专有硬件Vega系统上的Java虚拟机。</p>
<p><strong>每个Azul VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的GC时间的垃圾收集器、专有硬件优化的线</strong><br><strong>程调度等优秀特性。</strong></p>
<p>2010年，Azul Systems 公司开始从硬件转向软件，发布了自己的<strong>Zing JVM</strong>，可以在通用x86平台上提供接近于Vega系统的特性。</p>
<h5 id="8、Liquid-VM（BEA）"><a href="#8、Liquid-VM（BEA）" class="headerlink" title="8、Liquid VM（BEA）"></a>8、Liquid VM（BEA）</h5><p>高性能Java虚拟机中的战斗机</p>
<p>BEA公司开发的，直接运行在自家Hypervisor系统上</p>
<p>Liquid VM即是现在的JRockit VM（Virtual Edition），<strong>Liquid VM不需要成操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等</strong>。</p>
<p>随着JRockit虚拟机终止开发，Liquid VM项目也停止了。</p>
<h5 id="9、Apache-Harmony（IBM和Inter）"><a href="#9、Apache-Harmony（IBM和Inter）" class="headerlink" title="9、Apache Harmony（IBM和Inter）"></a>9、Apache Harmony（IBM和Inter）</h5><p>Apache Harmony是IBM和Inter联合开发的开源JVM，受到同样开源的OpenJDK的压制。</p>
<p>虽然目前并没有Apache Harmony被大规模商用的案例，但是它的Java类库代码吸纳进了Android SDK。</p>
<h5 id="10、Microsoft-JVM（Microsoft）"><a href="#10、Microsoft-JVM（Microsoft）" class="headerlink" title="10、Microsoft JVM（Microsoft）"></a>10、Microsoft JVM（Microsoft）</h5><p>微软为了在IE3浏览器中支持Java Applets，开发了Microsoft JVM。</p>
<p>只能在Window平台下运行。但确实是当时Windows下性能最好的Java VM。</p>
<p>1997年，Sun以侵犯商标、不正当竞争罪名指控微软成功，赔了sun很多钱。微软在windowsXP SP3中抹掉了其VM。现在windows上安装的jdk都是HotSpot。</p>
<h5 id="11、TaobaoJVM（Alibaba）"><a href="#11、TaobaoJVM（Alibaba）" class="headerlink" title="11、TaobaoJVM（Alibaba）"></a>11、TaobaoJVM（Alibaba）</h5><p>Alibaba基于OpenJDK开发了自己的定制版本AlibabaJDK，简称AJDK。是整个阿里Java体系的基石。</p>
<p>基于OpenJDK HotSpot VM发布的<strong>国内第一个优化、深度定制且开源的高性能服务器版Java虚拟机</strong>。</p>
<ul>
<li>创新GCIH （GC invisible heap）技术实现了off-heap，<strong>即将生命周期较长的java对象从heap中移到heap之外，并且GC不能管理GCIH内部的java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的</strong>。</li>
<li>GCIH中的<strong>对象还能够在多个java虚拟机进程中实现共享</strong>。</li>
<li>使用crc32指令顺序JVM intrinsic降低JNI 的调用开销</li>
<li>PMU hardware的java profiling tool 的诊断协助功能</li>
<li>针对大数据场景的ZenGC</li>
</ul>
<p>taobao NM应用在阿里产品上性能高，<strong>硬件严重依赖Intel的CPU，损失了兼容性，但提高 了性能</strong>。</p>
<p>目前已经在淘宝、天猫上线，把Oracle官方版本全部替换了。</p>
<h5 id="12、Dalvik-VM（Google）"><a href="#12、Dalvik-VM（Google）" class="headerlink" title="12、Dalvik VM（Google）"></a>12、Dalvik VM（Google）</h5><p>谷歌开发的，应用与Android系统，并在Android2.2中提供了JIT，发展迅猛。</p>
<p>Dalvik VM只能称作虚拟机，而不能称作”Java 虚拟机”，它<strong>没有遵循Java虚拟机规范</strong></p>
<p><strong>不能执行Java的Class文件</strong></p>
<p><strong>基于寄存器架构，不是jvm的栈架构</strong></p>
<p>执行的是编译以后的dex（Dalvik Executable）文件。执行效率比较高。</p>
<ul>
<li>它执行的dex（Dalvik Executable）文件可以通过Class文件转化而来，使用Java语法编写的应用程序，可以直接使用大部分的Java API等。</li>
</ul>
<p>Android5.0使用支持提前编译（Ahead of Time Compila，AOT）的ART VM替换了Dalvik VM</p>
<h5 id="13、Graal-VM"><a href="#13、Graal-VM" class="headerlink" title="13、Graal VM"></a>13、Graal VM</h5><p>2018年4月，Oracle Labs公开了Graal VM，号称”<strong>Run Programs Faster Anywhere</strong>“。与1995年java的”write once，run anywhere”遥相呼应。</p>
<p>Graal VM在HotSpot VM基础上增强而成的<strong>跨语言全栈虚拟机</strong>，<strong>可以作为”任何语言”的运行平台使用</strong>。语言包括：Java、Scala、Groovy、Kotlin；C、C++、JavaScript、Ruby、Python、R等。</p>
<p>支持不同语言中混合对方的接口和对象，支持这些语言使用已经编写好的本地库文件</p>
<p>工作原理：将这些语言的源代码或源代码编译后的中间格式，通过解释器转换成能被Graal VM接收的中间表示。Graal VM通过Truffle工具快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。</p>
<p><strong>如果说HotSpot有一天真的被取代，Graal VM希望最大</strong>。但是Java的软件生态没有丝毫变化。</p>
<h5 id="14、其他虚拟机"><a href="#14、其他虚拟机" class="headerlink" title="14、其他虚拟机"></a>14、其他虚拟机</h5><ul>
<li>Java Card VM</li>
<li>Squawk VM</li>
<li>JavaInJava</li>
<li>Maxine VM</li>
<li>Jikes RVM</li>
<li>IKVM.NET</li>
<li>Jam VM</li>
<li>Cacao VM</li>
<li>Sable VM</li>
<li>Kaffe</li>
<li>Jelatine JVM</li>
<li>Nano VM</li>
<li>MRP</li>
<li>Moxie JVM</li>
</ul>
<hr>
<h3 id="2、类加载器子系统（Class-Loader）"><a href="#2、类加载器子系统（Class-Loader）" class="headerlink" title="2、类加载器子系统（Class Loader）"></a>2、类加载器子系统（Class Loader）</h3><h4 id="1、内部结构概述"><a href="#1、内部结构概述" class="headerlink" title="1、内部结构概述"></a>1、内部结构概述</h4><h5 id="1、类加载器子系统作用"><a href="#1、类加载器子系统作用" class="headerlink" title="1、类加载器子系统作用"></a>1、类加载器子系统作用</h5><ul>
<li>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识（CA FE BA BE，是一个魔数(Coffee baby)）。</li>
<li>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</li>
<li>加载的类信息存放与一块称为方法区的内存空间。除了类信息以外，方法区还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）常量池在运行过程中加载到内存里，叫运行时常量池。</li>
</ul>
<h5 id="2、类加载器ClassLoader角色"><a href="#2、类加载器ClassLoader角色" class="headerlink" title="2、类加载器ClassLoader角色"></a>2、类加载器ClassLoader角色</h5><p><img src="/2021/04/19/JVM/image-20210420231839277.png" alt="image-20210420231839277"></p>
<ol>
<li>class file 存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来，根据这个文件实例化出n个一模一样的实例。</li>
<li>class file 加载到JVM中,被称为DNA元数据模板，放在方法区。</li>
<li>在.class文件-&gt; JVM -&gt;最终成为元数据模板,此过程就要一个运输工具(类装载器Class Loader) ,扮演一个快递员的角色。</li>
</ol>
<h4 id="2、类加载器与类的加载过程"><a href="#2、类加载器与类的加载过程" class="headerlink" title="2、类加载器与类的加载过程"></a>2、类加载器与类的加载过程</h4><h5 id="1、JVM架构"><a href="#1、JVM架构" class="headerlink" title="1、JVM架构"></a>1、JVM架构</h5><p>JVM架构-简图：<br><img src="/2021/04/19/JVM/%E7%AC%AC02%E7%AB%A0_JVM%E6%9E%B6%E6%9E%84-%E7%AE%80%E5%9B%BE.jpg" alt="第02章_JVM架构-简图"></p>
<p>JVM架构-详细图解（中英文）：</p>
<p><img src="/2021/04/19/JVM/image-20210420161504521.png" alt="image-20210420161504521"></p>
<h5 id="2、类加载的过程"><a href="#2、类加载的过程" class="headerlink" title="2、类加载的过程"></a>2、类加载的过程</h5><p>类加载的过程：</p>
<p><img src="/2021/04/19/JVM/image-20210420232214018.png" alt="image-20210420232214018"></p>
<p>程序加载过程：</p>
<p><img src="/2021/04/19/JVM/image-20210420232257344.png" alt="image-20210420232257344"></p>
<h5 id="3、类加载的三个阶段"><a href="#3、类加载的三个阶段" class="headerlink" title="3、类加载的三个阶段"></a>3、类加载的三个阶段</h5><h6 id="1、阶段一：Loading（加载）"><a href="#1、阶段一：Loading（加载）" class="headerlink" title="1、阶段一：Loading（加载）"></a>1、阶段一：Loading（加载）</h6><p>加载：</p>
<ol>
<li>通过一个类的<strong>全限定类名</strong>获取定义此类的<strong>二进制字节流</strong>。</li>
<li>将这个字节流所代表的<strong>静态存储结构转化为方法区的运行时数据结构</strong>。</li>
<li><strong>在内存中生成一个代表这个类的java. lang.Class对象</strong>， 作为方法区这个类的各种数据的访问入口。</li>
</ol>
<p>补充:加载.class文件的方式：</p>
<ul>
<li>从<strong>本地系统</strong>中直接加载</li>
<li>通过<strong>网络</strong>获取，典型场景: Web Applet</li>
<li>从<strong>zip压缩包</strong>中读取，成为日后jar、war格式的基础</li>
<li><strong>运行时计算生成</strong>，使用最多的是：动态代理技术（java.lang.reflect.proxy）</li>
<li>由<strong>其他文件生成</strong>，典型场景：JSP应用</li>
<li>从<strong>专有数据库</strong>中提取.class文件,比较少见</li>
<li>从<strong>加密文件</strong>中获取，典型的防Class文件被反编译的保护措施</li>
</ul>
<h6 id="2、阶段二：Linking（链接）"><a href="#2、阶段二：Linking（链接）" class="headerlink" title="2、阶段二：Linking（链接）"></a>2、阶段二：Linking（链接）</h6><p><strong>验证(Verify) :</strong></p>
<ul>
<li><p>目的在于<strong>确保Class文件的字节流中包含信息符合当前虚拟机要求</strong>，<strong>保证被加载类的正确性</strong>，不会危害虚拟机自身安全。</p>
</li>
<li><p>主要包括四种验证</p>
<ul>
<li>文件格式验证</li>
<li>元数据验证</li>
<li>字节码验证</li>
<li>符号引用验证</li>
</ul>
</li>
<li><p>例如：class文件在文件开头有特定的文件标识（CA FE BA BE，是一个魔数(Coffee baby)）</p>
<p><img src="/2021/04/19/JVM/image-20210420234046557.png" alt="image-20210420234046557"></p>
</li>
</ul>
<p><strong>准备(Prepare) ：</strong></p>
<ul>
<li>为<strong>类变量分配内存并且设置该类变量的默认初始值</strong>，即零值。</li>
<li>这里<strong>不包含用final修饰的static（即：常量）</strong>，因为final在编译的时候就会分配了，准备阶段会显式初始化。</li>
<li>这里<strong>不会为实例变量分配初始化</strong>，<strong>类变量会分配在方法区</strong>中，而<strong>实例变量是会随着对象一起分配到Java堆</strong>中。</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//prepare: a = 0 ---&gt; Initialization : a = 1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>其中数据类型不同，默认初始值也就不同：</p>
<ul>
<li>整型（byte\short\int\long）：0</li>
<li>浮点型（float\double）:0.0f</li>
<li>字符型（char）：\u0000</li>
<li>布尔型（boolean）：false</li>
<li>引用类型：null</li>
</ul>
<p><strong>解析(Resolve) :</strong></p>
<ul>
<li>将<strong>常量池内的符号引用转换为直接引用</strong>的过程。</li>
<li>事实上，解析操作往往会伴随着<strong>JVM在执行完初始化之后</strong>再执行。</li>
<li>符号引用就是<strong>一组符号来描述所引用的目标</strong>。符号引用的字面量形式明确定义在《java虚拟机规范》的Class文件格式中。<strong>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</strong>。</li>
<li>解析动作主要针对<strong>类</strong>或<strong>接口</strong>、<strong>字段</strong>、<strong>类方法</strong>、<strong>接口方法</strong>、<strong>方法类型</strong>等。对应常量池中的CONSTANT_ Class_ info、CONSTANT Fieldref_ info、 CONSTANT Methodref_ info等。</li>
</ul>
<h6 id="3、阶段三：Initialization（初始化）"><a href="#3、阶段三：Initialization（初始化）" class="headerlink" title="3、阶段三：Initialization（初始化）"></a>3、阶段三：Initialization（初始化）</h6><p>初始化：</p>
<ul>
<li><p><strong>初始化阶段就是执行类构造器方法<clinit>()的过程</clinit></strong>。</p>
</li>
<li><p>此方法不需定义，是javac编译器自动收集类中的所有<strong>类变量的赋值动作</strong>和<strong>静态代码块</strong>中的语句合并而来。</p>
<p>当不涉及到类变量的赋值动作与有关静态static（包括静态代码快、静态构造器，静态变量等等）的动作时，类构造器方法<clinit>()不会创建。</clinit></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClinitTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//任何一个类声明以后，内部至少存在一个类的构造器&lt;init&gt;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/19/JVM/image-20210421005041972.png" alt="image-20210421005041972"></p>
</li>
<li><p>构造器方法中<strong>指令按语句在源文件中出现的顺序执行</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInitTest</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">static</span>&#123;</span><br><span class="line">       num = <span class="number">2</span>;</span><br><span class="line">       <span class="comment">// 赋值</span></span><br><span class="line">       number = <span class="number">20</span>;</span><br><span class="line">       System.out.println(num);</span><br><span class="line">       <span class="comment">//System.out.println(number);//报错：非法的前向引用。</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 声明 </span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">10</span>;  <span class="comment">//linking之prepare: number = 0 --&gt; initial: 20 --&gt; 10</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ClassInitTest.num);<span class="comment">//2</span></span><br><span class="line">        System.out.println(ClassInitTest.number);<span class="comment">//10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><clinit> ()不同于类的构造器</clinit></strong>。(关联: 构造器是虚拟机视角下的<init> ())</init></p>
<p>任何一个类声明以后，内部至少存在一个类的构造器<init>（可以是自己声明的，也可以说系统默认提供的）</init></p>
<p><img src="/2021/04/19/JVM/image-20210421005632840.png" alt="image-20210421005632840"></p>
</li>
<li><p>若该类具有父类，JVM会保证<strong>子类的<clinit> ()执行前，父类的<clinit>()已经执行完毕</clinit></clinit></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClinitTest1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span>&#123;</span><br><span class="line">            A = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//加载Father类，其次加载Son类。</span></span><br><span class="line">        System.out.println(Son.B);<span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>虚拟机必须保证<strong>一个类的<clinit>()方法在多线程下被同步加锁</clinit></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable r = () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始&quot;</span>);</span><br><span class="line">            DeadThread dead = <span class="keyword">new</span> DeadThread();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r,<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r,<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeadThread</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 若一个类的&lt;clinit&gt;()方法在多线程下被同步加锁</span></span><br><span class="line">            <span class="comment">// 那么这里的打印代码就只会执行一次</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;初始化当前类&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<blockquote>
<p>线程2开始<br>线程1开始<br>线程2初始化当前类</p>
</blockquote>
<p>一个类只需要往内存中加载一次就可以了，加载之后将其放在方法区（方法区在JDK7之前被称为永久代，JDK7之后被称为源空间），源空间其实使用的是本地内存，即类加载到内存之后是使用直接内存进行缓存。若以后使用到该类，那么使用的都是内存中已经存在的类本身。所以，<strong>虚拟机在加载类的时候只会调用一次<clinit>方法</clinit></strong>。</p>
</li>
</ul>
<h4 id="3、类加载器分类"><a href="#3、类加载器分类" class="headerlink" title="3、类加载器分类"></a>3、类加载器分类</h4><h5 id="1、类加载器分类"><a href="#1、类加载器分类" class="headerlink" title="1、类加载器分类"></a>1、类加载器分类</h5><p>JVM支持<strong>两种类型的类加载器</strong>，分别为<strong>引导类加载器( Bootstrap ClassLoader)**和</strong>自定义类加载器(User-Defined ClassLoader)** 。</p>
<ul>
<li><p>引导类加载器( Bootstrap ClassLoader)：</p>
<ul>
<li>本身不是使用java语言编写，而是使用C与C++进行编写</li>
</ul>
</li>
<li><p>自定义类加载器(User-Defined ClassLoader)</p>
<ul>
<li><p>使用java语言编写</p>
</li>
<li><p>派生于抽象类ClassLoader。所以扩展类加载器（Extinction Class Loader）与系统类加载器（System Class Loader）都属于自定义类加载器</p>
<p>其中sun.misc.Launcher它是一个java虚拟机的入口应用</p>
<p><img src="/2021/04/19/JVM/image-20210421012614177.png" alt="image-20210421012614177"></p>
</li>
</ul>
</li>
</ul>
<p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将<strong>所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</strong>。</p>
<p>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个：</p>
<p><img src="/2021/04/19/JVM/image-20210421011954294.png" alt="image-20210421011954294"></p>
<p>这里的四者之间的关系是<strong>包含关系</strong>。不是上层下层，也不是子父类的继承关系。</p>
<p>对于引导类加载器（Bootstrap Class Loader）、扩展类加载器（Extension Class Loader）与系统类加载器（System Class Loader）三者的关系：</p>
<ul>
<li>系统类加载器（System Class Loader）的上层就是扩展类加载器（Extension Class Loader）：对于用户自定义类来说：默认使用系统类加载器进行加载</li>
<li>扩展类加载器（Extension Class Loader）的上层是引导类加载器（Bootstrap Class Loader）</li>
<li>引导类加载器（Bootstrap Class Loader）是最高层的类加载器：<strong>Java的核心类库</strong>都是使用引导类加载器进行加载的。并且我们获取不到引导类加载器。因为引导类加载器并不是所以java语言进行编写的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取系统类加载器</span></span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">        <span class="comment">//获取其上层：扩展类加载器</span></span><br><span class="line">        ClassLoader extClassLoader = systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extClassLoader);<span class="comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span></span><br><span class="line">        <span class="comment">//获取其上层：获取不到引导类加载器</span></span><br><span class="line">        ClassLoader bootstrapClassLoader = extClassLoader.getParent();</span><br><span class="line">        System.out.println(bootstrapClassLoader);<span class="comment">//null</span></span><br><span class="line">        <span class="comment">//对于用户自定义类来说：默认使用系统类加载器进行加载</span></span><br><span class="line">        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">        <span class="comment">//String类使用引导类加载器进行加载的。---&gt; Java的核心类库都是使用引导类加载器进行加载的。</span></span><br><span class="line">        ClassLoader classLoader1 = String.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader1);<span class="comment">//null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、启动类加载器-引导类加载器，Bootstrap-ClassLoader-（虚拟机自带的加载器）"><a href="#2、启动类加载器-引导类加载器，Bootstrap-ClassLoader-（虚拟机自带的加载器）" class="headerlink" title="2、启动类加载器(引导类加载器，Bootstrap ClassLoader )（虚拟机自带的加载器）"></a>2、启动类加载器(引导类加载器，Bootstrap ClassLoader )（虚拟机自带的加载器）</h5><ul>
<li>这个类加载<strong>使用C/C++语言实现</strong>的，嵌套在JVM内部，是JVM的一部分。</li>
<li>它用来<strong>加载Java的核心库</strong>(JAVA HOME/jre/lib/rt.jar、resources. jar或sun.boot.class.path路径下的内容) , 用于<strong>提供JVM自身需要的类</strong></li>
<li>并<strong>不继承自java. lang .ClassLoader</strong>,<strong>没有父加载器</strong>。</li>
<li><strong>加载扩展类和应用程序类加载器，并指定为他们的父类加载器</strong>。</li>
<li>出于安全考虑，Bootstrap启动类加载器<strong>只加载包名为java、javax、sun等开头的类</strong></li>
</ul>
<h5 id="3、扩展类加载器-Extension-ClassLoader-（虚拟机自带的加载器）"><a href="#3、扩展类加载器-Extension-ClassLoader-（虚拟机自带的加载器）" class="headerlink" title="3、扩展类加载器(Extension ClassLoader)（虚拟机自带的加载器）"></a>3、扩展类加载器(Extension ClassLoader)（虚拟机自带的加载器）</h5><ul>
<li><p><strong>Java语言编写</strong>，由sun.misc.Launcher$ExtClassLoader实现</p>
</li>
<li><p><strong>派生于ClassLoader类</strong></p>
</li>
<li><p><strong>父类加载器为启动类加载器</strong></p>
</li>
<li><p>从java. ext. dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录(扩展目录)下加载类库。</p>
<p><strong>如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</strong></p>
</li>
<li><p><strong>JDK9以后</strong>扩展类加载器改为<strong>平台类加载器</strong></p>
</li>
</ul>
<h5 id="4、应用程序类加载器-系统类加载器，AppClassLoader-（虚拟机自带的加载器）"><a href="#4、应用程序类加载器-系统类加载器，AppClassLoader-（虚拟机自带的加载器）" class="headerlink" title="4、应用程序类加载器(系统类加载器，AppClassLoader)（虚拟机自带的加载器）"></a>4、应用程序类加载器(系统类加载器，AppClassLoader)（虚拟机自带的加载器）</h5><ul>
<li><strong>java语言编写</strong>，由sun.misc.Launcher$AppClassLoader实现</li>
<li><strong>派生于ClassLoader类</strong></li>
<li><strong>父类加载器为扩展类加载器</strong></li>
<li>它负责<strong>加载环境变量classpath或系统属性java.class.path指定路径下的类库</strong></li>
<li><strong>该类加载是程序中默认的类加载器</strong>，一般来说，<strong>Java应用的类都是由它来完成加载</strong></li>
<li><strong>通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器</strong></li>
</ul>
<h5 id="5、用户自定义类加载器"><a href="#5、用户自定义类加载器" class="headerlink" title="5、用户自定义类加载器"></a>5、用户自定义类加载器</h5><ul>
<li><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。</p>
</li>
<li><p>为什么要自定义类加载器：</p>
<ul>
<li><p><strong>隔离加载类</strong>：</p>
<p>在某些框架中需要使用中间件，然而中间件与应用模块是隔离的。所以需要把类加载到不同的环境当中，确保应用当中引用到的框架的jar包与中间件的jar包是不冲突的（冲突：框架与中间件的某些类的类名一样，路径也相同）。</p>
<p>所以需要做一个类的仲裁。一般主流的容器类框架都会自定义类加载器，让本身与不同中间件之间是隔离的，避免类的冲突。</p>
</li>
<li><p><strong>修改类加载的方式</strong>：</p>
<p>除了引导类加载器，其他类加载器都可以在需要的时候进行动态加载</p>
</li>
<li><p><strong>扩展加载源</strong>：</p>
<p>可以从数据库当中，或者电视机的机饼盒等等加载字节码文件的来源</p>
</li>
<li><p><strong>防止源码泄漏</strong>：</p>
<p>对字节码文件进行加密，防止被反编译篡改。</p>
<p>加密之后运行代码时就需要进行解密，这时候就可以通过自定义加载器的方式进行解密</p>
</li>
</ul>
</li>
<li><p>用户自定义类加载器实现步骤：</p>
<ol>
<li><p>开发人员可以通过<strong>继承抽象类java.lang.ClassLoader类</strong>的方式，实现自己的类加载器，以满足一些特殊的需求；</p>
</li>
<li><p>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载类，但是<strong>在JDK1.2之后</strong>已不再建议用户去覆盖loadClass()方法，而是<strong>建议把自定义的类加载逻辑写在findClass()方法中</strong>。（findClass()方法与defineClass()方法配合使用）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] result = getClassFromCustomPath(name);</span><br><span class="line">            <span class="keyword">if</span>(result == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> defineClass(name,result,<span class="number">0</span>,result.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassFromCustomPath(String name)&#123;</span><br><span class="line">        <span class="comment">//从自定义路径中加载指定类:细节略</span></span><br><span class="line">        <span class="comment">//如果指定路径的字节码文件进行了加密，则需要在此方法中进行解密操作。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CustomClassLoader customClassLoader = <span class="keyword">new</span> CustomClassLoader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;One&quot;</span>,<span class="keyword">true</span>,customClassLoader);</span><br><span class="line">            Object obj = clazz.newInstance();</span><br><span class="line">            System.out.println(obj.getClass().getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在编写自定义类加载器时，<strong>如果没有太过于复杂的需求，可以直接继承URLClassLoader类</strong>，这样就<strong>可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁</strong>。</p>
</li>
</ol>
</li>
</ul>
<h4 id="4、Class-Loader的使用说明"><a href="#4、Class-Loader的使用说明" class="headerlink" title="4、Class Loader的使用说明"></a>4、Class Loader的使用说明</h4><p>ClassLoader类，它是一个<strong>抽象类</strong>，其后<strong>所有的类加载器都继承自ClassLoader</strong> (不包括启动类加载器）</p>
<p>相关方法与描述：</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>方法名称</th>
</tr>
</thead>
<tbody><tr>
<td>getParent()</td>
<td>返回该类加载器的超类加载器</td>
</tr>
<tr>
<td>loadClass(String name)</td>
<td>加载名称为name的类，返回结果为java.lang.Class类的实例</td>
</tr>
<tr>
<td>findClass(String name)</td>
<td>查找名称为name的类，返回结果为java lang Class类的实例</td>
</tr>
<tr>
<td>findLoadedClass(String name)</td>
<td>查找名称为name的已经被加载过的类，返回结果为java lang Class类的实例</td>
</tr>
<tr>
<td>defineClass(String name, byte[] b, int off, int len)</td>
<td>把字节数组b中的内容转换为一个Java类,返回结果为java.lang.Class类的实例</td>
</tr>
<tr>
<td>resolveClass(Class&lt;?&gt; c)</td>
<td>连接指定的一个Java类</td>
</tr>
</tbody></table>
<p>获取ClassLoader的途径:</p>
<ol>
<li><p>获取当前类的ClassLoader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clazz.getClassLoader()</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取当前线程上下文的ClassLoader</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().getContextClassLoader()</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取系统的ClassLoader</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader.getSystemClassLoader()</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取调用者的ClassLoader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DriverManager.getCallerClassLoader()</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="5、双亲委派机制"><a href="#5、双亲委派机制" class="headerlink" title="5、双亲委派机制"></a>5、双亲委派机制</h4><h5 id="1、什么是双亲委派机制"><a href="#1、什么是双亲委派机制" class="headerlink" title="1、什么是双亲委派机制"></a>1、什么是双亲委派机制</h5><p>Java虚拟机对class文件采用的是<strong>按需加载</strong>的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是<strong>双亲委派模式</strong>，即<strong>把请求交由父类处理</strong>，它是一种任务委派模式。</p>
<h5 id="2、工作原理"><a href="#2、工作原理" class="headerlink" title="2、工作原理"></a>2、工作原理</h5><ol>
<li>如果一个类加载器收到类加载请求，它并不会自己去加载，而是把这个请求委托给父类的加载器去执行；</li>
<li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li>
<li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li>
</ol>
<p><img src="/2021/04/19/JVM/image-20210421103744316.png" alt="image-20210421103744316"></p>
<h5 id="3、例子"><a href="#3、例子" class="headerlink" title="3、例子"></a>3、例子</h5><p><img src="/2021/04/19/JVM/image-20210421105124634.png" alt="image-20210421105124634"></p>
<ul>
<li>SPI接口是由引导类加载器加载的</li>
<li>具体接口的实现类由于使用了第三方jdbc.jar，所以是由线程上下文类加载器加载的，而线程上下文类加载器的默认就是系统类加载器。（反向委派）</li>
</ul>
<h5 id="4、优势"><a href="#4、优势" class="headerlink" title="4、优势"></a>4、优势</h5><ul>
<li><p>避免类的重复加载</p>
</li>
<li><p>保护程序安全，防止核心API被随意篡改</p>
<ul>
<li>自定义类：java.lang.String</li>
<li>自定义类：java.lang,ShkStart</li>
</ul>
</li>
</ul>
<p>在src目录下新建java.lang.String：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是自定义的String类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//错误: 在类 java.lang.String 中找不到 main 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,String&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<blockquote>
<p>在类 java.lang.String 中找不到 main 方法</p>
</blockquote>
<p>在src目录下新建java.lang并在该包下编写自定义的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShkStart</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果：java.lang.SecurityException：Prohibited package name：java.lang</p>
</blockquote>
<p><strong>沙箱安全机制</strong>：</p>
<p>自定义String类，但是在加载自定义String类的时候会率先随意引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\lang\String.class），报错信息说没有main方法就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是<strong>沙箱安全机制</strong>。</p>
<h4 id="6、其他"><a href="#6、其他" class="headerlink" title="6、其他"></a>6、其他</h4><h5 id="1、在JVM中表示两个class对象是否为同一个类存在两个必要条件"><a href="#1、在JVM中表示两个class对象是否为同一个类存在两个必要条件" class="headerlink" title="1、在JVM中表示两个class对象是否为同一个类存在两个必要条件"></a>1、在JVM中表示两个class对象是否为同一个类存在两个必要条件</h5><ul>
<li><strong>类的完整类名必须一致，包括包名</strong>。</li>
<li><strong>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同</strong></li>
</ul>
<p>换句话说：在JVM中，既使这两个类对象（class对象）来源于同一个Class文件，被同一个虚拟机所加载，但<strong>只要加载它们的ClassLoader实例对象不同</strong>，那么这两个类对象也是<strong>不相等</strong>的。</p>
<h5 id="2、对类加载器的引用"><a href="#2、对类加载器的引用" class="headerlink" title="2、对类加载器的引用"></a>2、对类加载器的引用</h5><p>JVM必须知道一个类型是由启动类加载器加载的还是有用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么<strong>JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</strong>。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</p>
<h5 id="3、类的主动使用与被动使用"><a href="#3、类的主动使用与被动使用" class="headerlink" title="3、类的主动使用与被动使用"></a>3、类的主动使用与被动使用</h5><p>Java程序对类的使用方式分为：主动使用和被动使用</p>
<ul>
<li><p>主动使用，又分为七种情况：</p>
<ul>
<li><p>创建类的实例</p>
</li>
<li><p>访问某个类或接口的静态变量，或者对该静态变量赋值</p>
</li>
<li><p>调用类的静态方法</p>
</li>
<li><p>反射（比如：Class.forName(“com.atguigu.Test”)）</p>
</li>
<li><p>初始化一个类的子类</p>
</li>
<li><p>Java虚拟机启动时被标明为启动类的类</p>
</li>
<li><p>JDK7开始通过动态语言支持：</p>
<p>java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</p>
</li>
</ul>
</li>
<li><p>被动使用：除了上述七种情况，其他使用Java类的方式都被看作是对<strong>类的被动使用</strong>，都<strong>不会导致类的初始化</strong>。</p>
</li>
</ul>
<hr>
<h3 id="3、运行时数据区概述及线程"><a href="#3、运行时数据区概述及线程" class="headerlink" title="3、运行时数据区概述及线程"></a>3、运行时数据区概述及线程</h3><h4 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h4><h5 id="1、经典的JVM内存布局"><a href="#1、经典的JVM内存布局" class="headerlink" title="1、经典的JVM内存布局"></a>1、经典的JVM内存布局</h5><p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。</p>
<p><strong>不同的JVM对于内存的划分方式和管理机制存在着部分差异</strong>。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局：</p>
<p><img src="/2021/04/19/JVM/image-20210421112837894.png" alt="image-20210421112837894"></p>
<p>其中：方法区在JVM规范中是一个逻辑概念，由虚拟机自己进行具体实现。</p>
<ul>
<li><strong>HotSpot7和以前的版本</strong>用的是堆上的<strong>永久代</strong>实现方法区</li>
<li><strong>HotSpot8之后</strong>使用<strong>元数据区</strong>实现方法区</li>
<li><strong>常量池</strong>在jdk8以后也被放到了堆中</li>
</ul>
<h5 id="2、进程同步与线程同步："><a href="#2、进程同步与线程同步：" class="headerlink" title="2、进程同步与线程同步："></a>2、进程同步与线程同步：</h5><p>Java虚拟机定义了若干种程序运行期间会使用到的<strong>运行时数据区</strong>，其中有一些会<strong>随着虚拟机启动而创建，随着虚拟机退出而销毁(进程同步)**。另外一些则是</strong>与线程一一对应的<strong>，这些</strong>与线程对应的数据区域会随着线程开始和结束而创建和销毁**。</p>
<p>灰色的为单独线程私有的，红色的为多个线程共享的。即:</p>
<ul>
<li>每个线程：独立包括程序计数器、栈、本地栈。</li>
<li>每个进程：<strong>线程间共享</strong>，堆、堆外内存(永久代或元空间、代码缓存)（问题：怎么保证线程安全）</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210421113146594.png" alt="image-20210421113146594"></p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC03%E7%AB%A0_%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E5%92%8C%E7%A7%81%E6%9C%89%E7%9A%84%E7%BB%93%E6%9E%84.jpg" alt="第03章_线程共享和私有的结构"></p>
<p>​    其中：（一个线程一份）</p>
<ul>
<li>PC：程序计数器</li>
<li>VMS：虚拟机栈</li>
<li>NMS：本地方法栈</li>
</ul>
<h5 id="3、关于线程间共享的说明："><a href="#3、关于线程间共享的说明：" class="headerlink" title="3、关于线程间共享的说明："></a>3、关于线程间共享的说明：</h5><p><img src="/2021/04/19/JVM/image-20210421114556021.png" alt="image-20210421114556021"></p>
<p><strong>每个JVM只有一个Runtime实例</strong>。即为运行时环境，相当于内存结构的中间的那个框框（运行时数据区(Runtime Data Area)）：运行时环境。</p>
<h4 id="2、线程"><a href="#2、线程" class="headerlink" title="2、线程"></a>2、线程</h4><h5 id="1、关于线程"><a href="#1、关于线程" class="headerlink" title="1、关于线程"></a>1、关于线程</h5><p><strong>线程是一个程序里的运行单元</strong>。JVM允许<strong>一个应用有多个线程并行</strong>的执行。</p>
<p>在Hotspot JVM里，<strong>每个线程都与操作系统的本地线程直接映射</strong>。</p>
<ul>
<li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。</li>
</ul>
<p>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法。</p>
<h5 id="2、线程的分类"><a href="#2、线程的分类" class="headerlink" title="2、线程的分类"></a>2、线程的分类</h5><ul>
<li>普通线程</li>
<li>守护线程</li>
</ul>
<h5 id="3、JVM的系统线程"><a href="#3、JVM的系统线程" class="headerlink" title="3、JVM的系统线程"></a>3、JVM的系统线程</h5><p>如果你使用jconsole或者是任何一个调试工具，都能看到在后台有许多线程在运行。</p>
<p>这些<strong>后台线程不包括</strong>调用public static void main (String[])的<strong>main线程以及所有这个main线程自己创建的线程</strong>。</p>
<p>这些主要的后台系统线程在HotSpot JVM里主要是以下几个：</p>
<ul>
<li><p><strong>虚拟机线程</strong>：</p>
<p>这种线程的操作是需要<strong>JVM达到安全点</strong>才会出现。这些操作必须<strong>在不同的线程中发生的原因是他们都需要JVM达到安全点</strong>，这样堆才不会变化。这种线程的执行类型包括**”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销**。</p>
</li>
<li><p><strong>周期任务线程</strong>：</p>
<p>这种线程是<strong>时间周期事件的体现(比如中断)**，他们</strong>一般用于周期性操作的调度执行**。</p>
</li>
<li><p><strong>GC线程</strong>：</p>
<p>这种线程<strong>对在JVM里不同种类的垃圾收集行为提供了支持</strong>。</p>
</li>
<li><p><strong>编译线程</strong>：</p>
<p>这种线程在运行时会<strong>将字节码编译成到本地代码</strong>。</p>
</li>
<li><p><strong>信号调度线程</strong>：</p>
<p>这种线程接收信号并<strong>发送给JVM</strong>， <strong>在它内部通过调用适当的方法进行处理</strong>。</p>
</li>
</ul>
<hr>
<h3 id="4、程序计数器（PC寄存器）"><a href="#4、程序计数器（PC寄存器）" class="headerlink" title="4、程序计数器（PC寄存器）"></a>4、程序计数器（PC寄存器）</h3><h4 id="1、PC-Register介绍"><a href="#1、PC-Register介绍" class="headerlink" title="1、PC Register介绍"></a>1、PC Register介绍</h4><p><img src="/2021/04/19/JVM/image-20210422000432697.png" alt="image-20210422000432697"></p>
<p>JVM中的程序计数寄存器(Program Counter Register) 中，Register 的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。<strong>CPU只有把数据装载到寄存器才能够运行</strong>。</p>
<p>这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器(或指令计数器)会更加贴切(也称为程序钩子)，并且也不容易引起一些不必要的误会。<strong>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟</strong>。</p>
<p><strong>作用</strong>：</p>
<p>PC寄存器<strong>用来存储指向下一条指令的地址</strong>，也即将要执行的指令代码。<strong>由执行引擎读取下一条指令</strong>。</p>
<p><img src="/2021/04/19/JVM/image-20210421201053065.png" alt="image-20210421201053065"></p>
<ul>
<li>它是一块很小的内存空间，几乎可以忽略不记。也是<strong>运行速度最快的存储区域</strong>。</li>
<li>在JVM规范中，<strong>每个线程都有它自己的程序计数器，是线程私有的</strong>，<strong>生命周期与线程的生命周期保持一致</strong>。</li>
<li><strong>任何时间一个线程都只有一个方法在执行</strong>，也就是所谓的<strong>当前方法</strong>。<strong>程序计数器会存储当前线程正在执行的Java方法的JVM指令地址</strong>；或者，<strong>如果是在执行native方法，则是未指定值(undefned)</strong></li>
<li><strong>它是程序控制流的指示器</strong>，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li>
<li><strong>字节码解释器</strong>工作时就是<strong>通过改变这个计数器的值来选取下一条需要执行的字节码指令</strong>。</li>
<li>它<strong>不存在垃圾回收</strong>问题。</li>
<li>它是<strong>唯一一个在Java虚拟机规范中没有规定任何OutOtMemoryError情况的区域</strong>。</li>
<li>即：<strong>无GC，无OOM</strong></li>
</ul>
<h4 id="2、举例说明"><a href="#2、举例说明" class="headerlink" title="2、举例说明"></a>2、举例说明</h4><p><img src="/2021/04/19/JVM/image-20210422001738599.png" alt="image-20210422001738599"></p>
<p><img src="/2021/04/19/JVM/image-20210422001753431.png" alt="image-20210422001753431"></p>
<p>针对<code>5</code>进行举例：（PC寄存器的意义或者作用）</p>
<ol>
<li>指令地址<code>5</code>就是PC寄存器里面存放的值</li>
<li>执行引擎会在PC寄存器里面获取指令地址对应的操作指令（istore_2）</li>
<li>执行引擎得到操作指令后会执行下面两个操作：<ol>
<li>操作虚拟机栈（如局部变量表、操作数栈等等），实现数据的存取操作以及一些求和运算等等。</li>
<li>把字节码指令翻译为机器指令</li>
</ol>
</li>
<li>机器指令可以让对应的CPU做运算</li>
</ol>
<h4 id="3、两个常见问题"><a href="#3、两个常见问题" class="headerlink" title="3、两个常见问题"></a>3、两个常见问题</h4><ol>
<li><p>使用PC寄存器存储字节码指令地址有什么用呢？为什么使用PC寄存器记录当前线程的执行地址呢？</p>
<p>因为CPU需要不停的切换各个进程，这时候切换回来以后，就得知道从哪开始继续执行。</p>
<p>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC04%E7%AB%A0_PC%E5%AF%84%E5%AD%98%E5%99%A8.jpg" alt="第04章_PC寄存器"></p>
</li>
<li><p>PC寄存器为什么会被设定为线程私有？</p>
<p>我们都知道所谓的<strong>多线程在一个特定的时间段内只会执行其中某一个线程的方法</strong>，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢?</p>
<p>为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，<strong>这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况</strong>。</p>
<p>由于<strong>CPU时间片轮限制</strong>，众多线程在并发执行过程中，任何一个确定的时刻，<strong>一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令</strong>。</p>
<p>这样必然导致经常中断或恢复，如何保证分毫无差呢?</p>
<p><strong>每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响</strong>。</p>
</li>
</ol>
<h4 id="4、CPU时间片"><a href="#4、CPU时间片" class="headerlink" title="4、CPU时间片"></a>4、CPU时间片</h4><p><strong>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片</strong>。</p>
<p>在<strong>宏观</strong>上：我们可以<strong>同时打开多个应用程序，每个程序并行不悖，同时运行</strong>。</p>
<p>但在<strong>微观</strong>上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平？一种方法就是<strong>引入时间片，每个程序轮流执行</strong>。</p>
<p>并行与并发：</p>
<ul>
<li>并行就是两个核同时算</li>
<li>并发就是一个核算两个一人一段。</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210421202826450.png" alt="image-20210421202826450"></p>
<hr>
<h3 id="5、虚拟机栈"><a href="#5、虚拟机栈" class="headerlink" title="5、虚拟机栈"></a>5、虚拟机栈</h3><h4 id="1、虚拟机栈概述"><a href="#1、虚拟机栈概述" class="headerlink" title="1、虚拟机栈概述"></a>1、虚拟机栈概述</h4><h5 id="1、虚拟机栈出现的背景"><a href="#1、虚拟机栈出现的背景" class="headerlink" title="1、虚拟机栈出现的背景"></a>1、虚拟机栈出现的背景</h5><p>由于跨平台性的设计，<strong>Java的指令都是根据栈来设计</strong>的。不同平台CPU架构不同，所以不能设计为基于寄存器的。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>跨平台</li>
<li>指令集小</li>
<li>编译器容易实现</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>性能下降</li>
<li>实现同样的功能需要更多的指令</li>
</ul>
<h5 id="2、内存中的栈与堆"><a href="#2、内存中的栈与堆" class="headerlink" title="2、内存中的栈与堆"></a>2、内存中的栈与堆</h5><p>栈：</p>
<ul>
<li><strong>栈是运行时的单位</strong></li>
<li><strong>栈解决程序的运行问题</strong>，即程序如何执行，或者说如何处理数据</li>
</ul>
<p>堆：</p>
<ul>
<li><strong>堆是存储的单位</strong></li>
<li><strong>堆解决的是数据存储的问题</strong>，即数据怎么放、放在哪里。</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210422005102514.png" alt="image-20210422005102514"></p>
<h5 id="3、虚拟机栈基本内容"><a href="#3、虚拟机栈基本内容" class="headerlink" title="3、虚拟机栈基本内容"></a>3、虚拟机栈基本内容</h5><p>Java虚拟机栈是什么?</p>
<p>Java虚拟机栈(Java Virtual Machine Stack) ，早期也叫Java栈。<strong>每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧</strong>(Stack Frame) （栈存储数据的基本单位），<strong>对应着一次次的Java方法调用</strong>。</p>
<ul>
<li>是线程私有的</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210422012357234.png" alt="image-20210422012357234"></p>
<p>Java虚拟机栈生命周期：</p>
<ul>
<li><strong>生命周期和线程一致</strong>。</li>
</ul>
<p>Java虚拟机栈作用：</p>
<ul>
<li>主管Java程序的运行，它保存方法的**局部变量(8种基本数据类型、对象的引用)**、部分结果，并参与方法的调用和返回。</li>
</ul>
<p>栈的特点(优点)：</p>
<ul>
<li><p>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。</p>
</li>
<li><p>JVM直接对Java栈的操作只有两个:</p>
<ul>
<li>每个方法执行，伴随着进栈(入栈、压栈)</li>
<li>执行结束后的出栈工作</li>
</ul>
</li>
<li><p>对于栈来说<strong>不存在垃圾回收问题</strong>，但是存在内存溢出的情况。</p>
</li>
<li><p>即：<strong>无GC，有OOM</strong></p>
<p><img src="/2021/04/19/JVM/image-20210422013552022.png" alt="image-20210422013552022"></p>
</li>
</ul>
<p>栈中可能存在的异常：</p>
<p>Java虚拟机规范<strong>允许Java栈的大小是动态的或者是固定不变</strong>的。</p>
<ul>
<li><p>如果采用<strong>固定大小</strong>的Java虚拟机栈，那<strong>每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定</strong>。如果<strong>线程请求分配的栈容量超过Java虚拟机栈允许的最大容量</strong>，Java虚拟机将会抛出一个<strong>StackOverflowError异常</strong>。</p>
<p><img src="/2021/04/19/JVM/image-20210422013326303.png" alt="image-20210422013326303"></p>
</li>
<li><p>如果Java虚拟机栈可以<strong>动态扩展</strong>，并且<strong>在尝试扩展的时候无法申请到足够的内存</strong>，或者<strong>在创建新的线程时没有足够的内存去创建对应的虚拟机栈</strong>，那Java虚拟机将会抛出一个<strong>OutOfMemoryError异常</strong>。</p>
</li>
</ul>
<p>设置栈内存大小：</p>
<p>我们可以使用<strong>参数-Xss选项来设置线程的最大栈空间</strong>，**栈的大小直接决定了函数调用的最大可达<code>深度</code>**。</p>
<p><img src="/2021/04/19/JVM/image-20210422014055436.png" alt="image-20210422014055436"></p>
<p>设置步骤：</p>
<ol>
<li><p>在IDEA点开<code>Run</code></p>
<p><img src="/2021/04/19/JVM/image-20210422014347776.png" alt="image-20210422014347776"></p>
</li>
<li><p>在Run下面有选项<code>Edit Configurations...</code></p>
<p><img src="/2021/04/19/JVM/blog\XGH-blog\source_posts\JVM\image-20210422014445720.png" alt="image-20210422014445720"></p>
</li>
<li><p>在当前类下的<code>VM options</code>中进行参数设置。（参数参考上-Xss的设置）程序调优的一种方案：<strong>参数调优</strong></p>
<p><img src="/2021/04/19/JVM/image-20210422014706947.png" alt="image-20210422014706947"></p>
</li>
</ol>
<p>参数设置后的测试方法：</p>
<p><img src="/2021/04/19/JVM/image-20210422013442292.png" alt="image-20210422013442292"></p>
<h4 id="2、栈的存储单位"><a href="#2、栈的存储单位" class="headerlink" title="2、栈的存储单位"></a>2、栈的存储单位</h4><h5 id="1、栈中存储什么"><a href="#1、栈中存储什么" class="headerlink" title="1、栈中存储什么?"></a>1、栈中存储什么?</h5><ul>
<li><strong>每个线程都有自己的栈</strong>，栈中的数据都是<strong>以栈帧(Stack Frame)为基本存储单位</strong>的格式存在。</li>
<li>在这个线程上正在执行的<strong>每个方法都各自对应一个栈帧(Stack Frame)</strong></li>
<li>栈帧是一个<strong>内存区块</strong>，是一个<strong>数据集</strong>，<strong>维系着方法执行过程中的各种数据信息</strong>。</li>
</ul>
<h5 id="2、栈的运行原理"><a href="#2、栈的运行原理" class="headerlink" title="2、栈的运行原理"></a>2、栈的运行原理</h5><ul>
<li><p>JVM直接对Java栈的操作只有两个，就是<strong>对栈帧的压栈和出栈</strong>，<strong>遵循“先进后出”/“后进先出”原则</strong>。</p>
</li>
<li><p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧(栈项栈帧)是有效的，这个栈帧被称为<strong>当前栈帧(Current Frame)</strong> ，与当前栈帧相对应的方法就是<strong>当前方法(Current Method)**，定义这个方法的类就是</strong>当前类(Current Class)** 。</p>
</li>
<li><p><strong>执行引擎运行的所有字节码指令只针对当前栈帧进行操作</strong>。</p>
</li>
<li><p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC05%E7%AB%A0_%E6%96%B9%E6%B3%95%E4%B8%8E%E6%A0%88%E6%A1%A2.jpg" alt="第05章_方法与栈桢"></p>
</li>
<li><p>不同线程中所包含的栈帧是不允许存在相互引用的，即<strong>不可能在一个栈帧之中引用另外一个线程的栈帧</strong>。</p>
</li>
<li><p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p>
</li>
<li><p>Java方法有两种返回函数的方式：</p>
<ul>
<li><strong>正常的函数返回，使用return指令</strong></li>
<li><strong>抛出异常</strong></li>
</ul>
<p>不管使用哪种方式，都会导致<strong>栈帧被弹出</strong>。</p>
</li>
</ul>
<h5 id="3、栈帧的内部结构"><a href="#3、栈帧的内部结构" class="headerlink" title="3、栈帧的内部结构"></a>3、栈帧的内部结构</h5><p>每个栈帧中存储着：</p>
<ul>
<li><strong>局部变量表(Local Variables：LV)</strong></li>
<li><strong>操作数栈(Operand Stack) (或表达式栈)</strong></li>
<li>动态链接(Dynamic Linking) ( 或指向运行时常量池的方法引用) </li>
<li>方法返回地址(Return Address) (或方法正常退出或者异常退出的定义)</li>
<li>一些附加信息</li>
</ul>
<p><img src="/2021/04/19/JVM/%E7%AC%AC05%E7%AB%A0_%E6%A0%88%E6%A1%A2%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.jpg" alt="第05章_栈桢内部结构"></p>
<p><img src="/2021/04/19/JVM/image-20210422173049395.png" alt="image-20210422173049395"></p>
<h4 id="3、局部变量表-Local-Variables"><a href="#3、局部变量表-Local-Variables" class="headerlink" title="3、局部变量表( Local Variables)"></a>3、局部变量表( Local Variables)</h4><h5 id="1、局部变量表的概述"><a href="#1、局部变量表的概述" class="headerlink" title="1、局部变量表的概述"></a>1、局部变量表的概述</h5><ul>
<li>局部变量表也被称之为<strong>局部变量数组</strong>或<strong>本地变量表</strong></li>
<li><strong>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括<strong>各类基本数据类型</strong>、<strong>对象引用(reference)</strong> ，以及<br><strong>return Address类型</strong>。（因为各类数据类型都可以通过<strong>数字</strong>来表示）</li>
<li>由于局部变量表是建立在<strong>线程的栈上</strong>，是<strong>线程的私有数据</strong>，因此<strong>不存在数据安全问题</strong></li>
<li><strong>局部变量表所需的容量大小是在编译期确定下来</strong>的，并<strong>保存在方法的Code属性的maximum local variables数据项</strong>中。 在方法<strong>运行期间是不会改变</strong>局部变量表的大小的。</li>
<li><strong>方法嵌套调用的次数由栈的大小决定</strong>。一般来说，<strong>栈越大，方法嵌套调用次数越多</strong>。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li>
<li><strong>局部变量表中的变量只在当前方法调用中有效</strong>。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。<strong>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁</strong>。</li>
</ul>
<h5 id="2、对程序编译后的字节码文件的查看方法"><a href="#2、对程序编译后的字节码文件的查看方法" class="headerlink" title="2、对程序编译后的字节码文件的查看方法"></a>2、对程序编译后的字节码文件的查看方法</h5><p>程序代码：（以main方法为例，其他方法类似）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalVariablesTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalVariablesTest test = <span class="keyword">new</span> LocalVariablesTest();</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">        test.test1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/19/JVM/image-20210422180804881.png" alt="image-20210422180804881"></p>
<p><img src="/2021/04/19/JVM/image-20210422181213595.png" alt="image-20210422181213595"></p>
<p><img src="/2021/04/19/JVM/image-20210422181755767.png" alt="image-20210422181755767"></p>
<p><img src="/2021/04/19/JVM/image-20210422182334511.png" alt="image-20210422182334511"></p>
<p><img src="/2021/04/19/JVM/image-20210422193112649.png" alt="image-20210422193112649"></p>
<p><img src="/2021/04/19/JVM/image-20210422193542032.png" alt="image-20210422193542032"></p>
<h5 id="3、关于Slot的理解"><a href="#3、关于Slot的理解" class="headerlink" title="3、关于Slot的理解"></a>3、关于Slot的理解</h5><ul>
<li><p><strong>参数值的存放总是在局部变量数组的index0开始</strong>，到数组长度-1的索引结束。</p>
</li>
<li><p><strong>局部变量表的最基本的存储单元是Slot (变量槽)</strong></p>
</li>
<li><p><strong>局部变量：表中存放编译期可知的各种基本数据类型(8种)，引用类型(reference)，returnAddress类型的变量。</strong></p>
</li>
<li><p>在局部变量表里，<strong>32位以内的类型只占用一个slot (包括returnAddress类型)，64位的类型(long和double)占用两个slot</strong>。</p>
<ul>
<li>byte、short 、char、在存储前被转换为int，boolean 也被转换为int，0表示false，非0表示true，float、<strong>引用数据类型的引用</strong></li>
<li>long和double则占据两个Slot。</li>
</ul>
</li>
<li><p>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的基本变量值</p>
</li>
<li><p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制</strong>到局部变量表中的每一个Slot上</p>
</li>
<li><p><strong>如果需要访问局部变量表中一个64bit的基本变量值时，只需要使用前一个索引即可。</strong>（比如：访问long或double类型变量）</p>
<p><img src="/2021/04/19/JVM/image-20210422200200175.png" alt="image-20210422200200175"></p>
</li>
<li><p>如果当前帧是由<strong>构造方法</strong>或者<strong>实例方法</strong>创建的，那么<strong>该<code>对象引用this</code>将会存放在index为0的slot处</strong>，其余的参数按照参数表顺序继续排列。</p>
</li>
<li><p><strong>在静态(static)方法中不能引用this</strong>：因为this变量不存在于静态方法的局部变量表中！！</p>
<p><img src="/2021/04/19/JVM/image-20210422201450476.png" alt="image-20210422201450476"></p>
</li>
</ul>
<h5 id="4、Slot的重复利用"><a href="#4、Slot的重复利用" class="headerlink" title="4、Slot的重复利用"></a>4、Slot的重复利用</h5><p><strong>栈帧中的局部变量表中的槽位是可以重用的</strong>，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而<strong>达到节省资源的目的</strong>。</p>
<p>变量c使用之前已经销毁的变量b占据的slot的位置：</p>
<p><img src="/2021/04/19/JVM/image-20210422202145932.png" alt="image-20210422202145932"></p>
<h5 id="5、静态变量与局部变量的对比"><a href="#5、静态变量与局部变量的对比" class="headerlink" title="5、静态变量与局部变量的对比"></a>5、静态变量与局部变量的对比</h5><p><strong>变量的分类</strong>：</p>
<ul>
<li>按照数据类型分：<ul>
<li>基本数据类型</li>
<li>引用数据类型</li>
</ul>
</li>
<li>按照在类中声明的位置分：<ul>
<li>成员变量：在使用前，都经历过默认初始化赋值<ul>
<li>类变量（static修饰）： linking的prepare阶段：给类变量默认赋值  —&gt; initial阶段：给类变量显式赋值即静态代码块赋值</li>
<li>实例变量（没有static修饰）：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值</li>
</ul>
</li>
<li>局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过。</li>
</ul>
</li>
</ul>
<p><strong>静态变量（类变量）与局部变量对比</strong>：</p>
<ul>
<li><p>参数表分配完毕之后，再<strong>根据方法体内定义的变量的顺序和作用域分配</strong>。</p>
</li>
<li><p>我们知道<strong>类变量</strong>表有两次初始化的机会，第一次是在“<strong>准备阶段</strong>”，执行系统初始化，对<strong>类变量设置零值</strong>，另一次则是在“<strong>初始化</strong>”阶段，赋予<strong>程序员在代码中定义的初始值</strong>。</p>
</li>
<li><p>和类变量初始化不同的是，<strong>局部变量表**</strong>不存在系统初始化<strong>的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// 报错：没有赋值不能够使用。</span></span><br><span class="line">    System.out.println(i).</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="6、补充说明："><a href="#6、补充说明：" class="headerlink" title="6、补充说明："></a>6、补充说明：</h5><ul>
<li>在栈帧中，与<strong>性能调优</strong>关系最为密切的部分就是<strong>局部变量表</strong>。在方法执行时，虚拟机使用局部变量表完成方法的传递。</li>
<li><strong>局部变量表中的变量也是重要的<code>垃圾回收根节点</code>（根搜索算法\可达性分析），只要被局部变量表中直接或间接引用的对象都不会被回收</strong>。</li>
</ul>
<h4 id="4、操作数栈-Operand-Stack"><a href="#4、操作数栈-Operand-Stack" class="headerlink" title="4、操作数栈(Operand Stack)"></a>4、操作数栈(Operand Stack)</h4><ul>
<li><p>每一个独立的栈帧中除了包含局部变量表以外，还包含一个<strong>后进先出(Last- In-First-Out：LIFO)的操作数栈</strong>，也可以称之为<strong>表达式栈(Expression Stack)</strong> 。</p>
</li>
<li><p><strong>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈(push) /出栈(pop)。</strong></p>
<ul>
<li><p>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。</p>
</li>
<li><p>比如：执行复制、交换、求和等操作</p>
<p><img src="/2021/04/19/JVM/image-20210422204325546.png" alt="image-20210422204325546"></p>
</li>
</ul>
</li>
<li><p>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量<code>临时</code>的存储空间</strong>。</p>
</li>
<li><p>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，<strong>这个方法的操作数栈是空的</strong>。</p>
</li>
<li><p><strong>每一个操作数栈都会拥有一个明确的栈深度用于存储数值</strong>，其<strong>所需的最大深度在编译期就定义好了</strong>，在方法<strong>运行期间是不会改变</strong>操作数栈的大小的。保存在方法的<code>Code</code>属性中，为<code>max_ stack</code>的值。</p>
</li>
<li><p>栈中的任何一个元素都是可以任意的Java数据类型。</p>
<ul>
<li><strong>32bit</strong>的类型占用<strong>一个</strong>栈单位深度</li>
<li><strong>64bit</strong>的类型占用<strong>两个</strong>栈单位深度</li>
</ul>
</li>
<li><p>操作数栈<strong>并非采用访问索引的方式来进行数据访问</strong>的，而是<strong>只能通过标准的入栈(push)和出栈(pop) 操作</strong>来完成一次数据访问。</p>
</li>
<li><p><strong>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中</strong>，并更新PC寄存器中下一条需要执行的字节码指令。</p>
<p><img src="/2021/04/19/JVM/image-20210422211053093.png" alt="image-20210422211053093"></p>
</li>
<li><p><strong>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配</strong>，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</p>
</li>
<li><p>另外，我们说<strong>Java虚拟机的解释引擎是基于栈的执行引擎</strong>，其中的栈指的就是<strong>操作数栈</strong>。</p>
</li>
</ul>
<h4 id="5、代码跟踪"><a href="#5、代码跟踪" class="headerlink" title="5、代码跟踪"></a>5、代码跟踪</h4><h5 id="1、对操作数栈相关知识点的代码分析"><a href="#1、对操作数栈相关知识点的代码分析" class="headerlink" title="1、对操作数栈相关知识点的代码分析"></a>1、对操作数栈相关知识点的代码分析</h5><p><img src="/2021/04/19/JVM/image-20210422210316458.png" alt="image-20210422210316458"></p>
<p><img src="/2021/04/19/JVM/image-20210422210545629.png" alt="image-20210422210545629"></p>
<p><img src="/2021/04/19/JVM/image-20210422210620080.png" alt="image-20210422210620080"></p>
<p><img src="/2021/04/19/JVM/image-20210422210641231.png" alt="image-20210422210641231"></p>
<p><img src="/2021/04/19/JVM/image-20210422210655579.png" alt="image-20210422210655579"></p>
<h5 id="2、面试问题：i-VS-i"><a href="#2、面试问题：i-VS-i" class="headerlink" title="2、面试问题：i++ VS ++i"></a>2、面试问题：i++ VS ++i</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//第1类问题：</span></span><br><span class="line">        <span class="keyword">int</span> i1 = <span class="number">10</span>;</span><br><span class="line">        i1++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i2 = <span class="number">10</span>;</span><br><span class="line">        ++i2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第2类问题：</span></span><br><span class="line">        <span class="keyword">int</span> i3 = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> i4 = i3++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i5 = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> i6 = ++i5;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第3类问题：</span></span><br><span class="line">        <span class="keyword">int</span> i7 = <span class="number">10</span>;</span><br><span class="line">        i7 = i7++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i8 = <span class="number">10</span>;</span><br><span class="line">        i8 = ++i8;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//第4类问题：</span></span><br><span class="line">        <span class="keyword">int</span> i9 = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> i10 = i9++ + ++i9;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>第一类问题：两种没什么区别，都是实现变量的加1操作</p>
<h4 id="6、栈顶缓存技术"><a href="#6、栈顶缓存技术" class="headerlink" title="6、栈顶缓存技术"></a>6、栈顶缓存技术</h4><p>前面提过，基于栈式架构的虛拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派( instruction dispatch) 次数和内存读/写次数。</p>
<p>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了<strong>栈顶缓存(ToS，Top-of-stack Cashing) 技术</strong>，<strong>将栈顶元素全部缓存在<code>物理CPU的寄存器</code>中，以此降低对内存的读/写次数，提升执行引擎的执行效率</strong>。</p>
<h4 id="7、动态链接-Dynamic-Linking-（指向运行时常量池的方法引用）（帧数据区之一）"><a href="#7、动态链接-Dynamic-Linking-（指向运行时常量池的方法引用）（帧数据区之一）" class="headerlink" title="7、动态链接(Dynamic Linking)（指向运行时常量池的方法引用）（帧数据区之一）"></a>7、动态链接(Dynamic Linking)（指向运行时常量池的方法引用）（帧数据区之一）</h4><ul>
<li><p>每一个栈帧内部都包含一个指向**<code>运行时常量池</code><strong>中</strong>该栈帧所属方法的引用<strong>。包含这个引用的目的就是为了</strong>支持当前方法的代码能够实现动态链接(Dynamic Linking)** 。比如: invokedynamic指令</p>
</li>
<li><p>在Java源文件被编译到字节码文件中时，<strong>所有的变量和方法引用都作为符号引用</strong>(Symbolic Reference) <strong>保存在class文件的常量池里</strong>。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了<strong>将这些符号引用转换为调用方法的直接引用</strong>。（多态也是通过动态链接实现的）</p>
</li>
<li><p>类被加载之后，Class文件中的常量池会被复制一份到方法区，成为“运行时常量池”</p>
<p><img src="/2021/04/19/JVM/image-20210422213416813.png" alt="image-20210422213416813"></p>
</li>
<li><p>为什么需要常量池呢?      常量池的作用，就是为了提供一些符号和常量，便于指令的识别。</p>
</li>
</ul>
<h4 id="8、方法的调用：解析与分派"><a href="#8、方法的调用：解析与分派" class="headerlink" title="8、方法的调用：解析与分派"></a>8、方法的调用：解析与分派</h4><h5 id="1、静态链接与动态链接"><a href="#1、静态链接与动态链接" class="headerlink" title="1、静态链接与动态链接"></a>1、静态链接与动态链接</h5><p>在JVM中，将符号引用转换为调用方法的直接引用与<strong>方法的绑定机制</strong>相关。</p>
<ul>
<li><p>静态链接：<br>当一个字节码文件被装载进JVM内部时，如果被调用的<strong>目标方法在编译期可知</strong>，且<strong>运行期保持不变</strong>时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。</p>
</li>
<li><p>动态链接：</p>
<p>如果<strong>被调用的方法在编译期无法被确定下来</strong>，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。</p>
</li>
</ul>
<h5 id="2、方法的绑定机制"><a href="#2、方法的绑定机制" class="headerlink" title="2、方法的绑定机制"></a>2、方法的绑定机制</h5><p>对应的方法的绑定机制为：<strong>早期绑定(Early Binding) 和晚期绑定(Late Binding)</strong> 。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用</strong>的过程，这<strong>仅仅发生一次</strong>。</p>
<ul>
<li><p>早期绑定：</p>
<p>早期绑定就是指被调用的<strong>目标方法如果在编译期可知，且运行期保持不变</strong>时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p>
</li>
<li><p>晚期绑定：</p>
<p>如果<strong>被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法</strong>，这种绑定方式也就被称之为晚期绑定。</p>
</li>
</ul>
<h5 id="3、虚方法与非虚方法"><a href="#3、虚方法与非虚方法" class="headerlink" title="3、虚方法与非虚方法"></a>3、虚方法与非虚方法</h5><p>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然<strong>这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式</strong>。</p>
<p>Java中<strong>任何一个普通的方法其实都具备虚函数的特征</strong>，它们相当于C++语言中的虚函数(C++中则需要使用关键字virtual来显式定义)。如果在Java程序中<strong>不希望某个方法拥有虛函数的特征</strong>时，则可以<strong>使用关键字final来标记这个方法</strong>。（通过final修饰不能重写）</p>
<p>子类对象的多态性的使用前提（多态 &lt;–&gt; 虚方法）</p>
<ol>
<li>类的继承关系</li>
<li>方法的重写</li>
</ol>
<p>非虚方法：</p>
<ul>
<li><strong>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的</strong>。这样的方法称为<strong>非虚方法</strong>。</li>
<li><strong>静态方法、私有方法、final方法、实例构造器、父类方法（因为java没有多继承所以调用父类的方法是非虚方法：super.xxx()可以找到调用的是哪个方法）都是非虚方法</strong>。</li>
<li>其他方法称为虚方法。</li>
</ul>
<p><strong>虚拟机中提供了以下几条方法调用指令</strong>：</p>
<ul>
<li>普通调用指令：<ol>
<li><strong>invokestatic：调用静态方法，解析阶段确定唯一方法版本</strong></li>
<li><strong>invokespecial：调用<init>方法、 私有及父类方法，解析阶段确定唯一方法版本</init></strong></li>
<li>invokevirtual：调用所有虛方法</li>
<li>invokeinterface：调用接口方法</li>
</ol>
</li>
<li>动态调用指令:<ol start="5">
<li>invokedynamic: 动态解析出需要调用的方法，然后执行</li>
</ol>
</li>
</ul>
<p><strong>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本</strong>。其中<strong>invokestatic指令和invokespecial指令调用的方法称为非虛方法，其余的(final修饰的除外)称为虚方法</strong>。</p>
<h5 id="4、关于invokedynamic"><a href="#4、关于invokedynamic" class="headerlink" title="4、关于invokedynamic"></a>4、关于invokedynamic</h5><ul>
<li>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是<strong>Java为了实现「动态类型语言」支持而做的一种改进</strong>。</li>
<li>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。<strong>直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式</strong>。</li>
<li>Java7中增加的动态语言类型支持的本质是<strong>对Java虚拟机规范的修改，而不是对Java语言规则的修改</strong>，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是<strong>运行在Java平台的动态语言的编译器</strong>。</li>
<li>动态类型语言和静态类型语言：<ul>
<li>动态类型语言和静态类型语言两者的区别就在于<strong>对类型的检查是在编译期还是在运行期</strong>，满足前者（编译期）就是静态类型语言，反之（运行期）是动态类型语言。</li>
<li>说的再直白一点就是，<strong>静态类型语言是判断变量自身的类型信息</strong>；<strong>动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息</strong>，这是动态语言的一个重要特征。</li>
</ul>
</li>
</ul>
<h5 id="5、方法重写的本质"><a href="#5、方法重写的本质" class="headerlink" title="5、方法重写的本质"></a>5、方法重写的本质</h5><p><strong>Java语言中方法重写的本质</strong>： </p>
<ol>
<li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作<code>C</code>。</li>
<li>如果在类型<code>C</code>中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则<strong>返回这个方法的直接引用</strong>，查找过程结束；如果不通过，则<strong>返回java.lang.illegalAccessError异常</strong>。</li>
<li>否则，<strong>按照继承关系从下往上依次对<code>C</code>的各个父类进行第2步的搜索和验证过程</strong>。</li>
<li>如果始终没有找到合适的方法，则<strong>抛出java.lang.AbstractMethodError异常</strong>。</li>
</ol>
<p><strong>IllegalAccessError介绍</strong>：</p>
<p>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</p>
<h5 id="6、虚方法表"><a href="#6、虚方法表" class="headerlink" title="6、虚方法表"></a>6、虚方法表</h5><ul>
<li><p>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，<strong>为了提高性能</strong>，<strong>JVM采用在类的方法区建立一个虚方法表(virtual method table) (非虚方法不会出现在表中)来实现。使用索引表来代替查找</strong>。</p>
</li>
<li><p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</p>
</li>
<li><p>那么虚方法表什么时候被创建?</p>
<p>虚方法表会在类加载的链接阶段（解析Resolve）被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。</p>
</li>
</ul>
<p>每个类有一个虚方法表，使用某方法时直接在这表里查找该方法在哪个类里了。</p>
<p>没有虚方法表的情况下，需要在当前类查找，找不到再去父类查找。</p>
<p><img src="/2021/04/19/JVM/image-20210422225120851.png" alt="image-20210422225120851"></p>
<p><img src="/2021/04/19/JVM/image-20210422225328056.png" alt="image-20210422225328056"></p>
<p><img src="/2021/04/19/JVM/image-20210422225533000.png" alt="image-20210422225533000"></p>
<p><img src="/2021/04/19/JVM/image-20210422225747189.png" alt="image-20210422225747189"></p>
<h4 id="9、方法返回地址-Return-Address"><a href="#9、方法返回地址-Return-Address" class="headerlink" title="9、方法返回地址(Return Address)"></a>9、方法返回地址(Return Address)</h4><ul>
<li><strong>存放调用该方法的pc寄存器的值</strong>。</li>
<li>一个方法的结束，有两种方式：<ul>
<li><strong>正常执行完成</strong></li>
<li><strong>出现未处理的异常，非正常退出</strong></li>
</ul>
</li>
<li>无论通过哪种方式退出，<strong>在方法退出后都返回到该方法被调用的位置</strong>。方法<strong>正常退出</strong>时，<strong>调用者的pc计数器的值作为返回地址</strong>，即<strong>调用该方法的指令的下一条指令的地址</strong>。而通过<strong>异常退出</strong>的，返回地址是要<strong>通过异常表来确定，栈帧中一般不会保存这部分信息</strong>。</li>
</ul>
<p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p>
<ol>
<li><p>执行引擎遇到任意一个方法返回的字节码指令(return) ，会有返回值传递给上层的方法调用者，简称正常完成出口；</p>
<ul>
<li>一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定。</li>
<li>在字节码指令中，返回指令包含<code>ireturn</code> (当返回值是boolean、 byte、char、short和int类型时使用)、<code>lreturn</code>、 <code>freturn</code>、<code>dreturn</code>以及<code>areturn</code>，另外还有一个<code>return</code>指令供声明为void的方法、实例初始化方法、类和接口的初始化方法使用。</li>
</ul>
</li>
<li><p>在方法执行的过程中遇到了异常(Exception)，并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称<strong>异常完成出口</strong>。</p>
<p><strong>方法执行过程中抛出异常时的异常处理，存储在一个异常处理表</strong>，方便在发生异常的时候找到处理异常的代码。</p>
<p><img src="/2021/04/19/JVM/image-20210423004042185.png" alt="image-20210423004042185"></p>
</li>
</ol>
<p>本质上，<strong>方法的退出就是当前栈帧出栈</strong>的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p>
<p>正常完成出口和异常完成出口的区别在于：<strong>通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</strong></p>
<h4 id="10、一些附加信息"><a href="#10、一些附加信息" class="headerlink" title="10、一些附加信息"></a>10、一些附加信息</h4><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如，对<strong>程序调试提供支持的信息</strong>。</p>
<h4 id="11、栈的相关面试题"><a href="#11、栈的相关面试题" class="headerlink" title="11、栈的相关面试题"></a>11、栈的相关面试题</h4><ul>
<li><p>举例栈溢出的情况? (StackOverflowError)</p>
<ul>
<li>通过-Xss设置栈的大小OOM</li>
</ul>
</li>
<li><p>调整栈大小，就能保证不出现溢出吗?</p>
<ul>
<li>不能</li>
</ul>
</li>
<li><p>分配的栈内存越大越好吗?</p>
<ul>
<li>不是!</li>
</ul>
</li>
<li><p>垃圾回收是否会涉及到虚拟机栈?</p>
<ul>
<li>不会的!</li>
</ul>
</li>
<li><p>方法中定义的局部变量是否线程安全?</p>
<ul>
<li>具体问题具体分析</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 面试题：</span></span><br><span class="line"><span class="comment"> * 方法中定义的局部变量是否线程安全？具体情况具体分析</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   何为线程安全？</span></span><br><span class="line"><span class="comment"> *      如果只有一个线程才可以操作此数据，则必是线程安全的。</span></span><br><span class="line"><span class="comment"> *      如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020 下午 7:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//s1的声明方式是线程安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//StringBuilder:线程不安全</span></span><br><span class="line">        StringBuilder s1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//sBuilder的操作过程：是线程不安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(StringBuilder sBuilder)</span></span>&#123;</span><br><span class="line">        sBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        sBuilder.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s1的操作：是线程不安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuilder s1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s1的操作：是线程安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">method4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuilder s1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s1.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            s.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">            s.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        method2(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="12、关于运行时数据区的五大部分的OOM与GC问题"><a href="#12、关于运行时数据区的五大部分的OOM与GC问题" class="headerlink" title="12、关于运行时数据区的五大部分的OOM与GC问题"></a>12、关于运行时数据区的五大部分的OOM与GC问题</h4><table>
<thead>
<tr>
<th>运行时数据区</th>
<th>GC</th>
<th>OOM</th>
</tr>
</thead>
<tbody><tr>
<td>程序计数器（PC寄存器）</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>虚拟机栈</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>本地方法栈</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>堆</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>方法区</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<hr>
<h3 id="6、本地方法接口"><a href="#6、本地方法接口" class="headerlink" title="6、本地方法接口"></a>6、本地方法接口</h3><p><img src="/2021/04/19/JVM/image-20210423090739894.png" alt="image-20210423090739894"></p>
<h4 id="1、什么是本地方法"><a href="#1、什么是本地方法" class="headerlink" title="1、什么是本地方法?"></a>1、什么是本地方法?</h4><p>简单地讲，<strong>一个Native Method就是一个Java调用非Java代码的接口</strong>。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern “C”告知C++编译器去调用一个C的函数。</p>
<p>“A native method is a Java method whose implementation is provided by non-java code.”</p>
<p>在定义一个native method时， 并不提供实现体(有些像定义一个Java interface)，因为其实现体是由非java语言在外面实现的。</p>
<p>本地接口的作用是<strong>融合不同的编程语言为Java所用，它的初衷是融合C/C++程序</strong>。</p>
<p><strong>标识符native可以与所以其它的java标识符连用，但是<code>abstract</code>除外</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IHaveNatives</span> </span>&#123;</span><br><span class="line">    <span class="comment">// native 与 public、void</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">Native1</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">	<span class="comment">// native 与 static</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">Native2</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// native 与 private、synchronized</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">synchronized</span> <span class="keyword">float</span> <span class="title">Native3</span><span class="params">(Object o)</span></span>;</span><br><span class="line">	<span class="comment">// native 与 默认</span></span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">void</span> <span class="title">Native4</span><span class="params">(<span class="keyword">int</span>[] ary)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2、为什么要使用Native-Method"><a href="#2、为什么要使用Native-Method" class="headerlink" title="2、为什么要使用Native Method?"></a>2、为什么要使用Native Method?</h4><p>Java使用起来非常方便，然而有些层次的任务用<strong>Java实现起来不容易</strong>，或者我们<strong>对程序的效率很在意</strong>时，问题就来了。</p>
<ul>
<li>与Java环境外交互：<br>有时<strong>Java应用需要与Java外面的环境交互</strong>，这是本地方法存在的主要原因。你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</li>
<li>与操作系统交互：<br>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器(解释字节码)和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。通过<strong>使用本地方法我们得以用Java实现了jre的与底层系统的交互</strong>，<strong>甚至JVM的一些部分就是用c写的</strong>。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</li>
<li>Sun’s Java<br><strong>Sun的解释器是用C实现的</strong>，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如:类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用C实现的，并被植入JVM内部，在windows 95的平台上，这个本地方法最终将调用win32 SetPriority() API。 这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库(external dynamic link library)提供，然后被JVM调用。</li>
</ul>
<h4 id="3、现状"><a href="#3、现状" class="headerlink" title="3、现状"></a>3、现状</h4><p><strong>目前该方法使用的越来越少了，除非是与硬件有关的应用</strong>，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。</p>
<hr>
<h3 id="7、本地方法栈-Native-Method-Stack"><a href="#7、本地方法栈-Native-Method-Stack" class="headerlink" title="7、本地方法栈(Native Method Stack)"></a>7、本地方法栈(Native Method Stack)</h3><ul>
<li><p><strong>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用</strong>。</p>
</li>
<li><p>本地方法栈，也是<strong>线程私有</strong>的。</p>
</li>
<li><p>允许被实现成<strong>固定或者是可动态扩展的内存大小</strong>。(在内存溢出方面是相同的)</p>
<ul>
<li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个StackoverflowError异常。</li>
<li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虛拟机将会抛出一个OutOfMemoryError异常。</li>
</ul>
</li>
<li><p>本地方法是使用C语言实现的。</p>
</li>
<li><p>它的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载本地方法库。</p>
<p><img src="/2021/04/19/JVM/image-20210423094103986.png" alt="image-20210423094103986"></p>
</li>
<li><p>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。<strong>它和虚拟机拥有同样的权限</strong>。</p>
<ul>
<li>本地方法可以通过<code>本地方法接口</code>来<strong>访问虛拟机内部的运行时数据区</strong>。</li>
<li>它甚至可以<strong>直接使用本地处理器中的寄存器</strong></li>
<li><strong>直接从本地内存的堆中分配任意数量的内存</strong>。</li>
</ul>
</li>
<li><p>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。(这里存在本地方法栈只是对于HotSpot JVM而言)</p>
</li>
<li><p>在HotSpot JVM中，直接将<strong>本地方法栈和虚拟机栈合二为一</strong>。</p>
</li>
</ul>
<hr>
<h3 id="8、堆（Heap）"><a href="#8、堆（Heap）" class="headerlink" title="8、堆（Heap）"></a>8、堆（Heap）</h3><h4 id="1、堆的核心概述"><a href="#1、堆的核心概述" class="headerlink" title="1、堆的核心概述"></a>1、堆的核心概述</h4><ul>
<li><p><strong>一个JVM实例只存在一个堆内存，堆也是Java<code>内存管理</code>的核心区域</strong>。</p>
</li>
<li><p>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是<strong>JVM管理的最大一块内存空间</strong>。</p>
<ul>
<li>堆内存的大小是可以调节的。</li>
</ul>
</li>
<li><p>《Java虚拟机规范》规定，堆可以处于<strong>物理上不连续的内存空间</strong>中，但<strong>在逻辑上</strong>它应该被视为<strong>连续</strong>的。</p>
<p>这里涉及到对象实例在堆内存中的存储方式，<strong>物理内存连续的采用指针碰撞</strong>，<strong>不连续的采用动态链表</strong></p>
</li>
<li><p>所有的线程共享Java堆，在这里还可以划分<strong>线程私有的缓冲区</strong>(Thread Local Al location Buffer, <strong>TLAB</strong>) 。</p>
</li>
<li><p>《Java虛拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。</p>
<ul>
<li>The heap is the run-time data area from which memory for all class instances and arrays is allocated.</li>
<li>我要说的是：“<strong>几乎</strong>”所有的对象实例都在这里分配内存。——从实际使用角度看的。</li>
</ul>
</li>
<li><p>数组和对象可能永远不会存储在栈上，因为<strong>栈帧中保存引用</strong>，<strong>这个引用指向对象或者数组在堆中的位置</strong>。</p>
</li>
<li><p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</p>
</li>
<li><p><strong>堆，是GC ( Garbage Collection, 垃圾收集器)执行垃圾回收的重点区域</strong>。</p>
<p><img src="/2021/04/19/JVM/image-20210423155400525.png" alt="image-20210423155400525"></p>
</li>
<li><p>内存细分：</p>
<p>现代垃圾收集器大部分都基于分代收集理论设计,堆空间细分为：</p>
<ul>
<li><strong>Java 7</strong>及之前堆内存逻辑上分为三部分：新生区 + 养老区 + <strong>永久区</strong><ul>
<li>Young Generation Space    新生区    Young/New<ul>
<li>又被划分 为Eden区和Survivor区</li>
</ul>
</li>
<li>Tenure generation space    养老区    Old/Tenure</li>
<li>Permanent Space    永久区    Perm</li>
</ul>
</li>
<li><strong>Java 8</strong>及之后堆内存逻辑上分为三部分：新生区 + 养老区 + <strong>元空间</strong><ul>
<li>Young Generation Space    新生区    Young/New<ul>
<li>又被划分为Eden区和Survivor区</li>
</ul>
</li>
<li>Tenure generation space    养老区    Old/ Tenure</li>
<li>Meta Space     元空间    Meta</li>
</ul>
</li>
</ul>
<p>约定：</p>
<ul>
<li>新生区 &lt;=&gt; 新生代 &lt;=&gt; 年轻代</li>
<li>养老区 &lt;=&gt; 老年区 &lt;=&gt; 老年代</li>
<li>永久区 &lt;=&gt; 永久代</li>
</ul>
<p><img src="/2021/04/19/JVM/%E7%AC%AC08%E7%AB%A0_%E5%A0%86%E5%92%8C%E6%96%B9%E6%B3%95%E5%8C%BA%E5%9B%BE.jpg" alt="第08章_堆和方法区图"></p>
<p>堆空间的内部结构：</p>
<p><img src="/2021/04/19/JVM/image-20210423160441505.png" alt="image-20210423160441505"></p>
</li>
</ul>
<h4 id="2、设置堆内存大小与OOM"><a href="#2、设置堆内存大小与OOM" class="headerlink" title="2、设置堆内存大小与OOM"></a>2、设置堆内存大小与OOM</h4><ul>
<li>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”<code>-Xmx</code>“和”``-Xms`”来进行设置。<ul>
<li><strong>“<code>-Xms</code>“用于表示堆区（年轻代+老年代）的<code>起始内存</code>，等价于-XX: InitialHeapSize</strong><ul>
<li>-X是JVM的运行参数</li>
<li>ms是memory start</li>
</ul>
</li>
<li><strong>“<code>-Xmx</code>”则用于表示堆区（年轻代+老年代）的<code>最大内存</code>，等价于-XX :MaxHeapSize</strong></li>
</ul>
</li>
<li>查看设置的参数：<ol>
<li>jps /  jstat -gc 进程id</li>
<li>-XX:+PrintGCDetails</li>
</ol>
</li>
<li>一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出OutOfMemoryError异常。</li>
<li>开发中建议将初始堆内存和最大的堆内存设置成相同的值。即将-Xms和-Xmx两个参数配置相同的值，其目的是<strong>为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能，避免系统压力</strong>。</li>
<li>默认情况下，初始内存大小：物理电脑内存大小 / 64；最大内存大小：物理电脑内存大小 / 4</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 设置堆空间大小的参数</span></span><br><span class="line"><span class="comment"> * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小</span></span><br><span class="line"><span class="comment"> *      -X 是jvm的运行参数</span></span><br><span class="line"><span class="comment"> *      ms 是memory start</span></span><br><span class="line"><span class="comment"> * -Xmx 用来设置堆空间（年轻代+老年代）的最大内存大小</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. 默认堆空间的大小</span></span><br><span class="line"><span class="comment"> *    初始内存大小：物理电脑内存大小 / 64</span></span><br><span class="line"><span class="comment"> *             最大内存大小：物理电脑内存大小 / 4</span></span><br><span class="line"><span class="comment"> * 3. 手动设置：-Xms600m -Xmx600m</span></span><br><span class="line"><span class="comment"> *     开发中建议将初始堆内存和最大的堆内存设置成相同的值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 4. 查看设置的参数：方式一： jps   /  jstat -gc 进程id</span></span><br><span class="line"><span class="comment"> *                  方式二：-XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSpaceInitial</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//返回Java虚拟机中的堆内存总量</span></span><br><span class="line">        <span class="keyword">long</span> initialMemory = Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">        <span class="comment">//返回Java虚拟机试图使用的最大堆内存量</span></span><br><span class="line">        <span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">        <span class="comment">// 手动设置600M之后：575M</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-Xms : &quot;</span> + initialMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-Xmx : &quot;</span> + maxMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(&quot;系统内存大小为：&quot; + initialMemory * 64.0 / 1024 + &quot;G&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;系统内存大小为：&quot; + maxMemory * 4.0 / 1024 + &quot;G&quot;);</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/19/JVM/image-20210423165450302.png" alt="image-20210423165450302"></p>
<p>结论：<strong>新生代的存储总量为一个伊甸园区加一个幸存者区</strong>(1或2，不能并存)，所以虽然设置了600M，但是实际上为575M。</p>
<p><strong>关于异常（Exception）与错误（Error）</strong>：</p>
<p>Java 语言规范将派生于 Error 类或 RuntimeException 类的所有异常称为非检查型（unchecked）异常，所有其他的异常称为检查型（checked）异常</p>
<h4 id="3、年轻代与老年代"><a href="#3、年轻代与老年代" class="headerlink" title="3、年轻代与老年代"></a>3、年轻代与老年代</h4><ul>
<li><p>存储在JVM中的Java对象可以被划分为两类：</p>
<ul>
<li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速</li>
<li>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致。</li>
</ul>
</li>
<li><p>Java堆区进一步细分的话，可以划分为<strong>年轻代</strong>(YoungGen)和<strong>老年代</strong>(OldGen)</p>
</li>
<li><p>其中年轻代又可以划分为<strong>Eden空间</strong>、 <strong>Survivor0空间</strong>和<strong>Survivor1空间</strong>(有时也叫做<strong>from区</strong>、<strong>to区</strong>)</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC08%E7%AB%A0_%E5%A0%86%E7%A9%BA%E9%97%B4%E7%BB%86%E8%8A%82.jpg" alt="第08章_堆空间细节"></p>
</li>
<li><p>相关的参数设置与默认值（在开发中一般不会改变）</p>
<ul>
<li>-XX:NewRatio：配置新生代与老年代在堆结构的占比。<ul>
<li>默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3</li>
<li>可以修改- XX: NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5</li>
</ul>
</li>
<li>-XX:SurvivorRatio：设置新生代中Eden区与Survivor区的比例。默认值是8<ul>
<li>在HotSpot中， Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1。</li>
<li>当然开发人员可以通过选项“-XX:SurvivorRatio””调整这个空间比例。比如-XX: SurvivorRatio=8</li>
<li>但在实际测试当中发现其实JVM分配Eden空间和两个Survivor空间的时候比例为6:1:1，即默认值为6而不是8，但是java官方表示的默认值就是8。如果要将比例修改为8:1:1，需要设置：<ul>
<li>-XX:-UseAdaptiveSizePolicy ：关闭自适应的内存分配策略  （暂时用不到）（但发现没用，还是6:1:1）</li>
<li>-XX: SurvivorRatio=8，手动设置SurvivorRatio为8。（这还算什么默认值。。。）</li>
</ul>
</li>
</ul>
</li>
<li>-Xmn：设置新生代的空间的大小。（一般不设置）<ul>
<li>但一般新生代与老年代的空间分配是-XX:NewRatio设置的，默认为2。</li>
<li>当设置了-Xmn的时候，就与-XX:NewRatio冲突了</li>
<li>这时候JVM使用的是-Xmn设置的值（JDK8下测试）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>几乎所有</code>的Java对象都是在Eden区被new出来的</strong>。</p>
</li>
<li><p>绝大部分的Java对象的销毁都在新生代进行了。</p>
<ul>
<li>IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。</li>
</ul>
</li>
<li><p>可以使用选项”-Xmn”设置新生代最大内存大小。</p>
<ul>
<li>这个参数一般使用默认值就可以了。</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210423173418189.png" alt="image-20210423173418189"></p>
</li>
</ul>
<h4 id="4、图解大小分配过程"><a href="#4、图解大小分配过程" class="headerlink" title="4、图解大小分配过程"></a>4、图解大小分配过程</h4><p>为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中停生内存碎片。</p>
<ol>
<li><p>new的对象先放伊甸园区。此区有大小限制。</p>
</li>
<li><p>当<strong>伊甸园的空间填满</strong>时，程序又需要创建对象，JVM的垃圾回收器**(Minor GC)将对伊甸园区进行垃圾回收**，将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区。</p>
</li>
<li><p>然后将伊甸园中的剩余对象移动到幸存者0区（to区）。</p>
</li>
<li><p>如果再次触发垃圾回收，此时JVM的垃圾回收器(Minor GC)对伊甸园区进行垃圾回收（<strong>主动：伊甸园区满即触发</strong>），会放到幸存者1区（to区）。以及同时上次幸存下来的放到幸存者0区（from区）的，如果没有回收，也会放到幸存者1区（to区）。（被动：就算幸存者1区（to区）满了也不触发Minor GC垃圾回收器）</p>
</li>
<li><p>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</p>
</li>
<li><p>啥时候能去养老区呢?可以设置次数。<strong>默认是<code>15</code>次</strong>。</p>
<p>可以设置参数: -XX:MaxTenuringThreshold=<N>进行设置。</N></p>
</li>
<li><p>在养老区，相对悠闲。当养老区内存不足时，再次触发GC: Major GC， 进行养老区的内存清理。</p>
</li>
<li><p>若养老区执行了Major GC之后发现依然无法进行对象的保存，就会产生OOM异常：<br> java. lang.OutOfMemoryError：Java heap space</p>
<p><img src="/2021/04/19/JVM/image-20210423181733858.png" alt="image-20210423181733858"></p>
</li>
</ol>
<p>总结：</p>
<ul>
<li>针对幸存者s0,s1区的总结：复制之后有交换，谁空谁是to。</li>
<li>关于垃圾回收:频繁在新生区收集，<strong>很少在养老区收集</strong>，<strong>几乎不在永久区/元空间收集</strong>。</li>
</ul>
<p>对象分配流程图（含特殊情况）：</p>
<p><img src="/2021/04/19/JVM/image-20210423191247043.png" alt="image-20210423191247043"></p>
<p>VisualVM状态图分析：</p>
<p><img src="/2021/04/19/JVM/image-20210423192127797.png" alt="image-20210423192127797"></p>
<p>常用的调优工具：</p>
<ul>
<li>JDK命令行</li>
<li>Eclipse : Memory Analyzer Tool</li>
<li>Jconsole</li>
<li>VisualVM</li>
<li>Jprofiler</li>
<li>Java Flight Recorder</li>
<li>GCViewer</li>
<li>GC Easy</li>
</ul>
<h4 id="5、minor-GC、Major-GC、Full-GC"><a href="#5、minor-GC、Major-GC、Full-GC" class="headerlink" title="5、minor GC、Major GC、Full GC"></a>5、minor GC、Major GC、Full GC</h4><h5 id="1、GC的分类"><a href="#1、GC的分类" class="headerlink" title="1、GC的分类"></a>1、GC的分类</h5><ul>
<li>JVM在进行GC时，并非每次都对上面三个内存(新生代、老年代、方法区)区域一起回收的，大部分时候回收的都是指新生代。</li>
<li>针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集(Partial GC)，一种是整堆收集(Full GC)<ul>
<li>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：<ul>
<li>新生代收集(Minor GC / Young GC)：只是新生代（Eden/S0、S1）的垃圾收集</li>
<li>老年代收集(MajorGC/Old GC)：只是老年代的垃圾收集。<ul>
<li>目前，只有CMS GC会有单独收集老年代的行为。</li>
<li><strong>注意，很多时候Major GC会和Fu1l GC混淆使用，需要具体分辨是老年代回收还是整堆回收</strong>。</li>
</ul>
</li>
<li>混合收集(Mixed GC)：收集整个新生代以及部分老年代的垃圾收集。<ul>
<li>目前，只有G1 GC会有这种行为</li>
</ul>
</li>
</ul>
</li>
<li>整堆收集(Full GC)：收集整个java堆和方法区的垃圾收集。</li>
</ul>
</li>
</ul>
<h5 id="2、最简单的分代式GC策略的触发条件"><a href="#2、最简单的分代式GC策略的触发条件" class="headerlink" title="2、最简单的分代式GC策略的触发条件"></a>2、最简单的分代式GC策略的触发条件</h5><ul>
<li><p>年轻代GC(Minor GC)触发机制：</p>
<ul>
<li>当年轻代空间不足时， 就会触发Minor GC， 这里的年轻代满指的是Eden代满，Survivor满不会引发GC。( 每次Minor GC会清理年轻代的内存。)</li>
<li>因为Java对象大多都具备朝生夕灭的特性，所以MinorGC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</li>
<li>Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210423195836487.png" alt="image-20210423195836487"></p>
</li>
<li><p>老年代GC (Major GC/Full GC)触发机制:</p>
<ul>
<li>指发生在老年代的GC，对象从老年代消失时，我们说“Major GC”或“Full GC”发生了。</li>
<li>出现了Major GC，经常会伴随至少一次的Minor GC (但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程)。<ul>
<li>也就是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC</li>
</ul>
</li>
<li>MajorGC的速度一般会比MinorGC慢10倍以上，STW的时间更长。</li>
<li>如果Major GC后，内存还不足，就报OOM了。</li>
<li>Major GC的速度一般会比Minor GC慢10倍以上。</li>
</ul>
</li>
<li><p>Full GC触发机制：(后面细讲)</p>
<ul>
<li>触发Full GC执行的情况有如下五种：<ol>
<li>调用System.gc()时，系统建议执行Full GC，但是不必然执行</li>
<li>老年代空间不足</li>
<li>方法区空间不足</li>
<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li>
<li>由Eden区、survivor space0 (From Space)区向survivor space1 (To Space)区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li>
</ol>
</li>
<li>说明: <strong>full gc是开发或调优中尽量要避免的。这样暂时时间会短一些</strong>。</li>
</ul>
</li>
</ul>
<h4 id="6、堆空间分代思想"><a href="#6、堆空间分代思想" class="headerlink" title="6、堆空间分代思想"></a>6、堆空间分代思想</h4><p>为什么需要把java堆分代?不分代就不能正常工作了吗?</p>
<p>经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p>
<ul>
<li>新生代：有Eden、两块大小相同的Survivor (又称为from/to， s0/s1)构成，to总为空。</li>
<li>老年代：存放新生代中经历多次GC仍然存活的对象。</li>
</ul>
<p>其实不分代完全可以，分代的唯一理由就是<strong>优化GC性能</strong>。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。</p>
<p>而很多对象都是<strong>朝生夕死</strong>的，如果分代的话，把新创建的对象放到某一地方， 当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p>
<h4 id="7、内存分配策略-或对象提升-Promotion-规则"><a href="#7、内存分配策略-或对象提升-Promotion-规则" class="headerlink" title="7、内存分配策略(或对象提升(Promotion)规则)"></a>7、内存分配策略(或对象提升(Promotion)规则)</h4><p>如果对象在Eden出生并经过第一次MinorGC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对 象年龄设为1。对象在Survivor区中每熬过一次MinorGC ，年龄就增加1 岁，当它的年龄增加到一定程度(默认为15岁，其实每个JVM、 每个GC都有所不同)时，就会被晋升到老年代中。</p>
<p>对象晋升老年代的年龄阈值，可以通过选项<code>-XX: MaxTenuringThreshold</code>来设置。</p>
<p>针对不同年龄段的对象分配原则如下所示：</p>
<ul>
<li>优先分配到Eden</li>
<li><strong>大对象直接分配到老年代</strong><ul>
<li>尽量避免程序中出现过多的大对象（特别是朝生夕死的大对象），防止过多的STW</li>
</ul>
</li>
<li><strong>长期存活(15岁)的对象分配到老年代</strong></li>
<li>动态对象年龄判断<ul>
<li>如果Survivor 区中<strong>相同年龄的所有对象大小的总和大于Survivor空间的一半</strong>，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</li>
</ul>
</li>
<li>空间分配担保<ul>
<li><code>-XX: HandlePromotionFailure</code> </li>
</ul>
</li>
</ul>
<h4 id="8、为对象分配内存：TLAB"><a href="#8、为对象分配内存：TLAB" class="headerlink" title="8、为对象分配内存：TLAB"></a>8、为对象分配内存：TLAB</h4><h5 id="1、为什么有TLAB-Thread-Local-Allocation-Buffer"><a href="#1、为什么有TLAB-Thread-Local-Allocation-Buffer" class="headerlink" title="1、为什么有TLAB ( Thread Local Allocation Buffer ) ?"></a>1、为什么有TLAB ( Thread Local Allocation Buffer ) ?</h5><ul>
<li>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</li>
<li>由于对象实例的创建在JVM中非常频繁，因此<strong>在并发环境下从堆区中划分内存空间是线程不安全</strong>的</li>
<li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</li>
</ul>
<h5 id="2、什么是TLAB？"><a href="#2、什么是TLAB？" class="headerlink" title="2、什么是TLAB？"></a>2、什么是TLAB？</h5><ul>
<li>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM<strong>为每个线程分配了一个私有缓存区域</strong>，它<strong>包含在Eden空间</strong>内。</li>
<li>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为<strong>快速分配策略</strong>。</li>
<li>据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</li>
</ul>
<p><img src="/2021/04/19/JVM/%E7%AC%AC08%E7%AB%A0_TLAB.jpg" alt="第08章_TLAB"></p>
<h5 id="3、TLAB相关说明"><a href="#3、TLAB相关说明" class="headerlink" title="3、TLAB相关说明"></a>3、TLAB相关说明</h5><ul>
<li>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但<strong>JVM确实是将TLAB作为内存分配的首选</strong>。</li>
<li>在程序中，开发人员可以通过选项“<code>-XX:UseTLAB</code>”设置是否开启TLAB空间。<strong>默认为开启</strong>。</li>
<li>默认情况下，TLAB空间的内存非常小，**仅占有整个Eden空间的1%**，当然我们可以通过选项“<code>-XX:TLABWasteTargetPercent</code>”设置TLAB空间所占用Eden空间的百分比大小。</li>
<li>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用<strong>加锁机制</strong>确保数据操作的原子性，从而<strong>直接在Eden空间中分配内存</strong>。</li>
</ul>
<p><img src="/2021/04/19/JVM/%E7%AC%AC08%E7%AB%A0_%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B.jpg" alt="第08章_对象分配过程"></p>
<h4 id="9、小结堆空间的常用的JVM参数设置"><a href="#9、小结堆空间的常用的JVM参数设置" class="headerlink" title="9、小结堆空间的常用的JVM参数设置"></a>9、小结堆空间的常用的JVM参数设置</h4><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">官网说明</a>：</p>
<ul>
<li>-XX: +PrintFlagsInitial：查看所有的参数的默认初始值</li>
<li>-XX: +PrintFlagsFinal：查看所有的参数的最终值(可能会存在修改，不再是初始值)</li>
<li>-Xms：初始堆空间内存 (默认为物理内存的1/64)</li>
<li>-Xmx：最大堆空间内存(默认为物理内存的1/4)</li>
<li>-Xmn：设置新生代的大小。(初始值及最大值)</li>
<li>-XX:NewRatio: 配置新生代与老年代在堆结构的占比</li>
<li>-XX: SurvivorRatio：设置新生代中Eden和S0/S1空间的比例</li>
<li>-XX: MaxTenuringThreshold：设置新生代垃圾的最大年龄</li>
<li>-XX: +PrintGCDetails：输出详细的GC处理日志<ul>
<li>打印gc简要信息：</li>
<li>-XX: +PrintGC</li>
<li>-verbose: gc </li>
</ul>
</li>
<li>XX: HandlePromotionFailure：是否设置空间分配担保</li>
</ul>
<p>在发生MinorGC之前，虚拟机会<strong>检查老年代最大可用的连续空间是否大于新生代所有对象的总空间</strong>。</p>
<ul>
<li>如果大于，则此次Minor GC是安全的</li>
<li>如果小于，则虚拟机会查看-XX: HandlePromotionFailure设置值是否允许担保失败。<ul>
<li>如果HandlePromotionFailure=true，那么会<strong>继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小</strong>。<ul>
<li>如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；</li>
<li>如果小于，则改为进行一次Full GC。</li>
</ul>
</li>
<li>如果HandlePromotionFailure=false，则改为进行一次Full GC。</li>
</ul>
</li>
</ul>
<p>在JDK6 Update24（JDK7）之后，HandlePromotionFailure参数不会再影响到虛拟机的空间分配担保策略，观察0penJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update24之后的规则变为<strong>只要老年代的连续空间大于新生代对象总大小</strong>或者<strong>历次晋升的平均大小就会进行Minor GC</strong>， 否则将进行Full GC。</p>
<h4 id="10、堆是分配对象的唯一选择吗？"><a href="#10、堆是分配对象的唯一选择吗？" class="headerlink" title="10、堆是分配对象的唯一选择吗？"></a>10、堆是分配对象的唯一选择吗？</h4><h5 id="1、堆是分配对象的唯一选择吗？"><a href="#1、堆是分配对象的唯一选择吗？" class="headerlink" title="1、堆是分配对象的唯一选择吗？"></a>1、堆是分配对象的唯一选择吗？</h5><p>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</p>
<p>随着<strong>JIT编译期的发展</strong>与<strong>逃逸分析技术</strong>逐渐成熟，<strong>栈上分配</strong>、<strong>标量替换优化技术</strong>将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p>
<p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是<strong>如果经过逃逸分析(Escape Analysis) 后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配</strong>。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的<strong>堆外存储技术</strong>。</p>
<p>此外，前面提到的基于openJDK深度定制的TaoBaoVM，其中创新的GCIH (GC invisible heap)技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p>
<h5 id="2、逃逸分析概述"><a href="#2、逃逸分析概述" class="headerlink" title="2、逃逸分析概述"></a>2、逃逸分析概述</h5><h6 id="1、什么是逃逸分析？"><a href="#1、什么是逃逸分析？" class="headerlink" title="1、什么是逃逸分析？"></a>1、什么是逃逸分析？</h6><ul>
<li><p>如何将堆上的对象分配到栈，需要使用<strong>逃逸分析手段</strong>。</p>
</li>
<li><p>这是一种可以有效减少Java程序中<strong>同步负载</strong>和<strong>内存堆分配压力</strong>的<strong>跨函数全局数据流分析算法</strong>。</p>
</li>
<li><p>通过逃逸分析，Java HotSpot编译器能够分析出<strong>一个新的对象的引用的使用范围</strong>从而决定是否要将这个对象分配到堆上。</p>
</li>
<li><p>逃逸分析的基本行为就是分析对象动态作用域：</p>
<ul>
<li><p>当<strong>一个对象在方法中被定义</strong>后，<strong>对象只在方法内部使用</strong>，则认为<strong>没有发生逃逸</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">my_method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    V v = <span class="keyword">new</span> V();</span><br><span class="line">    <span class="comment">//use v</span></span><br><span class="line">    v = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除。</p>
</blockquote>
</li>
<li><p>当<strong>一个对象在方法中被定义</strong>后，它<strong>被外部方法所引用</strong>，则认为<strong>发生逃逸</strong>。例如作为<strong>调用参数</strong>传递到其他地方中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title">createStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer() ;</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append (s2);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>发生了逃逸的对象StringBuffer，作为返回值被返回回去了，在方法外可以被调用</p>
</blockquote>
<p>改进代码，让StringBuffer sb逃不出去：（转换为String类型）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1) ;</span><br><span class="line">    sb.append(s2) ;</span><br><span class="line">    <span class="keyword">return</span> sb.toString() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h6 id="2、逃逸分析的几种情况："><a href="#2、逃逸分析的几种情况：" class="headerlink" title="2、逃逸分析的几种情况："></a>2、逃逸分析的几种情况：</h6><p>如何快速的判断是否发生了逃逸分析，大家就看**<code>new的对象实体</code>是否有可能在方法外被调用**。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逃逸分析</span></span><br><span class="line"><span class="comment"> *  如何快速的判断是否发生了逃逸分析，大家就看new的对象实体是否有可能在方法外被调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EscapeAnalysis</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> EscapeAnalysis obj;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    方法返回EscapeAnalysis对象，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EscapeAnalysis <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj == <span class="keyword">null</span>? <span class="keyword">new</span> EscapeAnalysis() : obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    为成员属性赋值，发生逃逸</span></span><br><span class="line"><span class="comment">    //思考：如果当前的obj引用声明为static的？</span></span><br><span class="line"><span class="comment">    		仍然会发生逃逸。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = <span class="keyword">new</span> EscapeAnalysis();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对象的作用域仅在当前方法中有效，没有发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useEscapeAnalysis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EscapeAnalysis e = <span class="keyword">new</span> EscapeAnalysis();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    引用成员变量的值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useEscapeAnalysis1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//getInstance().xxx()同样会发生逃逸</span></span><br><span class="line">        EscapeAnalysis e = getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3、逃逸分析相关的参数设置："><a href="#3、逃逸分析相关的参数设置：" class="headerlink" title="3、逃逸分析相关的参数设置："></a>3、逃逸分析相关的参数设置：</h6><ul>
<li>在JDK 6u23（JDK7）版本之后，<strong>HotSpot中默认就已经开启了逃逸分析</strong>。</li>
<li>如果使用的是较早的版本，开发人员则可以通过：<ul>
<li>选项“<code>-XX: +DoEscapeAnalysis</code>“显式开启逃逸分析</li>
<li>通过选项“<code>-XX: +PrintEscapeAnalysis</code>“查看逃逸分析的筛选结果。</li>
</ul>
</li>
</ul>
<h6 id="4、结论"><a href="#4、结论" class="headerlink" title="4、结论:"></a>4、结论:</h6><p><strong>开发中能使用局部变量的，就不要使用在方法外定义。</strong></p>
<h6 id="5、逃逸分析的代码优化"><a href="#5、逃逸分析的代码优化" class="headerlink" title="5、逃逸分析的代码优化"></a>5、逃逸分析的代码优化</h6><p>使用逃逸分析，编译器可以对代码做如下优化：</p>
<ol>
<li><strong>栈上分配</strong>。<strong>将堆分配转化为栈分配</strong>。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。</li>
<li><strong>同步省略</strong>。如果一个对象被发现只能从一个线程被访问到，那么<strong>对于这个对象的操作可以不考虑同步</strong>。</li>
<li><strong>分离对象或标量替换</strong>。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分(或全部)可以不存储在内存，而是<strong>存储在CPU寄存器</strong>中。</li>
</ol>
<h6 id="6、代码优化之栈上分配"><a href="#6、代码优化之栈上分配" class="headerlink" title="6、代码优化之栈上分配"></a>6、代码优化之栈上分配</h6><ul>
<li>JIT编译器在编译期间根据逃逸分析的结果，发现如果<strong>一个对象并没有逃逸出方法的话，就可能被优化成栈上分配</strong>。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</li>
<li>常见的栈上分配的场景<ul>
<li>在逃逸分析中，已经说明了。分别是<strong>给成员变量赋值</strong>、<strong>方法返回值</strong>、<strong>实例引用传递</strong>。</li>
</ul>
</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栈上分配测试</span></span><br><span class="line"><span class="comment"> * -Xmx256 -Xms256 -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * 先关闭逃逸分析：-XX:-DoEscapeAnalysis</span></span><br><span class="line"><span class="comment"> * 在打开逃逸分析：-XX:+DoEscapeAnalysis</span></span><br><span class="line"><span class="comment"> * 观察对比</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackAllocation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查看执行时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为： &quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">        <span class="comment">// 为了方便查看堆内存中对象个数，线程sleep</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();<span class="comment">//未发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果分析：</p>
<blockquote>
<p>在关闭逃逸分析的时候：代码执行时间：55ms，发生了GC</p>
<p>在开启逃逸分析的时候：代码执行时间：4ms，并没有发生GC</p>
</blockquote>
<p>结论：</p>
<p>逃逸分析优化了对非逃逸对象的内存分配，实现了栈上分配。加快了程序的执行效率，并消除了GC，没有了STW，用户线程不会被阻碍。</p>
<h6 id="7、代码优化之同步省略（锁消除）"><a href="#7、代码优化之同步省略（锁消除）" class="headerlink" title="7、代码优化之同步省略（锁消除）"></a>7、代码优化之同步省略（锁消除）</h6><ul>
<li>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</li>
<li>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来<strong>判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程</strong>。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的<br>同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫<strong>同步省略</strong>，也叫<strong>锁消除</strong>。</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object hollis = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">synchronized</span>(hollis) &#123;</span><br><span class="line">            System.out.println(hollis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中对hollis这个对象进行加锁，但是hollis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉。（在字节码文件下依旧存在synchronized的身影，即：字节码当中的monitorenter与monitorexit中间包裹的部分，只是在运行阶段进行了代码优化）</p>
<p>优化成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object hollis = <span class="keyword">new</span> Object() ;</span><br><span class="line">    System.out.println(hollis) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="8、代码优化之标量替换"><a href="#8、代码优化之标量替换" class="headerlink" title="8、代码优化之标量替换"></a>8、代码优化之标量替换</h6><p>**标量(Scalar)**是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</p>
<p>相对的，那些还可以分解的数据叫做**聚合量(Aggregate)**，Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p>
<p>在JIT阶段，如果经过逃逸分析，发现<strong>一个对象不会被外界访问</strong>的话，那么经过JIT优化，就会把这个<strong>对象拆解成若干个其中包含的若干个成员变量来代替</strong>。这个过程就是<strong>标量替换</strong>。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标量替换测试</span></span><br><span class="line"><span class="comment"> *  -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations</span></span><br><span class="line"><span class="comment"> * 先关闭标量替换：-XX:-EliminateAllocations</span></span><br><span class="line"><span class="comment"> * 在打开标量替换：-XX:+EliminateAllocations</span></span><br><span class="line"><span class="comment"> * 观察对比</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScalarReplace</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User u = <span class="keyword">new</span> User();<span class="comment">//未发生逃逸</span></span><br><span class="line">        u.id = <span class="number">5</span>;</span><br><span class="line">        u.name = <span class="string">&quot;www.atguigu.com&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为： &quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果分析：</p>
<blockquote>
<p>在关闭标量替换的时候：代码执行时间：57ms，发生了GC</p>
<p>在开启标量替换的时候：代码执行时间：4ms，并没有发生GC</p>
</blockquote>
<p>结论：</p>
<ul>
<li><p>代码优化：（在alloc()方法中）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> String name = <span class="string">&quot;www.atguigu.com&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，Uesr这个聚合量经过逃逸分析后，发现它并没有逃逸，就被替换成两个标量了。</p>
<p>那么标量替换有什么好处呢?</p>
<p>就是可以<strong>大大减少堆内存的占用</strong>。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。</p>
<p><strong>标量替换为栈上分配提供了很好的基础。</strong></p>
</li>
<li><p>另外，在开启<code>-XX:+DoEscapeAnalysis</code>即逃逸分析，同时关闭标量替换的时候为什么还会存在GC？</p>
<p>可以理解为（弹幕，不一定对）：</p>
<ul>
<li>栈上分配是要基于标量替换，即使开启了逃逸分析但是没有开启标量替换，他还是会在堆上分配。</li>
<li>对象未发生逃逸 + 开启标量替换 = 栈上分配 </li>
<li>可以将“栈上分配”理解为1个概念，具体要通过逃逸分析和标量替换两个参数决定</li>
</ul>
</li>
<li><p>标量替换参数设置：</p>
<p>参数<code>-XX: +EliminateAllocations</code>：开启了标量替换(默认打开)，允许将对象打散分配在栈上。</p>
</li>
<li><p>上述代码在主函数中进行了1亿次alloc。调用进行对象创建，由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。 使用如下参数运行上述代码：（逃逸分析在JDK7之后已经自动添加，这里针对的是服务器端）</p>
<ul>
<li>-server</li>
<li>-Xmx100m</li>
<li>-Xms100m</li>
<li>-XX: +DoEscapeAnalysis</li>
<li>-XX: +PrintGC</li>
<li>-XX: +EliminateAllGcations</li>
</ul>
<p>这里使用参数如下：</p>
<ul>
<li>参数-server：启动Server模式，因为<strong>在Server模式下，才可以启用逃逸分析</strong>。（java的JVM默认就是一个Server模式，不用我们手动开启）</li>
<li>参数-XX:+DoEscapeAnalysis：启用逃逸分析</li>
<li>参数-Xmx10m：指定了堆空间最大为10MB</li>
<li>参数-xx: +PrintGC：将打印GC日志。</li>
<li>参数-XX:+E1 iminateAllocations：开启了标量替换(默认打开)，允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配。</li>
</ul>
</li>
</ul>
<h6 id="9、逃逸分析总结"><a href="#9、逃逸分析总结" class="headerlink" title="9、逃逸分析总结"></a>9、逃逸分析总结</h6><ul>
<li>关于逃逸分析的论文在1999年就已经发表了，但直到JDK 1.6才有实现，而且这项技术到如今也并不是十分成熟的。</li>
<li>其根本原因就是<strong>无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程</strong>。</li>
<li>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</li>
<li>虽然这项技术并不十分成熟，但是它也是<strong>即时编译器优化技术中一个十分重要的手段</strong>。</li>
<li>注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，Oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。</li>
<li>目前很多书籍还是基于JDK 7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，<strong>intern字符串缓存和静态变量</strong>并不是被转移到元数据区，而是<strong>直接在堆上分配</strong>，所以这一点同样符合前面一点的结论：<strong>对象实例都是分配在堆上</strong>。</li>
</ul>
<h4 id="11、堆总结"><a href="#11、堆总结" class="headerlink" title="11、堆总结"></a>11、堆总结</h4><ul>
<li>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</li>
<li>老年代放置长生命周期的对象，通常都是从Survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上；如果对象较大，JVM会试图直接分配在Eden其他位置上;如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。</li>
<li>当GC只发生在年轻代中，回收年轻代对象的行为被称为MinorGC。当GC发生在老年代时则被称为MajorGC或者Ful1GC。一般的，MinorGC 的发生频率要比MajorGC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</li>
</ul>
<hr>
<h3 id="9、方法区（Method-Area）"><a href="#9、方法区（Method-Area）" class="headerlink" title="9、方法区（Method Area）"></a>9、方法区（Method Area）</h3><h4 id="1、栈、堆、方法区的交互关系"><a href="#1、栈、堆、方法区的交互关系" class="headerlink" title="1、栈、堆、方法区的交互关系"></a>1、栈、堆、方法区的交互关系</h4><p>从线程是否共享的角度来看</p>
<p><img src="/2021/04/19/JVM/image-20210424010349347.png" alt="image-20210424010349347"></p>
<p>从代码看出栈、堆、方法区的交互关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/19/JVM/image-20210424010520101.png" alt="image-20210424010520101"></p>
<h4 id="2、方法区的理解"><a href="#2、方法区的理解" class="headerlink" title="2、方法区的理解"></a>2、方法区的理解</h4><h5 id="1、官方文档："><a href="#1、官方文档：" class="headerlink" title="1、官方文档："></a>1、<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4">官方文档</a>：</h5><p><img src="/2021/04/19/JVM/image-20210424010921229.png" alt="image-20210424010921229"></p>
<h5 id="2、方法区的位置"><a href="#2、方法区的位置" class="headerlink" title="2、方法区的位置"></a>2、方法区的位置</h5><p>《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpot JVM而言，方法区还有一个别名叫做**Non-Heap (非堆)**，目的就是要和堆分开。</p>
<p>所以，<strong>方法区看作是一块独立于Java堆的内存空间</strong>。</p>
<h5 id="3、方法区和基本理解"><a href="#3、方法区和基本理解" class="headerlink" title="3、方法区和基本理解"></a>3、方法区和基本理解</h5><ul>
<li>方法区(Method Area) 与Java堆一样，是<strong>各个线程共享的内存区域</strong>。</li>
<li>方法区在<strong>JVM启动的时候被创建</strong>，并且它的实际的<strong>物理内存空间</strong>中和Java堆区一样都<strong>可以是不连续</strong>的。</li>
<li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li>
<li><strong>方法区的大小决定了系统可以保存多少个类</strong>，如果系统定义了太多的类，导致方法区溢出，虛拟机同样会抛出内存溢出错误：java.lang.OutOfMemoryError:<strong>PermGen space</strong> （JDK7）或者 java.lang.OutOfMemoryError: <strong>Metaspace</strong>（JDK8）<ul>
<li><strong>加载大量的第三方的jar包；Tomcat 部署的工程过多(30-50个)，大量动态的生成反射类</strong></li>
</ul>
</li>
<li>关闭JVM就会释放这个区域的内存。</li>
</ul>
<h5 id="4、Hotspot中方法区的演进"><a href="#4、Hotspot中方法区的演进" class="headerlink" title="4、Hotspot中方法区的演进"></a>4、Hotspot中方法区的演进</h5><ul>
<li><p>在<strong>JDK7及以前</strong>，习惯上把方法区，称为<strong>永久代</strong>。<strong>JDK8</strong>开始，使用<strong>元空间</strong>取代了永久代。</p>
<blockquote>
<p>In JDK8,classes metadata is now stored in the <strong>native heap</strong> and this space is called <strong>Metaspace</strong>.</p>
</blockquote>
</li>
<li><p>本质上，<strong>方法区和永久代并不等价</strong>。仅是对hotspot而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。 例如: <strong>BEA JRockit/ IBM J9中不存在永久代</strong>的概念。</p>
<ul>
<li>现在来看，当年使用永久代，不是好的idea。导致Java程序更容易OOM (超过-XX : MaxPermSize上限)</li>
</ul>
<p><img src="/2021/04/19/JVM/%E7%AC%AC08%E7%AB%A0_%E5%A0%86%E5%92%8C%E6%96%B9%E6%B3%95%E5%8C%BA%E5%9B%BE.jpg" alt="第08章_堆和方法区图"></p>
</li>
<li><p>而到了JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间( Metaspace)来代替。</p>
<p><img src="/2021/04/19/JVM/image-20210424014427319.png" alt="image-20210424014427319"></p>
</li>
<li><p>元空间的本质和永久代类似，都是<strong>对JVM规范中方法区的实现</strong>。不过元空间与永久代最大的区别在于：<strong>元空间不在虛拟机设置的内存中，而是使用本地内存</strong>。</p>
</li>
<li><p>永久代、元空间二者并不只是名字变了，内部结构也调整了。</p>
<ul>
<li>根据《Java虚拟机规范》的规定，如果<strong>方法区</strong>无法满足新的内存分配需求时，将抛出<strong>OOM异常</strong>。</li>
</ul>
</li>
</ul>
<h4 id="3、设置方法区大小与OOM"><a href="#3、设置方法区大小与OOM" class="headerlink" title="3、设置方法区大小与OOM"></a>3、设置方法区大小与OOM</h4><ul>
<li><p>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。</p>
</li>
<li><p>JDK7及以前：</p>
<ul>
<li><p>通过<code>-XX:PermSize</code>来设置永久代<strong>初始</strong>分配空间。<strong>默认值是20.75M</strong></p>
</li>
<li><p><code>-XX:MaxPermSize</code>来设定永久代<strong>最大</strong>可分配空间。<strong>32位机器默认是64M</strong>，<strong>64位机器模式是82M</strong></p>
</li>
<li><p>当JVM加载的类信息容量超过了这个值，会报异常OutofMemoryError : PermGen space</p>
<p><img src="/2021/04/19/JVM/image-20210424014940690.png" alt="image-20210424014940690"></p>
</li>
</ul>
</li>
<li><p>jdk8及以后:</p>
<ul>
<li><p>元数据区大小可以使用参数<code>-XX :MetaspaceSize</code>和<code>-XX :MaxMetaspaceSize</code>指定，替代上述原有的两个参数。</p>
</li>
<li><p><strong>默认值依赖于平台</strong>。<strong>windows下，-XX:MetaspaceSize是21M， -XX: MaxMetaspaceSize的值是-1， 即没有限制</strong>。</p>
</li>
<li><p>参数设置方法：</p>
<ul>
<li>jdk7及以前：-XX:PermSize=100m -XX:MaxPermSize=100m</li>
<li>jdk8及以后：-XX:MetaspaceSize=100m  -XX:MaxMetaspaceSize=100m(这个一般不会改)</li>
</ul>
</li>
<li><p>与永久代不同，<strong>如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存</strong>。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError: Metaspace</p>
</li>
<li><p><code>-XX : MetaspaceSize</code>：<br><strong>设置初始的元空间大小</strong>。对于一个<strong>64位的服务器端JVM</strong>来说，其默认的-XX :MetaspaceSize值为<strong>21MB</strong>。这就是<strong>初始的高水位线</strong>，一 旦触及这个水位线，Full GC将会被触发并卸载没用的类(即这些类对应的类加载器不再存活)，然后这个高水位线将会重置。<strong>新的高水位线的值取决于GC后释放了多少元空间</strong>。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。</p>
<p><img src="/2021/04/19/JVM/image-20210424015216603.png" alt="image-20210424015216603"></p>
</li>
<li><p>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议<strong>将-XX:MetaspaceSize设置为一个相对较高的值</strong>。</p>
</li>
</ul>
</li>
</ul>
<h4 id="4、如何解决OOM"><a href="#4、如何解决OOM" class="headerlink" title="4、如何解决OOM"></a>4、如何解决OOM</h4><ol>
<li>要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具(如Eclipse Memory Analyzer) 对dump出来的堆转储快照进行分析，重点是<strong>确认内存中的对象是否是必要</strong>的，也就是要先分清楚到底是<strong>出现了内存泄漏(MemoryLeak)**还是</strong>内存溢出(Memory Overflow)<strong>。</strong>内存泄漏堆积会导致内存溢出<strong>，所以</strong>判断内存溢出第一步是查看内存是否泄漏**。</li>
<li>如果是<strong>内存泄漏</strong>，可进一步通过工具<strong>查看泄漏对象到GC Roots的引用链</strong>。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots 引用链的信息，就可以比较准确地定位出泄漏代码的位置。</li>
<li>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当<strong>检查虚拟机的堆参数</strong>(-Xmx与-Xms) ，<strong>与机器物理内存对比看是否还可以调大</strong>，从<strong>代码</strong>上检查<strong>是否存在某些对象生命周期过长、持有状态时间过长</strong>的情况，尝试减少程序运行期的内存消耗。</li>
</ol>
<h4 id="5、方法区的内部结构"><a href="#5、方法区的内部结构" class="headerlink" title="5、方法区的内部结构"></a>5、方法区的内部结构</h4><p><img src="/2021/04/19/JVM/image-20210424020826940.png" alt="image-20210424020826940"></p>
<h5 id="1、方法区存储的内容"><a href="#1、方法区存储的内容" class="headerlink" title="1、方法区存储的内容"></a>1、方法区存储的内容</h5><p>《深入理解Java虚拟机》书中对方法区(Method Area)存储内容描述如下：</p>
<p>它用于存储已<strong>被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等。</p>
<p><img src="/2021/04/19/JVM/image-20210424020942369.png" alt="image-20210424020942369"></p>
<h5 id="2、方法区和内部结构"><a href="#2、方法区和内部结构" class="headerlink" title="2、方法区和内部结构"></a>2、方法区和内部结构</h5><h6 id="1、类型信息"><a href="#1、类型信息" class="headerlink" title="1、类型信息"></a>1、类型信息</h6><p>对每个加载的类型( 类calss、接口interface、枚举enum、注解annotation)，JVM必须在方法区中存储以下类型信息：</p>
<ol>
<li>这个类型的<strong>完整有效名称</strong>(全名=包名.类名)</li>
<li>这个类型<strong>直接父类的完整有效名</strong>(对于interface或是java. lang.object， 都没有父类)</li>
<li>这个类型的<strong>修饰符</strong>(public, abstract, final的某个子集)</li>
<li>这个类型<strong>直接接口的一个有序列表</strong></li>
</ol>
<h6 id="2、域（Field）信息"><a href="#2、域（Field）信息" class="headerlink" title="2、域（Field）信息"></a>2、域（Field）信息</h6><p>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</p>
<p>域的相关信息包括：</p>
<ul>
<li>域名称</li>
<li>域类型</li>
<li>域修饰符：public，private，protected，static，final，volatile，transient的某个子集</li>
</ul>
<h6 id="3、方法（Method）信息"><a href="#3、方法（Method）信息" class="headerlink" title="3、方法（Method）信息"></a>3、方法（Method）信息</h6><p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p>
<ul>
<li>方法名称</li>
<li>方法的返回类型(或void)</li>
<li>方法参数的数量和类型(按顺序)</li>
<li>方法的修饰符(public，private，protected，static，final，synchronized，native，abstract的一个子集)</li>
<li>方法的字节码 (bytecodes)、操作数栈、局部变量表及大小(abstract和native方法除外)</li>
<li>异常表(abstract和native方法除外)<ul>
<li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li>
</ul>
</li>
</ul>
<h6 id="4、non-final的类变量"><a href="#4、non-final的类变量" class="headerlink" title="4、non-final的类变量"></a>4、non-final的类变量</h6><ul>
<li>静态变量和类关联在一起，<strong>随着类的加载而加载</strong>，它们成为类数据在逻辑上的一部分。</li>
<li><strong>类变量被类的所有实例共享，即使没有类实例时你也可以访问它</strong>。</li>
<li><clinit> javac编译器自动搜集字节码中的类变量的赋值动作和静态代码块组成的语句</clinit></li>
</ul>
<h6 id="5、全局常量：static-final"><a href="#5、全局常量：static-final" class="headerlink" title="5、全局常量：static final"></a>5、全局常量：static final</h6><p><strong>被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配</strong>。</p>
<p><img src="/2021/04/19/JVM/image-20210424024056293.png" alt="image-20210424024056293"></p>
<h5 id="3、运行时常量池-VS-常量池"><a href="#3、运行时常量池-VS-常量池" class="headerlink" title="3、运行时常量池 VS 常量池"></a>3、运行时常量池 VS 常量池</h5><p><img src="/2021/04/19/JVM/image-20210424024352733.png" alt="image-20210424024352733"></p>
<ul>
<li><p><strong>方法区</strong>，内部包含了<strong>运行时常量池</strong>。</p>
</li>
<li><p><strong>字节码文件</strong>，内部包含了<strong>常量池</strong>。</p>
</li>
<li><p>方法区的运行时常量池就是class字节码文件中的常量池经过类加载器进行加载之后存放进内存之后得到。</p>
<p>但由于方法区的运行时常量池是具备动态性，所以可能比字节码文件里的常量池要大。</p>
</li>
<li><p>要弄清楚方法区，需要理解清楚ClassFile，因为加载类的信息都在方法区。</p>
</li>
<li><p>要弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的常量池。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">官网描述如下</a>：</p>
<p><img src="/2021/04/19/JVM/image-20210424030341079.png" alt="image-20210424030341079"></p>
</li>
<li><p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是<strong>常量池表(Constant Pool Table)</strong> ，**包括各种字面量和对类型、域和方法的<code>符号引用</code>**。</p>
<p><img src="/2021/04/19/JVM/image-20210424030544494.png" alt="image-20210424030544494"></p>
</li>
</ul>
<h5 id="4、为什么需要常量池？"><a href="#4、为什么需要常量池？" class="headerlink" title="4、为什么需要常量池？"></a>4、为什么需要常量池？</h5><p>一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，<strong>这个字节码包含了指向常量池的<code>引用</code>**。在</strong>动态链接的时候会用到运行时常量池**。</p>
<p>比如如下的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHel1o</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Object obj = new Object();经过编译之后会生成如下字节码文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0:	new #2				&#x2F;&#x2F; Class java&#x2F; lang&#x2F; object</span><br><span class="line">1:	dup</span><br><span class="line">2:	invokespecial #3	&#x2F;&#x2F; Method java&#x2F; lang&#x2F;object &quot;&lt;init&gt;&quot;( ) V</span><br></pre></td></tr></table></figure>

<p>虽然编译过后的class文件只有194字节，但是里面却使用了String、System、 PrintStream及object等结构。这里代码量其实已经很小了。如果代码多，引用到的结构会更多!这里就需要常量池了!</p>
<h5 id="5、常量池中的内容"><a href="#5、常量池中的内容" class="headerlink" title="5、常量池中的内容"></a>5、常量池中的内容</h5><p>几种在常量池内存储的数据类型包括：</p>
<ul>
<li>数量值</li>
<li>字符串值</li>
<li>类引用</li>
<li>字段引用</li>
<li>方法引用</li>
</ul>
<h5 id="6、常量池小结"><a href="#6、常量池小结" class="headerlink" title="6、常量池小结"></a>6、常量池小结</h5><p><strong>常量池</strong>，可以看做是<strong>一张表</strong>，虚拟机指令根据这张常量表<strong>找到要执行的类名、方法名、参数类型、字面量等类型</strong>。</p>
<h5 id="7、运行时常量池"><a href="#7、运行时常量池" class="headerlink" title="7、运行时常量池"></a>7、运行时常量池</h5><ul>
<li><strong>运行时常量池</strong>( Runtime Constant Pool) 是<strong>方法区的一部分</strong>。</li>
<li><strong>常量池表</strong>( Constant Pool Table) 是<strong>Class文件的一部分</strong>，<strong>用于存放<code>编译期</code>生成的<code>各种字面量与符号引用</code>**，</strong>这部分内容将在<code>类加载后</code>存放到方法区的运行时常量池中**。</li>
<li>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</li>
<li>JVM为每个已加载的类型(类或接口)都维护一个常量池。池中的数据项像数组项一样，是通过**<code>索引访问</code>**的。</li>
<li>运行时常量池中包含多种不同的常量，<strong>包括编译期就已经明确的数值字面量</strong>，也包括到<strong>运行期解析后才能够获得的方法或者字段引用</strong>。此时不再是常量池中的符号地址了，这里换为<code>真实地址</code>。<ul>
<li>运行时常量池，相对于Class文件常量池的另一重要特征是：**<code>具备动态性</code>**。<ul>
<li>String. intern( )</li>
</ul>
</li>
</ul>
</li>
<li>运行时常量池类似于传统编程语言中的符号表(symboltable)，但是它所包含的数据却比符号表要更加丰富一些。</li>
<li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutOfMemoryError异常。</li>
</ul>
<h4 id="6、方法区使用举例"><a href="#6、方法区使用举例" class="headerlink" title="6、方法区使用举例"></a>6、方法区使用举例</h4><p><img src="/2021/04/19/JVM/image-20210424165338137.png" alt="image-20210424165338137"></p>
<p><img src="/2021/04/19/JVM/image-20210424165401780.png"></p>
<p><img src="/2021/04/19/JVM/image-20210424165459908.png" alt="image-20210424165459908"></p>
<h4 id="7、方法区的演进细节"><a href="#7、方法区的演进细节" class="headerlink" title="7、方法区的演进细节"></a>7、方法区的演进细节</h4><h5 id="1、方法区的演进"><a href="#1、方法区的演进" class="headerlink" title="1、方法区的演进"></a>1、方法区的演进</h5><p>首先明确：<strong>只有HotSpot才有永久代</strong>。</p>
<p>BEA JRockit、 IBM J9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一。</p>
<p>Hotspot中方法区的变化：</p>
<table>
<thead>
<tr>
<th>版本</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>jdk1.6及之前</td>
<td>有永久代(permanent generation)，静态变量存放在永久代上</td>
</tr>
<tr>
<td>jdk1.7</td>
<td>有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中</td>
</tr>
<tr>
<td>jdk1.8及之后</td>
<td>无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆</td>
</tr>
</tbody></table>
<p><img src="/2021/04/19/JVM/%E7%AC%AC08%E7%AB%A0_%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E6%BC%94%E8%BF%9B%E7%BB%86%E8%8A%82-hotspot.jpg" alt="第08章_方法区的演进细节-hotspot"></p>
<h5 id="2、元空间-VS-永久代"><a href="#2、元空间-VS-永久代" class="headerlink" title="2、元空间 VS 永久代"></a>2、元空间 VS 永久代</h5><p><a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/122">永久代为什么要被元空间替换</a>？</p>
<ul>
<li><p>随着Java8 的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间(Metaspace)。</p>
</li>
<li><p>由于类的元数据分配在<strong>本地内存</strong>中，<strong>元空间的最大可分配空间就是系统可用内存空间</strong>。</p>
</li>
<li><p>这项改动是很有必要的，原因有:</p>
<ol>
<li><p><strong>为永久代设置空间大小是很难确定的</strong>。</p>
<p>在某些场景下，如果动态加载类过多，容易产生Perm区的OOM。比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。</p>
<p>“Exception in thread ‘dubbo client x.x connector’ java.lang OutOfMemoryError: PermGen space</p>
<p>而元空间和永久代之间最大的区别在于：<strong>元空间并不在虚拟机中，而是使用本地内存</strong>。因此，默认情况下，元空间的大小仅受本地内存限制。</p>
</li>
<li><p>对<strong>永久代进行调优是很困难</strong>的。</p>
</li>
</ol>
</li>
</ul>
<h5 id="3、StringTable的调整"><a href="#3、StringTable的调整" class="headerlink" title="3、StringTable的调整"></a>3、StringTable的调整</h5><p>StringTable为什么要调整?</p>
<p><strong>jdk7</strong>中将StringTable放到了<strong>堆空间</strong>中。因为<strong>永久代的回收效率很低</strong>，在full gc的时候才会触发。而full gc是老年代的空间不足、永久代不足时才会触发。这就<strong>导致StringTable回收效率不高</strong>。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p>
<h5 id="4、静态变量的位置"><a href="#4、静态变量的位置" class="headerlink" title="4、静态变量的位置"></a>4、静态变量的位置</h5><p>结论：<strong>静态引用对应的对象实体始终都存在堆空间</strong></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 《深入理解Java虚拟机》中的案例：</span></span><br><span class="line"><span class="comment"> * staticObj、instanceObj、localObj存放在哪里？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticObjTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> ObjectHolder staticObj = <span class="keyword">new</span> ObjectHolder();</span><br><span class="line">        ObjectHolder instanceObj = <span class="keyword">new</span> ObjectHolder();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ObjectHolder localObj = <span class="keyword">new</span> ObjectHolder();</span><br><span class="line">            System.out.println(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectHolder</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> StaticObjTest.Test();</span><br><span class="line">        test.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>staticObj（静态变量）</strong>随着Test的类型信息存放在<strong>方法区</strong>，<strong>instanceObj（实例变量）</strong>随着Test的对象实例存放在<strong>Java堆</strong>，<strong>localObject（局部变量）</strong>则是存放在foo( )方法栈帧的<strong>局部变量表</strong>中。</p>
<p>三个对象的数据在<strong>内存中的地址</strong>都落在<strong>Eden区范围内</strong>。</p>
<p>所以结论：<strong>只要是对象实例必然会在Java堆中分配</strong>。</p>
<p>接着，找到了一个引用该staticObj对象的地方，是在一个java.lang.Class的实例里，并且给出了这个实例的地址，通过Inspector查看该对象实例，可以清楚看到这确实是一个java.lang.Class类型的对象实例，里面有一个名为staticObj的实例字段：</p>
<p><img src="/2021/04/19/JVM/image-20210424172219770.png" alt="image-20210424172219770"></p>
<p>从《Java虚拟机规范》所定义的概念模型来看，所有<strong>Class相关的信息都应该存放在方法区</strong>之中，但方法区该如何实现，《Java虚拟机规范》 并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。</p>
<p>JDK 7及其以后版本的HotSpot虚拟机选择把<strong>静态变量</strong>与类型在Java语言一端的映射Class对象存放在一起，<strong>存储于Java堆之中</strong>，从我们的实验中也明确验证了这一点。</p>
<h4 id="8、方法区的垃圾回收"><a href="#8、方法区的垃圾回收" class="headerlink" title="8、方法区的垃圾回收"></a>8、方法区的垃圾回收</h4><p>有些人认为方法区如HotSpot虚拟机中的元空间或者永久代)是没有垃圾收集行为的，其实不然。《Java虚拟机规范》 对方法区的约束是非常宽松的，提到过<strong>可以不要求虚拟机在方法区中实现垃圾收集</strong>。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在(如JDK11时期的ZGC收集器就不支持类卸载)。</p>
<p><strong>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的</strong>。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虛拟机对此区域未完全回收而导致内存泄漏。</p>
<p>**方法区的垃圾收集主要回收两部分内容：<code>常量池中废弃的常量</code>和<code>不再使用的类型</code>**。</p>
<ul>
<li>先来说说方法区内**常量池之中主要存放的两大类常量：<code>字面量</code>和<code>符号引用</code>**。<br>字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。</li>
<li>而符号引用则属于编译原理方面的概念，包括下面三类常量：<ol>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ol>
</li>
<li>HotSpot虚拟机对常量池的回收策略是很明确的，只要<strong>常量池中的常量没有被任何地方引用，就可以被回收</strong>。</li>
<li>回收废弃常量与回收Java堆中的对象非常类似。</li>
<li>判定<strong>一个常量是否“废弃”</strong>还是相对简单，而要判定<strong>一个类型是否属于“不再被使用的类”</strong>的条件就比较苛刻了。需要同时满足下面三个条件：<ol>
<li>该类所有的实例都已经被回收，也就是<strong>Java堆中不存在该类及其任何派生子类的实例</strong>。</li>
<li><strong>加载该类的类加载器已经被回收</strong>，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</li>
<li><strong>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</strong>。</li>
</ol>
</li>
<li>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“<strong>被允许</strong>”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收,HotSpot虚拟机提供了<code>-Xnoclassgc</code>参数进行控制，还可以使用<code>-verbose:class</code>以及<code>-XX: +TraceClass-Loading</code>、<code>-XX: +TraceClassUnLoading</code>查看类加载和卸载信息</li>
<li>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</li>
</ul>
<h4 id="9、总结"><a href="#9、总结" class="headerlink" title="9、总结"></a>9、总结</h4><p><img src="/2021/04/19/JVM/%E7%AC%AC09%E7%AB%A0_%E5%B0%8F%E7%BB%93.jpg" alt="第09章_小结"></p>
<h4 id="10、常见面试题"><a href="#10、常见面试题" class="headerlink" title="10、常见面试题"></a>10、常见面试题</h4><ul>
<li>百度:<ul>
<li>三面：说一下JVM内存模型吧，有哪些区?分别干什么的?</li>
</ul>
</li>
<li>蚂蚁金服:<ul>
<li>Java8的内存分代改进</li>
<li>JVM内存分哪几个区，每个区的作用是什么?</li>
<li>一面: JVM内存分布/内存结构?栈和堆的区别?堆的结构?为什么两个survivor区?</li>
<li>二面: Eden和Survior的比例分配</li>
</ul>
</li>
<li>小米:<ul>
<li>jvm内存分区，为什么要有新生代和老年代</li>
</ul>
</li>
<li>字节跳动:<ul>
<li>二面: Java的内存分区</li>
<li>二面:讲讲jvm运行时数据库区</li>
<li>什么时候对象会进入老年代?</li>
</ul>
</li>
<li>京东:<ul>
<li>JVM的内存结构，Eden和Survivor比例。</li>
<li>JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。</li>
</ul>
</li>
<li>天猫:<ul>
<li>一面: Jvm内存模型以及分区，需要详细到每个区放什么。</li>
<li>一面: JVM的内存模型，Java8做了什么修改</li>
</ul>
</li>
<li>拼多多:<ul>
<li>JVM 内存分哪几个区，每个区的作用是什么?</li>
</ul>
</li>
<li>美团:<ul>
<li>java内存分配</li>
<li>jvm的永久代中会发生垃圾回收吗?</li>
<li>一面: jvm内存分区，为什么要有新生代和老年代?</li>
</ul>
</li>
</ul>
<hr>
<h3 id="10、对象的实例化、内存布局与访问定位"><a href="#10、对象的实例化、内存布局与访问定位" class="headerlink" title="10、对象的实例化、内存布局与访问定位"></a>10、对象的实例化、内存布局与访问定位</h3><h4 id="1、对象的实例化"><a href="#1、对象的实例化" class="headerlink" title="1、对象的实例化"></a>1、对象的实例化</h4><h5 id="1、大厂面试题"><a href="#1、大厂面试题" class="headerlink" title="1、大厂面试题"></a>1、大厂面试题</h5><ul>
<li>美团:<ul>
<li>对象在JVM中是怎么存储的?</li>
<li>对象头信息里面有哪些东西?</li>
</ul>
</li>
<li>蚂蚁金服:<ul>
<li>二面: java对象头里有什么</li>
</ul>
</li>
</ul>
<h5 id="2、对象实例化"><a href="#2、对象实例化" class="headerlink" title="2、对象实例化"></a>2、对象实例化</h5><p><img src="/2021/04/19/JVM/%E7%AC%AC10%E7%AB%A0_%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96.jpg" alt="第10章_对象的实例化"></p>
<p>创建对象的字节码解析：</p>
<p><img src="/2021/04/19/JVM/image-20210424193206898.png" alt="image-20210424193206898"></p>
<p>创建步骤：</p>
<ol>
<li><p>判断对象对应的类是否加载、链接、初始化</p>
<p>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。( 即<strong>判断类元信息是否存在</strong>)。如果没有，那么在<strong>双亲委派模式</strong>下，使用当前类加载器以ClassLoader+包名+类名为Key进行查找对应的.class文件。如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class类对象。</p>
</li>
<li><p>为对象分配内存</p>
<p>首先<strong>计算对象占用空间大小</strong>，接着在堆中划分一块内存给新对象。</p>
<p><strong>如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小</strong>。</p>
<ul>
<li><p>如果内存规整，使用<strong>指针碰撞</strong>：</p>
<p>如果内存是规整的，那么虚拟机将采用的是**指针碰撞法(Bump The Pointer)**来为对象分配内存。意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带有compact(整理)过程的收集器时，使用指针碰撞。</p>
</li>
<li><p>如果内存不规整，虚拟机需要维护-一个列表，使用<strong>空闲列表分配</strong>：</p>
<p>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存。意思是<strong>虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容</strong>。这种分配方式成为“空闲列表(Free List)“。</p>
</li>
</ul>
<p>说明：选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的<strong>垃圾收集器是否带有压缩整理功能</strong>决定。</p>
</li>
<li><p>处理并发安全问题</p>
<p>在分配内存空间时，另外一个问题是及时保证new对象时候的线程安全性：创建对象是非常频繁的操作，虚拟机需要解决并发问题。虚拟机采用了两种方式解决并发问题：</p>
<ol>
<li>CAS ( Compare And Swap )失败重试、区域加锁：保证指针更新操作的原子性；</li>
<li>TLAB把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为<strong>本地线程分配缓冲区</strong>，(TLAB ，Thread Local Allocation Buffer) 虚拟机是否使用TLAB，可以通过<code>-XX: +/-UseTLAB</code>参数来设定（’+’：打开 ‘-‘：关闭）。</li>
</ol>
</li>
<li><p>初始化分配到的空间</p>
<p>内存分配结束，虚拟机将分配到的内存空间都**初始化为零值(不包括对象头)**。这一步保证了对象的实例字段在Java代码中可以不用赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
</li>
<li><p>设置对象的对象头</p>
<p>将对象的所属类(即类的元数据信息)、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p>
</li>
<li><p>执行init方法进行初始化</p>
<p>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。</p>
<p>因此一般来说(由字节码中是否跟随有invokespecial指令所决定)，new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样<strong>一个真正可用的对象才算完全创建</strong>出来。</p>
</li>
</ol>
<h4 id="2、对象的内存布局"><a href="#2、对象的内存布局" class="headerlink" title="2、对象的内存布局"></a>2、对象的内存布局</h4><p><img src="/2021/04/19/JVM/%E7%AC%AC10%E7%AB%A0_%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.jpg" alt="第10章_内存布局"></p>
<p>小结：图示</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC10%E7%AB%A0_%E5%9B%BE%E7%A4%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.jpg" alt="第10章_图示对象的内存布局"></p>
<h4 id="3、对象的访存定位"><a href="#3、对象的访存定位" class="headerlink" title="3、对象的访存定位"></a>3、对象的访存定位</h4><p><img src="/2021/04/19/JVM/%E7%AC%AC10%E7%AB%A0_%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D.jpg" alt="第10章_对象访问定位"></p>
<p>图示：JVM是如何通过栈帧中的对象引用访问到其内部的对象实例的呢?</p>
<p><img src="/2021/04/19/JVM/image-20210424190106896.png" alt="image-20210424190106896"></p>
<h5 id="1、句柄访问"><a href="#1、句柄访问" class="headerlink" title="1、句柄访问"></a>1、句柄访问</h5><p>图示：</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC10%E7%AB%A0_%E6%96%B9%E5%BC%8F1%EF%BC%9A%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE.jpg" alt="第10章_方式1：句柄访问"></p>
<p>好处：reference中存储稳定句柄地址，对象被移动(垃圾收集时移动对象很普遍)时只会改变句柄中实例数据指针即可，reference本身不需要被修改。</p>
<h5 id="2、直接指针（HotSpot采用）"><a href="#2、直接指针（HotSpot采用）" class="headerlink" title="2、直接指针（HotSpot采用）"></a>2、直接指针（HotSpot采用）</h5><p>图示：</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC10%E7%AB%A0_%E6%96%B9%E5%BC%8F2%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE.jpg" alt="第10章_方式2：使用直接指针访问"></p>
<hr>
<h3 id="11、直接内存-Direct-Memory"><a href="#11、直接内存-Direct-Memory" class="headerlink" title="11、直接内存(Direct Memory)"></a>11、直接内存(Direct Memory)</h3><h4 id="1、直接内存概述"><a href="#1、直接内存概述" class="headerlink" title="1、直接内存概述"></a>1、直接内存概述</h4><ul>
<li>不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。</li>
<li><strong>直接内存是在Java堆外</strong>的、<strong>直接向系统申请的内存区间</strong>。</li>
<li>来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存</li>
<li>通常，<strong>访问直接内存的速度会优于Java堆。即读写性能高。</strong><ul>
<li>因此出于性能考虑，<strong>读写频繁的场合可能会考虑使用直接内存</strong>。</li>
<li><strong>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区</strong></li>
</ul>
</li>
</ul>
<h4 id="2、IO-VS-NIO"><a href="#2、IO-VS-NIO" class="headerlink" title="2、IO VS NIO"></a>2、IO VS NIO</h4><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">IO</th>
<th align="center">NIO (New IO / Non-Blocking IO：非阻塞IO)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">实现</td>
<td align="center">byte[] / char[]</td>
<td align="center">Buffer（缓存区）</td>
</tr>
<tr>
<td align="center">形式</td>
<td align="center">Stream（流）</td>
<td align="center">Channel（管道）</td>
</tr>
</tbody></table>
<h4 id="3、直接缓存区（IO）-VS-非直接缓存区（NIO）"><a href="#3、直接缓存区（IO）-VS-非直接缓存区（NIO）" class="headerlink" title="3、直接缓存区（IO） VS 非直接缓存区（NIO）"></a>3、直接缓存区（IO） VS 非直接缓存区（NIO）</h4><p>读写文件，需要与磁盘交互，需要由用户态切换到内核态。在内核态时，需要内存如下图的操作。</p>
<p>使用IO，见下图。这<strong>里需要两份内存存储重复数据，效率低</strong>。</p>
<p><img src="/2021/04/19/JVM/image-20210424225618054.png" alt="image-20210424225618054"></p>
<p>使用NIO时，如下图。</p>
<p><strong>操作系统划出的直接缓存区可以被java代码直接访问，只有一份。 NIO适合对大文件的读写操作</strong>。</p>
<p><img src="/2021/04/19/JVM/image-20210424225837934.png" alt="image-20210424225837934"></p>
<h4 id="4、直接内存的OOM异常"><a href="#4、直接内存的OOM异常" class="headerlink" title="4、直接内存的OOM异常"></a>4、直接内存的OOM异常</h4><ul>
<li><p><strong>直接内存也可能导致OutOfMemoryError异常</strong></p>
<p><img src="/2021/04/19/JVM/image-20210424231245461.png" alt="image-20210424231245461"></p>
</li>
<li><p>由于直接内存在Java堆外，因此它的大小不会直接受限于-Xmx指定的最大堆大小，但是<strong>系统内存是有限</strong>的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。</p>
</li>
<li><p>缺点</p>
<ul>
<li><strong>分配回收成本较高</strong></li>
<li><strong>不受JVM内存回收管理</strong></li>
</ul>
</li>
<li><p>直接内存大小可以通过<code>MaxDirectMemorySize</code>设置</p>
</li>
<li><p>如果不指定，<strong>默认与堆的最大值-Xmx参数值一致</strong></p>
</li>
</ul>
<p>简单理解：</p>
<p><strong>java process memory = java heap + native memory</strong></p>
<p><img src="/2021/04/19/JVM/image-20210424231440926.png" alt="image-20210424231440926"></p>
<hr>
<h3 id="12、执行引擎"><a href="#12、执行引擎" class="headerlink" title="12、执行引擎"></a>12、执行引擎</h3><h4 id="1、执行引擎概述"><a href="#1、执行引擎概述" class="headerlink" title="1、执行引擎概述"></a>1、执行引擎概述</h4><h5 id="1、执行引擎的作用"><a href="#1、执行引擎的作用" class="headerlink" title="1、执行引擎的作用"></a>1、执行引擎的作用</h5><ul>
<li>执行引擎是Java虛拟机<strong>核心</strong>的组成部分之一。</li>
<li>“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此<strong>可以不受物理条件制约地定制指令集与执行引擎的结构体系</strong>，能够<strong>执行那些不被硬件直接支持的指令集格式</strong>。</li>
<li>JVM的主要任务是负责<strong>装载字节码到其内部</strong>，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。</li>
<li>那么，如果想要让一个Java程序运行起来，执行引擎(Execution Engine)的任务就是<strong>将字节码指令解释/编译为对应平台上的本地机器指令</strong>才可以。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。</li>
</ul>
<h5 id="2、执行引擎的工作过程"><a href="#2、执行引擎的工作过程" class="headerlink" title="2、执行引擎的工作过程"></a>2、执行引擎的工作过程</h5><ul>
<li>执行引擎在执行的过程中究竟需要执行什么样的字节码指令<strong>完全依赖于PC寄存器</strong>。</li>
<li>每当执行完一项指令操作后，PC寄存器就会<strong>更新下一条需要被执行的指令地址</strong>。</li>
<li>当前方法在执行的过程中，<strong>执行引擎</strong>有可能会<strong>通过</strong>存储在局部变量表中的<strong>对象引用准确定位</strong>到存储在Java堆区中的<strong>对象实例信息</strong>，以及<strong>通过对象头中的元数据指针定位到目标对象的类型信息</strong>。</li>
</ul>
<p>从外观上来看，所有的Java虚拟机的执行引擎输入、输出都是一致的：<strong>输入的是字节码二进制流</strong>，处理过程是<strong>字节码解析执行的等效过程</strong>，<strong>输出的是执行结果</strong>。</p>
<h4 id="2、Java代码编译和执行过程"><a href="#2、Java代码编译和执行过程" class="headerlink" title="2、Java代码编译和执行过程"></a>2、Java代码编译和执行过程</h4><p><img src="/2021/04/19/JVM/image-20210425022648722.png" alt="程序执行过程"></p>
<p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图中的各个步骤。</p>
<p>Java代码编译是由Java源码编译器来完成，流程图如下所示：</p>
<p><img src="/2021/04/19/JVM/image-20210425005150269.png" alt="image-20210425005150269"></p>
<p>Java字节码的执行是由JVM执行引擎来完成，流程图如下所示：</p>
<p><img src="/2021/04/19/JVM/image-20210425005213179.png" alt="image-20210425005213179"></p>
<p>问题1：什么是解释器( Interpreter)，什么是JIT编译器? </p>
<ul>
<li>解释器：当Java虛拟机启动时会根据预定义的规范<strong>对字节码采用逐行解释的方式执行</strong>，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</li>
<li>JIT (Just In Time Compiler) 编译器：就是虚拟机将<strong>源代码直接编译成和本地机器平台相关的机器语言</strong>。</li>
<li>解释器：边逐行翻译边运行</li>
<li>编译器：一起编译好再执行</li>
</ul>
<p>问题2：为什么说Java是半编译半解释型语言?</p>
<ul>
<li><p>JDK1.0时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。</p>
</li>
<li><p>现在JVM在执行Java代码的时候，通常都会将<strong>解释执行与编译执行二者结合起来</strong>进行。</p>
</li>
<li><p>经过编译器编译之后可以在方法区中进行缓存（热点代码）</p>
<p><img src="/2021/04/19/JVM/image-20210425005819291.png" alt="image-20210425005819291"></p>
</li>
</ul>
<h4 id="3、机器码、指令、汇编语言"><a href="#3、机器码、指令、汇编语言" class="headerlink" title="3、机器码、指令、汇编语言"></a>3、机器码、指令、汇编语言</h4><h5 id="1、理解执行引擎"><a href="#1、理解执行引擎" class="headerlink" title="1、理解执行引擎"></a>1、理解执行引擎</h5><p><img src="/2021/04/19/JVM/%E7%AC%AC12%E7%AB%A0_%E7%90%86%E8%A7%A3%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E.jpg" alt="第12章_理解执行引擎"></p>
<h5 id="2、机器码"><a href="#2、机器码" class="headerlink" title="2、机器码"></a>2、机器码</h5><ul>
<li>各种用二进制编码方式表示的指令，叫做<strong>机器指令码</strong>。开始，人们就用它采编写程序，这就是机器语言。</li>
<li>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。</li>
<li>用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，<strong>执行速度最快</strong>。</li>
<li>机器指令与CPU紧密相关，所以<strong>不同种类的CPU所对应的机器指令也就不同</strong>。</li>
</ul>
<h5 id="3、指令与指令集"><a href="#3、指令与指令集" class="headerlink" title="3、指令与指令集"></a>3、指令与指令集</h5><ul>
<li>指令<ul>
<li>由于机器码是有0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。指令就是把机器码中特定的0和1序列，简化成对应的指令(一般为英文简写，如mov,inc等)，可读性稍好</li>
<li>由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令(比如mov)，对应的机器码也可能不同。</li>
</ul>
</li>
<li>指令集<ul>
<li>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。</li>
<li>如常见的<ul>
<li>x86指令集，对应的是x86架构的平台</li>
<li>ARM指令集，对应的是ARM架构的平台</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="4、汇编语言"><a href="#4、汇编语言" class="headerlink" title="4、汇编语言"></a>4、汇编语言</h5><ul>
<li>由于指令的可读性还是太差，于是人们又发明了汇编语言。</li>
<li>在汇编语言中，用<strong>助记符</strong>(Mnemonics)代替<strong>机器指令的操作码</strong>，用<strong>地址符号</strong>(Symbol) 或<strong>标号</strong>(Label)代替<strong>指令或操作数的地址</strong>。</li>
<li>在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。<ul>
<li>由于计算机只认识指令码，所以用<strong>汇编语言编写的程序还必须翻译成机器指令码</strong>，计算机才能识别和执行。</li>
</ul>
</li>
</ul>
<h5 id="5、高级语言"><a href="#5、高级语言" class="headerlink" title="5、高级语言"></a>5、高级语言</h5><ul>
<li>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。高级语言比机器语言、汇编语言<strong>更接近人的语言</strong>。</li>
<li>当计算机执行高级语言编写的程序时，<strong>仍然需要把程序解释和编译成机器的指令码</strong>。完成这个过程的程序就叫做<strong>解释程序</strong>或<strong>编译程序</strong>。</li>
</ul>
<p><img src="/2021/04/19/JVM/%E7%AC%AC12%E7%AB%A0_%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80%E3%80%81%E6%B1%87%E7%BC%96%E3%80%81%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80-1619284091715.jpg" alt="第12章_机器语言、汇编、高级语言"></p>
<h5 id="6、字节码"><a href="#6、字节码" class="headerlink" title="6、字节码"></a>6、字节码</h5><ul>
<li>字节码是一种**中间状态(中间码)的二进制代码(文件)**，它比机器码更抽象，需要直译器转译后才能成为机器码</li>
<li>字节码主要为了实现特定软件运行和软件环境、<strong>与硬件环境无关</strong>。（<strong>实现跨平台</strong>）</li>
<li>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。<ul>
<li>字节码的典型应用为Java bytecode。</li>
</ul>
</li>
</ul>
<p><img src="/2021/04/19/JVM/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%80%A7.jpg" alt="第01章_Java语言的跨平台性"></p>
<h5 id="7、C-C-源程序执行过程"><a href="#7、C-C-源程序执行过程" class="headerlink" title="7、C/C++源程序执行过程"></a>7、C/C++源程序执行过程</h5><p>编译过程又可以分成两个阶段：编译和汇编。</p>
<ul>
<li><strong>编译过程</strong>：是读取源程序(字符流)，对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码</li>
<li><strong>汇编过程</strong>：实际上指把汇编语言代码翻译成目标机器指令的过程。</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210425020914156.png" alt="image-20210425020914156"></p>
<h4 id="4、解释器"><a href="#4、解释器" class="headerlink" title="4、解释器"></a>4、解释器</h4><h5 id="1、解释器概述"><a href="#1、解释器概述" class="headerlink" title="1、解释器概述"></a>1、解释器概述</h5><p>JVM设计者们的初衷仅仅只是单纯地为了<strong>满足Java程序实现跨平台特性</strong>，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。</p>
<p>为什么需要字节码文件作为中间过渡，而不是采用将java源文件直接编译成对应的不同操作系统的机器指令的方式（此方式也可以实现跨平台）？</p>
<p>字节码文件是<strong>为了提高编译器的效率</strong>，同时也是Java虚拟机被称为<strong>跨语言的平台</strong>的基础。</p>
<p><img src="/2021/04/19/JVM/image-20210425021622259.png" alt="image-20210425021622259"></p>
<h5 id="2、解释器的工作机制（或工作任务）"><a href="#2、解释器的工作机制（或工作任务）" class="headerlink" title="2、解释器的工作机制（或工作任务）"></a>2、解释器的工作机制（或工作任务）</h5><ul>
<li>解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</li>
<li>当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</li>
</ul>
<h5 id="3、解释器分类"><a href="#3、解释器分类" class="headerlink" title="3、解释器分类"></a>3、解释器分类</h5><p>在Java的发展历史里，一共有两套解释执行器，即古老的<strong>字节码解释器</strong>、现在普遍使用的<strong>模板解释器</strong>。</p>
<ul>
<li>字节码解释器在执行时通过<strong>纯软件代码模拟字节码的执行</strong>，效率非常低下。</li>
<li>模板解释器将<strong>每一条字节码和一个模板函数相关联</strong>，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。<ul>
<li>在HotSpot VM中，解释器主要由<strong>Interpreter模块</strong>和<strong>Code模块</strong>构成。<ul>
<li>Interpreter模块：实现了解释器的<strong>核心功能</strong></li>
<li>Code模块：用于<strong>管理</strong>HotSpot VM在运行时生成的<strong>本地机器指令</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="4、解释器现状"><a href="#4、解释器现状" class="headerlink" title="4、解释器现状"></a>4、解释器现状</h5><ul>
<li>由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Perl、Ruby等。但是在今天，<strong>基于解释器执行已经沦落为低效的代名词</strong>，并且时常被一些<br>C/C++程序员所调侃。</li>
<li>为了解决这个问题，JVM平台支持一种叫作<strong>即时编译</strong>的技术。即时编译的目的是避免函数被解释执行，而是<strong>将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可</strong>，这种方式可以使执行效率大幅度提升。</li>
<li>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</li>
</ul>
<h4 id="5、JIT编译器"><a href="#5、JIT编译器" class="headerlink" title="5、JIT编译器"></a>5、JIT编译器</h4><h5 id="1、Java代码的执行分类"><a href="#1、Java代码的执行分类" class="headerlink" title="1、Java代码的执行分类"></a>1、Java代码的执行分类</h5><ol>
<li><p>第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行</p>
</li>
<li><p>第二种是编译执行(直接编译成机器码)。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT, Just In Time）将方法编译成机器码后再执行</p>
<p><img src="/2021/04/19/JVM/image-20210425022648722.png" alt="程序执行过程"></p>
</li>
</ol>
<ul>
<li>HotSpot VM是目前市面上高性能虚拟机的代表作之一。它采用<strong>解释器与即时编译器并存</strong>的架构。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代<br>码的时间和直接解释执行代码的时间。</li>
<li>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++程序一 较高下的地步。</li>
</ul>
<h5 id="2、为什么需要解释器？"><a href="#2、为什么需要解释器？" class="headerlink" title="2、为什么需要解释器？"></a>2、为什么需要解释器？</h5><p>有些开发人员会感觉到诧异，既然HotSpot VM中 已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢?比如JRockit VM内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。</p>
<p>首先明确：</p>
<p>当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。</p>
<p>总结成一句话：<strong>解释器的响应速度快，执行速度慢；而编译器的响应速度慢，执行速度快。</strong></p>
<p>所以：</p>
<p>尽管JRockit VM中程序的执行性能会非常高效，但<strong>程序在启动时必然需要花费更长的时间来进行编译</strong>。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。在此模式下，<strong>当Java 虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率</strong>。</p>
<p>同时，<strong>解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”</strong>。</p>
<h5 id="3、HotSpot-JVM-的执行方式"><a href="#3、HotSpot-JVM-的执行方式" class="headerlink" title="3、HotSpot JVM 的执行方式"></a>3、HotSpot JVM 的执行方式</h5><p>当虚拟机启动的时候，<strong>解释器可以首先发挥作用</strong>，而不必等待即时编译器全部编译完成再执行，这样可以<strong>省去许多不必要的编译时间</strong>。并且<strong>随着程序运行时间的推移，即时编译器逐渐发挥作用</strong>，根据<strong>热点探测功能</strong>，将<strong>有价值的字节码编译为本地机器指令，以换取更高的程序执行效率</strong>。</p>
<p>相关案例：</p>
<p>注意解释执行与编译执行在线上环境微妙的辩证关系。<strong>机器在热机状态可以承受的负载要大于冷机状态</strong>。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。</p>
<p>热机状态：已经启动很长时间；冷机状态：刚刚启动</p>
<p>在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的1/8。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的JVM均是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动之后，当前1/2发布成功的服务器马上全部宕机,此故障说明了JIT的存在。——阿里团队</p>
<p><img src="/2021/04/19/JVM/image-20210425024022961.png" alt="image-20210425024022961"></p>
<h5 id="4、JIT即时编译器"><a href="#4、JIT即时编译器" class="headerlink" title="4、JIT即时编译器"></a>4、JIT即时编译器</h5><h6 id="1、概念解释"><a href="#1、概念解释" class="headerlink" title="1、概念解释"></a>1、概念解释</h6><ul>
<li>Java语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器(其实叫“ 编译器的前端”更准确一些)把. java文件转变成.class文件的过程；</li>
<li>也可能是指虚拟机的后端运行期编译器(JIT编译器，Just In Time Compiler)把字节码转变成机器码的过程。</li>
<li>还可能是指使用静态提前编译器 (AOT编译器，Ahead Of Time Compiler) 直接把.java文件编译成本地机器代码的过程。</li>
</ul>
<p>相关的编译器：</p>
<ul>
<li>前端编译器：Sun的Javac、Eclipse JDT中的增量式编译器( ECJ)</li>
<li>JIT编译器：HotSpot VM的C1、C2编译器</li>
<li>AOT编译器：GNU Compiler for the Java (GCJ)、Excelsior JET。</li>
</ul>
<h6 id="2、是否选择使用编译器"><a href="#2、是否选择使用编译器" class="headerlink" title="2、是否选择使用编译器"></a>2、是否选择使用编译器</h6><p>热点代码及探测方式</p>
<p>当然是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被<strong>调用执行的频率</strong>而定。关于那些需要被编译为本地代码的字节码，也被称之为“<strong>热点代码</strong>”，JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出<strong>深度优化</strong>，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。</p>
<h6 id="3、热点代码及探测方式"><a href="#3、热点代码及探测方式" class="headerlink" title="3、热点代码及探测方式"></a>3、热点代码及探测方式</h6><ul>
<li><p><strong>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”</strong>，因此都可以通过<strong>JIT编译器编译为本地机器指令</strong>。由于这种编译方式发生在方法的执行过程中，因此也被称之为<strong>栈上替换</strong>，或简称为<strong>OSR (On Stack Replacement)编译</strong>。</p>
</li>
<li><p>一个方法究竟<strong>要被调用多少次</strong>，或者<strong>一个循环体究竟需要执行多少次</strong>循环才可以达到这个标准?</p>
<p>必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠<strong>热点探测功能</strong>。</p>
</li>
<li><p><strong>目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测</strong>。</p>
</li>
<li><p>采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为<strong>方法调用计数器</strong>(Invocation Counter)和<strong>回边计数器</strong>(BackEdge Counter) 。</p>
<ul>
<li><strong>方法调用计数器用于统计方法的调用次数</strong></li>
<li><strong>回边计数器则用于统计循环体执行的循环次数</strong></li>
</ul>
</li>
</ul>
<h6 id="4、方法调用计数器"><a href="#4、方法调用计数器" class="headerlink" title="4、方法调用计数器"></a>4、方法调用计数器</h6><ul>
<li><p>这个计数器就用于<strong>统计方法被调用的次数</strong>，它的默认阈值<strong>在Client模式下是1500次</strong>，<strong>在Server 模式下是10000 次</strong>。超过这个阈值，就会触发JIT编译。</p>
</li>
<li><p>这个阈值可以通过虛拟机参数<code>-XX:CompileThreshold</code>来人为设定。</p>
</li>
<li><p>当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断<strong>方法调用计数器与回边计数器值之和</strong>是否超过方法调用计数器的阈值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</p>
</li>
<li><p>方法调用计数器的工作流程图：</p>
<p><img src="/2021/04/19/JVM/image-20210425024857559.png" alt="image-20210425024857559"></p>
<p>简化版本：</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC12%E7%AB%A0_%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8.jpg" alt="第12章_方法调用计数器"></p>
</li>
<li><p>热度衰减</p>
<ul>
<li>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即<strong>一段时间之内方法被调用的次数</strong>。当超过<strong>一定的时间限度</strong>，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被<strong>减少一半</strong>，这个过程称为<strong>方法调用计数器热度的衰减</strong>(Counter Decay) ，而这段时间就称为此方法统计的<strong>半衰周期</strong>(Counter Half Life Time) 。</li>
<li>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数<code>-XX:UseCounterDecay</code>来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</li>
<li>另外，可以使用<code>-XX:CounterHalfLifeTime</code> 参数设置半衰周期的时间，单位是秒。</li>
</ul>
</li>
</ul>
<h6 id="5、回边计数器"><a href="#5、回边计数器" class="headerlink" title="5、回边计数器"></a>5、回边计数器</h6><ul>
<li><p>它的作用是统计一个方法中<strong>循环体代码执行的次数</strong>，在字节码中遇到控制流向后跳转的指令称为“回边” (Back Edge) 。显然，建立回边计数器统计的目的就是为了<strong>触发OSR编译</strong>。</p>
</li>
<li><p>回边计数器的执行流程图：</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC12%E7%AB%A0_%E5%9B%9E%E8%BE%B9%E8%AE%A1%E6%95%B0%E5%99%A8.jpg" alt="第12章_回边计数器"></p>
</li>
</ul>
<h6 id="6、HotSpot-VM可以设置程序执行方式"><a href="#6、HotSpot-VM可以设置程序执行方式" class="headerlink" title="6、HotSpot VM可以设置程序执行方式"></a>6、HotSpot VM可以设置程序执行方式</h6><p>缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是<strong>完全采用解释器执行</strong>，还是<strong>完全采用即时编译器执行</strong>。如下所示：</p>
<ul>
<li><p><code>-Xint</code>：完全采用解释器模式执行程序；</p>
</li>
<li><p><code>-Xcomp</code>： 完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行。</p>
</li>
<li><p><code>-Xmixed</code>：采用解释器+即时编译器的混合模式共同执行程序。（默认）</p>
<p><img src="/2021/04/19/JVM/image-20210425031931789.png" alt="image-20210425031931789"></p>
</li>
</ul>
<h6 id="7、HotSpot-VM中JIT分类"><a href="#7、HotSpot-VM中JIT分类" class="headerlink" title="7、HotSpot VM中JIT分类"></a>7、HotSpot VM中JIT分类</h6><p>在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称为<strong>C1编译器</strong>和<strong>C2编译器</strong>。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p>
<ul>
<li><p><code>-client</code>：指定Java虚拟机运行在Client模式下，并使用C1编译器；</p>
<ul>
<li>C1编译器会对字节码进行<strong>简单和可靠的优化</strong>，<strong>耗时短</strong>。以达到更快的编译速度。</li>
</ul>
</li>
<li><p><code>-server</code>：指定Java虚拟机运行在Server模式下，并使用C2编译器。（对于84位的操作系统默认就是Srver模式，不能修改）</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">官方</a>：</p>
<p><img src="/2021/04/19/JVM/image-20210425030403484.png" alt="image-20210425030403484"></p>
<p><img src="/2021/04/19/JVM/image-20210425030645445.png" alt="image-20210425030645445"></p>
<ul>
<li>C2进行<strong>耗时较长的优化，以及激进优化</strong>。但优化的代码执行效率更高。</li>
</ul>
</li>
</ul>
<p><strong>分层编译(Tiered Compilation)策略</strong>：程序解释执行(不开启性能监控)可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。</p>
<p>不过在Java7版本之后，一旦开发人员在程序中显式指定命令“-server”时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。</p>
<p><strong>C1和C2编译器不同的优化策略：</strong></p>
<ul>
<li>在不同的编译器上有不同的优化策略，C1骗译器上主要有<strong>方法内联</strong>，<strong>去虚拟化</strong>、<strong>冗余消除</strong>。<ul>
<li>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</li>
<li>去虚拟化：对唯一的实现类进行内联</li>
<li>冗余消除：在运行期间把一些不会执行的代码折叠掉</li>
</ul>
</li>
<li>C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化：<ul>
<li>标量替换：用标量值代替聚合对象的属性值</li>
<li>栈上分配：对于未逃逸的对象分配对象在栈而不是堆</li>
<li>同步消除：清除同步操作，通常指synchronized</li>
</ul>
</li>
</ul>
<p>总结:</p>
<ul>
<li>一般来讲，<strong>JIT编译出来的机器码性能比解释器高</strong>。</li>
<li>C2编译器启动时长比C1编译器慢，系统稳定执行以后，C2编译器执行速度远远快于C1编译器。</li>
</ul>
<h6 id="8、最后补充"><a href="#8、最后补充" class="headerlink" title="8、最后补充"></a>8、最后补充</h6><ul>
<li>关于C1与C2：<ul>
<li>自JDK10起，HotSpot又加入一个全新的即时编译器：<strong>Graal编译器</strong>。</li>
<li>编译效果短短几年时间就追评了C2编译器。未来可期。</li>
<li>目前，带着“实验状态”标签，需要使用开关参数去激活，才可以使用。<ul>
<li><code>-XX: +UnlockExperimentalVMOptions</code> </li>
<li><code>-XX: +UseJVMCICompiler</code></li>
</ul>
</li>
</ul>
</li>
<li>关于AOT编译器：（AOT VS JIT）<ul>
<li>jdk9引入了AOT编译器(静态提前编译器，Ahead Of Time Compiler)</li>
<li>Java 9引入了实验性AOT编译工具<strong>jaotc</strong>。它借助了Graal编译器，将所输入的Java类文件转换为机器码，并存放至生成的动态共享库之中。</li>
<li>所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在<strong>程序的运行过程中</strong>，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，在<strong>程序运行之前</strong>，便将字节码转换为机器码的过程。<ul>
<li>.java -&gt; .class -(jaotc)-&gt; .so(机器指令)</li>
</ul>
</li>
<li>最大好处：Java虛拟机加载已经预编译成二进制库，可以直接执行。不必等待即时编译器的预热，减少Java应用给人带来“第一次运行慢”的不良体验</li>
<li>缺点:<ul>
<li>破坏了java“一次编译，到处运行”，必须为每个不同硬件、os编译对应的发行包。</li>
<li><strong>降低了Java链接过程的动态性</strong>，加载的代码在编译期就必须全部已知。</li>
<li>还需要继续优化中，最初只支持Linux x64 java base</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="13、String-Table"><a href="#13、String-Table" class="headerlink" title="13、String Table"></a>13、String Table</h3><h4 id="1、String的基本特性"><a href="#1、String的基本特性" class="headerlink" title="1、String的基本特性"></a>1、String的基本特性</h4><ul>
<li><p>String：字符串，使用一对<code>&quot;&quot;</code>引起来表示。</p>
<ul>
<li><pre><code class="java">// 字面量的方式
String str = &quot;Hello&quot;;
// new的方式
String string = new String(&quot;Hi&quot;);
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- String声明为final的，**不可被继承**</span><br><span class="line"></span><br><span class="line">- String实现了Serializable接口：表示字符串是**支持序列化**的</span><br><span class="line"></span><br><span class="line">- String实现了Comparable接口：表示String可以**比较大小**</span><br><span class="line"></span><br><span class="line">- String在JDK8及以前内部定义了final char[] value用于存储字符串数据。**JDK9时改为byte[]**</span><br><span class="line"></span><br><span class="line">  - [官方](http:&#x2F;&#x2F;openjdk.java.net&#x2F;jeps&#x2F;254</span><br><span class="line">    )：</span><br><span class="line"></span><br><span class="line">    ![image-20210425194526787](JVM&#x2F;image-20210425194526787.png)</span><br><span class="line"></span><br><span class="line">    ![image-20210425201622470](JVM&#x2F;image-20210425201622470.png)</span><br><span class="line"></span><br><span class="line">- String：代表不可变的字符序列。简称：不可变性</span><br><span class="line"></span><br><span class="line">  - 当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值</span><br><span class="line">  - 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值</span><br><span class="line">  - 当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</span><br><span class="line"></span><br><span class="line">- 通过字面量的方式（区别与new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</span><br><span class="line"></span><br><span class="line">- 字符串常量池中是不会存储相同内容的字符串的</span><br><span class="line"></span><br><span class="line">  - String的String Pool时一个固定大小的Hashtable，默认值大小长度是1009。如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长。而链表长了后直接会造成的影响就是当调用String.intern时性能会大幅下降。</span><br><span class="line">  - 使用&#96;-XX: StringTableSize&#96;可设置StringTable的长度</span><br><span class="line">  - 在JDK6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多的就会导致效率下降很快。StringTableSize设置没有要求</span><br><span class="line">  - 在JDK7中，StringTable的长度默认值是60013，StringTableSize设置没有要求</span><br><span class="line">  - 在JDK8开始，设置StringTable的长度的话，1009是可设置的最小值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 2、String的内存分配</span><br><span class="line"></span><br><span class="line">- 在Java语言中有8种基本数据类型和一种比较特殊的类型String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。</span><br><span class="line"></span><br><span class="line">- 常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，**String类型的常量池比较特殊。它的主要使用方法有两种**：</span><br><span class="line"></span><br><span class="line">  - 直接使用双引号&#96;&quot;&quot;&#96;声明出来的String对象会直接存储在常量池中。</span><br><span class="line"></span><br><span class="line">    - &#96;&#96;&#96;java</span><br><span class="line">      String info &#x3D; &quot;Hello&quot;</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>如果不是用双引号<code>&quot;&quot;</code>声明的String对象，可以使用String提供的intern()方法。</p>
</li>
</ul>
</li>
<li><p><strong>Java6及以前，字符串常量池存放在永久代</strong>。</p>
</li>
<li><p>Java7中Oracle的工程师对字符串池的逻辑做了很大的改变，即将<strong>字符串常量池的位置调整到Java堆内</strong>。</p>
<ul>
<li><p>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。</p>
</li>
<li><p>字符串常量池概念原本使用比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java7中使用String.intern()。</p>
</li>
<li><p>Java8元空间，字符串常量池在堆</p>
<p><img src="/2021/04/19/JVM/image-20210425213811970.png" alt="image-20210425213811970"></p>
</li>
</ul>
</li>
<li><p>为什么StringTable要调整？</p>
<ul>
<li>permSize默认比较小</li>
<li>永久代垃圾回收的频率低</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.oracle.com/technetwork/java/javase/jdk7-relnotes-418459.html#jdk7changes">官网</a>：</p>
<p><img src="/2021/04/19/JVM/image-20210425214013347.png" alt="image-20210425214013347"></p>
</li>
</ul>
<h4 id="3、String的基本操作"><a href="#3、String的基本操作" class="headerlink" title="3、String的基本操作"></a>3、String的基本操作</h4><p>Java语言规范里要求<strong>完全相同的字符串字面量</strong>，应该包含同样的Unicode字符序列（包含同一份码点序列的常量），并且<strong>必须是指向同一个String类实例</strong>。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;<span class="comment">//line 1</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;<span class="comment">//line 2</span></span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();<span class="comment">//line 3</span></span><br><span class="line">        Memory mem = <span class="keyword">new</span> Memory();<span class="comment">//line 4</span></span><br><span class="line">        mem.foo(obj);<span class="comment">//line 5</span></span><br><span class="line">    &#125;<span class="comment">//line 9</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Object param)</span> </span>&#123;<span class="comment">//line 6</span></span><br><span class="line">        String str = param.toString();<span class="comment">//line 7</span></span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;<span class="comment">//line 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/19/JVM/image-20210425215451317.png" alt="image-20210425215451317"></p>
<p>A string is created in line 7.it goes in the String Pool in the heap space and a reference is created in the foo() stack space for it.</p>
<h4 id="4、字符串拼接操作"><a href="#4、字符串拼接操作" class="headerlink" title="4、字符串拼接操作"></a>4、字符串拼接操作</h4><ol>
<li>常量与插入的拼接结果在常量池，原理是<strong>编译期优化</strong></li>
<li>常量池中不会存在相同内容的常量</li>
<li>只要其中有一个是变量，结果就在堆（非字符串常量池）中。变量拼接原理是<strong>StringBuilder</strong>（底层新建了一个StringBuilder对象进行字符串拼接）</li>
<li>如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址。</li>
</ol>
<p>相关案例：</p>
<p>总结：</p>
<ul>
<li><p>如果拼接符号的前后出现了变量，则相当于在堆空间中new String()，具体的内容为拼接的结果</p>
</li>
<li><p>intern():判断字符串常量池中是否存在javaEEhadoop值，如果存在，则返回常量池中javaEEhadoop的地址；如果字符串常量池中不存在javaEEhadoop，则在常量池中加载一份javaEEhadoop，并返回次对象的地址。</p>
</li>
<li><p>如下的s1 + s2 的执行细节：(变量s是我临时定义的）</p>
<ul>
<li><p>StringBuilder s = new StringBuilder();</p>
</li>
<li><p>s.append(“a”)</p>
</li>
<li><p>s.append(“b”)</p>
</li>
<li><p>s.toString()  –&gt; 约等于 new String(“ab”)</p>
<p>StringBuilder的toString()方法的new里面放的是char数组，不会在常量池创建对，而new String(“ab”)这里放的是字面量，会先在常量池创对象</p>
</li>
</ul>
<p>补充：在jdk5.0之后使用的是StringBuilder,在jdk5.0之前使用的是StringBuffer</p>
</li>
<li><p>字符串拼接操作不一定使用的是StringBuilder!</p>
<ul>
<li>如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译期优化，即非StringBuilder的方式。</li>
</ul>
</li>
<li><p>针对于final修饰类、方法、基本数据类型、引用数据类型的量的结构时，能使用上final的时候建议使用上。</p>
<p>final修饰的变量一旦赋值后就不能再次赋值，所以可以做编译期优化，但是如果使用final String s = new String(“a”)；则不会做编译期优化，必须运行时才能确定。</p>
</li>
<li><p>体会执行效率：通过StringBuilder的append()的方式添加字符串的效率要远高于使用String的字符串拼接方式！</p>
<ul>
<li><p>详情：</p>
<ul>
<li>StringBuilder的append()的方式：自始至终中只创建过一个StringBuilder的对象</li>
<li>使用String的字符串拼接方式：创建过多个StringBuilder和String的对象</li>
<li>使用String的字符串拼接方式：内存中由于创建了较多的StringBuilder和String的对象，内存占用更大；如果进行GC，需要花费额外的时间。</li>
</ul>
</li>
<li><p>改进的空间：在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值highLevel的情况下,建议使用构造器实例化：</p>
<p>StringBuilder s = new StringBuilder(highLevel);//new char[highLevel]</p>
</li>
</ul>
</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest5</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;<span class="comment">//编译期优化：等同于&quot;abc&quot;</span></span><br><span class="line">        String s2 = <span class="string">&quot;abc&quot;</span>; <span class="comment">//&quot;abc&quot;一定是放在字符串常量池中，将此地址赋给s2</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 最终.java编译成.class,再执行.class</span></span><br><span class="line"><span class="comment">         * String s1 = &quot;abc&quot;;</span></span><br><span class="line"><span class="comment">         * String s2 = &quot;abc&quot;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(s1 == s2); <span class="comment">//true</span></span><br><span class="line">        System.out.println(s1.equals(s2)); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"></span><br><span class="line">        String s3 = <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">        String s4 = <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;<span class="comment">//编译期优化</span></span><br><span class="line">        <span class="comment">//如果拼接符号的前后出现了变量，则相当于在堆空间中new String()，具体的内容为拼接的结果：javaEEhadoop</span></span><br><span class="line">        String s5 = s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">        String s6 = <span class="string">&quot;javaEE&quot;</span> + s2;</span><br><span class="line">        String s7 = s1 + s2;</span><br><span class="line"></span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">        System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s3 == s6);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s3 == s7);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s5 == s6);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s5 == s7);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s6 == s7);<span class="comment">//false</span></span><br><span class="line">        <span class="comment">//intern():判断字符串常量池中是否存在javaEEhadoop值，如果存在，则返回常量池中javaEEhadoop的地址；</span></span><br><span class="line">        <span class="comment">//如果字符串常量池中不存在javaEEhadoop，则在常量池中加载一份javaEEhadoop，并返回次对象的地址。</span></span><br><span class="line">        String s8 = s6.intern();</span><br><span class="line">        System.out.println(s3 == s8);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        String s3 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        如下的s1 + s2 的执行细节：(变量s是我临时定义的）</span></span><br><span class="line"><span class="comment">        ① StringBuilder s = new StringBuilder();</span></span><br><span class="line"><span class="comment">        ② s.append(&quot;a&quot;)</span></span><br><span class="line"><span class="comment">        ③ s.append(&quot;b&quot;)</span></span><br><span class="line"><span class="comment">        ④ s.toString()  --&gt; 约等于 new String(&quot;ab&quot;)</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        补充：在jdk5.0之后使用的是StringBuilder,在jdk5.0之前使用的是StringBuffer</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String s4 = s1 + s2;<span class="comment">//</span></span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 字符串拼接操作不一定使用的是StringBuilder!</span></span><br><span class="line"><span class="comment">       如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译期优化，即非StringBuilder的方式。</span></span><br><span class="line"><span class="comment">    2. 针对于final修饰类、方法、基本数据类型、引用数据类型的量的结构时，能使用上final的时候建议使用上。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String s1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        String s3 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        String s4 = s1 + s2;</span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//练习：</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">        String s3 = s2 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s3);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String s4 = <span class="string">&quot;javaEE&quot;</span>;<span class="comment">//s4:常量</span></span><br><span class="line">        String s5 = s4 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s5);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    体会执行效率：通过StringBuilder的append()的方式添加字符串的效率要远高于使用String的字符串拼接方式！</span></span><br><span class="line"><span class="comment">    详情：① StringBuilder的append()的方式：自始至终中只创建过一个StringBuilder的对象</span></span><br><span class="line"><span class="comment">           使用String的字符串拼接方式：创建过多个StringBuilder和String的对象</span></span><br><span class="line"><span class="comment">         ② 使用String的字符串拼接方式：内存中由于创建了较多的StringBuilder和String的对象，内存占用更大；如果进行GC，需要花费额外的时间。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     改进的空间：在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值highLevel的情况下,建议使用构造器实例化：</span></span><br><span class="line"><span class="comment">               StringBuilder s = new StringBuilder(highLevel);//new char[highLevel]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="comment">//        method1(100000);//4014</span></span><br><span class="line">        method2(<span class="number">100000</span>);<span class="comment">//7</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> highLevel)</span></span>&#123;</span><br><span class="line">        String src = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; highLevel;i++)&#123;</span><br><span class="line">            src = src + <span class="string">&quot;a&quot;</span>;<span class="comment">//每次循环都会创建一个StringBuilder、String</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(src);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(<span class="keyword">int</span> highLevel)</span></span>&#123;</span><br><span class="line">        <span class="comment">//只需要创建一个StringBuilder</span></span><br><span class="line">        StringBuilder src = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; highLevel; i++) &#123;</span><br><span class="line">            src.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(src);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/19/JVM/image-20210425221328973.png" alt="image-20210425221328973"></p>
<p><img src="/2021/04/19/JVM/image-20210425221607026.png" alt="image-20210425221607026"></p>
<p><img src="/2021/04/19/JVM/image-20210425221622886.png" alt="image-20210425221622886"></p>
<p><img src="/2021/04/19/JVM/image-20210425221651006.png" alt="image-20210425221651006"></p>
<p>StringBuilder执行拼接操作：</p>
<ul>
<li>好处：从始至终就创建了一个stringBuilder对象去执行append操作</li>
<li>改进空间：<ul>
<li>可以使用StringBuilder的带参数的构造器，指定大小</li>
<li>如果调用默认构造器，初始容量16，进行大量存储操作时，会导致频繁扩容(数组大小是不可变的,所以得新建数组，然后进行数组间的copy，中间也会产生垃级对象，耗时耗力。</li>
</ul>
</li>
</ul>
<h4 id="5、intern-的使用"><a href="#5、intern-的使用" class="headerlink" title="5、intern()的使用"></a>5、intern()的使用</h4><h5 id="1、Java-lang-String-intern-的相关解释"><a href="#1、Java-lang-String-intern-的相关解释" class="headerlink" title="1、Java.lang.String.intern()的相关解释"></a>1、Java.lang.String.intern()的相关解释</h5><p><img src="/2021/04/19/JVM/image-20210426012219855.png" alt="image-20210426012219855"></p>
<h5 id="2、intern-的使用"><a href="#2、intern-的使用" class="headerlink" title="2、intern()的使用"></a>2、intern()的使用</h5><p>如果不是用双引号声明的String对象，可以使用String提供的intern方法: intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。</p>
<ul>
<li><p>比如：</p>
<ul>
<li><pre><code class="java">String myInfo = new String(&quot;I love atguigu&quot;).intern();
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 也就是说，如果在任意字符串上调用String.intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是true：</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;java</span><br><span class="line">    (&quot;a&quot; + &quot;b&quot; + &quot;c&quot;).intern() &#x3D;&#x3D; &quot;abc&quot;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p>通俗点讲，Interned String就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池(String Intern Pool)。</p>
</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210426020658942.png" alt="image-20210426020658942"></p>
<ul>
<li>如何保证变量s指向的是字符串常量池中的数据呢？<ul>
<li>有两种方式：<ul>
<li>方式一： String s = “shkstart”;//字面量定义的方式</li>
<li>方式二： 调用intern()<ul>
<li><pre><code>    String s = new String(&quot;shkstart&quot;).intern();</code></pre>
</li>
<li><pre><code>    String s = new StringBuilder(&quot;shkstart&quot;).toString().intern();</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="3、面试题题目-new-String-“ab”-会创建几个对象-拓展-new-String-“a”-new-String-“b”-呢"><a href="#3、面试题题目-new-String-“ab”-会创建几个对象-拓展-new-String-“a”-new-String-“b”-呢" class="headerlink" title="3、面试题题目: new String(“ab”) 会创建几个对象?    拓展: new String(“a”) + new String (“b”)呢?"></a>3、面试题题目: new String(“ab”) 会创建几个对象?    拓展: new String(“a”) + new String (“b”)呢?</h5><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringNewTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        String str = new String(&quot;ab&quot;);</span></span><br><span class="line"></span><br><span class="line">        String str = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目： new String(“ab”) 会创建几个对象?</p>
<ul>
<li>new String(“ab”)会创建几个对象？看字节码，就知道是两个。<ul>
<li>一个对象是：new关键字在堆空间创建的</li>
<li>另一个对象是：字符串常量池中的对象”ab”。 字节码指令：ldc</li>
</ul>
</li>
</ul>
<p>拓展: new String(“a”) + new String (“b”)呢?</p>
<ul>
<li>看字节码，知道是五个对象<ul>
<li>对象1：new StringBuilder()</li>
<li>对象2： new String(“a”)</li>
<li>对象3： 常量池中的”a”</li>
<li>对象4： new String(“b”)</li>
<li>对象5： 常量池中的”b”</li>
</ul>
</li>
<li>深入剖析： StringBuilder的toString():<ul>
<li>对象6 ：new String(“ab”)</li>
</ul>
</li>
<li>强调一下，toString()的调用（底层用的是char[]数组创建的字符串），在字符串常量池中，没有生成”ab”</li>
</ul>
<h5 id="4、intern-的使用-jdk6-vs-jdk7-8"><a href="#4、intern-的使用-jdk6-vs-jdk7-8" class="headerlink" title="4、intern()的使用: jdk6 vs jdk7/8"></a>4、intern()的使用: jdk6 vs jdk7/8</h5><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如何保证变量s指向的是字符串常量池中的数据呢？</span></span><br><span class="line"><span class="comment"> * 有两种方式：</span></span><br><span class="line"><span class="comment"> * 方式一： String s = &quot;shkstart&quot;;//字面量定义的方式</span></span><br><span class="line"><span class="comment"> * 方式二： 调用intern()</span></span><br><span class="line"><span class="comment"> *         String s = new String(&quot;shkstart&quot;).intern();</span></span><br><span class="line"><span class="comment"> *         String s = new StringBuilder(&quot;shkstart&quot;).toString().intern();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringIntern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        s.intern();<span class="comment">//调用此方法之前，字符串常量池中已经存在了&quot;1&quot;</span></span><br><span class="line">        String s2 = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        System.out.println(s == s2);<span class="comment">//jdk6：false   jdk7/8：false</span></span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);<span class="comment">//s3变量记录的地址为：new String(&quot;11&quot;)</span></span><br><span class="line">        <span class="comment">//执行完上一行代码以后，字符串常量池中，是否存在&quot;11&quot;呢？答案：不存在！！</span></span><br><span class="line">        s3.intern();<span class="comment">//在字符串常量池中生成&quot;11&quot;。如何理解：jdk6:创建了一个新的对象&quot;11&quot;,也就有新的地址。</span></span><br><span class="line">                                            <span class="comment">//         jdk7:此时常量中并没有创建&quot;11&quot;,而是创建一个指向堆空间中new String(&quot;11&quot;)的地址</span></span><br><span class="line">        String s4 = <span class="string">&quot;11&quot;</span>;<span class="comment">//s4变量记录的地址：使用的是上一行代码代码执行时，在常量池中生成的&quot;11&quot;的地址</span></span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//jdk6：false  jdk7/8：true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于s3 == s4在JDK6 与 JDK7/8中答案不同的解析：</p>
<ul>
<li><p>JDK6：在JDK6中，字符串常量池是放在永久代中</p>
<ul>
<li><p>执行到String s3 = new String(“1”) + new String(“1”);的时候，程序在堆空间创建了一片空间用来存放字符串”11”，局部变量s3里存放着字符串”11”在堆空间当中的地址。</p>
<p>注意：此时的字符串常量池中并不存在字符串”11”（底层调用了StringBuilder的toString()方法，其中的new String使用char[]数组的方式创建了字符串”11”）</p>
</li>
<li><p>执行到s3.intern();的时候，intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。然而字符串常量池当中并不存在字符串”11”。所以，程序在字符串常量池中生成”11”对象。</p>
</li>
<li><p>执行到String s4 = “11”;的时候，由于在字符串常量池中存在了字符串”11”，所以局部变量s4里存放了字符串”11”在字符串常量池当中的引用（即地址）</p>
</li>
<li><p>由于变量s3的引用是堆当中字符串对象”11”的地址，而变量s4的引用是字符串常量池中字符串”11”的地址。两者并不相等。</p>
</li>
</ul>
</li>
<li><p>JDK7/8：在JDK7/8中，字符串常量池放在堆中</p>
<ul>
<li>执行String s3 = new String(“1”) + new String(“1”);与上面描述的一样</li>
<li>执行到s3.intern();的时候，由于字符串常量池是存放在堆空间当中，而字符串”11”对象也在堆空间，所以intern()方法在字符串常量池中创建字符串”11”的时候，直接将堆空间中的字符串”11”的地址存放进了字符串常量池的字符串”11”对象当中，即字符串常量池中存放的是堆空间中字符串”11”的引用。即变量s3的引用也指向了字符串常量池的字符串”11”</li>
<li>代码执行到String s4 = “11”;的时候，由于在字符串常量池中存在了字符串”11”，所以局部变量s4里存放了字符串”11”在字符串常量池当中的引用（即地址），然而字符串常量池中的字符串”11”存放的是堆空间的字符串”11”的地址。即：变量s4的引用也指向了堆空间在的字符串”11”的地址</li>
<li>这样一来堆空间与字符串常量池存放的字符串”11”为同一个对象。因此变量s3与变量s4指向的都是同一个地址，使用两者相等。</li>
</ul>
</li>
</ul>
<p>JDK6的执行图：</p>
<p><img src="/2021/04/19/JVM/image-20210426022637283.png" alt="image-20210426022637283"></p>
<p>JDK7的执行图：</p>
<p><img src="/2021/04/19/JVM/image-20210426022851422.png" alt="image-20210426022851422"></p>
<p>对上面案例在进行扩展：</p>
<p>代码：将 String s4 = “11”; 与 String s5 = s3.intern(); 执行顺序进行互换，并使用s5接收返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringIntern1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//StringIntern.java中练习的拓展：</span></span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);<span class="comment">//new String(&quot;11&quot;)</span></span><br><span class="line">        <span class="comment">//执行完上一行代码以后，字符串常量池中，是否存在&quot;11&quot;呢？答案：不存在！！</span></span><br><span class="line">        String s4 = <span class="string">&quot;11&quot;</span>;<span class="comment">//在字符串常量池中生成对象&quot;11&quot;</span></span><br><span class="line">        String s5 = s3.intern();<span class="comment">//intern方法会从字符串常量池中查询当前字符串是否存在，若存在就会返回该字符串的引用(地址)</span></span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s5 == s4);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5、总结String的intern-方法的使用"><a href="#5、总结String的intern-方法的使用" class="headerlink" title="5、总结String的intern()方法的使用"></a>5、总结String的intern()方法的使用</h5><ul>
<li>jdk1. 6中,将这个字符串对象尝试放入串池。<ul>
<li>如果字符串常量池中有，则并不会放入。返回已有的字符串常量池中的对象的地址</li>
<li>如果没有，会把<strong>此对象复制一份</strong>(<strong>新建对象</strong>)，放入字符串常量池，并返回字符串常量池中的对象地址</li>
</ul>
</li>
<li>Jdk1.7起，将这个字符串对象尝试放入串池。<ul>
<li>如果字符串常量池中有，则并不会放入。返回已有的字符串常量池中的对象的地址</li>
<li>如果没有，则会<strong>把对象的引用地址复制一份</strong>(<strong>没有新建对象</strong>)，放入字符串常量池，并返回字符串常量池中的引用地址</li>
</ul>
</li>
</ul>
<h5 id="6、关于intern-方法的两道练习"><a href="#6、关于intern-方法的两道练习" class="headerlink" title="6、关于intern()方法的两道练习"></a>6、关于intern()方法的两道练习</h5><h6 id="1、练习1"><a href="#1、练习1" class="headerlink" title="1、练习1:"></a>1、练习1:</h6><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExer1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//String x = &quot;ab&quot;;</span></span><br><span class="line">        String s = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);<span class="comment">//new String(&quot;ab&quot;)</span></span><br><span class="line">        <span class="comment">//在上一行代码执行完以后，字符串常量池中并没有&quot;ab&quot;</span></span><br><span class="line"></span><br><span class="line">        String s2 = s.intern();<span class="comment">//jdk6中：在串池中创建一个字符串&quot;ab&quot;</span></span><br><span class="line">                               <span class="comment">//jdk8中：串池中没有创建字符串&quot;ab&quot;,而是创建一个引用，指向new String(&quot;ab&quot;)，将此引用返回</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s2 == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:true  jdk8:true</span></span><br><span class="line">        System.out.println(s == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:false  jdk8:true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图示：</p>
<p><img src="/2021/04/19/JVM/image-20210426032250932.png" alt="image-20210426032250932"></p>
<p>放开 String x = “ab”; 注释之后的图示：</p>
<p><img src="/2021/04/19/JVM/image-20210426032752667.png" alt="image-20210426032752667"></p>
<h6 id="2、练习2"><a href="#2、练习2" class="headerlink" title="2、练习2"></a>2、练习2</h6><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExer2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>);<span class="comment">//执行完以后，会在字符串常量池和堆空间中都会生成&quot;ab&quot;，不同对象。s1指向的是堆空间当中的字符串&quot;abc&quot;</span></span><br><span class="line"><span class="comment">//        String s1 = new String(&quot;a&quot;) + new String(&quot;b&quot;);////执行完以后，在堆空间中会生成字符串&quot;abc&quot;，但不会在字符串常量池中会生成&quot;ab&quot;</span></span><br><span class="line">        s1.intern();</span><br><span class="line">        String s2 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//在jdk7：false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7、使用intern-测试执行效率：空间角度的使用上"><a href="#7、使用intern-测试执行效率：空间角度的使用上" class="headerlink" title="7、使用intern()测试执行效率：空间角度的使用上"></a>7、使用intern()测试执行效率：空间角度的使用上</h5><p>两种方式创建字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr[i] = <span class="keyword">new</span> String(String.valueOf(data[i % data.length]));</span><br><span class="line"></span><br><span class="line">arr[i] = <span class="keyword">new</span> String(String.valueOf(data[i % data.length])).intern();</span><br></pre></td></tr></table></figure>

<p>结论：对于程序中<strong>大量存在的字符串</strong>，尤其其中存在很多<strong>重复</strong>字符串时，<strong>使用intern()可以节省内存空间</strong>。</p>
<p>应用场景：</p>
<p>大的网站平台，需要内存中存储大量的字符串。比如社交网站，很多人都存储:北京市、海淀区等信息。这时候如果字符串都调用intern()方法，就会明显降低内存的大小。</p>
<h4 id="6、StringTable的垃圾回收"><a href="#6、StringTable的垃圾回收" class="headerlink" title="6、StringTable的垃圾回收"></a>6、StringTable的垃圾回收</h4><p>使用new String()的方式和使用new String().intern()的方式创建字符串都会在堆与字符串常量池创建字符串对象，但是为什么在存在大量重复的字符串的时候使用intern()会更节省内存空间呢？ =》 答案：StringTable存在垃圾回收。</p>
<ul>
<li>使用new String()的方式创建字符串不仅仅会在字符串常量池当中创建字符串对象（不重复），还会在堆空间当中创建大量的字符串对象（存在重复），这些堆空间的字符串对象都有一个变量的引用指向，GC不会进行垃圾回收。</li>
<li>使用new String().intern()的方式创建字符串虽然也会在堆空间和字符串常量池创建字符串对象，但是局部变量的指向的是字符串常量池的字符串对象，堆空间的字符串对象虽然也被创建了，但是没有变量的引用指向，会被GC回收。</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210426115438284.png" alt="image-20210426115438284"></p>
<h4 id="7、G1的String去重操作"><a href="#7、G1的String去重操作" class="headerlink" title="7、G1的String去重操作"></a>7、G1的String去重操作</h4><p><a target="_blank" rel="noopener" href="http://openjdk.java.netjeps/192">官网</a></p>
<ul>
<li>背景：对许多Java应用(有大的也有小的)做的测试得出以下结果：<ul>
<li>堆存活数据集合里面String对象占了25%</li>
<li>堆存活数据集合里面重复的String对象有13.5%</li>
<li>String对象的平均长度是45</li>
</ul>
</li>
<li>许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，<strong>Java堆中存活的数据集合差不多25%是String对象</strong>。更进一步，这里面差不多一半string对象是重复的，重复的意思是说：string1.equals(string2)=true。<strong>堆上存在重复的String对象必然是一种内存的浪费</strong>。这个项目将在G1垃圾收集器中实现自动持续对重复的String对象进行去重，这样就能避免浪费内存。</li>
<li>实现<ul>
<li>当垃圾收集器工作的时候，会访问堆上存活的对象。<strong>对每一个访问的对象都会检查是否是候选的要去重的String对象</strong>。</li>
<li>如果是，把这个对象的一个引用插入到<strong>队列</strong>中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的String对象。</li>
<li>使用一个<strong>hashtable来记录所有的被String对象使用的不重复的char数组</strong>。当去重的时候，会查这个hashtable，来看堆上是否已经存在一个一模一样的char数组。</li>
<li>如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</li>
<li>如果查找失败，<strong>char数组会被插入到hashtable，这样以后的时候就可以共享这个数组了</strong>。</li>
</ul>
</li>
<li>命令行选项<ul>
<li>UseStringDeduplication(bool)：开启String去重，<strong>默认是不开启的，需要手动开启</strong>。</li>
<li>PrintStringDeduplicationStatistics(bool)：打印详细的去重统计信息</li>
<li>StringDeduplicationAgeThreshold(uintx)：达到这个年龄的String对象被认为是去重的候选对象</li>
</ul>
</li>
</ul>
<hr>
<h3 id="14、垃圾回收概述"><a href="#14、垃圾回收概述" class="headerlink" title="14、垃圾回收概述"></a>14、垃圾回收概述</h3><ul>
<li>垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。</li>
<li>关于垃圾收集有三个经典问题：<ul>
<li>哪些内存需要回收?</li>
<li>什么时候回收?</li>
<li>如何回收?</li>
</ul>
</li>
<li>垃圾收集机制是Java的招牌能力，<strong>极大地提高了开发效率</strong>。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。</li>
</ul>
<h4 id="1、什么是垃圾"><a href="#1、什么是垃圾" class="headerlink" title="1、什么是垃圾"></a>1、什么是垃圾</h4><ul>
<li>什么是垃圾( Garbage) 呢<ul>
<li>垃圾是指<strong>在运行程序中没有任何指针指向的对象</strong>，这个对象就是需要被回收的垃圾。</li>
<li>外文: An object is considered garbage when it can no longer be reached from any pointer in the running program.</li>
</ul>
</li>
<li>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致<strong>内存溢出</strong>。</li>
<li>内存溢出：存在引用指向不再被使用的对象，导致该对象无法被回收。比如匿名内部类存在指向外部类的引用等等。</li>
</ul>
<h4 id="2、为什么需要GC"><a href="#2、为什么需要GC" class="headerlink" title="2、为什么需要GC"></a>2、为什么需要GC</h4><ul>
<li>对于高级语言来说，一个基本认知是如果不进行垃圾回收，<strong>内存迟早都会被消耗完</strong>，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</li>
<li>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便<strong>JVM将整理出的内存分配给新的对象</strong>。</li>
<li>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，<strong>没有GC就不能保证应用程序的正常进行。</strong>而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</li>
</ul>
<h4 id="3、早期的垃圾回收"><a href="#3、早期的垃圾回收" class="headerlink" title="3、早期的垃圾回收"></a>3、早期的垃圾回收</h4><ul>
<li><p>在早期的C/C++时代，垃圾回收基本上是手工进行的。开发人员可以使用new关键字进行内存申请，并使用delete关键字进行内存释放。比如以下代<br>码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MibBridge *pBridge = <span class="keyword">new</span> cmBaseGroupBridge();</span><br><span class="line"><span class="comment">//如果注册失败，使用Delete释放该对象所占内存区域</span></span><br><span class="line"><span class="keyword">if</span> (pBridge-&gt;Register(kDestroy) != NO_ERROR)</span><br><span class="line">	<span class="keyword">delete</span> pBridge;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这种方式可以<strong>灵活控制内存释放的时间</strong>，但是会给开发人员带来<strong>频繁申请和释放内存的管理负担</strong>。倘若有一处内存区间由于程序员编码的问题忘记被回<br>收，那么就会产生<strong>内存泄漏</strong>，垃圾对象永远无法被清除，随着系统运行时间的不断增长，<strong>垃圾对象所耗内存可能持续上升</strong>，直到出现内存溢出并造成<strong>应用程序崩溃</strong>。</p>
</li>
<li><p>在有了垃圾回收机制后，，上述代码块极有可能变成这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MibBridge *pBridge = <span class="keyword">new</span> cmBaseGroupBridge();</span><br><span class="line">pBridge-&gt;Register(kDestroy);</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势。可以说，这种自动化的内存分配和垃圾回收的方式己经成为现代开发语言必备的标准。</p>
</li>
</ul>
<h4 id="4、java垃圾回收机制"><a href="#4、java垃圾回收机制" class="headerlink" title="4、java垃圾回收机制"></a>4、java垃圾回收机制</h4><ul>
<li><p>自动内存管理无需开发人员手动参与内存的分配与回收，这样<strong>降低内存泄漏和内存溢出的风险</strong></p>
<ul>
<li>没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄漏问题让你头疼不已。</li>
</ul>
</li>
<li><p>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以<strong>更专心地专注于业务开发</strong></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html">oracle官网关于垃圾回收的介绍</a></p>
</li>
<li><p>对于Java开发人员而言自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会<strong>弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力</strong>。</p>
</li>
<li><p>此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见OutOfMemoryError时，快速地<strong>根据错误异常日志定位问题和解决问题</strong>。</p>
</li>
<li><p>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术**实施必要的<code>监控</code>和<code>调节</code>**。</p>
</li>
<li><p>垃圾回收的区域：**<code>堆</code>(Heap)与<code>方法区</code>(Method Area)**</p>
<p><img src="/2021/04/19/JVM/image-20210426180331460.png" alt="image-20210426180331460"></p>
</li>
<li><p>垃圾回收器可以对年轻代回收，也可以对老年代回收，甚至是全堆和方法区的回收。</p>
<ul>
<li>其中，**<code>Java堆</code>是垃圾收集器的工作重点**。</li>
</ul>
</li>
<li><p>从次数上讲：</p>
<ul>
<li><strong>频繁收集Young区</strong></li>
<li><strong>较少收集Old区</strong></li>
<li><strong>基本不动方法区（Perm区或元空间）</strong></li>
</ul>
</li>
</ul>
<hr>
<h3 id="15、垃圾回收相关算法"><a href="#15、垃圾回收相关算法" class="headerlink" title="15、垃圾回收相关算法"></a>15、垃圾回收相关算法</h3><ul>
<li>判断对象存活<ul>
<li>在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先<strong>需要区分出内存中哪些是存活对象，哪些是已经死亡的对象</strong>。只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为<strong>垃圾标记阶段</strong>。</li>
<li>那么在JVM中究竟是如何标记一个死亡对象呢?简单来说，当<strong>一个对象已经不再被任何的存活对象继续引用</strong>时，就可以宣判为已经死亡。</li>
<li>判断对象存活一般有两种方式：**<code>引用计数算法</code><strong>和</strong><code>可达性分析算法</code>**。</li>
</ul>
</li>
<li>回收垃圾<ul>
<li>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是<strong>执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存</strong>。</li>
<li>目前在JVM中比较常见的三种垃圾收集算法是：**<code>标记一清除算法(Mark-Sweep)</code><strong>、</strong><code>复制算法(Copying)</code><strong>、</strong><code>标记-压缩算法(Mark-Compact)</code>**。</li>
</ul>
</li>
</ul>
<h4 id="1、标记阶段：引用计数算法"><a href="#1、标记阶段：引用计数算法" class="headerlink" title="1、标记阶段：引用计数算法"></a>1、标记阶段：引用计数算法</h4><h5 id="1、引用计数算法概述"><a href="#1、引用计数算法概述" class="headerlink" title="1、引用计数算法概述"></a>1、引用计数算法概述</h5><ul>
<li><strong>引用计数算法</strong>(Reference Counting)比较简单，对<strong>每个对象保存一个整型的引用计数器属性</strong>。<strong>用于记录对象被引用的情况</strong>。</li>
<li>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</li>
<li>优点：<ul>
<li><strong>实现简单，垃圾对象便于辨识</strong>；</li>
<li><strong>判定效率高，回收没有延迟性</strong>。</li>
</ul>
</li>
<li>缺点:<ul>
<li>它需要单独的字段存储计数器，这样的做法增加了<strong>存储空间的开销</strong>。</li>
<li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了<strong>时间开销</strong>。</li>
<li>引用计数器有一个严重的问题，即<strong>无法处理循环引用</strong>的情况。这是一条致命缺陷，导致<strong>在Java的垃圾回收器中没有使用这类算法</strong>。</li>
</ul>
</li>
</ul>
<h5 id="2、循环引用"><a href="#2、循环引用" class="headerlink" title="2、循环引用"></a>2、循环引用</h5><p><img src="/2021/04/19/JVM/image-20210426203337926.png" alt="image-20210426203337926"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * 证明：java使用的不是引用计数算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefCountGC</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个成员属性唯一的作用就是占用一点内存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//5MB</span></span><br><span class="line">    Object reference = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RefCountGC obj1 = <span class="keyword">new</span> RefCountGC();</span><br><span class="line">        RefCountGC obj2 = <span class="keyword">new</span> RefCountGC();</span><br><span class="line"></span><br><span class="line">        obj1.reference = obj2;</span><br><span class="line">        obj2.reference = obj1;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 手动断开各自reference的引用</span></span><br><span class="line">        obj1 = <span class="keyword">null</span>;</span><br><span class="line">        obj2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//显式的执行垃圾回收行为</span></span><br><span class="line">        <span class="comment">//这里发生GC，obj1和obj2能否被回收？能 -&gt; java使用的不是引用计数算法</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图示：</p>
<p><img src="/2021/04/19/JVM/image-20210426204015295.png" alt="image-20210426204015295"></p>
<h5 id="3、小结"><a href="#3、小结" class="headerlink" title="3、小结"></a>3、小结</h5><ul>
<li>引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。</li>
<li>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。</li>
<li>Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。</li>
<li>Python如何解决循环引用?<ul>
<li><strong>手动解除</strong>：很好理解，就是在合适的时机，解除引用关系。</li>
<li>使用<strong>弱引用weakref</strong>，weakref是Python提供的标准库，旨在解决循环引用。</li>
</ul>
</li>
</ul>
<h4 id="2、标记阶段：可达性分析算法-或根搜索算法、追踪性垃圾收集"><a href="#2、标记阶段：可达性分析算法-或根搜索算法、追踪性垃圾收集" class="headerlink" title="2、标记阶段：可达性分析算法(或根搜索算法、追踪性垃圾收集)"></a>2、标记阶段：可达性分析算法(或根搜索算法、追踪性垃圾收集)</h4><ul>
<li><p>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以<strong>有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生</strong>。</p>
</li>
<li><p>相较于引用计数算法，这里的可达性分析就是<strong>Java、C#**选择的。这种类型的垃圾收集通常也叫作</strong>追踪性垃圾收集**(Tracing GarbageCollection)。</p>
</li>
<li><p>所谓”GC Roots”根集合就是<strong>一组必须活跃的引用</strong>。</p>
</li>
<li><p>基本思路：</p>
<ul>
<li>可达性分析算法是以根对象集合(GC Roots) 为起始点，按照从上至下的方式<strong>搜索被根对象集合所连接的目标对象是否可达</strong>。</li>
<li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为<strong>引用链</strong>(Reference Chain)</li>
<li>如果<strong>目标对象没有任何引用链相连，则是不可达的</strong>，就意味着该对象己经死亡，可以标记为垃圾对象。</li>
<li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li>
</ul>
</li>
<li><p>图示</p>
<p><img src="/2021/04/19/JVM/image-20210426210515944.png" alt="image-20210426210515944"></p>
</li>
<li><p>在Java语言中，GC Roots包括以下几类元素：</p>
<ul>
<li><strong>虚拟机栈中引用的对象</strong><ul>
<li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li>
</ul>
</li>
<li><strong>本地方法栈内JNI (通常说的本地方法)引用的对象</strong></li>
<li>方法区中<strong>类静态属性引用的对象</strong><ul>
<li>比如：Java类的引用类型静态变量</li>
</ul>
</li>
<li>方法区中<strong>常量引用的对象</strong><ul>
<li>比如：<strong>字符串常量池(String Table)里的引用</strong></li>
</ul>
</li>
<li><strong>所有被同步锁synchronized持有的对象</strong></li>
<li>Java虚拟机内部的引用。<ul>
<li><strong>基本数据类型对应的Class对象</strong>，<strong>一些常驻的异常对象</strong>(如:NullPointerException、OutOfMemoryError) ，<strong>系统类加载器</strong>。</li>
</ul>
</li>
<li><strong>反映java虛拟机内部情况的JMXBean</strong>、<strong>JVMTI中注册的回调</strong>、<strong>本地代码缓存</strong>等。</li>
</ul>
</li>
<li><p>图示：</p>
<p><img src="/2021/04/19/JVM/image-20210426210824260.png" alt="image-20210426210824260"></p>
</li>
<li><p>除了这些固定的GC Roots 集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：<strong>分代收集</strong>和<strong>局部回收(Partial GC)</strong></p>
<ul>
<li>如果<strong>只针对Java堆中的某一块区域进行垃圾回收</strong>(比如：<strong>典型的只针对新生代</strong>)，必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的<strong>对象完全有可能被其他区域的对象所引用</strong>，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性。</li>
</ul>
</li>
<li><p>小技巧：</p>
<ul>
<li>由于<strong>Root采用栈方式存放变量和指针</strong>，所以<strong>如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root</strong>。</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个<strong>能保障一致性的快照中进行</strong>。这点不满足的话分析结果的准确性就无法保证。</li>
<li>这点也是导致GC进行时必须”<code>Stop The World</code>“的一个重要原因。<ul>
<li>即使是号称(几乎)不会发生停顿的CMS收集器中，<strong>枚举根节点时也是必须要停顿的</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3、对象的finalization机制"><a href="#3、对象的finalization机制" class="headerlink" title="3、对象的finalization机制"></a>3、对象的finalization机制</h4><ul>
<li>Java语言提供了对象终止(finalization)机制来允许开发人员提供<strong>对象被销毁之前的自定义处理逻辑</strong>。</li>
<li>当垃圾回收器发现没有引用指向一个对象，即：<strong>垃圾回收此对象之前，总会先调用这个对象的finalize()方法</strong>。</li>
<li>finalize()方法允许在子类中被重写，<strong>用于在对象被回收时进行资源释放</strong>。通常在这个方法中<strong>进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接</strong>等。</li>
<li><strong>永远不要主动调用某个对象的finalize()方法，应该交给垃圾回收机制调用</strong>。理由包括下面三点：<ul>
<li>在finalize() 时<strong>可能会导致对象复活</strong>。</li>
<li>finalize() 方法的<strong>执行时间是没有保障的，它完全由GC线程决定</strong>，极端情况下，若不发生GC，则finalize()方法将没有执行机会。</li>
<li><strong>一个糟糕的finalize()会严重影响GC的性能</strong>。</li>
</ul>
</li>
<li>从功能上来说，finalize()方法与C++中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize()方法在本质上不同于C++中的析构函数。</li>
<li>由于finalize()方法的存在，<strong>虚拟机中的对象一般处于三种可能的状态</strong>。</li>
<li>如果从所有的根节点都无法访问到某个对象，说明对象已经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。<strong>一个无法触及的对象有可能在某一个条件（finalize()方法）下“复活”自己</strong>，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：<ul>
<li><strong>可触及的</strong>：从根节点开始，可以到达这个对象。</li>
<li><strong>可复活的</strong>：对象的所有引用都被释放，但是对象有可能在finalize()中复活。</li>
<li><strong>不可触及的</strong>：对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，<strong>因为finalize()只会被调用一次</strong>。</li>
</ul>
</li>
<li>以上3种状态中，是由于finalize()方法的存在进行的区分。<strong>只有在对象不可触及时才可以被回收</strong>。</li>
<li>判定一个对象objA是否可回收，至少要经历两次标记过程，具体过程：<ul>
<li><strong>如果对象objA到GC Roots没有引用链，则进行第一次标记</strong>。</li>
<li>进行筛选，判断此对象是否有必要执行finalize()方法<ul>
<li>如果<strong>对象objA没有重写finalize()方法</strong>，或者<strong>finalize()方法已经被虚拟机调用过</strong>，则虚拟机视为“没有必要执行”，<strong>objA被判定为不可触及</strong>的。</li>
<li>如果<strong>对象objA重写了finalize()方法，且还未执行过</strong>，那么objA会被插入到<strong>F-Queue队列</strong>中，由一个<strong>虚拟机自动创建的、<code>低优先级</code>的Finalizer线程</strong>触发其finalize()方法执行。</li>
<li>finalize()方法是对象逃脱死亡的最后机会，稍后<strong>GC会对F-Queue队列中的对象进行第二次标记</strong>。如果<strong>objA在finalize()方法中与引用链上的任何一个对象建立了联系</strong>，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成<strong>不可触及</strong>的状态，也就是说，<strong>一个对象的finalize方法只会被调用一次</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4、MAT与JProfiler的GC-Roots溯源"><a href="#4、MAT与JProfiler的GC-Roots溯源" class="headerlink" title="4、MAT与JProfiler的GC Roots溯源"></a>4、MAT与JProfiler的GC Roots溯源</h4><h5 id="1、MAT概述"><a href="#1、MAT概述" class="headerlink" title="1、MAT概述"></a>1、MAT概述</h5><p>MAT是Memory Analyzer的简称，它是一款功能强大的Java堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。</p>
<p>MAT是基于Eclipse开发的，是一款免费的性能分析工具。</p>
<p>大家可以在<a target="_blank" rel="noopener" href="http://www.eclipse.org/mat/">官网</a>下载并使用MAT。</p>
<h5 id="2、获取dump文件"><a href="#2、获取dump文件" class="headerlink" title="2、获取dump文件"></a>2、获取dump文件</h5><ol>
<li><p>命令行使用jmap</p>
<p><img src="/2021/04/19/JVM/image-20210426214539114.png" alt="image-20210426214539114"></p>
</li>
<li><p>使用JVisualVM导出</p>
<ul>
<li>捕获的heap dump文件是一个临时文件，关闭JVisua1VM后自动删除，若要保留，需要将其另存为文件。</li>
<li>可通过以下方法捕获heap dump：<ul>
<li>在左侧”Application”(应用程序)子窗口中右击相应的应用程序，选择Heap Dump(堆Dump)。</li>
<li>在Monitor (监视)子标签页中点击Heap Dump (堆Dump)按钮。</li>
</ul>
</li>
<li>本地应用程序的Heap dumps作为应用程序标签页的一个子标签页打开。同时，heap dump 在左侧的Application (应用程序)栏中对应一个含有时间戳的节点。右击这个节点选择save as (另存为)即可将heap dump保存到本地。</li>
</ul>
</li>
</ol>
<h5 id="3、使用MAT打开heap-dump文件-hprof"><a href="#3、使用MAT打开heap-dump文件-hprof" class="headerlink" title="3、使用MAT打开heap dump文件.hprof"></a>3、使用MAT打开heap dump文件.hprof</h5><ol>
<li><p>File -&gt; Open File -&gt; 找到对应的.hprof文件导入</p>
</li>
<li><p>导入后图示：</p>
<p><img src="/2021/04/19/JVM/image-20210426220319212.png" alt="image-20210426220319212"></p>
</li>
<li><p>在MAT中查看GC Roots的方法</p>
<p><img src="/2021/04/19/JVM/image-20210426220439764.png" alt="image-20210426220439764"></p>
</li>
<li><p>GC Roots的相关展示：详情可查看<a target="_blank" rel="noopener" href="https://help.eclipse.org/2020-03/index.jsp?topic=/org.eclipse.mat.ui.help/concepts/gcroots.html">官网</a></p>
<p><img src="/2021/04/19/JVM/image-20210426221159953.png" alt="image-20210426221159953"></p>
</li>
</ol>
<h5 id="4、使用Profiler进行GC-Roots溯源"><a href="#4、使用Profiler进行GC-Roots溯源" class="headerlink" title="4、使用Profiler进行GC Roots溯源"></a>4、使用Profiler进行GC Roots溯源</h5><ol>
<li><p>Live memory -&gt; All Objects -&gt; View -&gt; Mark Current Values (查看当前对象的个数)（光标变绿）</p>
<p><img src="/2021/04/19/JVM/image-20210426223157917.png" alt="image-20210426223157917"></p>
<p><img src="/2021/04/19/JVM/image-20210426223406880.png" alt="image-20210426223406880"></p>
</li>
<li><p>选择其中一个占内存较多的类 -&gt; Show Selection In Heap Walker -&gt; References(查看当前类的相关引用)</p>
<p><img src="/2021/04/19/JVM/blog\XGH-blog\source_posts\JVM\image-20210426223532525.png" alt="image-20210426223532525"></p>
<p><img src="/2021/04/19/JVM/image-20210426223639192.png" alt="image-20210426223639192"></p>
</li>
<li><p>查看哪个对象在哪里被关联（用来解决内存泄漏问题：查看内存泄漏的相关对象在哪里被引用）</p>
<p><img src="/2021/04/19/JVM/image-20210426224059101.png" alt="image-20210426224059101"></p>
<p><img src="/2021/04/19/JVM/image-20210426224309986.png" alt="image-20210426224309986"></p>
</li>
</ol>
<h5 id="5、使用Profiler分析OOM"><a href="#5、使用Profiler分析OOM" class="headerlink" title="5、使用Profiler分析OOM"></a>5、使用Profiler分析OOM</h5><ol>
<li><p>可以在代码中使用参数：<code>-XX: +HeapDumpOnOutOfMemoryError</code>，当程序出现OOM的时候在当前目录下自动生成Heap Dump文件</p>
</li>
<li><p>Heap Walker -&gt; Current Object Set -&gt; Biggest Objects查看是否存在占用内存的超大对象</p>
<p><img src="/2021/04/19/JVM/blog\XGH-blog\source_posts\JVM\image-20210426224832591.png" alt="image-20210426224832591"></p>
</li>
<li><p>在Thread Dump处查看哪个线程的哪个位置出现了OOM</p>
<p><img src="/2021/04/19/JVM/image-20210426225204897.png" alt="image-20210426225204897"></p>
</li>
</ol>
<h4 id="5、清除阶段：标记-清除算法"><a href="#5、清除阶段：标记-清除算法" class="headerlink" title="5、清除阶段：标记-清除算法"></a>5、清除阶段：标记-清除算法</h4><ul>
<li><p>背景：</p>
<ul>
<li>标记一清除算法( Mark-Sweep )是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并应用于Lisp语言。</li>
</ul>
</li>
<li><p>执行过程：</p>
<p>当<strong>堆中的有效内存空间(available memory)被耗尽</strong>的时候，就会<strong>停止整个程序</strong>(也被称为stop the world) ，然后进行两项工作，第一项则是<strong>标记</strong>，第二项则是<strong>清除</strong>。</p>
<ul>
<li>标记：Collector<strong>从引用根节点开始遍历，标记<code>所有被引用的对象</code>**。一般是</strong>在对象的Header中记录为<code>可达对象</code>**。</li>
<li>清除：Collector对<strong>堆内存从头到尾进行线性的遍历</strong>，如果发现<strong>某个对象在其Header中没有标记为可达对象</strong>，则将其<strong>回收</strong>。</li>
</ul>
</li>
<li><p>图示：</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC14%E7%AB%A0_%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.jpg" alt="第14章_标记-清除算法"></p>
</li>
<li><p>缺点：</p>
<ul>
<li><strong>效率不算高</strong></li>
<li>在<strong>进行GC</strong>的时候，需要<strong>停止整个应用程序</strong>，导致<strong>用户体验差</strong></li>
<li>这种方式清理出来的<strong>空闲内存是不连续的</strong>，<strong>产生内存碎片</strong>。</li>
<li>需要<strong>维护一个空闲列表</strong></li>
</ul>
</li>
<li><p>注意：何为清除(<strong>透明覆盖</strong>)</p>
<ul>
<li>这里所谓的清除并不是真的置空，而是<strong>把需要清除的对象地址保存在空闲的地址列表里</strong>。</li>
<li>下次<strong>有新对象需要加载</strong>时，<strong>判断垃圾的位置空间</strong>是否够，如果够，就存放。</li>
</ul>
</li>
</ul>
<h4 id="6、清除阶段：复制算法"><a href="#6、清除阶段：复制算法" class="headerlink" title="6、清除阶段：复制算法"></a>6、清除阶段：复制算法</h4><ul>
<li><p>背景：</p>
<p>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，”使用双存储区的Lisp语言垃圾收集器CALISP Garbage Collector Algorithm Using Serial Secondary Storage)”M.L.Minsky在该论文中描述的算法被人们称为复制(Copying) 算法，它也被M.L.Minsky本人成功地引入到了Lisp语言的一个实现版本中。</p>
</li>
<li><p>核心思想：</p>
<p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的<strong>存活对象复制</strong>到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p>
</li>
<li><p>图示：</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC14%E7%AB%A0_%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.jpg" alt="第14章_复制算法"></p>
</li>
<li><p>优点：</p>
<ul>
<li>没有标记和清除的过程，<strong>实现简单，运行高效</strong></li>
<li>复制过去以后<strong>保证空间的连续性，不会出现”碎片”问题</strong></li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li><strong>需要两倍的内存空间</strong></li>
<li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。</li>
</ul>
</li>
<li><p>特别的：</p>
<ul>
<li>如果系统中的<strong>垃圾对象很多</strong>，复制算法不会很理想。复制算法需要<strong>复制的存活对象数量要求不要太多</strong>，或者说<strong>非常少</strong>才行。</li>
<li>即<strong>特别适合垃圾对象很多，存活对象很少</strong>的场景；例如：Young区的Survivor0和Survivor1区</li>
</ul>
</li>
<li><p>应用场景：</p>
<p>在新生代，对常规应用的垃圾回收，一次通常可以回收70% - 99%的内存空间。</p>
<p>回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</p>
<p><img src="/2021/04/19/JVM/image-20210427010211524.png" alt="image-20210427010211524"></p>
</li>
</ul>
<h4 id="7、清除阶段：标记-压缩算法"><a href="#7、清除阶段：标记-压缩算法" class="headerlink" title="7、清除阶段：标记-压缩算法"></a>7、清除阶段：标记-压缩算法</h4><ul>
<li><p>背景：</p>
<ul>
<li><strong>复制算法的高效性是建立在存活对象少、垃圾对象多的前提</strong>下的。这种情况在新生代经常发生，但是在<strong>老年代</strong>，更常见的情况是<strong>大部分对象都是存活对象</strong>。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，<strong>基于老年代垃圾回收的特性，需要使用其他的算法</strong>。</li>
<li>标记-清除算法的确可以应用在老年代中，但是该算法不仅<strong>执行效率低下</strong>，而且在<strong>执行完内存回收后还会产生内存碎片</strong>，所以JVM的设计者需要在此基础之上进行改进。标记-压缩(Mark一Compact) 算法由此诞生。</li>
<li>1970年前后，G.L.Steele、C.J.Chene和D.s.Wise等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。</li>
</ul>
</li>
<li><p>执行过程：</p>
<ul>
<li>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</li>
<li>第二阶段将所有的存活对象压缩到内存的一端，按<strong>顺序</strong>排放。</li>
<li>之后，清理边界外所有的空间。</li>
</ul>
</li>
<li><p>图示：</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC14%E7%AB%A0_%E6%A0%87%E8%AE%B0-%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95.jpg" alt="第14章_标记-压缩算法"></p>
</li>
<li><p>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为<strong>标记-清除-压缩(Mark- Sweep- Compact)算法</strong>。</p>
</li>
<li><p>二者的本质差异在于<strong>标记-清除算法是一种非移动式的回收算法</strong>，<strong>标记-压缩是移动式的</strong>。<strong>是否移动回收后的存活对象</strong>是一项优缺点并存的风险决策。</p>
<ul>
<li>风险：<strong>所有引用到存活对象的引用都需要修改</strong></li>
</ul>
</li>
<li><p>可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要<strong>给新对象分配内存时，JVM只需要持有一个内存的起始地址</strong>即可，这比维护一个空闲列表显然少了许多开销。</p>
</li>
<li><p>指针碰撞：</p>
<ul>
<li>如果内存空间以规整和有序的方式分布，即已用和未用的内存都各自一边，<strong>彼此之间维系着一个记录下一次分配起始点的标记指针</strong>，当为新对象分配内存时，只需要通过<strong>修改指针的偏移量将新对象分配在第一个空闲内存位置</strong>上，这种分配方式就叫做指针碰撞(Bump the Pointer) 。</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li><strong>消除了</strong>标记-清除算法当中<strong>内存区域分散的缺点</strong>，我们需要给新对象分配内存时，<strong>JVM只需要持有一个内存的起始地址即可</strong>。</li>
<li><strong>消除了</strong>复制算法当中，<strong>内存减半的高额代价</strong>。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>从效率上来说，<strong>标记-整理算法要低于复制算法</strong>。</li>
<li>移动对象的同时，如果<strong>对象被其他对象引用，则还需要调整引用的地址</strong>。</li>
<li>移动过程中，需要全程暂停用户应用程序。即: <strong>STW</strong></li>
</ul>
</li>
</ul>
<h4 id="8、小结"><a href="#8、小结" class="headerlink" title="8、小结"></a>8、小结</h4><p>对比三种清除算法</p>
<table>
<thead>
<tr>
<th></th>
<th>Mark-Sweep</th>
<th>Mark-Compact</th>
<th>Copying</th>
</tr>
</thead>
<tbody><tr>
<td>速度</td>
<td>中等</td>
<td>最慢</td>
<td>最快</td>
</tr>
<tr>
<td>空间开销</td>
<td>少（但会堆积碎片）</td>
<td>少（不会堆积碎片）</td>
<td>通常需要活对象的两倍大小（不堆积碎片）</td>
</tr>
<tr>
<td>移动对象</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>再分配对象空间使用</td>
<td>空闲列表</td>
<td>指针碰撞</td>
<td>指针碰撞</td>
</tr>
</tbody></table>
<p>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。</p>
<p>而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。</p>
<h4 id="9、分代收集算法"><a href="#9、分代收集算法" class="headerlink" title="9、分代收集算法"></a>9、分代收集算法</h4><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</p>
<p>分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，<strong>不同生命周期的对象可以采取不同的收集方式，以便提高回收效率</strong>。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p>
<p>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如<strong>Http请求中的Session对象、线程、Socket连接</strong>，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：<strong>String对象</strong>， 由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p>
<p><strong>目前几乎所有的GC都是采用分代收集( Generational Collecting) 算法执行垃圾回收的</strong>。</p>
<p>在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p>
<ul>
<li>年轻代(Young Gen)<ul>
<li>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，<strong>回收频繁</strong>。</li>
<li>这种情况<strong>复制算法</strong>的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而<strong>复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解</strong>。</li>
</ul>
</li>
<li>老年代(Tenured Gen)<ul>
<li>老年代特点：区域较大，对象生命周期长、存活率高，<strong>回收不及年轻代频繁</strong>。</li>
<li>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是<strong>由标记-清除或者是标记-清除与标记-整理的混合实现</strong>。<ul>
<li>Mark阶段的<strong>开销与存活对象的数量成正比</strong>。</li>
<li>Sweep阶段的<strong>开销与所管理区域的大小成正比</strong>。</li>
<li>Compact阶段的<strong>开销与存活对象的数量成正比</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>以HotSpot中的<strong>CMS回收器</strong>为例，CMS是<strong>基于Mark- Sweep实现</strong>的，对于对象的回收效率很高。而对于碎片问题，CMS采用<strong>基于Mark-Compact算法的Serial Old回收器作为补偿措施</strong>：当内存回收不佳(碎片导致的Concurrent Mode Failure时)，将采用<strong>Serial Old执行Full GC以达到对老年代内存的整理</strong>。</p>
<p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代。</p>
<h4 id="10、增量收集算法、分区算法"><a href="#10、增量收集算法、分区算法" class="headerlink" title="10、增量收集算法、分区算法"></a>10、增量收集算法、分区算法</h4><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种Stop the World的状态。在<strong>Stop the World(SWT)状态</strong>下，应用程序所有的线程都会挂起，暂停切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将<strong>严重影响用户体验或者系统的稳定性</strong>。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集( Incremental Collecting) 算法的诞生。</p>
<p><strong>基本思想：</strong></p>
<ul>
<li>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以<strong>让垃圾收集线程和应用程序线程交替执行</strong>。<strong>每次垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成</strong>。（<strong>并发思想</strong>）</li>
<li>总的来说，<strong>增量收集算法的基础仍是传统的标记-清除和复制算法</strong>。增量收集算法通过<strong>对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</strong>。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能<strong>减少系统的停顿时间</strong>。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的<strong>总体成本上升</strong>，造成<strong>系统吞吐量的下降</strong>。</li>
</ul>
<p><strong>分区算法</strong>：</p>
<ul>
<li><p>一般来说，<strong>在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长</strong>。</p>
</li>
<li><p>为了更好地<strong>控制GC产生的停顿时间</strong>，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</p>
</li>
<li><p>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间region。</p>
</li>
<li><p>每一个小区间都独立使用，独立回收。这种算法的好处是<strong>可以控制一次回收多少个小区间</strong>。</p>
</li>
<li><p>图示：</p>
<p><img src="/2021/04/19/JVM/image-20210427023448226.png" alt="image-20210427023448226"></p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC14%E7%AB%A0_%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95.jpg" alt="第14章_分区算法"></p>
</li>
</ul>
<p>注意，这些只是基本的算法思路，实际GC实现过程要复杂的多，目前还在发展中的前沿GC都是复合算法，并且并行和并发兼备。</p>
<hr>
<h3 id="16、垃圾回收相关概念"><a href="#16、垃圾回收相关概念" class="headerlink" title="16、垃圾回收相关概念"></a>16、垃圾回收相关概念</h3><h4 id="1、System-gc-的理解"><a href="#1、System-gc-的理解" class="headerlink" title="1、System.gc()的理解"></a>1、System.gc()的理解</h4><ul>
<li>在目录情况下，通过System.gc()或者runtime.getRuntime().gc()的调用，<strong>会显式触发Full GC</strong>，<strong>同时对老年代和新时代进行回收</strong>，尝试释放被丢弃对象占用的内存。</li>
<li>然而System.gc()调用附带一个免责声明，无法保证对垃圾收集器的调用。</li>
<li>JVM实现者可以通过System.gc()调用来觉得JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，<strong>无须手动触发，否则就太过于麻烦了</strong>。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()。</li>
</ul>
<p>System.gc()提醒jvm的垃圾回收器执行gc,但是不确定是否马上执行gc，但是调用System.runFinalization()方法可以强制调用使用引用的对象的finalize()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemGCTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SystemGCTest();</span><br><span class="line">        System.gc();<span class="comment">//提醒jvm的垃圾回收器执行gc,但是不确定是否马上执行gc</span></span><br><span class="line">        <span class="comment">//与Runtime.getRuntime().gc();的作用一样</span></span><br><span class="line">        System.runFinalization();<span class="comment">//强制调用使用引用的对象的finalize()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;SystemGCTest 重写了finalize()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>System.gc()的相关案例：</p>
<p><img src="/2021/04/19/JVM/image-20210427112323264.png" alt="image-20210427112323264"></p>
<p>问题：调用System.gc()无法保证对垃圾收集器的调用，为什么上述案例中，每次调用都会有垃圾回收信息输出?是进行了GC吗?</p>
<h4 id="2、内存溢出-OOM-与内存泄漏-Memory-Leak"><a href="#2、内存溢出-OOM-与内存泄漏-Memory-Leak" class="headerlink" title="2、内存溢出(OOM)与内存泄漏(Memory Leak)"></a>2、内存溢出(OOM)与内存泄漏(Memory Leak)</h4><h5 id="1、内存溢出（OOM）"><a href="#1、内存溢出（OOM）" class="headerlink" title="1、内存溢出（OOM）"></a>1、内存溢出（OOM）</h5><ul>
<li><p>内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。</p>
</li>
<li><p>由于GC一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现OOM的情况。</p>
</li>
<li><p>大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Full GC操作，这时候会回收大量的内存供应用程序继续使用。</p>
</li>
<li><p>javadoc中对OutOfMemoryError的解释是：<strong>没有空闲内存，并且垃圾收集器也无法提供更多内存</strong>。</p>
</li>
<li><p>首先说没有空闲内存的情况:说明Java虛拟机的堆内存不够。原因有二：</p>
<ol>
<li><p><strong>Java虚拟机的堆内存设置不够</strong>。</p>
<p>比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以<strong>通过参数-Xms、-Xmx来调整</strong>。</p>
</li>
<li><p><strong>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集(存在被引用)</strong></p>
<p>对于老版本的Oracle JDK， 因为永久代的大小是有限的，并且JVM对永久代垃圾回收(如，常量池回收、卸载不再需要的类型)非常不积极，所以当我们不断添加新类型的时候，永久代出现OutOfMemoryError也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似intern字符串缓存占用太多空间，也会导致OOM问题。对应的异常信息，会标记出来和<strong>永久代</strong>相关：”java.lang.OutOfMemoryError: PermGen space”。</p>
<p>随着<strong>元数据区</strong>的引入，方法区内存已经不再那么窘迫，所以相应的OOM有所改观，出现OOM的异常信息则变成了：”java.lang.OutOfMemoryError: Metaspace”。 直接内存不足，也会导致OOM。</p>
</li>
</ol>
</li>
<li><p>这里面隐含着一层意思是，在抛出OutOfMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。</p>
<ul>
<li>例如：在引用机制分析中，涉及到JVM会去尝试回收<strong>软引用指向的对象</strong>等。</li>
<li>在java.nio.BIts.reserveMemory()方法中，我们能清楚的看到，System.gc()会被调用，以清理空间。</li>
</ul>
</li>
<li><p>当然，也不是在任何情况下垃圾收集器都会被触发的</p>
<ul>
<li>比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接拋出OutOfMemoryError。</li>
</ul>
</li>
</ul>
<h5 id="2、内存泄漏（Memory-Leak）"><a href="#2、内存泄漏（Memory-Leak）" class="headerlink" title="2、内存泄漏（Memory Leak）"></a>2、内存泄漏（Memory Leak）</h5><ul>
<li><p>也称作”存储渗漏”。严格来说，<strong>只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏</strong>。</p>
</li>
<li><p>但实际情况很多时候一些不太好的实践 (或疏忽)会导致对象的生命周期变得很长甚至导致OOM，也可以叫做**宽泛意义上的”内存泄漏”**。</p>
</li>
<li><p>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现OutOfMemory异常，导致程序崩溃。</p>
</li>
<li><p>注意，这里的存储空间并不是指物理内存，而是指<strong>虚拟内存大小</strong>，这个虚拟内存大小<strong>取决于磁盘交换区设定的大小</strong>。</p>
</li>
<li><p>图示：</p>
<p><img src="/2021/04/19/JVM/image-20210427230217504.png" alt="image-20210427230217504"></p>
</li>
<li><p>举例：</p>
<ol>
<li><p>单例模式：</p>
<p><strong>单例的生命周期和应用程序是一样长</strong>的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</p>
</li>
<li><p>一些<strong>提供close的资源未关闭</strong>导致内存泄漏：</p>
<p>数据库连接(dataSourse . getConnection())，网络连接(socket)和io连接必须手动close，否则是不能被回收的。</p>
</li>
</ol>
</li>
</ul>
<h4 id="3、Stop-The-World"><a href="#3、Stop-The-World" class="headerlink" title="3、Stop The World"></a>3、Stop The World</h4><ul>
<li>Stop-The-World，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。<strong>停顿产生时整个应用程序线程都会被暂停，没有任何响应</strong>，有点像卡死的感觉，这个停顿称为STW。<ul>
<li><strong>可达性分析算法中枚举根节点(GC Roots)会导致所有Java执行线程停顿</strong>。<ul>
<li>分析工作必须在一个能确保一致性的快照中进行</li>
<li>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</li>
<li><strong>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</strong></li>
</ul>
</li>
</ul>
</li>
<li>被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STW的发生。</li>
<li>STW事件和采用哪款GC无关，<strong>所有的GC都有STW这个事件</strong>。</li>
<li>哪怕是G1也不能完全避免Stop-the-world情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</li>
<li>STW是JVM在<strong>后台自动发起和自动完成的</strong>。在用户不可见的情况下，把用户正常的工作线程全部停掉。</li>
<li><strong>开发中不要用System.gc()；会导致Stop-the-world的发生</strong>。</li>
</ul>
<h4 id="4、垃圾回收的并行与并发"><a href="#4、垃圾回收的并行与并发" class="headerlink" title="4、垃圾回收的并行与并发"></a>4、垃圾回收的并行与并发</h4><h5 id="1、并发（Concurrent）"><a href="#1、并发（Concurrent）" class="headerlink" title="1、并发（Concurrent）"></a>1、并发（Concurrent）</h5><ul>
<li>在操作系统中，是指<strong>一个时间段</strong>中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在<strong>同一个处理器</strong>上运行。</li>
<li>并发不是真正意义上的”同时进行”，只是CPU把一个时间段分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换，由于CPU处理的速度非常快，主要时间间隔处理得当，即可让用户感觉是多个应用程序在同时运行。</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210427231222179.png" alt="image-20210427231222179"></p>
<h5 id="2、并行（Parallel）"><a href="#2、并行（Parallel）" class="headerlink" title="2、并行（Parallel）"></a>2、并行（Parallel）</h5><ul>
<li>当系统有<strong>一个以上CPU</strong>时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程<strong>互不抢占CPU资源</strong>，可以<strong>同时进行</strong>，我们称之为并行（Parallel）。</li>
<li>其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行。</li>
<li>适合<strong>科学计算，后台处理等弱交互场景</strong></li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210427231302158.png" alt="image-20210427231302158"></p>
<h5 id="3、并行-VS-并发"><a href="#3、并行-VS-并发" class="headerlink" title="3、并行 VS 并发"></a>3、并行 VS 并发</h5><p>二者对比：</p>
<ul>
<li><strong>并发</strong>，指的是<strong>多个事情，在同一时间段内同时发生了</strong>。</li>
<li><strong>并行</strong>，指的是<strong>多个事情，在同一时间点上同时发生了</strong>。</li>
</ul>
<ul>
<li><strong>并发</strong>的多个任务之间是<strong>互相抢占资源</strong>的。</li>
<li><strong>并行</strong>的多个任务之间是<strong>不互相抢占资源</strong>的。</li>
</ul>
<ul>
<li>只有在<strong>多CPU或者一个CPU多核</strong>的情况中，才会发生<strong>并行</strong>。</li>
<li>否则，<strong>看似同时发生的事情，其实都是并发执行的</strong>。</li>
</ul>
<h5 id="4、垃圾回收的并发与并行"><a href="#4、垃圾回收的并发与并行" class="headerlink" title="4、垃圾回收的并发与并行"></a>4、垃圾回收的并发与并行</h5><p>并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：</p>
<ul>
<li><p>并行(Parallel)：指<strong>多条垃圾收集线程并行工作</strong>，但此时<strong>用户线程仍处于等待状态</strong>。</p>
<ul>
<li>如并行的垃圾回收器：ParNew、 Parallel Scavenge、 Parallel Old;</li>
</ul>
</li>
<li><p>串行(Serial)</p>
<ul>
<li>相较于并行的概念，<strong>单线程执行</strong>。</li>
<li><strong>如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</strong></li>
</ul>
<p>图示：</p>
<p><img src="/2021/04/19/JVM/image-20210427231437839.png" alt="image-20210427231437839"></p>
</li>
<li><p>并发(Concurrent)：指<strong>用户线程与垃圾收集线程同时执行</strong>(但不一定是并行的，可能会交替执行)，<strong>垃圾回收线程在执行时不会停顿用户程序的运行</strong>。</p>
<ul>
<li><strong>用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上</strong>；</li>
<li>如: CMS、G1</li>
</ul>
<p>图示：</p>
<p><img src="/2021/04/19/JVM/image-20210427231919364.png" alt="image-20210427231919364"></p>
</li>
</ul>
<h4 id="5、安全点与安全区域"><a href="#5、安全点与安全区域" class="headerlink" title="5、安全点与安全区域"></a>5、安全点与安全区域</h4><h5 id="1、安全点（Safepoint）"><a href="#1、安全点（Safepoint）" class="headerlink" title="1、安全点（Safepoint）"></a>1、安全点（Safepoint）</h5><p>程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为”安全点(Safepoint)”</p>
<p>Safe Point的选择很重要，<strong>如果太少可能导致GC等待的时间太长</strong>，<strong>如果太频繁可能导致运行时的性能问题</strong>。大部分指令的执行时间都非常短暂，通常会根据“<strong>是否具有让程序长时间执行的特征</strong>”为标准。</p>
<p>比如：选择些执行时间较长的指令作为Safe Point，如<strong>方法调用</strong>、<strong>循环跳转</strong>和<strong>异常跳转</strong>等。</p>
<p>如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢?</p>
<ul>
<li><p><strong>抢先式中断</strong>：(目前没有虚拟机采用了)</p>
<p>首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</p>
</li>
<li><p><strong>主动式中断</strong>：</p>
<p><strong>设置一个中断标志</strong>，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。</p>
</li>
</ul>
<h5 id="2、安全区域"><a href="#2、安全区域" class="headerlink" title="2、安全区域"></a>2、安全区域</h5><p>Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint 。但是，程序“不执行”的时候呢?</p>
<p>例如线程处于 Sleep 状态或 Blocked 状态，这时候线程无法响应JVM 的中断请求，”走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域(Safe Region)来解决。</p>
<p><strong>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的</strong>。我们也可以把 Safe Region 看做是被扩展了的Safepoint。 </p>
<p>实际执行时：</p>
<ol>
<li>当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region，如果这段时间内发生GC，<strong>JVM会忽略标识为Safe Region状态的线程</strong>;</li>
<li>当线程即将离开Safe Region时，会检查JVM是否已经完成GC，如果完成了则继续运行，否则<strong>线程必须等待直到收到可以安全离开Safe Region的信号为止</strong>;</li>
</ol>
<h4 id="6、在谈引用"><a href="#6、在谈引用" class="headerlink" title="6、在谈引用"></a>6、在谈引用</h4><p>我们希望能描述这样一类对象：当<strong>内存空间还足够</strong>时，则能<strong>保留在内存</strong>中；如果<strong>内存空间在进行垃圾收集后还是很紧张</strong>，则可以<strong>抛弃</strong>这些对象。</p>
<p>[既<strong>偏门</strong>又<strong>非常高频</strong>的面试题]<code>强引用、软引用、弱引用、虚引用有什么区别?</code> <code>具体使用场景是什么?</code></p>
<p>在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为<code>强引用(StrongReference)</code>、<code>软引用(Soft Reference)</code> 、<code>弱引用(Weak Reference)</code>和<code>虚引用(Phantom Reference)</code> 4种，<strong>这4种引用强度依次逐渐减弱</strong>。（强软弱虚）</p>
<p>除<strong>强引用</strong>外，其他3种引用均可以在java.lang.ref包中找到它们的身影。如下图，显示了这3种引用类型对应的类，开发人员可以在应用程序中直接使用它们。</p>
<p><img src="/2021/04/19/JVM/image-20210427233208635.png" alt="image-20210427233208635"></p>
<p>Reference子类中只有<strong>终结器引用是包内可见</strong>的，<strong>其他3种引用类型均为public</strong>，可以在应用程序中直接使用</p>
<ul>
<li><strong><code>强引用(StrongReference)</code>**：最传统的“引用”的定义，是指</strong>在程序代码之中普遍存在的引用赋值<strong>，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，</strong>只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象<strong>。（</strong>不回收**）</li>
<li><strong><code>软引用(SoftReference)</code>**：</strong>在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常<strong>。（</strong>内存不足即回收**）</li>
<li><strong><code>弱引用(WeakReference)</code>**：</strong>被弱引用关联的对象只能生存到下一次垃圾收集之前<strong>。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。（</strong>发现即回收**）</li>
<li><strong><code>虚引用(PhantomReference)</code>**：一个对象是否有虛引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是</strong>能在这个对象被收集器回收时收到一个系统通知<strong>。（</strong>对象回收的跟踪**）</li>
</ul>
<h4 id="7、再谈引用：强引用Strong-Reference（不回收）"><a href="#7、再谈引用：强引用Strong-Reference（不回收）" class="headerlink" title="7、再谈引用：强引用Strong Reference（不回收）"></a>7、再谈引用：强引用Strong Reference（不回收）</h4><p>在Java程序中，最常见的引用类型是强引用(<strong>普通系统99%以上都是强引用</strong>)，也就是我们最常见的普通对象引用，也是<strong>默认的引用类型</strong>。</p>
<p>当在Java语言中<strong>使用new操作符创建一个新的对象</strong>， 并<strong>将其赋值给一个变量</strong>的时候， 这个变量就成为指向该对象的一个强引用。</p>
<p><strong>强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</strong></p>
<p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应(强)引用赋值为null，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</p>
<p>相对的，软引用、 弱引用和虚引用的对象是软可触及、弱可触及和虛可触及的，在一定条件下，都是可以被回收的。所以，<strong>强引用是造成Java内存泄漏的主要原因之一</strong>。</p>
<p>强引用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer str = <span class="keyword">new</span> StringBuffer (<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>局部变量str指向StringBuffer实例所在堆空间，通过str可以操作该实例，那么str就是StringBuffer实例的强引用</p>
<p>对应内存结构：<img src="/2021/04/19/JVM/image-20210428093616812.png" alt="image-20210428093616812"></p>
<p>此时，如果再运行一个赋值语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer str1 = str;</span><br></pre></td></tr></table></figure>

<p>对应内存结构：<img src="/2021/04/19/JVM/image-20210428093737403.png" alt="image-20210428093737403"></p>
<p>本例中的两个引用，都是强引用，强引用具备以下特点：</p>
<ul>
<li>强引用可以<strong>直接访问目标对象</strong>。</li>
<li><strong>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象</strong>。</li>
<li>强引用<strong>可能导致内存泄漏</strong>。</li>
</ul>
<h4 id="8、再谈引用：软引用Soft-Reference（内存不足即回收）"><a href="#8、再谈引用：软引用Soft-Reference（内存不足即回收）" class="headerlink" title="8、再谈引用：软引用Soft Reference（内存不足即回收）"></a>8、再谈引用：软引用Soft Reference（内存不足即回收）</h4><p>软引用是用来描述一些<strong>还有用</strong>，但<strong>非必需</strong>的对象。<strong>只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收</strong>，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p>
<p>软引用通常用来实现<strong>内存敏感的缓存</strong>。比如：<strong>高速缓存</strong>就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。实例：<strong>Mybatis的一些内部类中就使用了软引用</strong>。</p>
<p>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列(Reference Queue) 。</p>
<p>类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</p>
<p>在java doc中，软引用是这样描述的：</p>
<blockquote>
<p>虚拟机在抛出 OutOfMemoryError 之前会<strong>保证所有的软引用对象已被清除</strong>。此外，没有任何约束保证软引用将在某个特定的时间点被清除，或者确定一组不同的软引用对象被清除的顺序。不过，虚拟机的具体实现会倾向于<strong>不清除最近创建或最近使用过的软引用</strong>。</p>
</blockquote>
<p>软引用在我们的日常开发中使用的场景很多，比如商城中商品的信息。某个商品可能会被多人访问，此时我们可以把该商品的信息使用软引用保存。当系统内存足够时，可以实现高速查找，当系统内存不足又会被回收，避免<code>OOM</code>的风险。</p>
<p>注意：</p>
<p>尽管软引用会在OOM之前被清理，但是，<strong>这并不表示Full GC会清理软引用对象</strong>。在经过Full GC后我们的软引用对象都放入了old区，由于Full GC的存在，程序大多数情况下并不会OOM。<strong>由于软引用对象占据了老年代的空间，Full GC将执行的更为频繁</strong>。所以还是建议使用弱引用。</p>
<p>当然，我们可以通过参数：<code>-XX:SoftRefLRUPolicyMSPerMB=0</code>来设置当Full GC时回收软引用。其中参数值为Full GC保留的 SoftReference 数量，参数值越大，GC 后保留的软引用对象就越多。设置这个参数值为0时，Full GC就会回收我们的软引用对象了。</p>
<p>在JDK 1.2版之后提供了java.lang.ref.SoftReference类来实现软引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object(); <span class="comment">//声明强引用</span></span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> SoftReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>; <span class="comment">//销毁强引用</span></span><br></pre></td></tr></table></figure>



<h4 id="9、再谈引用：弱引用Weak-Reference（发现即回收）"><a href="#9、再谈引用：弱引用Weak-Reference（发现即回收）" class="headerlink" title="9、再谈引用：弱引用Weak Reference（发现即回收）"></a>9、再谈引用：弱引用Weak Reference（发现即回收）</h4><p>弱引用也是用来描述那些非必需对象，<strong>只被弱引用关联的对象只能生存到下一次垃圾收集发生为止</strong>。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。</p>
<p>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，<strong>弱引用对象可以存在较长的时间</strong>。</p>
<p>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，<strong>通过这个队列可以跟踪对象的回收情况</strong>。</p>
<p><strong>软引用、弱引用都非常适合来保存那些可有可无的缓存数据</strong>。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</p>
<p>实例：</p>
<ul>
<li>三级缓存（内存(弱引用) -&gt; 本地 -&gt; 网络）</li>
<li><code>ThreadLocal</code>的内部实现就是一个<code>ThreadLocalMap</code>,该<code>map</code>的<code>Entry</code>的<code>key</code>为<code>ThreadLocal</code>本身，<code>value</code>为我们向<code>ThreadLocal</code>对象<code>set</code>的值，其中的<code>key</code>就是弱引用对象</li>
<li>集合<code>WeakHashMap</code>，都是使用了弱引用实现的</li>
</ul>
<p>在JDK 1.2版之后提供了java.lang.ref.WeakReference类来实现弱引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object(); <span class="comment">//声明强引用</span></span><br><span class="line">WeakReference&lt;Object&gt; wr = <span class="keyword">new</span> WeakReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>; <span class="comment">//销毁强引用</span></span><br></pre></td></tr></table></figure>

<p>弱引用对象与软引用对象的最大不同就在于，<strong>当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收</strong>。<strong>弱引用对象更容易、更快被GC回收</strong>。</p>
<p><strong>面试题：你开发中使用过WeakHashMap吗?</strong></p>
<h4 id="10、再谈引用：虚引用Phantom-Reference（对象回收跟踪）"><a href="#10、再谈引用：虚引用Phantom-Reference（对象回收跟踪）" class="headerlink" title="10、再谈引用：虚引用Phantom Reference（对象回收跟踪）"></a>10、再谈引用：虚引用Phantom Reference（对象回收跟踪）</h4><p>也称为“<strong>幽灵引用</strong>”或者“<strong>幻影引用</strong>”，是<strong>所有引用类型中最弱的一个</strong>。</p>
<p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</p>
<p>它<strong>不能单独使用</strong>，也<strong>无法通过虚引用来获取被引用的对象</strong>。当试图通过虚引用的get()方法取得对象时，<strong>总是null</strong>。</p>
<p><strong>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</strong></p>
<p><strong>虚引用必须和引用队列一起使用</strong>。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以<strong>通知应用程序对象的回收情况</strong>。</p>
<p><strong>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录</strong>。</p>
<p>在JDK 1.2版之后提供了PhantomReference类来实现虚引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">ReferenceQueue phantomQueue = <span class="keyword">new</span> ReferenceQueue( );</span><br><span class="line">PhantomReference&lt;object&gt; pf = <span class="keyword">new</span> PhantomReference&lt;object&gt;(obj, phantomQueue);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>对象回收跟踪的代码实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.PhantomReference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 虚引用的测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhantomReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PhantomReferenceTest obj;<span class="comment">//当前类对象的声明</span></span><br><span class="line">    <span class="keyword">static</span> ReferenceQueue&lt;PhantomReferenceTest&gt; phantomQueue = <span class="keyword">null</span>;<span class="comment">//引用队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 守护线程，用来跟踪对象的回收</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckRefQueue</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (phantomQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    PhantomReference&lt;PhantomReferenceTest&gt; objt = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        objt = (PhantomReference&lt;PhantomReferenceTest&gt;) phantomQueue.remove();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (objt != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;追踪垃圾回收过程：PhantomReferenceTest实例被GC了&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; <span class="comment">//finalize()方法只能被调用一次！</span></span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;调用当前类的finalize()方法&quot;</span>);</span><br><span class="line">        obj = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> CheckRefQueue();</span><br><span class="line">        t.setDaemon(<span class="keyword">true</span>);<span class="comment">//设置为守护线程：当程序中没有非守护线程时，守护线程也就执行结束。</span></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        phantomQueue = <span class="keyword">new</span> ReferenceQueue&lt;PhantomReferenceTest&gt;();</span><br><span class="line">        obj = <span class="keyword">new</span> PhantomReferenceTest();</span><br><span class="line">        <span class="comment">//构造了 PhantomReferenceTest 对象的虚引用，并指定了引用队列</span></span><br><span class="line">        PhantomReference&lt;PhantomReferenceTest&gt; phantomRef = <span class="keyword">new</span> PhantomReference&lt;PhantomReferenceTest&gt;(obj, phantomQueue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//不可获取虚引用中的对象</span></span><br><span class="line">            System.out.println(phantomRef.get());</span><br><span class="line">            <span class="comment">//将强引用去除</span></span><br><span class="line">            obj = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//第一次进行GC,由于对象可复活，GC无法回收该对象</span></span><br><span class="line">            System.gc();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 是 null&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 可用&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;第 2 次 gc&quot;</span>);</span><br><span class="line">            obj = <span class="keyword">null</span>;</span><br><span class="line">            System.gc(); <span class="comment">//一旦将obj对象回收，就会将此虚引用存放到引用队列中。</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 是 null&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 可用&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="11、再谈引用：终结器引用Final-reference"><a href="#11、再谈引用：终结器引用Final-reference" class="headerlink" title="11、再谈引用：终结器引用Final reference"></a>11、再谈引用：终结器引用Final reference</h4><ul>
<li>它用以<strong>实现对象的finalize()方法</strong>，也可以称为<strong>终结器引用</strong>。</li>
<li>无需手动编码，其<strong>内部配合引用队列</strong>使用。</li>
<li>在GC时，终结器引用入队。由<strong>Finalizer线程通过终结器引用找到被引用对象并调用它的finalize()方法，第二次GC时才能回收被引用对象</strong>。</li>
</ul>
<hr>
<h3 id="17、垃圾回收器"><a href="#17、垃圾回收器" class="headerlink" title="17、垃圾回收器"></a>17、垃圾回收器</h3><h4 id="1、GC分类与性能指标"><a href="#1、GC分类与性能指标" class="headerlink" title="1、GC分类与性能指标"></a>1、GC分类与性能指标</h4><h5 id="1、垃圾回收器概述"><a href="#1、垃圾回收器概述" class="headerlink" title="1、垃圾回收器概述"></a>1、垃圾回收器概述</h5><ul>
<li>垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的JVM来实现。</li>
<li>由于JDK的版本处于高速迭代过程中，因此Java发展至今已经衍生了众多的GC版本。</li>
<li>从不同角度分析垃圾收集器，可以将GC分为不同的类型。</li>
</ul>
<h5 id="2、垃圾回收器分类"><a href="#2、垃圾回收器分类" class="headerlink" title="2、垃圾回收器分类"></a>2、垃圾回收器分类</h5><h6 id="1、按线程数分，可以分为串行垃圾回收器和并行垃圾回收器"><a href="#1、按线程数分，可以分为串行垃圾回收器和并行垃圾回收器" class="headerlink" title="1、按线程数分，可以分为串行垃圾回收器和并行垃圾回收器"></a>1、按<strong>线程数</strong>分，可以分为<strong>串行垃圾回收器</strong>和<strong>并行垃圾回收器</strong></h6><p><img src="/2021/04/19/JVM/image-20210428111017627.png" alt="image-20210428111017627"></p>
<ul>
<li>串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。<ul>
<li>在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，<strong>串行回收默认被应用在客户端的<code>Client模式</code>下的JVM中</strong></li>
<li>在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器。</li>
</ul>
</li>
<li>和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“Stop-the-world”机制。</li>
</ul>
<h6 id="2、按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器"><a href="#2、按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器" class="headerlink" title="2、按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器"></a>2、按照<strong>工作模式</strong>分，可以分为<strong>并发式垃圾回收器</strong>和<strong>独占式垃圾回收器</strong></h6><ul>
<li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</li>
<li>独占式垃圾回收器(Stop the world)一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210428111338892.png" alt="image-20210428111338892"></p>
<h6 id="3、按碎片处理方式分，可分为压缩式垃圾回收器和非压缩式垃圾回收器"><a href="#3、按碎片处理方式分，可分为压缩式垃圾回收器和非压缩式垃圾回收器" class="headerlink" title="3、按碎片处理方式分，可分为压缩式垃圾回收器和非压缩式垃圾回收器"></a>3、按<strong>碎片处理方式</strong>分，可分为<strong>压缩式垃圾回收器</strong>和<strong>非压缩式垃圾回收器</strong></h6><ul>
<li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。<ul>
<li>再分配对象空间使用：指针碰撞</li>
</ul>
</li>
<li>非压缩式的垃圾回收器不进行这步操作。<ul>
<li>再分配对象空间使用：空闲列表</li>
</ul>
</li>
</ul>
<h6 id="4、按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器"><a href="#4、按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器" class="headerlink" title="4、按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器"></a>4、按<strong>工作的内存区间</strong>分，又可分为<strong>年轻代垃圾回收器</strong>和<strong>老年代垃圾回收器</strong></h6><h5 id="3、评估GC的性能指标"><a href="#3、评估GC的性能指标" class="headerlink" title="3、评估GC的性能指标"></a>3、评估GC的性能指标</h5><ul>
<li><strong>吞吐量：运行用户代码的时间占总运行时间的比例</strong><ul>
<li>(总运行时间:程序的运行时间十内存回收的时间)</li>
</ul>
</li>
<li>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li>
<li><strong>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。</strong></li>
<li>收集频率：相对于应用程序的执行，收集操作发生的频率。</li>
<li><strong>内存占用：Java堆区所占的内存大小。</strong></li>
<li>快速：一个对象从诞生到被回收所经历的时间。</li>
</ul>
<p>关于吞吐量、暂停时间与内存占用：</p>
<ul>
<li>这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。</li>
<li>这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。</li>
<li>简单来说，主要抓住两点：<ul>
<li>吞吐量</li>
<li>暂停时间</li>
</ul>
</li>
</ul>
<h6 id="1、吞吐量（throughput）"><a href="#1、吞吐量（throughput）" class="headerlink" title="1、吞吐量（throughput）"></a>1、吞吐量（throughput）</h6><ul>
<li><p>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间 / (运行用户代码时间+垃圾收集时间)</p>
<ul>
<li>比如:虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</li>
</ul>
</li>
<li><p>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的。</p>
</li>
<li><p>吞吐量优先，意味着在单位时间内，STW的时间最短：0.2 + 0.2 = 0.4</p>
<p><img src="/2021/04/19/JVM/image-20210428111925067.png" alt="image-20210428111925067"></p>
</li>
</ul>
<h6 id="2、暂停时间（pause-time）"><a href="#2、暂停时间（pause-time）" class="headerlink" title="2、暂停时间（pause time）"></a>2、暂停时间（pause time）</h6><ul>
<li><p>“暂停时间”是指一个时间段内应用程序线程暂停，让GC线程执行的状态</p>
<ul>
<li>例如，GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的。</li>
</ul>
</li>
<li><p>暂停时间优先，意味着尽可能让单次STW的时间最短: 0.1 + 0.1 + 0.1 + 0.1+0.1=0.5</p>
<p><img src="/2021/04/19/JVM/image-20210428112108819.png" alt="image-20210428112108819"></p>
</li>
</ul>
<h6 id="3、吞吐量-VS-暂停时间"><a href="#3、吞吐量-VS-暂停时间" class="headerlink" title="3、吞吐量 VS 暂停时间"></a>3、吞吐量 VS 暂停时间</h6><ul>
<li>高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。</li>
<li>低暂停时间(低延迟)较好因为从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，<strong>有时候甚至短暂的200毫秒暂停都可能打断终端用户体验</strong>。因此，具有低的较大暂停时间是非常重要的，特别是<strong>对于一个交互式应用程序</strong>。</li>
<li>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标(矛盾)。<ul>
<li>因为如果选择以<strong>吞吐量优先</strong>，那么<strong>必然需要降低内存回收的执行频率</strong>，但是这样会<strong>导致GC需要更长的暂停时间来执行内存回收</strong>。</li>
<li>相反的，如果选择以<strong>低延迟优先为原则</strong>，那么为了降低每次执行内存回收时的暂停时间，也<strong>只能频繁地执行内存回收</strong>，但这又引起了<strong>年轻代内存的缩减和导致程序吞吐量的下降</strong>。</li>
</ul>
</li>
<li>在设计(或使用) GC算法时，我们必须确定我们的目标：一个GC算法只可能针对两个目标之一(即只专注于较大吞吐量或最小暂停时间)，或尝试找到一个二者的折衷。</li>
<li>现在标准：<strong>在最大吞吐量优先的情况下，降低停顿时间</strong>。</li>
</ul>
<h4 id="2、不同的垃圾回收器概述"><a href="#2、不同的垃圾回收器概述" class="headerlink" title="2、不同的垃圾回收器概述"></a>2、不同的垃圾回收器概述</h4><h5 id="1、垃圾回收器发展史"><a href="#1、垃圾回收器发展史" class="headerlink" title="1、垃圾回收器发展史"></a>1、垃圾回收器发展史</h5><p>有了虚拟机，就一定需要收集垃圾的机制，这就是Garbage Collection, 对应的产品我们称为Garbage Collector（GC）。</p>
<ul>
<li>1999年随JDK1.3.1一起来的是串行方式的Serial GC，它是第一款GC。ParNew垃圾收集器是Serial收集器的多线程版本</li>
<li>2002年2月26日，Parallel GC和Concurrent Mark Sweep GC跟随JDK1.4.2一起发布</li>
<li>Parallel GC在JDK6之后成为HotSpot默认GC。</li>
<li>2012年，在JDK1.7u4版本中，G1可用。</li>
<li>2017年，JDK9中G1变成默认的垃圾收集器，以替代CMS。</li>
<li>2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</li>
<li>—–分水岭——</li>
<li>2018年9月，JDK11发布。引入Epsilon垃圾回收器，又被称为”No-Op (无操作) “回收器。同时引入ZGC：可伸缩的低延迟垃圾回收器(Experimental)。</li>
<li>2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC：低停顿时间的GC (Experimental)。</li>
<li>2019年9月，JDK13发布。增强ZGC，自动返回未用堆内存给操作系统。</li>
<li>2020年3月，JDK14发布。删除CMS垃圾回收器。扩展ZGC在macOS和Windows上的应用</li>
</ul>
<h5 id="2、七款经典的垃圾收集器"><a href="#2、七款经典的垃圾收集器" class="headerlink" title="2、七款经典的垃圾收集器"></a>2、七款<strong>经典</strong>的垃圾收集器</h5><ul>
<li>串行回收器: Serial、Serial Old</li>
<li>并行回收器: ParNew、Parallel Scavenge、Parallel Old</li>
<li>并发回收器: CMS、G1</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210429023423991.png" alt="image-20210429023423991"></p>
<p><strong>七款经典收集器与垃圾分代之间的关系</strong></p>
<ul>
<li>新生代收集器: Serial、ParNew、Parallel Scavenge;</li>
<li>老年代收集器：Serial Old、Parallel Old、CMS;</li>
<li>整堆收集器：G1;</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210429024547757.png" alt="image-20210429024547757"></p>
<p><strong>垃圾收集器的组合关系</strong>：</p>
<p><img src="/2021/04/19/JVM/image-20210429023609239.png" alt="image-20210429023609239"></p>
<ol>
<li><p>两个收集器间有连线，表明它们可以搭配使用：</p>
<p>Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1;</p>
</li>
<li><p>其中Serial Old作为CMS出现”Concurrent Mode Failure” 失败的后备预案。</p>
</li>
<li><p>(红色虚线)由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃(JEP 173)，并在JDK 9中完全取消了这些组合的支持(JEP214) ，即：移除。</p>
</li>
<li><p>(绿色虚线)JDK 14中：弃用Parallel Scavenge和Serial Old GC组合(JEP366)</p>
</li>
<li><p>(青色虚线)JDK 14中：删除CMS垃圾回收器 (JEP 363)</p>
</li>
</ol>
<p>为什么要有很多收集器，一个不够吗?</p>
<p>因为Java的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。</p>
<p>虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以我们选择的只是<strong>对具体应用最合适的收集器</strong>。</p>
<p><strong>如何查看默认的垃圾收集器</strong>：</p>
<ul>
<li><code>XX:+PrintCommandLineFlags</code>：查看命令行相关参数(包含使用的垃圾收集器)</li>
<li>使用命令行指令：<code>jinfo -flag 相关垃圾回收器参数进程ID</code></li>
</ul>
<h4 id="3、Serial回收器：串行回收"><a href="#3、Serial回收器：串行回收" class="headerlink" title="3、Serial回收器：串行回收"></a>3、Serial回收器：串行回收</h4><ul>
<li><p>Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1. 3之前回收新生代唯一的选择。</p>
</li>
<li><p>Serial收集器作为HotSpot中<strong>Client模式下的默认新生代垃圾收集器</strong>。</p>
</li>
<li><p>Serial收集器采用<strong>复制算法</strong>、<strong>串行回收</strong>和**”Stop-the-World”机制**的方式执行内存回收。</p>
</li>
<li><p>除了年轻代之外，Serial收集器还提供用于<strong>执行老年代垃圾收集</strong>的Serial Old收集器。<strong>Serial Old收集器同样也采用了串行回收和”Stop the World”机制， 只不过内存回收算法使用的是标记-压缩算法</strong>。</p>
<ul>
<li>Serial Old是运行在<strong>Client模式下默认的老年代的垃圾回收器</strong></li>
<li>Serial Old在Server模式下主要有两个用途：<ul>
<li><strong>与新生代的Parallel Scavenge配合使用</strong></li>
<li><strong>作为老年代CMS收集器的后备垃圾收集方案</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它<strong>只会使用一个CPU或一条收集线程去完成垃圾收集工作</strong>，更重要的是在它进行垃圾收集时，<strong>必须暂停其他所有的工作线程</strong>，直到它收集结束(Stop The World) 。</p>
<p><img src="/2021/04/19/JVM/image-20210429085028563.png" alt="image-20210429085028563"></p>
</li>
<li><p>优势：<strong>简单而高效</strong>(与其他收集器的单线程比)，对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p>
<ul>
<li>运行在Client模式下的虚拟机是个不错的选择。</li>
</ul>
</li>
<li><p>在<strong>用户的桌面应用场景</strong>中，可用内存一般不大(几十MB至一两百MB)，可以在较短时间内完成垃圾收集(几十ms至一百多ms) , 只要不频繁发生，使用串行回收器是可以接受的。</p>
</li>
<li><p>在HotSpot虚拟机中，使用<code>-XX: +UseSerialGC</code>参数可以<strong>指定年轻代和老年代都使用串行收集器</strong>。</p>
<ul>
<li>等价于新生代用Serial GC， 且老年代用Serial Old GC</li>
</ul>
</li>
<li><p>总结：</p>
<ul>
<li>这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核cpu才可以用。现在都不是单核的了。</li>
<li>对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在Java web应用程序中是不会采用串行垃圾收集器的。</li>
</ul>
</li>
</ul>
<h4 id="4、ParNew回收器：并行回收"><a href="#4、ParNew回收器：并行回收" class="headerlink" title="4、ParNew回收器：并行回收"></a>4、ParNew回收器：并行回收</h4><ul>
<li><p>如果说Serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是<strong>Serial收集器的多线程版本</strong>。</p>
<ul>
<li>Par是Parallel的缩写，New：只能处理的是<strong>新生代</strong></li>
</ul>
</li>
<li><p>ParNew收集器除了采用<strong>并行回收的方式执行内存回收</strong>外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用<strong>复制算法、”Stop-the-World”机制</strong>。</p>
</li>
<li><p>ParNew是很多JVM运行<strong>在Server模式下新生代的默认垃圾收集器</strong>。</p>
</li>
<li><p>对于新生代，回收次数频繁，使用并行方式高效。</p>
</li>
<li><p>对于老年代，回收次数少，使用串行方式节省资源。 (CPU并行需要切换线程，串行可以省去切换线程的资源)</p>
<p><img src="/2021/04/19/JVM/image-20210429085347499.png" alt="image-20210429085347499"></p>
</li>
<li><p>由于ParNew收集器是基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比Serial收集器更高效?</p>
<ul>
<li>ParNew<br>收集器运行在多CPU的环境下，由于可以充分利用多CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</li>
<li>但是<strong>在单个CPU的环境下，ParNew收集器不比Serial收集器更高效</strong>。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地<br>做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。</li>
</ul>
</li>
<li><p>因为除Serial外，目前<strong>只有ParNew GC能与CMS收集器配合工作</strong></p>
</li>
<li><p>在程序中，开发人员可以通过选项”<code>-XX: +UseParNewGC</code>“手动指定使用ParNew收集器执行内存回收任务。它表示<strong>年轻代使用</strong>并行收集器，<strong>不影</strong><br><strong>响老年代</strong>。</p>
</li>
<li><p><code>-XX: ParallelGCThreads</code><strong>限制线程数量，默认开启和CPU数据相同的线程数</strong>。(一般不超过CPU的数据)</p>
</li>
</ul>
<h4 id="5、Parallel回收器：吞吐量优先"><a href="#5、Parallel回收器：吞吐量优先" class="headerlink" title="5、Parallel回收器：吞吐量优先"></a>5、Parallel回收器：吞吐量优先</h4><ul>
<li><p>HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样也采用了<strong>复制算法</strong>、<strong>并行回收</strong>和**”Stop the World”机制**。</p>
</li>
<li><p>那么Parallel收集器的出现是否多此一举?</p>
<ul>
<li>和ParNew收集器不同，Parallel Scavenge收集器的目标则是达至一个<strong>可控制的吞吐量(Throughput)**，它也被称为</strong>吞吐量优先的垃圾收集器**。</li>
<li><strong>自适应调节策略</strong>也是Parallel Scavenge 与ParNew一个重要区别。</li>
</ul>
</li>
<li><p>高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在<strong>服务器环境中</strong>使用。例如，那些<strong>执行批量处理、订单处理、工资支付、科学计算的应用程序</strong>。</p>
</li>
<li><p>Parallel收集器在JDK1.6时提供了<strong>用于执行老年代垃圾收集</strong>的Parallel Old收集器，用来<strong>代替老年代的Serial Old收集器</strong>。</p>
</li>
<li><p>Parallel Old收集器采用了<strong>标记-压缩算法</strong>，但同样也是<strong>基于并行回收</strong>和**”Stop-the-World”机制**。</p>
</li>
<li><p>在程序吞吐量优先的应用场景中，Parallel收集器和Parallel Old收集器的组合，在Server模式下的内存回收性能很不错。</p>
</li>
<li><p>在Java8中，<strong>默认是此垃圾收集器</strong>。</p>
<p><img src="/2021/04/19/JVM/image-20210429090344976.png" alt="image-20210429090344976"></p>
</li>
<li><p>参数配置：</p>
<ul>
<li><code>-XX: +UseParallelGC</code>：<strong>手动指定年轻代使用Parallel并行收集器执行内存回收任务</strong>。</li>
<li><code>-XX: +UseParallelOldGC</code>：<strong>手动指定老年代都是使用并行回收收集器</strong>。<ul>
<li>分别适用于新生代和老年代。<strong>默认jdk8是开启的</strong>。</li>
<li>上面两个参数，<strong>默认开启一个，另一个也会被开启。 (互相激活)</strong></li>
</ul>
</li>
<li><code>-XX: parallelGCThreads</code>：<strong>设置年轻代并行收集器的线程数</strong>。一般地，<strong>最好与CPU数量相等</strong>，以避免<strong>过多的线程数影响垃圾收集性能</strong>。<ul>
<li>在默认情况下，当CPU数量小于8个， ParallelGCThreads的值等于CPU数量。</li>
<li>当CPU数量大于8个，ParallelGCThreads 的值等于3+[5 * CPU_Count] / 8]</li>
</ul>
</li>
<li><code>-XX:MaxGCPaulseMillis</code>：<strong>设置垃圾收集器最大停顿时间(即STW的时间)。单位是毫秒</strong>。<ul>
<li>为了尽可能地把停顿时间控制在MaxGCPauseMills以内，收集器在工作时会调整Java堆大小或者其他一些参数。</li>
<li>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。</li>
<li><strong>该参数使用需谨慎</strong>。</li>
</ul>
</li>
<li><code>-XX: GCTimeRatio</code>：<strong>垃圾收集时间占总时间的比例</strong>(= 1 / (N + 1))。用于<strong>衡量吞吐量的大小</strong>。</li>
<li>取值范围(0,100)。默认值99，也就是垃圾回收时间不超过1%。</li>
<li><strong>与前一个-XX :MaxGCPauseMillis参数有一定矛盾性</strong>。暂停时间越长，Radio参数就容易超过设定的比例。</li>
<li><code>-XX: +UseAdaptiveSizePolilcy</code>：设置Parallel Scavenge收集器<strong>具有自适应调节策略</strong><ul>
<li>在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</li>
<li>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量(GCT imeRatio)和停顿时间<br>(MaxGCPauseMills)，让虚拟机自己完成调优工作。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="6、CMS回收器：低延迟"><a href="#6、CMS回收器：低延迟" class="headerlink" title="6、CMS回收器：低延迟"></a>6、CMS回收器：低延迟</h4><ul>
<li><p>在JDK 1.5时期，HotSpot推出了一款在<strong>强交互应用</strong>中几乎可认为有划时代意义的垃圾收集器：CMS (Concurrent -Mark -Sweep)收集器，<strong>这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作</strong>。</p>
</li>
<li><p>CMS收集器的关注点是<strong>尽可能缩短垃圾收集时用户线程的停顿时间</strong>。停顿时间越短(低延迟)就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p>
<ul>
<li><strong>目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短</strong>，以给用户带来较好的体验。</li>
<li>CMS收集器就非常符合这类应用的需求。</li>
</ul>
</li>
<li><p>CMS的垃圾收集算法采用<strong>标记-清除</strong>算法，并且也会**”Stop-the-world”**</p>
</li>
<li><p>不幸的是，<strong>CMS作为老年代的收集器</strong>，却<strong>无法与</strong>JDK 1.4.0中已经存在的<strong>新生代收集器Parallel Scavenge 配合工作</strong>，所以在JDK 1.5中<strong>使用CMS来收集老年代</strong>的时候，<strong>新生代只能选择ParNew或者Serial收集器中的一个</strong>。在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC。</p>
</li>
<li><p>CMS的工作原理：</p>
<p><img src="/2021/04/19/JVM/image-20210429095659541.png" alt="image-20210429095659541"></p>
</li>
<li><p>CMS整个过程比之前的收集器要复杂，整个过程分为<strong>4个主要阶段</strong>，即<strong>初始标记阶段</strong>、<strong>并发标记阶段</strong>、<strong>重新标记阶段</strong>和<strong>并发清除阶段</strong>。</p>
<ul>
<li>初始标记(Initial-Mark)阶段：在这个阶段中，程序中所有的工作线程都将会因为Stop-the-World”机制而出现短暂的暂停，这个阶段的主要任务<strong>仅仅只是标记出GCRoots能直接关联到的对象</strong>。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的<strong>速度非常快</strong>。</li>
<li>并发标记(Concurrent-Mark)阶段：<strong>从GC Roots的直接关联对象开始遍历整个对象图的过程</strong>，这个过程<strong>耗时较长</strong>但是<strong>不需要停顿用户线程</strong>，可以与垃圾收集线程一起<strong>并发运行</strong>。</li>
<li>重新标记(Remark) 阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了<strong>修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</strong>，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</li>
<li>并发清除(Concurrent-Sweep) 阶段：此阶段<strong>清理删除掉标记阶段判断的已经死亡的对象，释放内存空间</strong>。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时<strong>并发的</strong>。</li>
</ul>
</li>
<li><p>尽管CMS收集器采用的是<strong>并发回收(非独占式)**，但是在其</strong>初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制**暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“Stop-the-World”，只是尽可能地缩短暂停时间。</p>
</li>
<li><p><strong>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的</strong>。</p>
</li>
<li><p>另外，由于在垃圾收集阶段用户线程没有中断，所以<strong>在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用</strong>。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当<strong>堆内存使用率达到某一阈值时，便开始进行回收</strong>，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次”<strong>Concurrent Mode Failure</strong>“失败，这时虛拟机将启动<strong>后备预案:临时启用Serial Old收集器</strong>来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p>
</li>
<li><p>CMS收集器的垃圾收集算法采用的是<strong>标记-清除算法</strong>，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会<strong>产生一些内存碎片</strong>。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞(Bump the Pointer) 技术，而只能够选择<strong>空闲列表(Free List) 执行内存分配</strong>。</p>
</li>
<li><p>既然Mark Sweep会造成内存碎片，那么为什么不把算法换成Mark Compact呢?</p>
<ul>
<li>答案其实很简答，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢?</li>
<li>要保证用户线程能继续执行，前提的<strong>它运行的资源不受影响</strong>嘛。Mark Compact更适合“Stop the World”这种场景下使用</li>
</ul>
</li>
<li><p>CMS的优点：</p>
<ul>
<li><strong>并发收集</strong></li>
<li><strong>低延迟</strong></li>
</ul>
</li>
<li><p>CMS的弊端：</p>
<ol>
<li><strong>会产生内存碎片</strong>，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发Full GC。</li>
<li><strong>CMS收集器对CPU资源非常敏感</strong>。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</li>
<li><strong>CMS收集器无法处理浮动垃圾</strong>。可能出现”<strong>Concurrent Mode Failure</strong>“失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么<strong>在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收</strong>，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。</li>
</ol>
</li>
<li><p>CMS收集器可以设置的参数：</p>
<ul>
<li><code>-XX: +UseConcMarkSweepGC</code>：<strong>手动指定使用CMS收集器执行内存回收任务</strong>。<ul>
<li>开启该参数后会自动将<code>-XX: +UseParNewGC</code>打开。 即：<strong>ParNew (Young区用) +CMS (Old区用) + Serial Old的组合。</strong></li>
</ul>
</li>
<li><code>-XX:CMSlnitiatingOccupancyFraction</code>：<strong>设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收</strong>。<ul>
<li><strong>JDK5及以前版本的默认值为<code>68</code>**，即当</strong>老年代的空间<strong>使用率达到68%时，会执行一次CMS回收。</strong>JDK6及 以上版本默认值为92%**</li>
<li>如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此<strong>通过该选项便可以有效降低Full GC的执行次数</strong>。</li>
</ul>
</li>
<li><code>-XX: +UseCMSCompactAtFullCollection</code>：<strong>用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生</strong>。不过由于内存压缩整理过程无法并发执行，所带来的问题就是<strong>停顿时间变得更长</strong>了。</li>
<li><code>-XX: CMSFullGCsBeforeCompaction</code>：<strong>设置在执行多少次Full GC后对内存空间进行压缩整理</strong>。</li>
<li><code>-XX:Parallel CMSThreads</code>：<strong>设置CMS的线程数量</strong>。</li>
<li>CMS默认启动的线程数是<code>(ParallelGCThreads+3) / 4</code>，<strong>ParallelGCThreads是年轻代并行收集器的线程数</strong>。当CPU资源比较紧张时，受到CMs收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</li>
</ul>
</li>
<li><p>小结：</p>
<ul>
<li>HotSpot有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC这三个GC有什么不同呢?</li>
<li>请记住以下口令：<ul>
<li>如果你想要<strong>最小化地使用内存和并行开销</strong>，请选<strong>Serial GC</strong>;</li>
<li>如果你想要<strong>最大化应用程序的吞吐量</strong>，请选<strong>Parallel GC</strong>;</li>
<li>如果你想要<strong>最小化GC的中断或停顿时间</strong>，请选<strong>CMS GC</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p>JDK后续版本中CMS的变化</p>
<ul>
<li><p>JDK9新特性：<strong>CMS被标记为Deprecate了(JEP291)</strong></p>
<ul>
<li>如果对JDK9及以上版本的HotSpot虚拟机使用参数<code>-XX:+UseConcMarkSweepGC</code>来开启CMS收集器的话，用户会收到一个警告信息，<strong>提示CMS未来将会被废弃</strong>。</li>
</ul>
</li>
<li><p>JDK14新特性：<strong>删除CMS垃圾回收器(JEP363)</strong></p>
<ul>
<li><p>移除了CMS垃圾收集器，如果在JDK14中使用<code>-XX: +UseConcMarkSweepGC</code>的话，<strong>JVM不会报错，只是给出一个warning信息，但是不会exit</strong>。<strong>JVM会自动回退以默认GC方式启动JVM</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OpenJDK 64-Bit Server VM warning: Ignoring option UseConcMarkSweepGC;support was removed in 14. 0 and the VM will continue execution using the default collector.</span><br></pre></td></tr></table></figure>




</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="7、G1回收器：区域化分代式"><a href="#7、G1回收器：区域化分代式" class="headerlink" title="7、G1回收器：区域化分代式"></a>7、G1回收器：区域化分代式</h4><h5 id="1、两个问题"><a href="#1、两个问题" class="headerlink" title="1、两个问题"></a>1、两个问题</h5><p>问题1：既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First (G1)GC?</p>
<ul>
<li>原因就在于应用程序所应对的<strong>业务越来越庞大、复杂，用户越来越多</strong>，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。G1 (Garbage-First) 垃圾回收器是在Java7 update 4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。</li>
<li>与此同时，为了适应现在<strong>不断扩大的内存和不断增加的处理器数量</strong>，进一步降低暂停时间(pause time) ，同时兼顾良好的吞吐量。</li>
<li><strong>官方给G1设定的目标是<code>在延迟可控的情况下获得尽可能高的吞吐量</code>，所以才担当起”全功能收集器”的重任与期望。</strong></li>
</ul>
<p>问题2：为什么名字叫做Garbage First (G1) 呢?</p>
<ul>
<li>因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域(Region) (物理上不连续的)。使用不同的Region来表示Eden、 幸存者0区，幸存者1区，老年代等。</li>
<li>G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值)，<strong>在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region</strong>。</li>
<li>由于这种方式的侧重点在于回收垃圾最大量的区间(Region) ，所以我们给G1一个名字：<strong>垃圾优先(Garbage First)</strong> 。</li>
</ul>
<h5 id="2、G1概述"><a href="#2、G1概述" class="headerlink" title="2、G1概述"></a>2、G1概述</h5><p>G1 (Garbage-First)是一款<strong>面向服务端应用</strong>的垃圾收集器，<strong>主要针对配备多核CPU及大容量内存的机器</strong>，以<strong>极高概率满足GC停顿时间</strong>的同时，还<strong>兼具高吞吐量</strong>的性能特征。</p>
<p>在JDK1.7版本正式启用，移除了Experimental的标识，是<strong>JDK 9以后的默认垃圾回收器</strong>，取代了CMS回收器以及Parallel + Parallel Old组合。被Oracle官方称为“<strong>全功能的垃圾收集器</strong>”。</p>
<p>与此同时，CMS已经在JDK 9中被标记为废弃(deprecated) 。在jdk8中还不是默认的垃圾回收器，需要使用<code>-XX: +UseG1GC</code>来启用。</p>
<h5 id="3、G1的特点（优势）与缺点"><a href="#3、G1的特点（优势）与缺点" class="headerlink" title="3、G1的特点（优势）与缺点"></a>3、G1的特点（优势）与缺点</h5><p>与其他GC收集器相比，G1使用了全新的<strong>分区算法</strong>，其特点有如下四点：</p>
<ul>
<li><p><strong>并行与并发</strong></p>
<ul>
<li>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW</li>
<li>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，<strong>不会出现在整个回收阶段发生完全阻塞应用程序的情况</strong></li>
</ul>
</li>
<li><p><strong>分代收集</strong></p>
<ul>
<li><p>从分代上看，<strong>G1依然属于分代型垃圾回收器</strong>，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</p>
</li>
<li><p><strong>将堆空间分为若千个区域(Region) ,这些区域中包含了逻辑上的年轻代和老年代</strong>。</p>
</li>
<li><p>和之前的各类回收器不同，它<strong>同时兼顾年轻代和老年代</strong>。对比其他回收器，或者工作在年轻代，或者工作在老年代</p>
<p><img src="/2021/04/19/JVM/image-20210429235305962.png" alt="image-20210429235305962"></p>
</li>
</ul>
</li>
<li><p><strong>空间整合</strong></p>
<ul>
<li>CMS：“标记-清除”算法、内存碎片、若干次GC后进行一次碎片整理</li>
<li>G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。<strong>Region之间是复制算法</strong>，但<strong>整体上实际可看作是标记-压缩(Mark-Compact )算法</strong>，两种算法都可以<strong>避免内存碎片</strong>。这种特性<strong>有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC</strong>。尤其是当<strong>Java堆非常大的时候，G1的优势更加明显</strong>。</li>
</ul>
</li>
<li><p><strong>可预测的停顿时间模型</strong>(即：软实时soft real-time)</p>
<p>这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。(其中吞吐量 = M-N / M)</p>
<ul>
<li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li>
<li>G1跟踪各个Region里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值)，在后台维护一个优先列表，<strong>每次根据允许的收集</strong><br><strong>时间，优先回收价值最大的Region</strong>。保证了G1 收集器在有限的时间内可以<strong>获取尽可能高的收集效率</strong>。</li>
<li>相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</li>
</ul>
</li>
</ul>
<p>G1收集器的缺点：</p>
<ul>
<li>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是<strong>为了垃圾收集产生的内存占用(Footprint) 还是程序运行时的额外执行负载(Overload)</strong> 都要比CMS要高。</li>
<li>从经验上来说，在<strong>小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势</strong>。<strong>平衡点在6-8GB之间</strong>。</li>
</ul>
<h5 id="4、G1回收器的参数设置"><a href="#4、G1回收器的参数设置" class="headerlink" title="4、G1回收器的参数设置"></a>4、G1回收器的参数设置</h5><ul>
<li><strong><code>-XX: +UseG1GC</code>**：</strong>手动指定使用G1收集器执行内存回收任务**。</li>
<li><strong><code>-XX: G1HeapRegionSize</code>**：</strong>设置每个Region的大小**。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/ 2000。</li>
<li><strong><code>-XX: MaxGCPauseMillis</code>**：</strong>设置期望达到的最大GC停顿时间指标(JVM会尽力实现，但不保证达到)。默认值是200ms**</li>
<li><code>-XX: ParallelGCThread</code>：<strong>设置STW时GC线程数的值。最多设置为8</strong></li>
<li><code>-XX: ConcGCThreads</code>：<strong>设置并发标记的线程数</strong>。将n设置为<strong>并行垃圾回收线数(ParallelGCThreads)的1/4左右</strong>。</li>
<li><code>-XX: InitiatingHeapoccupancyPercent</code>：<strong>设置触发并发GC周期的Java堆占用率阈值</strong>。超过此值，就触发GC。<strong>默值是45</strong>。堆空间已用占比达到45%，老年代才会并发标记</li>
</ul>
<h5 id="5、G1回收器的常见操作步骤"><a href="#5、G1回收器的常见操作步骤" class="headerlink" title="5、G1回收器的常见操作步骤"></a>5、G1回收器的常见操作步骤</h5><ul>
<li>G1的设计原则就是<strong>简化JVM性能调优</strong>，开发人员只需要简单的三步即可完成调优：<ol>
<li>第一步：<strong>开启G1垃圾收集器</strong></li>
<li>第二步：<strong>设置堆的最大内存</strong></li>
<li>第三步：<strong>设置最大的停顿时间</strong></li>
</ol>
</li>
<li>G1中提供了三种垃圾回收模式：<strong>YoungGC、 Mixed GC和Full GC，在不同的条件下被触发</strong>。</li>
</ul>
<h5 id="6、G1回收器的适用场景"><a href="#6、G1回收器的适用场景" class="headerlink" title="6、G1回收器的适用场景"></a>6、G1回收器的适用场景</h5><ul>
<li><strong>面向服务端应用</strong>，针对具有<strong>大内存、多处理器</strong>的机器。(在普通大小的堆里表现并不惊喜)</li>
<li>最主要的应用是<strong>需要低GC延迟，并具有大堆的应用程序</strong>提供解决方案；</li>
<li>如：在堆大小<strong>约6GB或更大</strong>时，<strong>可预测的暂停时间可以低于0.5秒</strong>；(G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长)。</li>
<li>用来替换掉JDK1.5中的CMS收集器；在下面的情况时，使用G1可能比CMS好：<ol>
<li><strong>超过50%的Java堆被活动数据占用</strong>；</li>
<li><strong>对象分配频率或年代提升频率变化很大</strong>；</li>
<li><strong>GC停顿时间过长</strong>(长于0.5至1秒)</li>
</ol>
</li>
<li>HotSpot垃圾收集器里，除了G1以外，其他的垃圾收集器使用内置的JVM线程执行GC的多线程操作，而G1 GC可以采用<strong>应用线程承担后台运行的GC工作</strong>，即<strong>当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程</strong>。</li>
</ul>
<h5 id="7、分区Region：化整为零"><a href="#7、分区Region：化整为零" class="headerlink" title="7、分区Region：化整为零"></a>7、分区Region：化整为零</h5><p>使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB<br>之间，且为2的N次幂，即1MB, 2MB, 4MB, 8MB, 16MB, 32MB。可以通过<code>-XX:G1HeapRegionSize</code>设定。<strong>所有的Region大小相同，且在JVM生命周期内</strong><br><strong>不会被改变</strong>。</p>
<p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region (不需要连续)的集合。<strong>通过Region的动态分配方式实</strong><br><strong>现逻辑上的连续</strong>。</p>
<ul>
<li><strong>如果设置了Region数量，那么Region大小就不是固定的，但是大小肯定是2的幂次方，并且在1-32M之间</strong>；</li>
<li><strong>如果设置了Region大小，那么Region数量就不是固定的，但是肯定是2048附近</strong>；</li>
</ul>
<p>Region只能是Eden、Survivor、 Humongous中的一种，但是它的身份不是固定的，谁来占用那么这个Region就是谁的</p>
<p><img src="/2021/04/19/JVM/image-20210430001836775.png" alt="image-20210430001836775"></p>
<ul>
<li>一个region有可能属于Eden，Survivor 或者Old/Tenured 内存区域。但是一个region只可能属于一个角色。图中的E表示该region属于Eden内存区域，s表示属于Survivor内存区域，O表示属于Old内存区域。图中空白的表示未使用的内存空间。</li>
<li>G1垃圾收集器还增加了一种新的内存区域，叫做<strong>Humongous内存区域</strong>，如图中的H块。主要用于<strong>存储大对象</strong>，如果<strong>超过0.5个region，就放到H</strong>。region是可以连续分配的，小于0.5的就用两个连续的region分配</li>
<li>object that is more than half a region size is considered a “Humongous object” ：大于区域大小一半的对象都被视为“巨大对象”</li>
</ul>
<p>设置Humongous的原因：</p>
<p>对于<strong>堆中的大对象，默认直接会被分配到老年代</strong>，但是如果它是一个短期存在的大对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个<strong>Humongous区，它用来专门存放大对象</strong>。如果<strong>一个H区装不下一个大对象，那么G1会寻找连续的H区来存储</strong>。为了能找到<strong>连续的H区</strong>，有时候不得不<strong>启动Full GC</strong>。G1的<strong>大多数行为都把H区作为老年代的一部分来看待</strong>。</p>
<p>关于指针碰撞与空闲列表：</p>
<ul>
<li><p>Bump：单个Region使用指针碰撞的方式来放数据上面allocated是已经使用的内存空间，top就是指针的位置，unallocate是没有使用的内存空间</p>
<ul>
<li>Bump-the-pointer，即：指针碰撞</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210430002300492.png" alt="image-20210430002300492"></p>
</li>
<li><p>TLAB：虽然存在分区Region，但是依然有线程独有的TLAB空间，这样可以保证多个线程对对象修改可以并行操作</p>
<ul>
<li>TLAB，即：空闲列表</li>
</ul>
</li>
</ul>
<h5 id="8、G1回收器垃圾回收过程"><a href="#8、G1回收器垃圾回收过程" class="headerlink" title="8、G1回收器垃圾回收过程"></a>8、G1回收器垃圾回收过程</h5><p>G1 GC的垃圾回收过程主要包括如下三个环节：</p>
<ul>
<li>年轻代GC (Young GC)</li>
<li>老年代并发标记过程(Concurrent Marking)</li>
<li>混合回收(Mixed GC)</li>
<li>(如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。)</li>
</ul>
<p>顺时针，Young GC -&gt; Young GC +Concurrent Marking -&gt; Mixed GC顺序，进行垃圾回收。</p>
<p><img src="/2021/04/19/JVM/image-20210429185519798.png" alt="image-20210429185519798"></p>
<ul>
<li>应用程序分配内存，<strong>当年轻代的Eden区用尽时开始年轻代回收过程</strong>；G1的年轻代收集阶段是一个<strong>并行的独占式收集器</strong>。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后<strong>从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及</strong>。</li>
<li>当堆内存使用达到一定值(<strong>默认45%</strong>)时，开始老年代并发标记过程。</li>
<li>标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，<strong>G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了</strong>。同时，<strong>这个老年代Region是和年轻代一起被回收的</strong>。</li>
<li>举个例子：一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45号%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</li>
</ul>
<p><strong>G1回收器垃圾回收过程：Remembered Set</strong></p>
<ul>
<li><p>一个对象被不同区域引用的问题</p>
</li>
<li><p>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确?</p>
</li>
<li><p>在其他的分代收集器，也存在这样的问题(而G1更突出)</p>
</li>
<li><p>回收新生代也不得不同时扫描老年代?</p>
<ul>
<li>这样的话会降低Minor GC的效率；</li>
</ul>
</li>
<li><p>解决方法：</p>
<ul>
<li><strong>无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描</strong>：<ul>
<li>每个Region都有一个对应的Remembered Set；</li>
<li>每次Reference类型数据写操作时，都会产生一个Write Barrier 暂时中断操作；</li>
<li>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region(其他收集器：检查老年代对象是否引用了新生代对象)；</li>
<li>如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；<ul>
<li>卡表是记忆集的一种具体实现方式。 见《深入理解Java虚拟机》</li>
</ul>
</li>
<li>当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏；</li>
</ul>
</li>
</ul>
<p><img src="/2021/04/19/JVM/blog\XGH-blog\source_posts\JVM\image-20210430003324501.png" alt="image-20210430003324501"></p>
</li>
<li><p>上面提到的Remebered Set就是上述Reset，上面提到的Reference类型就是引用类型，其中Reset的作用是记录当前Region中哪些对象被外部引用指向，比如OId区中的对象会指向Eden区的对象，然后当我们要回收某个Region的时候，直接遍历遍历当前Region中的所有对象就可以了，然后针对性的去找到那些指向当前对象的其他对象，最终发现当前对象是否是根可达的，如果不是，那就应该被删除，其实之前的垃圾回收器都涉及到这个问题，当进行Minor GC的时候，通过GC Roots查找的时候还需要遍历Old区的对象，毕竟Old区对象也可能会指向Eden区对象，但是G1通过Rset避免了全堆的扫描，当引用类型数据写操作时，先暂时中断，然后判断当前引用类型数据是否被其他对象所指向，如果不被指向，那就直接放在Region中就可以了；如果被其他对象指向，那么还要判断这个对象是在当前要插入的Region中，还是在其他Region中;如果在其他Region中，那就需要使用CardTable把当前引用类型数据的指向信息放在Rset中，也就是形成上面的虚线连线，如果在当前Region中，那就不需要指向了，毕竟到时候我们会进行遍历查找根可达对象，那肯定会找到的，所以这种情况也是直接放在Region中就可以了。</p>
</li>
</ul>
<h5 id="9、G1回收过程一：年轻代GC"><a href="#9、G1回收过程一：年轻代GC" class="headerlink" title="9、G1回收过程一：年轻代GC"></a>9、G1回收过程一：年轻代GC</h5><p>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</p>
<p><strong>年轻代垃圾回收只会回收Eden区和Survivor区</strong>。</p>
<p>首先G1停止应用程序的执行(Stop-The-World)，G1创建回收集(Collection Set)，回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。</p>
<p><img src="/2021/04/19/JVM/image-20210430003008242.png" alt="image-20210430003008242"></p>
<p>然后开始如下回收过程：</p>
<ol>
<li><p>第一阶段，<strong>扫描根</strong>。可以体现Rset作用：<strong>避免全堆扫描</strong></p>
<ul>
<li>根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口。</li>
</ul>
</li>
<li><p>第二阶段，<strong>更新RSet</strong>。 作用：<strong>保证Rset中的数据准确性</strong></p>
<ul>
<li><p>处理dirty card queue中的card，更新RSet。此阶段完成后，<strong>RSet 可以准确的反映老年代对所在的内存分段中对象的引用</strong>。</p>
</li>
<li><p>对dirty card queue (脏卡表队列)的解释：</p>
<ul>
<li>对于应用程序的引用赋值语句object.field=object，JVM会在之前和之后执行特殊的操作以在dirty card queue中入队一个保存了对象引用信息的card。在年轻代回收的时候，G1会对Dirty Card Queue中所有的card进行处理，以更新RSet，保证RSet实时准确的反映引用关系。<ul>
<li>其中object.field=object中的第一个object代表老年代中的对象，而第二个object代表Eden区中的对象</li>
</ul>
</li>
<li>那为什么不在引用赋值语句处直接更新RSet呢?<ul>
<li>这是为了性能的需要，RSet的处理需要线程同步，开销会很大，使用队列性能会好很多。</li>
</ul>
</li>
</ul>
</li>
<li><p>脏卡表队列作用：</p>
<p>Reset更新需要线程同步，所以开销会很大，因此不能实时更新，因此我们需要把引用对象被其他对象引用的关系放在一个脏卡表队列中，当年轻代回收的时候会进行STW，所以我们也正好把脏卡表队列中的值更新到Rset中，这样不仅没有涉及到开销问题，还可以保证Rset中的数据是准确的。</p>
</li>
</ul>
</li>
<li><p>第三阶段，<strong>处理RSet</strong>。作用：<strong>根可达性遍历的一部分</strong></p>
<ul>
<li>识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</li>
</ul>
</li>
<li><p>第四阶段，<strong>复制对象</strong>。说明：<strong>新生代使用复制算法</strong></p>
<ul>
<li>此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到Old区中空的内存分段。如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。</li>
</ul>
</li>
<li><p>第五阶段，<strong>处理引用</strong>。空Eden：<strong>Eden变成空的，那它就变成了无主Region，因此会被记录到空链表中，等待下一次被分配</strong></p>
<ul>
<li>处理Soft，Weak，Phantom， Final， JNI Weak 等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</li>
<li>以上回收的都是强引用对象，下面回收软引用对象 (不足回收)、弱引用对象(发现回收)、虚引用对象</li>
</ul>
</li>
</ol>
<h5 id="10、G1回收过程二：并发标记过程"><a href="#10、G1回收过程二：并发标记过程" class="headerlink" title="10、G1回收过程二：并发标记过程"></a>10、G1回收过程二：并发标记过程</h5><ol>
<li><strong>初始标记阶段</strong>：标记从根节点直接可达的对象。<strong>这个阶段是STW的，并且会触发一次年轻代GC</strong>。</li>
<li><strong>根区域扫描(Root Region Scanning)**：G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在Young GC之前完成。</strong>主要扫描哪些老年代对象是可达的**，毕竟我们进行Young GC的时候会移动Survivor区，移动之后就找不到哪些老年代对象是可达的了</li>
<li><strong>并发标记(Concurrent Marking)**：在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被Young GC中断。在并发标记阶段，</strong>若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收**（实时回收）。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。</li>
<li>**再次标记(Remark)**：由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法：snapshot-at-the-beginning (SATB)。<ul>
<li>原因：并发标记不准确</li>
</ul>
</li>
<li><strong>独占清理(cleanup ,STW)**：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。</strong>是STW的<strong>。</strong>其实是一个统计计算过程，不会涉及垃圾清理**<ul>
<li><strong>这个阶段并不会实际上去做垃圾的收集</strong></li>
</ul>
</li>
<li><strong>并发清理阶段</strong>：识别并清理完全空闲的区域。<ul>
<li>并发清理阶段任务：<strong>如果发现区域对象中的所有对象都是垃圾，那么这个区域会被立即回收</strong>。</li>
</ul>
</li>
</ol>
<h5 id="11、G1回收过程三：混合回收"><a href="#11、G1回收过程三：混合回收" class="headerlink" title="11、G1回收过程三：混合回收"></a>11、G1回收过程三：混合回收</h5><p>当越来越多的对象晋升到老年代Old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个Old GC，除了回收整个Young Region，还会回收一部分的Old Region。 这里需要注意：是<strong>一部分老年代，而不是全部老年代</strong>。可以选择哪些Old Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是<strong>Mixed GC并不是Full GC</strong>。 </p>
<p><img src="/2021/04/19/JVM/image-20210429194133565.png" alt="image-20210429194133565"></p>
<ul>
<li>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次(可以通过<code>-XX: G1MixedGCCountTarget</code>设置)被回收。</li>
<li>混合回收的回收集(Collection Set)包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</li>
<li>由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。<strong>垃圾占内存分段比例越高的，越会被先回收</strong>。并且有一个阈值会决定内存分段是否被回收，<code>-XX:G1MixedGCLiveThresholdPercent</code>，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。<strong>如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。垃圾占比越多， 回收优先级越高</strong>；如果垃圾不足Region空间的65%，那么将不会进行回收。</li>
<li>混合回收并不一定要进行8次。有一个阈值<code>-XX:G1HeapWastePercent</code>，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。如果垃圾不足Region内存的10%，那么将不会对该老年代Region进行回收，综合上面的来看，只要垃圾占整个老年代Region的比例大于65%，才会对该Region进行回收</li>
</ul>
<h5 id="12、G1回收可选的过程四：Full-GC"><a href="#12、G1回收可选的过程四：Full-GC" class="headerlink" title="12、G1回收可选的过程四：Full GC"></a>12、G1回收可选的过程四：Full GC</h5><ul>
<li><p>G1的初衷就是要避免Fu1l GC的出现。但是如果上述方式不能正常工作，G1会<strong>停止应用程序的执行</strong>(Stop- The-World)，使用<strong>单线程</strong>的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p>
</li>
<li><p>要避免Full GC的发生，一旦发生需要进行调整。什么时候会发生Full GC呢?</p>
<ul>
<li>比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到Full GC，这种情况可以通过增大内存解决。</li>
</ul>
</li>
<li><p>导致G1Full GC的原因可能有三个:</p>
<ol>
<li>Evacuation的时候没有足够的to-space来存放晋升的对象；</li>
</ol>
<ul>
<li>解决：加大堆空间</li>
</ul>
<ol start="2">
<li>并发处理过程完成之前空间耗尽。</li>
</ol>
<ul>
<li>解决：调小触发并发GC周期的Java堆占用阈值(默认是45%， 在前面参数页有)</li>
</ul>
<ol start="3">
<li>最大GC暂停时间太短，导致在规定的时间间隔内无法完成垃圾回收，也会导致Full GC</li>
</ol>
<ul>
<li>解决：加大最大GC停顿时间</li>
</ul>
</li>
</ul>
<h5 id="13、G1回收过程：补充"><a href="#13、G1回收过程：补充" class="headerlink" title="13、G1回收过程：补充"></a>13、G1回收过程：补充</h5><p>从Oracle官方透露出来的信息可获知，回收阶段( Evacuation)其实本也有想过设计成<strong>与用户程序一起并发执行</strong>，但这件事情做起来比较复杂，考虑到G1只是回收一部分Region， 停顿时间是用户可控制的，所以并不迫切去实现，而<strong>选择把这个特性放到了G1之后出现的低延迟垃圾收集器(即ZGC)中</strong>。另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p>
<h5 id="14、G1回收器优化建议"><a href="#14、G1回收器优化建议" class="headerlink" title="14、G1回收器优化建议"></a>14、G1回收器优化建议</h5><ul>
<li>年轻代大小<ul>
<li>避免使用<code>-Xmn</code>或<code>-XX:NewRatio</code>等相关选项显式设置年轻代大小</li>
<li>固定年轻代的大小会覆盖暂停时间目标<ul>
<li>原因：年轻代GC是并行独占式的，所以最好让垃圾回收器自己去调节</li>
</ul>
</li>
</ul>
</li>
<li>暂停时间目标不要太过严苛<ul>
<li>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间</li>
<li>评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li>
<li>说明：暂停时间和吞吐量是此消彼长的，所以不要把暂停时间设置的太严格，不然因为这个原因引起Full GC也不太好</li>
</ul>
</li>
</ul>
<h4 id="8、垃圾回收总结"><a href="#8、垃圾回收总结" class="headerlink" title="8、垃圾回收总结"></a>8、垃圾回收总结</h4><p>截止JDK 1.8，一共有7款不同的垃圾收集器。每一款不同的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</p>
<table>
<thead>
<tr>
<th>垃圾收集器</th>
<th>分类</th>
<th>作用位置</th>
<th>使用算法</th>
<th>特点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>Serial</td>
<td>串行运行</td>
<td>作用于新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>适用于单CPU</td>
</tr>
<tr>
<td>ParNew</td>
<td>并行运行</td>
<td>作用于新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>多CPU环境Server模式下与CMS配合使用</td>
</tr>
<tr>
<td>Parallel</td>
<td>并行运行</td>
<td>作用于新生代</td>
<td>复制算法</td>
<td>吞吐量优先</td>
<td>适用于后台运算而不需要太多交互的场景</td>
</tr>
<tr>
<td>Serial Old</td>
<td>串行运行</td>
<td>作用于老年代</td>
<td>标记-压缩算法</td>
<td>响应速度优先</td>
<td>适用于单CPU环境下的Client模式</td>
</tr>
<tr>
<td>Parallel Old</td>
<td>并行运行</td>
<td>作用于老年代</td>
<td>标记-压缩算法</td>
<td>吞吐量优先</td>
<td>适用于后台运算而不需要太多交互的场景</td>
</tr>
<tr>
<td>CMS</td>
<td>并发运行</td>
<td>作用于老年代</td>
<td>标记-清除算法</td>
<td>响应速度优先</td>
<td>适用于互联网或B/S业务</td>
</tr>
<tr>
<td>G1</td>
<td>并发、并行运行</td>
<td>作用于新生代、老年代</td>
<td>标记-压缩算法、复制算法</td>
<td>响应速度优先</td>
<td>面向服务端应用</td>
</tr>
</tbody></table>
<p>GC发展阶段：Serial =&gt; Parallel (并行) =&gt; CMS (并发) =&gt; G1 =&gt; ZGC</p>
<p><strong>怎么选择垃圾回收器?</strong></p>
<ul>
<li>Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。</li>
<li>怎么选择垃圾收集器?<ol>
<li>优先调整堆的大小让JVM自适应完成。</li>
<li>如果<strong>内存小于100M</strong>， 使用<strong>串行收集器</strong></li>
<li>如果是<strong>单核、单机程序，并且没有停顿时间</strong>的要求，<strong>串行收集器</strong></li>
<li>如果是<strong>多CPU</strong>、需要<strong>高吞吐量</strong>、<strong>允许停顿时间超过1秒</strong>，选择<strong>并行</strong>或者<strong>JVM自己选择</strong>.</li>
<li>如果是<strong>多CPU</strong>、<strong>追求低停顿时间</strong>，需<strong>快速响应</strong>(比如延迟不能超过1秒，如互联网应用)，使用并发收集器官方推荐<strong>G1</strong>，性能高。现在互联网的项目，基本都是使用G1。</li>
<li>最后需要明确一个观点：<ol>
<li>没有最好的收集器，更没有万能的收集器；</li>
<li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li>
</ol>
</li>
</ol>
</li>
<li>面试：<ul>
<li>对于垃圾收集，面试官可以循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂得原理，一定会成为面试中的加分项。<br>这里较通用、基础性的部分如下：<ul>
<li>垃圾收集的算法有哪些?</li>
<li>如何判断一个对象是否可以回收?</li>
<li>垃圾收集器工作的基本流程。</li>
</ul>
</li>
<li>另外，大家需要多关注垃圾回收器这一章的各种常用的参数。</li>
</ul>
</li>
</ul>
<h4 id="9、GC日志分析"><a href="#9、GC日志分析" class="headerlink" title="9、GC日志分析"></a>9、GC日志分析</h4><p>通过阅读GC日志，我们可以了解Java虚拟机内存分配与回收策略。</p>
<ul>
<li><p>内存分配与垃圾回收的参数列表</p>
<ul>
<li><code>-XX: +PrintGC</code>：输出Gc日志。类似: -verbose :gc</li>
<li><code>-XX: +PrintGCDetails</code>：输出GC的详细日志</li>
<li><code>-XX: +PrintGCTimeStamjps</code>：输出GC的时间戳(以基准时间的形式)</li>
<li><code>-XX: +PrintGCDateStamps</code>：输出GC的时间戳(以日期的形式，如2013-05-04T21 :53:59.234+0800)</li>
<li><code>-XX: + PrintHeapAtGC</code> ：在进行GC的前后打印出堆的信息</li>
<li><code>-Xloggc: ../logs/gc.log</code>：日志文件的输出路径</li>
</ul>
</li>
<li><p>打开GC日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-verbose: gc</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个只会显示总的GC堆的变化， 如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) 80832K-&gt;19298K(227840K)，0.0084018secs]</span><br><span class="line">[GC (Metadata GC Threshold) 109499K-&gt;21465K (228352K)，0.0184066 secs]</span><br><span class="line">[Full GC (Metadata GC Threshold) 21465K-&gt;16716K(201728K) ，0.0619261secs ]</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数解析：</p>
<ul>
<li>GC、Full GC：GC的类型，GC只在新生代上进行，Full GC包括永生代，新生代， 老年代。</li>
<li>Allocation Failure: GC发生的原因。</li>
<li>80832K -&gt; 19298K：堆在GC前的大小和GC后的大小。</li>
<li>228840k：现在的堆大小。</li>
<li>0.0084018 secs：GC持续的时间。</li>
</ul>
</li>
</ul>
<ul>
<li><p>打开GC日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-verbose: gc -XX: +PrintGCDetails</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入信息如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure)[PSYoungGen: 70640K-&gt;10116K(141312K)] 80541K-&gt;20017K (227328K)，0.0172573secs]</span><br><span class="line">[Times: user=0.03 sys=0.00， real=0.02 secs]</span><br><span class="line">[GC (Metadata GC Threshold) [PSYoungGen: 98859K-&gt;8154K(142336K) ] 108760K-&gt;21261K (228352K)，0.0151573 secs]</span><br><span class="line">[Times: user=0.00 sys=0.01, real=0.02 secs]</span><br><span class="line">[Full GC (Metadata GC Threshold) [PSYoungGen: 8154K-&gt;0K(142336K) ] [ParOldGen: 13107K-&gt;16809K(62464K)] 21261K -&gt; 16809K (204800K),</span><br><span class="line">[Metaspace: 20599K-&gt;20599K (1067008K)]，0.0639732 secs]</span><br><span class="line">[Times: user=0.14 sys=0.00， real=0.06 secs]</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数解析:</p>
<ul>
<li>GC，Full FC：同样是GC的类型</li>
<li>Allocation Failure：GC原因</li>
<li>PSYoungGen：使用了Parallel Scavenge并 行垃圾收集器的新生代Gc前后大小的变化</li>
<li>ParoldGen：使用了Parallel Old并行垃圾收集器的老年代GC前后大小的变化</li>
<li>Metaspace：元数据区GC前后大小的变化，JDK1.8中引入了元数据区以替代永久代</li>
<li>XXX secs：指GC花费的时间</li>
<li>Times: user: 指的是垃圾收集器花费的所有CPU时间，sys: 花费在等待系统调用或系统事件的时间，real：GC从开始到结束的时间，包括其他进程占用时间片的实际时间。</li>
</ul>
</li>
</ul>
<ul>
<li><p>打开GC日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-verbose:gc -XX: +PrintGCDetails -XX: +PrintGCTimeStamps -XX:+PrintGCDateStamps</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入信息如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2019-09-24T22:15:24.518+0800:3.287: [GC(Allocation Failure) [ PSYoungGen: 136162K-&gt;5113K (136192K) ] 141425K-&gt;17632K (222208K)，0.0248249 secs] [Times: user=0. 05 sys=0.00，real=0.03 secs]</span><br><span class="line">2019-09-24T22:15:25.559+0800:4.329: [GC (Metadata GC Threshold)[ PSYoungGen:97578K-&gt;10068K(274944K) ] 110096K-&gt;22658K (360960K)，0.0094071 secs] [Times: user=0. 00 sys=0.00，real=0.01 secs]</span><br><span class="line">2019-09-24T22:15:25.569+0800: 4.338: [Full GC (Metadata GC Threshold) [ PSYoungGen:10068K-&gt;0K(274944K) ] [ParOldGen: 12590K-&gt;13564K (56320K) ] 22658K-&gt;13564K (331264K) ,</span><br><span class="line">[Metaspace: 20590K-&gt;20590K(1067008K)]， 0.0494875 secs]</span><br><span class="line">[Times: user=0.17 sys=0.02，real=0.05 secs]</span><br></pre></td></tr></table></figure>
</li>
<li><p>说明：带上了日期和时间</p>
</li>
</ul>
<ul>
<li>日志补充说明：<ul>
<li>“ [GC”和” [Full GC” 说明了这次垃圾收集的停顿类型，如果有”Full”则说明GC发生了”Stop The World”</li>
<li>使用Serial收集器在新生代的名字是Default New Generation，因此显示的是” [DefNew”</li>
<li>使用ParNew收集器在新生代的名字会变成” [ParNew”，意思是”Parallel New Generation”</li>
<li>使用Parallel Scavenge收集器在新生代的名字是” [PSYoungGen”</li>
<li>老年代的收集和新生代道理一样，名字也是收集器决定的</li>
<li>使用G1收集器的话，会显示为”garbage- first heap”</li>
<li>Allocation Failure：表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</li>
<li>[PSYoungGen: 5986K-&gt;696K(8704K) ] 5986K- &gt; 704K (9216K)中<ul>
<li>括号内：GC回收前年轻代大小，回收后大小，( 年轻代总大小)</li>
<li>括号外：GC回收前年轻代和老年代大小，回收后大小，( 年轻代和老年代总大小)</li>
</ul>
</li>
<li>user代表用户态回收耗时，sys 内核态回收耗时，rea实际耗时。由于多核的原因，时间总和可能会超过real时间</li>
</ul>
</li>
</ul>
<p>GC日志分析</p>
<p><img src="/2021/04/19/JVM/image-20210430011457790.png" alt="image-20210430011457790"></p>
<p>Minor GC日志：</p>
<p><img src="/2021/04/19/JVM/image-20210430011551243.png" alt="image-20210430011551243"></p>
<p>Full GC日志：</p>
<p><img src="/2021/04/19/JVM/image-20210430012224983.png" alt="image-20210430012224983"></p>
<p>如果想把GC日志存到文件的话，是下面这个参数：</p>
<ul>
<li>Xloggc: ./path/to/gc. log</li>
</ul>
<p>GC日志分析工具：</p>
<ul>
<li>可以用一些工具去分析这些gc日志。</li>
<li>常用的日志分析工具有：<strong>GCViewer</strong>、<strong>GCEasy</strong>、GCHisto、GCLogViewer、Hpjmeter、garbagecat等。</li>
</ul>
<h4 id="10、垃圾回收器的新发展"><a href="#10、垃圾回收器的新发展" class="headerlink" title="10、垃圾回收器的新发展"></a>10、垃圾回收器的新发展</h4><h5 id="1、垃圾回收器的发展"><a href="#1、垃圾回收器的发展" class="headerlink" title="1、垃圾回收器的发展"></a>1、垃圾回收器的发展</h5><p>GC仍然处于飞速发展之中，目前的默认选项<strong>G1 GC在不断的进行改进</strong>，很多我们原来认为的缺点，例如串行的Full GC、 Card Table扫描的低效等，都已经被大幅改进，例如，JDK 10以后，Full GC已经是并行运行，在很多场景下，其表现还略优于Parallel GC的并行Full GC实现。</p>
<p>即使是Serial GC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是GC相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，在<strong>Serverless等新的应用场景 下，Serial GC找到了新的舞台</strong>。</p>
<p>比较不幸的是CMS GC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但在JDK9中已经被标记为废弃，并在JDK14版本中移除。</p>
<h5 id="2、JDK11的新特性"><a href="#2、JDK11的新特性" class="headerlink" title="2、JDK11的新特性"></a>2、JDK11的新特性</h5><p><img src="/2021/04/19/JVM/image-20210429231614446.png" alt="image-20210429231614446"></p>
<h5 id="3、Open-JDK12的Shenandoah-GC：低停顿时间的GC-实验性"><a href="#3、Open-JDK12的Shenandoah-GC：低停顿时间的GC-实验性" class="headerlink" title="3、Open JDK12的Shenandoah GC：低停顿时间的GC (实验性)"></a>3、Open JDK12的Shenandoah GC：低停顿时间的GC (实验性)</h5><ul>
<li><p>现在G1回收器已成为默认回收器好几年了。</p>
</li>
<li><p>我们还看到了引入了两个新的收集器：</p>
<ul>
<li>ZGC( JDK11出现)</li>
<li>Shenandoah(Open JDK12)</li>
<li>主打特点：<strong>低停顿时间</strong></li>
</ul>
</li>
<li><p><strong>Shenandoah，无疑是众多GC中最孤独的一个</strong>。是第一款不由Oracle公司团队领导开发的HotSpot垃圾收集器。不可避免的受到官方的排挤。比如号称OpenJDK和OracleJDK没有区别的Oracle公司仍拒绝在OracleJDK12中支持Shenandoah。</p>
</li>
<li><p>Shenandoah垃圾回收器最初由RedHat进行的一项垃圾收集器研究项目Pauseless GC的实现，<strong>旨在针对JVM上的内存回收实现低停顿的需求</strong>。在2014年贡献给OpenJDK。</p>
</li>
<li><p>Red Hat研发Shenandoah团队对外宣称，<strong>Shenandoah垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为200MB还是200GB，99.9%的目标都可以把垃圾收集的停顿时间限制在十毫秒以内</strong>。不过实际使用性能将取决于实际工作堆的大小和工作负载。</p>
<p><img src="/2021/04/19/JVM/image-20210430015133115.png" alt="image-20210430015133115"></p>
</li>
<li><p>这是RedHat在2016年发表的论文数据，测试内容是使用Es对200GB的维基百科数据进行索引。从结果看：</p>
<ul>
<li>停顿时间比其他几款收集器确实有了质的飞跃，但也未实现最大停顿时间控制在十毫秒以内的目标。</li>
<li>而吞吐量方面出现了明显的下降，总运行时间是所有测试收集器里最长的。</li>
</ul>
</li>
<li><p>总结：</p>
<ul>
<li>Shenandoah GC的弱项：高运行负担下的吞吐量下降王</li>
<li>Shenandoah GC的强项：低延迟时间。</li>
<li>Shenandoah GC的工作过程大致分为九个阶段，这里就不再赘述。在之前Java12新特性视频里有过介绍。</li>
</ul>
</li>
</ul>
<p>[Java12新特性地址]<br><a target="_blank" rel="noopener" href="http://www.atguigu.com/download_detail.shtml?v=222">http://www.atguigu.com/download_detail.shtml?v=222</a><br>或<br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1jJ411M7kQ?from=search&amp;seid=12339069673726242866">https://www.bilibili.com/video/BV1jJ411M7kQ?from=search&amp;seid=12339069673726242866</a></p>
<h5 id="4、令人震惊、革命性的ZGC（JDK14新特性）"><a href="#4、令人震惊、革命性的ZGC（JDK14新特性）" class="headerlink" title="4、令人震惊、革命性的ZGC（JDK14新特性）"></a>4、令人震惊、革命性的ZGC（JDK14新特性）</h5><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/12/gctuning/">官网地址</a></p>
<ul>
<li><p>ZGC与Shenandoah目标高度相似，<strong>在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟</strong>。</p>
</li>
<li><p>《深入理解Java虚拟机》一书中这样定义ZGC：ZGC收集器是一款基于Region内存布局的，(暂时)不设分代的，使用了<code>读屏障</code>、<code>染色指针</code>和<code>内存多重映射</code>等技术来实现<strong>可并发的标记-压缩算法</strong>的，以<strong>低延迟为首要目标的一款垃圾收集器</strong>。</p>
</li>
<li><p>ZGC的工作过程可以分为4个阶段：</p>
<ul>
<li><strong>并发标记</strong></li>
<li><strong>并发预备重分配</strong></li>
<li><strong>并发重分配</strong></li>
<li><strong>并发重映射</strong>等。</li>
</ul>
</li>
<li><p>ZGC几乎在所有地方并发执行的，除了<strong>初始标记的是STW</strong>（10ms以内）的。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。</p>
</li>
<li><p>测试数据：</p>
<p><img src="/2021/04/19/JVM/image-20210430015758548.png" alt="image-20210430015758548"></p>
<p>低延迟：</p>
<p><img src="/2021/04/19/JVM/image-20210430015925777.png" alt="image-20210430015925777"></p>
</li>
<li><p>在ZGC的强项停顿时间测试上，它毫不留情的将Parallel、G1拉开了两个数量级的差距。无论平均停顿、958停顿、99%停顿、99. 98停顿，还是最大停顿时间，ZGC 都能毫不费劲控制在10毫秒以内。</p>
</li>
<li><p>虽然ZGC还在试验状态，没有完成所有特性，但此时性能已经相当亮眼，用“令人震惊、革命性”来形容，不为过。</p>
</li>
<li><p><strong>未来将在服务端、大内存、低延迟应用的首选垃圾收集器</strong>。</p>
</li>
<li><p>JEP 364: ZGC应用在macOS上</p>
</li>
<li><p>JEP 365: ZGC应用在Windows</p>
<ul>
<li>JDK14之前，ZGC仅Linux才支持。</li>
<li> 尽管许多使用ZGC的用户都使用类Linux的环境，但在Windows和macOs.上，人们也需要ZGC进行开发部署和测试。许多桌面应用也可以从ZGC中受益。因此，ZGC特性被移植到了Windows和macOS上。</li>
<li>现在mac或windows.上也能使用zGc了，示例如下：<br>**-XX: +Unloc kExperimentalVMOptions -XX: +UseZGC**</li>
</ul>
</li>
<li><p>其它垃圾回收器: AIiGC</p>
<p>AliGC是阿里巴巴JVM团队基于G1算法，面向大堆 (LargeHeap)应用场景。指定场景下的对比：</p>
<p><img src="/2021/04/19/JVM/image-20210429233231323.png" alt="image-20210429233231323"></p>
</li>
<li><p>当然，其他厂商也提供了各种独具一格的GC实现， 例如比较有名的低延迟GC：<a target="_blank" rel="noopener" href="https://www.infoq.com/articles/azul_gc_in_detail">Zing</a>，有兴趣可以参考提供的链接。</p>
</li>
</ul>
<hr>
<h3 id="18、垃圾回收的相关大厂面试题"><a href="#18、垃圾回收的相关大厂面试题" class="headerlink" title="18、垃圾回收的相关大厂面试题"></a>18、垃圾回收的相关大厂面试题</h3><ul>
<li>蚂蚁金服:<ul>
<li>你知道哪几种垃圾回收器，各自的优缺点，重点讲一下cms和G1</li>
<li>一面: JVM GC算法有哪些，目前的JDK版本采用什么回收算法</li>
<li>一面: G1回收器讲下回收过程</li>
<li>GC是什么?为什么要有GC?</li>
<li>一面: GC的两种判定方法? CMS收集器与G1收集器的特点。</li>
</ul>
</li>
<li>百度:<ul>
<li>说一下GC算法，分代回收说下</li>
<li>垃圾收集策略和算法</li>
</ul>
</li>
<li>天猫:<ul>
<li>一面: jvm GC原理，JVM怎么回收内存</li>
<li>一面: CMS特点，垃圾回收算法有哪些?各自的优缺点，他们共同的缺点是什么?</li>
</ul>
</li>
<li>滴滴:<ul>
<li>一面: java的垃圾回收器都有哪些，说下G1的应用场景，平时你是如何搭配使用垃圾回收器的</li>
</ul>
</li>
<li>京东:<ul>
<li>你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。</li>
<li>垃圾回收算法的实现原理。</li>
</ul>
</li>
<li>阿里:<ul>
<li>讲一讲垃圾回收算法。</li>
<li>什么情况下触发垃圾回收?</li>
<li>如何选择合适的垃圾收集算法?</li>
<li>JVM有哪三种垃圾回收器?</li>
</ul>
</li>
<li>字节跳动:<ul>
<li>常见的垃圾回收器算法有哪些，各有什么优劣?</li>
<li>system.gc() 和 runtime.gc() 会做什么事情?</li>
<li>一面: Java GC机制? GC Roots有哪些?</li>
<li>二面: Java对象的回收方式，回收算法。</li>
<li>CMS和G1了解么，CMS解决什么问题，说一下回收的过程。</li>
<li>CMS回收停顿了几次，为什么要停顿两次。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="0、其他"><a href="#0、其他" class="headerlink" title="0、其他"></a>0、其他</h3><h4 id="1、label"><a href="#1、label" class="headerlink" title="1、label"></a>1、label</h4><p>官方：</p>
<p>Refactor the code to remove this label and the need for it.</p>
<p>label标签，不属于关键字，类似于c的goto（很少用），用于标记跳转。底层就是goto语句，尽量不要用</p>
<h4 id="2、怎么学习Java的不同版本的新特性"><a href="#2、怎么学习Java的不同版本的新特性" class="headerlink" title="2、怎么学习Java的不同版本的新特性"></a>2、怎么学习Java的不同版本的新特性</h4><p>Java不同版本的新特性：</p>
<ol>
<li>语法层面：Lambda表达式、switch表达式、 自动装箱、自动拆箱、enum关键字、 &lt;&gt;泛式等等</li>
<li>API层面：Stream API、新的日期时间、Optional、 String、 集合框架</li>
<li>底层优化：JVM的优化，GC的变化、元空间、静态域、字符串常量池等</li>
</ol>
<h2 id="中篇：字节码与类的加载器"><a href="#中篇：字节码与类的加载器" class="headerlink" title="中篇：字节码与类的加载器"></a>中篇：字节码与类的加载器</h2><h3 id="1、class文件结构"><a href="#1、class文件结构" class="headerlink" title="1、class文件结构"></a>1、class文件结构</h3><h4 id="1、概述-1"><a href="#1、概述-1" class="headerlink" title="1、概述"></a>1、概述</h4><h5 id="1、字节码文件的跨平台性"><a href="#1、字节码文件的跨平台性" class="headerlink" title="1、字节码文件的跨平台性"></a>1、字节码文件的跨平台性</h5><ol>
<li><p>Java语言: 跨平台的语言(write once ，run anywhere)</p>
<ul>
<li>当Java源代码成功编译成字节码后，如果想在不同的平台上面运行，则无须再次编译</li>
<li>这个优势不再那么吸引人了。Python、 PHP、 Perl、 Ruby、 Lisp等有强大的解释器。</li>
<li>跨平台似乎已经快成为一门语言必选的特性。</li>
</ul>
</li>
<li><p>Java虚拟机：跨语言的平台</p>
<ul>
<li><p><strong>Java虚拟机不和包括Java在内的任何语言绑定，它只与“Class文件”这种特定的二进制文件格式所关联</strong>。</p>
</li>
<li><p>无论使用何种语言进行软件开发，只要能将源文件编译为正确的Class文件，那么这种语言就可以在Java虚拟机上执行。</p>
</li>
<li><p>可以说，统一而强大的Class文件结构，就是Java虚拟机的基石、桥梁。</p>
<p><img src="/2021/04/19/JVM/%E7%AC%AC01%E7%AB%A0_JVM%E8%B7%A8%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B9%B3%E5%8F%B0.jpg" alt="第01章_JVM跨语言的平台"></p>
</li>
<li><p>所有的JVM全部遵守Java虚拟机规范，也就是说所有的JVM环境都是一样的，这样一来字节码文件可以在各种JVM上运行。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/index.html">官方文档</a></p>
</li>
</ul>
</li>
<li><p>想要让一个Java程序正确地运行在JVM中， Java源码就必须要被编译为符合JVM规范的字节码。</p>
<ul>
<li><p><strong>前端编译器的主要任务</strong>就是<strong>负责将符合Java语法规范的Java代码转换为符合JVM规范的字节码文件</strong>。</p>
</li>
<li><p><strong>javac</strong>一种能够将Java源码编译为字节码的<strong>前端编译器</strong>。</p>
</li>
<li><p>javac编译器在<strong>将Java源码编译为个有效的字节码文件过程中经历了4个步骤，分别是词法解析、语法解析、语义解析以及生成字节码。</strong></p>
<p><img src="/2021/04/19/JVM/image-20210504004503138.png" alt="image-20210504004503138"></p>
</li>
</ul>
</li>
<li><p>Oracle的JDK软件包括两部分内容：</p>
<ul>
<li>一部分是将Java源代码编译成Java虚拟机的指令集的编译器</li>
<li>另一部分是用于实现Java虛拟机的运行时环境</li>
</ul>
</li>
</ol>
<h5 id="2、Java的前端编译器"><a href="#2、Java的前端编译器" class="headerlink" title="2、Java的前端编译器"></a>2、Java的前端编译器</h5><h6 id="1、关于前端编译器与后台编译器在程序编译过程中的作用"><a href="#1、关于前端编译器与后台编译器在程序编译过程中的作用" class="headerlink" title="1、关于前端编译器与后台编译器在程序编译过程中的作用"></a>1、关于前端编译器与后台编译器在程序编译过程中的作用</h6><p><img src="/2021/04/19/JVM/image-20210504005333757.png" alt="image-20210504005333757"></p>
<h6 id="2、前端编译器vs后端编译器"><a href="#2、前端编译器vs后端编译器" class="headerlink" title="2、前端编译器vs后端编译器"></a>2、前端编译器vs后端编译器</h6><p>Java源代码的编译结果是字节码，那么肯定需要有一种编译器能够将Java源码编译为字节码，承担这个重要责任的就是配置在path环境变量中的<strong>javac编译器</strong>。javac是一种能够<strong>将Java源码编译为字节码的前端编译器</strong>。</p>
<p>HotSpotVM并没有强制要求前端编译器只能使用javac来编译字节码，其实只要编译结果符合JVM规范都可以被JVM所识别即可。在Java的前端编译器领域，除了javac之外， 还有一种被大家经常用到的前端编译器，那就是内置在Eclipse中的<strong>ECJ (Eclipse Compiler for Java )编译器</strong>。和<strong>Javac的全量式编译</strong>不同，<strong>ECI是一种增量式编译器</strong>。</p>
<ul>
<li>在Eclipse中，当开发人员编写完代码后，使用“Ctrl+S”快捷键时，ECI编译器所采取的编译方案是把未编译部分的源码逐行进行编译，而非每次都全量编译。因此<strong>ECI的编译效率会比javac更加迅速和高效</strong>，当然编译质量和javac相比大致还是一样的。</li>
<li>ECI不仅是Eclipse的默认内置前端编译器，在<strong>Tomcat中同样也是使用ECJ编译器来编译jsp文件</strong>。由于ECJ编译器是采用GPLv2的开源协议进行源代码公开，所以，大家可以登录eclipse官网下载ECJ编译器的源码进行二次开发。</li>
<li>默认情况下，IntelliJ IDEA使用javac编译器。(还可以自己设置为AspectJ编译器 ajc)</li>
</ul>
<p><strong>前端编译器并不会直接涉及编译优化</strong>等方面的技术，而是将这些具体<strong>优化细节移交给HotSpot的JIT编译器(后端编译器)负责</strong>。</p>
<p>复习: </p>
<ul>
<li>JIT（及时编译器）</li>
<li>AOT(静态提前编译器，Ahead of Time Compiler)</li>
</ul>
<h5 id="3、透过字节码指令看代码细节"><a href="#3、透过字节码指令看代码细节" class="headerlink" title="3、透过字节码指令看代码细节"></a>3、透过字节码指令看代码细节</h5><p>BAT面试题：</p>
<ol>
<li>类文件结构有几个部分?</li>
<li>知道字节码吗?字节码都有哪些? Integer x = 5;int y = 5;比较x == y都经过哪些步骤?</li>
</ol>
<p>代码举例1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Integer x = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">5</span>;</span><br><span class="line">        System.out.println(x == y);<span class="comment">//true。自动拆箱</span></span><br><span class="line"></span><br><span class="line">        Integer i1 = <span class="number">10</span>;</span><br><span class="line">        Integer i2 = <span class="number">10</span>;</span><br><span class="line">        System.out.println(i1 == i2);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        Integer i3 = <span class="number">128</span>;</span><br><span class="line">        Integer i4 = <span class="number">128</span>;</span><br><span class="line">        System.out.println(i3 == i4);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相关字节码1：</p>
<p><img src="/2021/04/19/JVM/image-20210518205703047.png" alt="image-20210518205703047"></p>
<p><img src="/2021/04/19/JVM/image-20210518205820353.png" alt="image-20210518205820353"></p>
<p><img src="/2021/04/19/JVM/image-20210518205932030.png" alt="image-20210518205932030"></p>
<p><img src="/2021/04/19/JVM/image-20210518205941131.png" alt="image-20210518205941131"></p>
<p>代码举例2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        String str1 = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">        System.out.println(str == str1);<span class="comment">//false</span></span><br><span class="line">        String str2 = <span class="keyword">new</span> String(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">        System.out.println(str == str2);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相关字节码2：</p>
<p><img src="/2021/04/19/JVM/image-20210518215156842.png" alt="image-20210518215156842"></p>
<p><img src="/2021/04/19/JVM/image-20210518215729244.png" alt="image-20210518215729244">\</p>
<p><img src="/2021/04/19/JVM/image-20210518215755492.png" alt="image-20210518215755492"></p>
<p>代码举例3：</p>
<p><img src="/2021/04/19/JVM/image-20210518220102931.png" alt="image-20210518220102931"></p>
<p>相关说明：</p>
<ul>
<li>成员变量（非静态的）的赋值过程：<ul>
<li>默认初始化（注意这里会先调用所有父类的构造方法（super））</li>
<li>显式初始化 / 代码块中初始化</li>
<li>构造器中初始化</li>
<li>有了对象之后，可以”对象.属性”或”对象.方法”的方式对成员变量进行赋值。</li>
</ul>
</li>
</ul>
<p>相关字节码3：</p>
<p>对son：</p>
<p><img src="/2021/04/19/JVM/image-20210518221159306.png" alt="image-20210518221159306"></p>
<p>代码的执行过程：</p>
<ol>
<li>执行<code>Father f = new Son();</code></li>
<li>先初始化父类的构造器，在父类的构造器当中调用了print()方法</li>
<li>又因为Son重写了父类Father的print()方法，此时又没有到执行显示初始化的步骤（看上面的字节码文件）</li>
<li>因此打印的是<code>Son.x = 0</code></li>
<li>接着初始化Son本身的构造器，Son本身的构造器当中调用了print()方法</li>
<li>此时已经经历了显示初始化，x被赋予值30（具体看上面的成员变量（非静态的）的赋值过程）</li>
<li>因此打印的是<code>Son.x = 30</code></li>
<li>最后执行<code>System.out.println(f.x);</code></li>
<li>**<code>因为属性不存在多态性！！！</code>**变量f的声明类型是Father，所以它是Father类型的，不是Son类型。</li>
<li>所以f.x中的x也是Father的x，因此打印的才是<code>20</code></li>
</ol>
<h4 id="2、虚拟机的基石：class文件"><a href="#2、虚拟机的基石：class文件" class="headerlink" title="2、虚拟机的基石：class文件"></a>2、虚拟机的基石：class文件</h4><ul>
<li><p>字节码文件里是什么?</p>
<p>源代码经过编译器编译之后便会生成一个字节码文件，字节码是一种<strong>二进制的类文件</strong>，它的内容是JVM的指令，而不像C、C++经由编译器直接生成<strong>机器码</strong>。</p>
</li>
<li><p>什么是字节码指令(byte code)?<br>Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的<strong>操作码</strong>(opcode)以及跟随其后的零至多个代表此操作所需参数的<strong>操作数</strong>(operand)所构成。虚拟机中许多指令并不包含操作数，只有一个操作码。</p>
<p>比如：操作码 (操作数)</p>
<p><img src="/2021/04/19/JVM/image-20210504010005360.png" alt="image-20210504010005360"></p>
</li>
<li><p>如何解读供虚拟机解释执行的二进制字节码?</p>
<ol>
<li>方式一：一个一个二进制的看。这里用到的是Notepad++,需要安装一个HEX-Editor插件，或者使用Binary Viewer</li>
<li>方式二：使用javap指令：jdk 自带的反解析工具。eg：javap -v IntegerTest.class &gt;IntegerTest.txt</li>
<li><strong>方式三</strong>：使用IDEA插件：jclasslib或jclasslib bytecode viewer客户端工具。(可视化更好)</li>
</ol>
</li>
</ul>
<h4 id="3、class文件结构"><a href="#3、class文件结构" class="headerlink" title="3、class文件结构"></a>3、class文件结构</h4><h5 id="1、关于Class文件"><a href="#1、关于Class文件" class="headerlink" title="1、关于Class文件"></a>1、关于Class文件</h5><ul>
<li><p>相关的官方文档</p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">javase8 JVM-ClassFile的相关资料</a></p>
</li>
<li><p>Class类的本质</p>
<ul>
<li>任何一个Class文件都对应着唯一个类或接口的定义信息，但反过来说，Class文件实际上它并不一定以磁盘文件的形式存在。</li>
<li>Class 文件是一组以<strong>8位字节</strong>为基础单位的<strong>二进制流</strong>。（该二进制流可以来自于磁盘，也可以来自于网络）</li>
</ul>
</li>
<li><p>Class文件格式</p>
<ul>
<li>Class的结构不像XML等描述语言，由于它没有任何分隔符号。所以在其中的数据项，<strong>无论是字节顺序还是数量，都是被严格限</strong><br><strong>定的</strong>，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变。</li>
<li>例子：<ul>
<li>“下雨天留客天留我不留”：</li>
<li>“下雨天，留客天，留我不留?”</li>
<li>“下雨天，留客天，留我不?留!”</li>
<li>“下雨，天留客?天留，我不留!”</li>
</ul>
</li>
<li>目的：压缩字节码文件</li>
</ul>
</li>
<li><p>Class文件格式采用一种类似于C语言结构体的方式进行数据存储，这种结构中只有两种数据类型：**<code>无符号数</code><strong>和</strong><code>表</code>**。</p>
<ul>
<li><strong>无符号数属于基本的数据类型</strong>，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</li>
<li><strong>表</strong>是由多个无符号数或者其他表作为数据项构成的<strong>复合数据类型</strong>，所有表都习惯性地以“info”结尾。表用于描述有层次关系的复合结构的数据，<strong>整个Class文件本质上就是一张表</strong>。由于表没有固定长度，所以通常<strong>会在其前面加上个数说明</strong>。</li>
</ul>
</li>
<li><p>相关代码举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全类名：com.atguigu.java1.Demo</span></span><br><span class="line"><span class="comment"> * 全限定名：com/atguigu/java1/Demo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        num = num + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过javac编译过后的16进制的Class文件：</p>
<p><img src="/2021/04/19/JVM/image-20210519000727861.png" alt="image-20210519000727861"></p>
<p>经过插件——jclasslib反编译后的Class文件：</p>
<p><img src="/2021/04/19/JVM/image-20210519001523659.png" alt="image-20210519001523659"></p>
<p><strong>换句话说，充分理解了每一个字节码文件的细节，自己也可以反编译出Java源文件来</strong>。</p>
</li>
<li><p>Class文件结构概述：Class文件的结构并不是一成不变的，随着Java虛拟机的不断发展，总是不可避免地会对Class文件结构做出一些调整，但是其基本结构和框架是非常稳定的。</p>
<p>Class文件的总体结构如下:</p>
<ul>
<li>魔数<ul>
<li>u4               magic;</li>
</ul>
</li>
<li>Class文件版本<ul>
<li>u2             minor_version;</li>
<li>u2             major_version;</li>
</ul>
</li>
<li>常量池<ul>
<li>u2             constant_pool_count;</li>
<li>cp_info       constant_pool[constant_pool_count-1];</li>
</ul>
</li>
<li>访问标志<ul>
<li>u2             access_flags;</li>
</ul>
</li>
<li>类索引，父类索引，接口索引集合<ul>
<li>u2             this_class;</li>
<li>u2             super_class;</li>
<li>u2             interfaces_count;</li>
<li>u2             interfaces[interfaces_count];</li>
</ul>
</li>
<li>字段表集合<ul>
<li>u2             fields_count;</li>
<li>field_info    fields[fields_count];</li>
</ul>
</li>
<li>方法表集合<ul>
<li>u2             methods_count;</li>
<li>method_info    methods[methods_count];</li>
</ul>
</li>
<li>属性表集合<ul>
<li>u2             attributes_count;</li>
<li>attribute_info attributes[attributes_count];</li>
</ul>
</li>
</ul>
<p>The <code>ClassFile</code> Structure：（来自官网）</p>
<p><img src="/2021/04/19/JVM/image-20210519001835589.png" alt="image-20210519001835589"></p>
<p>这是一张Java字节码总的结构表，我们按照上面的顺序逐一进行解读就可以了：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>说明</th>
<th>长度</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u4</td>
<td>magic</td>
<td>魔数,识别Class文件格式</td>
<td>4个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>minor_version</td>
<td>副版本号(小版本)</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>major_version</td>
<td>主版本号(大版本)</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>constant_pool_count</td>
<td>常量池计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>cp_info</td>
<td>constant_pool</td>
<td>常量池表</td>
<td>n个字节</td>
<td>constant_pool_count-1</td>
</tr>
<tr>
<td>u2</td>
<td>access_flags</td>
<td>访问标识</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>this_class</td>
<td>类索引</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>super_class</td>
<td>父类索引</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces_count</td>
<td>接口计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces</td>
<td>接口索引集合</td>
<td>2个字节</td>
<td>interfaces_count</td>
</tr>
<tr>
<td>u2</td>
<td>fields_count</td>
<td>字段计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>field_info</td>
<td>fields</td>
<td>字段表</td>
<td>n个字节</td>
<td>fields_count</td>
</tr>
<tr>
<td>u2</td>
<td>methods_count</td>
<td>方法计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>method_info</td>
<td>methods</td>
<td>方法表</td>
<td>n个字节</td>
<td>methods_count</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>属性计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>属性表</td>
<td>n个字节</td>
<td>attributes_count</td>
</tr>
</tbody></table>
</li>
</ul>
<h5 id="2、01-魔数：Class文件的标志"><a href="#2、01-魔数：Class文件的标志" class="headerlink" title="2、01-魔数：Class文件的标志"></a>2、01-魔数：Class文件的标志</h5><p>**Magic Number (魔数)**：</p>
<ul>
<li><p>每个Class文件开头的4个字节的无符号整数称为魔数(Magic Number)</p>
</li>
<li><p>它的唯一作用是确定这个文件是否为一个能被虚拟机接受的有效合法的Class文件。即：魔数是Class文件的标识符。</p>
</li>
<li><p>魔数值固定为**<code>0xCAFEBABE</code>**。不会改变。</p>
</li>
<li><p>如果一个Class文件不以0xCAFEBABE开头，虚拟机在进行文件校验的时候就会直接抛出以下错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error: A JNI error has occurred, please check your installation and try again</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.ClassFormatError:Incompatible magic value 1885430635 in class file StringTest</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用魔数而不是扩展名来进行识别主要是基于<strong>安全方面</strong>的考虑，因为文件扩展名可以随意地改动。</p>
</li>
<li><p>其实魔数不只是在class文件当中有所应用。在图片.png、音乐.mp3等等，里面也有前几位作为魔数，作为进行对应文件的标识符</p>
</li>
</ul>
<h5 id="3、02-Class文件版本号"><a href="#3、02-Class文件版本号" class="headerlink" title="3、02-Class文件版本号"></a>3、02-Class文件版本号</h5><ul>
<li><p>紧接着魔数的4个字节存储的是Class 文件的版本号。同样也是4个字节。<strong>第5个和第6个字节</strong>所代表的含义就是编译的<strong>副版本号minor_ version</strong>, 而<strong>第7个和第8个字节</strong>就是编译的<strong>主版本号major_ version</strong>。</p>
</li>
<li><p>它们共同构成了class文件的格式版本号。譬如某个 Class文件 的主版本号为 M，副版本号为 m，那么这个 Class文件 的格式版本号就确定为 M.m。</p>
</li>
<li><p>版本号和Java编译器的对应关系如下表：</p>
<table>
<thead>
<tr>
<th>主版本（十进制）</th>
<th>副版本（十进制）</th>
<th>编译器版本</th>
</tr>
</thead>
<tbody><tr>
<td>45</td>
<td>3</td>
<td>1.1</td>
</tr>
<tr>
<td>46</td>
<td>0</td>
<td>1.2</td>
</tr>
<tr>
<td>47</td>
<td>0</td>
<td>1.3</td>
</tr>
<tr>
<td>48</td>
<td>0</td>
<td>1.4</td>
</tr>
<tr>
<td>49</td>
<td>0</td>
<td>1.5</td>
</tr>
<tr>
<td>50</td>
<td>0</td>
<td>1.6</td>
</tr>
<tr>
<td>51</td>
<td>0</td>
<td>1.7</td>
</tr>
<tr>
<td><strong>52</strong>（十六进制对应的是34）</td>
<td><strong>0</strong></td>
<td><strong>1.8</strong></td>
</tr>
<tr>
<td>53</td>
<td>0</td>
<td>1.9</td>
</tr>
<tr>
<td>54</td>
<td>0</td>
<td>1.10</td>
</tr>
<tr>
<td>55</td>
<td>0</td>
<td>1.11</td>
</tr>
</tbody></table>
</li>
<li><p>Java的版本号是从**<code>45</code>**开始的，JDK 1.1之后的每个JDK大版本发布主版本号向上加1。</p>
</li>
<li><p>虚拟机JDK版本为1.k (k &gt;= 2) 时，对应的class文件格式版本号的范围为<strong>45.0 - 44+k.0 (含两端)</strong> 。</p>
</li>
<li><p><strong>不同版本的Java编译器编译的Class文件对应的版本是不一样的。目前，高版本的Java虚拟机可以执行由低版本编译器生成的Class文件，但是低版本的Java虛拟机不能执行由高版本编译器生成的Class文件。否则JVM会抛出java.lang.UnsupportedClassVersionError异常。( 向下兼容)</strong></p>
</li>
<li><p>在实际应用中，由于<strong>开发环境和生产环境的不同</strong>，可能会导致该问题的发生。因此，需要我们在开发时，特别注意<strong>开发编译的JDK版本和生产环境中的JDK版本是否一致</strong>。</p>
</li>
<li><p>总结成一句话就是：<strong>高版本的虚拟机可以解释运行低版本的字节码文件</strong>。</p>
</li>
</ul>
<h5 id="4、03-常量池：存放所有常量"><a href="#4、03-常量池：存放所有常量" class="headerlink" title="4、03-常量池：存放所有常量"></a>4、03-常量池：存放所有常量</h5><h6 id="1、常量池概述"><a href="#1、常量池概述" class="headerlink" title="1、常量池概述"></a>1、常量池概述</h6><ul>
<li><p>常量池是Class文件中内容最为丰富的区域之一。常量池对于Class文件中的<strong>字段和方法解析</strong>也有着至关重要的作用。</p>
</li>
<li><p>随着Java虚拟机的不断发展，常量池的内容也日渐丰富。可以说，<strong>常量池是整个Class文件的基石</strong>。</p>
</li>
<li><p>官方文档：</p>
<p><img src="/2021/04/19/JVM/image-20210519012259460.png" alt="image-20210519012259460"></p>
</li>
<li><p>在版本号之后，紧跟着的是常量池的数量，以及若干个常量池表项。</p>
</li>
<li><p>常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的无符号数，代表常量池容量计数值(constant_ pool_ count) 。与Java中语言习惯不一样的是，这个容量<strong>计数是从1而不是0开始的。</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>constant_pool_count</td>
<td>1</td>
</tr>
<tr>
<td>cp_info</td>
<td>constant_pool</td>
<td>constant_pool_count-1</td>
</tr>
</tbody></table>
</li>
<li><p>由上表可见，Class文件使用了一个前置的容量计数器(constant_pool_count) 加若干个连续的数据项(constant_pool) 的形式来描述常量池内容。我们把这一 系列连续常量池数据称为常量池集合。</p>
</li>
<li><p><strong>常量池表项</strong>中，用于存放编译时期生成的各种**<code>字面量</code><strong>和</strong><code>符号引用</code><strong>，这部分内容将在类加载后进入</strong>方法区的运行时常量池**中存放。（其中字符串常量池在jdk7以后被移进堆空间中）</p>
</li>
</ul>
<h6 id="2、常量池计数器（constant-pool-count）"><a href="#2、常量池计数器（constant-pool-count）" class="headerlink" title="2、常量池计数器（constant_pool_ count）"></a>2、常量池计数器（constant_pool_ count）</h6><ul>
<li><p>由于常量池的数量不固定，时长时短，所以需要放置<strong>两个字节来表示常量池容量计数值</strong>。</p>
</li>
<li><p>常量池容量计数值(u2类型) ：<strong>从1开始</strong>，表示常量池中有多少项常量。即 <code>constant_pool_count=1</code> 表示常量池中有<strong>0</strong>个常量项</p>
</li>
<li><p>Demo的值为：</p>
<p><img src="/2021/04/19/JVM/image-20210519013853054.png" alt="image-20210519013853054"></p>
<p>其值为0x0016，转换为十进制，也就是22。</p>
<p>需要注意的是，这实际上只有21项常量。索引为范围是1-21。为什么呢?</p>
<ul>
<li>通常我们写代码时都是从0开始的，但是这里的常量池却是从1开始，因为它把第0项常量空出来了。 </li>
<li>这是为了满足后面某些指向常星池的索引值的数据在特定情况下需要表达“<strong>不引用任何一个常量池项目</strong>”的含义，这种情况可用<strong>索引值0</strong>来表示。</li>
</ul>
</li>
</ul>
<h6 id="3、常量池表"><a href="#3、常量池表" class="headerlink" title="3、常量池表"></a>3、常量池表</h6><ul>
<li><p>constant_ pool是一种表结构， 以1 ~ constant_ pool_ count - 1为索引。表明了后面有多少个常量项。</p>
</li>
<li><p>常量池主要存放两大类常量：<code>**字面量(Literal)**</code>和<code>**符号引用(Symbolic References )**</code></p>
</li>
<li><p>它包含了class文件结构及其子结构中引用的所有<strong>字符串常量</strong>、<strong>类或接口名</strong>、<strong>字段名</strong>和<strong>其他常量</strong>。常量池中的每一项都具备相同的特征。第1个字节作为类型标记，用于确定该项的格式，这个字节称为tag byte(标记字节、标签字节)。</p>
</li>
<li><p>tag byte与对应的类型：（最后三个是在jdk7添加的，体现了java对动态语言的支持）</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>标志(或标识)</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CONSTANT_utf8_info</td>
<td>1</td>
<td>UTF-8编码的字符串</td>
</tr>
<tr>
<td>CONSTANT_Integer_info</td>
<td>3</td>
<td>整型字面量</td>
</tr>
<tr>
<td>CONSTANT_Float_info</td>
<td>4</td>
<td>浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Long_info</td>
<td>5</td>
<td>长整型字面量</td>
</tr>
<tr>
<td>CONSTANT_Double_info</td>
<td>6</td>
<td>双精度浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Class_info</td>
<td>7</td>
<td>类或接口的符号引用</td>
</tr>
<tr>
<td>CONSTANT_String_info</td>
<td>8</td>
<td>字符串类型字面量</td>
</tr>
<tr>
<td>CONSTANT_Fieldref_info</td>
<td>9</td>
<td>字段的符号引用</td>
</tr>
<tr>
<td>CONSTANT_Methodref_info</td>
<td>10</td>
<td>类中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_InterfaceMethodref_info</td>
<td>11</td>
<td>接口中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_NameAndType_info</td>
<td>12</td>
<td>字段或方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_MethodHandle_info</td>
<td>15</td>
<td>表示方法句柄</td>
</tr>
<tr>
<td>CONSTANT_MethodType_info</td>
<td>16</td>
<td>标志方法类型</td>
</tr>
<tr>
<td>CONSTANT_InvokeDynamic_info</td>
<td>18</td>
<td>表示一个动态方法调用点</td>
</tr>
</tbody></table>
</li>
</ul>
<h6 id="4、常量池表——字面量和符号引用"><a href="#4、常量池表——字面量和符号引用" class="headerlink" title="4、常量池表——字面量和符号引用"></a>4、常量池表——字面量和符号引用</h6><ul>
<li><p>字面量和符号引用：</p>
<ul>
<li><p>常量池主要存放两大类常量：</p>
<ul>
<li>字面量(Literal) </li>
<li>符号引用(Symbolic References) 。</li>
</ul>
</li>
<li><p>如下表：</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>具体的常量</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>字面量</td>
<td>文本字符串</td>
<td>String str = “Hello”;</td>
</tr>
<tr>
<td></td>
<td>声明为final的常星值</td>
<td>final int NUM = 10;</td>
</tr>
<tr>
<td>符号引用</td>
<td>类和接口的全限定名</td>
<td>com/atguigu/test/Demo;</td>
</tr>
<tr>
<td></td>
<td>字段的名称和描述符</td>
<td>add、num</td>
</tr>
<tr>
<td></td>
<td>方法的名称和描述符</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>全限定名</p>
<ul>
<li>com/atguigu/test/Demo这个就是类的全限定名，仅仅是**把包名的”.”替换成”/“**，</li>
<li>为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会<strong>加入一个”;”表示全限定名结束</strong>。</li>
</ul>
</li>
<li><p>简单名称</p>
<ul>
<li>简单名称是指<strong>没有类型和参数修饰</strong>的<strong>方法</strong>或者<strong>字段名称</strong>，上面例子中的类的add()方法和num字段的简单名称分别是add和num。</li>
</ul>
</li>
<li><p>描述符</p>
<ul>
<li><p>描述符的作用是用来描述<strong>字段的数据类型</strong>、<strong>方法的参数列表(包括数量、类型以及顺序)**和</strong>返回值**。</p>
</li>
<li><p>根据描述符规则，基本数据类型(byte、char、double、float、int、long、short、boolean) 以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来表示，详见下表：(基本数据类型long对应的是J；基本数据类型boolean对应的是Z；几个[表示几维数组)</p>
<table>
<thead>
<tr>
<th>标志符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>B</td>
<td>基本数据类型byte</td>
</tr>
<tr>
<td>C</td>
<td>基本数据类型char</td>
</tr>
<tr>
<td>D</td>
<td>基本数据类型double</td>
</tr>
<tr>
<td>F</td>
<td>基本数据类型float</td>
</tr>
<tr>
<td>I</td>
<td>基本数据类型int</td>
</tr>
<tr>
<td>J</td>
<td>基本数据类型long</td>
</tr>
<tr>
<td>S</td>
<td>基本数据类型short</td>
</tr>
<tr>
<td>Z</td>
<td>基本数据类型boolean</td>
</tr>
<tr>
<td>V</td>
<td>代表void类型</td>
</tr>
<tr>
<td>L</td>
<td>对象类型，比如：<code>Ljava/lang/Object;</code></td>
</tr>
<tr>
<td>[</td>
<td>数组类型，代表一维数组。比如：<code>double[][][] is [[[D</code></td>
</tr>
</tbody></table>
</li>
<li><p>用描述符来描述方法时，按照<strong>先参数列表</strong>，<strong>后返回值的顺序描述</strong>，<strong>参数列表按照参数的严格顺序放在一组小括号”()”之内</strong>。</p>
<ul>
<li>如方法java.lang.String toString()的描述符为：() Ljava/lang/String；</li>
<li>方法int abc(int[] x, int y)的描述符为([II) I</li>
</ul>
</li>
</ul>
</li>
<li><p>补充说明：</p>
<ul>
<li>虚拟机在<strong>加载</strong>Class文件时才会进行<strong>动态链接</strong>，也就是说，<strong>Class 文件中不会保存各个方法和字段的最终内存布局信息</strong>，因此，这些字段和方法的符号引用不经过转换是无法直接被虚拟机使用的。<strong>当虚拟机运行时，需要从常量池中获得对应的符号引用，再在<code>类加载过程中的解析阶段</code>将其替换为直接引用，并翻译到具体的内存地址中</strong>。</li>
<li>这里说明下<strong>符号引用</strong>和<strong>直接引用</strong>的区别与关联：<ul>
<li>符号引用：符号引用以<strong>一组符号</strong>来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。<strong>符号引用与虚拟机实现的内存布局无关</strong>，引用的目标并不一定已经加载到了内存中。</li>
<li>直接引用：直接引用可以是直接<strong>指向目标的指针</strong>、<strong>相对偏移量</strong>或是个<strong>能间接定位到目标的句柄</strong>。<strong>直接引用是与虚拟机实现的内存布局相关的</strong>，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。 如果<strong>有了直接引用，那说明引用的目标必定已经存在于内存之中</strong>了。</li>
<li>加载前类的方法等信息只是字符串（字面量与符号引用），而加载后会把这个字符串（字面量与符号引用）替换成相对应的内存地址。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="5、常量池表——常量类型和结构"><a href="#5、常量池表——常量类型和结构" class="headerlink" title="5、常量池表——常量类型和结构"></a>5、常量池表——常量类型和结构</h6><p>常量池中每一项常量都是一个表，JDK1.7之后共有14种不同的表结构数据。如下表格所示：</p>
<p>常量类型和结构细节：</p>
<p><img src="/2021/04/19/JVM/1598773300484.png" alt="1598773300484"></p>
<p><img src="/2021/04/19/JVM/1598773308492.png" alt="1598773308492"></p>
<ul>
<li>根据上图每个类型的描述我们也可以知道每个类型是用来描述常量池中哪些内容(主要是字面量、符号引用)的。比如：CONSTANT_Integer_info是用来描述常量池中字面量信息的，而且只是整型字面量信息。</li>
<li>标志为15、16、18的常量项类型是用来支持动态语言调用的(jdk1.7时才加入的)。</li>
<li>细节说明：<ul>
<li>CONSTANT_Class_info：结构用于表示类或接口</li>
<li>CONSTANT_Fieldref_info、CONSTANT_Methodref_info和CONSTANT_InterfaceMethodref_info结构：表示字段、方法和接口方法</li>
<li>CONSTANT_string_info结构用于表示String类型的常量对象</li>
<li>CONSTANT_Integer_info和CONSTANT_Float_info：表示4字节(int 和float)的数值常量</li>
<li>CONSTANT_Long_info和ICONSTANT Double_info结构：表示8字节(long和double)的数值常量<ul>
<li>在class文件的常量池表中，所有的8字节常量均占两个表成员(项)的空间。如果一个CONSTANT_Long_info或CONSTANT_Double_info结构的项在常量池表中的索引位n，则常量池表中下一个可用项的索引位n+2，此时常量池表中索引为n+1的项仍然有效但必须视为不可用的。</li>
</ul>
</li>
<li>CONSTANT_NameAndType_info结构用于表示字段或方法，但是和之前的3个结构不同，CONSTANT_NameAndType_info结构没有指明该字段或方法所属的类或接口。</li>
<li>CONSTANT_utf8_info用于表示字符常量的值</li>
<li>CONSTANT_MethodHandle_info结构用于表示方法句柄</li>
<li>CONSTANT_MethodType_info结构：表示方法类型</li>
<li>CONSTANT_InvokeDynamic_info结构用于表示invokedynamic指令所用到的引导方法(bootstrap method)、 引导方法所用到的动态调用名(dynamic invocation name)、 参数和返回类型，并可以给引导方法传入一系列称为静态参数(static argument)的常量。</li>
</ul>
</li>
<li>解析方式：<ul>
<li>一个字节一个字节的解析</li>
<li>使用javap命令解析：javap -verbose Demo.class 或 jclasslib工具会更方便。</li>
</ul>
</li>
<li>总结1：<ul>
<li>这14种表(或者常量项结构)的共同点是：表开始的第一位是一个u1类型的标志位(tag)，代表当前这个常量项使用的是哪种表结构，即哪种常量类型。</li>
<li>在常量池列表中，CONSTANT_Utf8_info常量项是一种使用改进过的UTF - 8编码格式来存储诸如文字字符串、类或者接口的全限定名、字段或者方法的简单名称以及描述符等常量字符串信息。</li>
<li>这14种常量项结构还有一个特点是，其中13个常量项占用的字节固定，只有CONSTANT_Utf8_info占用字节不固定，其大小由length决定。为什么呢?<ul>
<li><strong>因为从常量池存放的内容可知，其存放的是字面量和符号引用，最终这些内容都会是一个字符串，这些字符串的大小是在编写程序时才确定</strong>，比如你定义一个类， 类名可以取长取短，所以在没编译前，大小不固定，编译后，通过utf-8编码， 就可以知道其长度。</li>
</ul>
</li>
</ul>
</li>
<li>总结2：<ul>
<li>常量池：可以理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型(后面的很多数据类型都会指向此处)，也是占用Class文件空间最大的数据项目之一。</li>
<li><strong>常量池中为什么要包含这些内容</strong>：<ul>
<li>Java代码在进行Javac编译的时候， 并不像C和C++那样有“连接”这一步骤，而是在虚拟机加载Class文件的时候进行动态链接。也就是说，<strong>在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用</strong>。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。关于类的创建和动态链接的内容，在虚拟机类加载过程时再进行详细讲解。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="5、04-访问标识"><a href="#5、04-访问标识" class="headerlink" title="5、04-访问标识"></a>5、04-访问标识</h5><p>访问标识（access_ flag、访问标志、访问标记）</p>
<ul>
<li><p>在常量池后，紧跟着访问标记。该标记使用两个字节表示，用于识别一些类或者接口层次的访问信息，包括：</p>
<ul>
<li>这个Class是类还是接口；</li>
<li>是否定义为public类型；</li>
<li>是否定义为abstract类型;如果是类的话，是否被声明为final等。</li>
</ul>
</li>
<li><p>各种访问标记如下所示：</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>标志为public类型</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>标志被声明为final，只有类可以设置</td>
</tr>
<tr>
<td>ACC_SUPER</td>
<td>0x0020</td>
<td>标志允许使用invokespecial字节码指令的新语义，JDK1.0.2之后编译出来的类的这个标志默认为真。（使用增强的方法调用父类方法）</td>
</tr>
<tr>
<td>ACC_INTERFACE</td>
<td>0x0200</td>
<td>标志这是一个接口</td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0x0400</td>
<td>是否为abstract类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>标志此类并非由用户代码产生（即：由编译器产生的类，没有源码对应）</td>
</tr>
<tr>
<td>ACC_ANNOTATION</td>
<td>0x2000</td>
<td>标志这是一个注解</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>标志这是一个枚举</td>
</tr>
</tbody></table>
</li>
<li><p>类的访问权限通常为ACC_ 开头的常量。</p>
</li>
<li><p>每一种类型的表示都是通过设置访问标记的32位中的特定位来实现的。比如，若是public final的类，则该标记为ACC_PUBLIC | ACC_FINAL。</p>
</li>
<li><p>使用ACC_SUPER可以让类更准确地定位到父类的方法super.method()，现代编译器都会设置并且使用这个标记。</p>
</li>
<li><p>补充说明：</p>
<ol>
<li>带有ACC_INTERFACE标志的class文件表示的是接口而不是类，反之则表示的是类而不是接口。<ol>
<li><strong>如果一个class文件被设置了ACC_INTERFACE 标志，那么同时也得设置ACC_ABSTRACT 标志。同时它不能再设置ACC_FINAL、ACC_SUPER或ACC_ENUM标志。</strong></li>
<li><strong>如果没有设置ACC_INTERFACE标志，那么这个class文件可以具有上表中除ACC_ANNOTATION外的其他所有标志。当然，ACC_FINAL和ACC_ ABSTRACT这类互斥的标志除外。这两个标志不得同时设置。</strong></li>
</ol>
</li>
<li>ACC_SUPER标志用于确定类或接口里面的invokespecial指令使用的是哪一种执行语义。<strong>针对Java虚拟机指令集的编译器都应当设置这个标志</strong>。对于Java SE 8及后续版本来说，无论class文件中这个标志的实际值是什么，也不管class文件的版本号是多少，Java虛拟机都认为每个class文件均设置了ACC_SUPER标志。<ol>
<li><strong>ACC_SUPER标志是为了向后兼容由旧Java编译器所编译的代码而设计的。</strong>目前的ACC_SUPER标志在由JDK 1.0.2之前的编译器所生成的access_flags中是没有确定含义的，如果设置了该标志，那么Oracle的Java虛拟机实现会将其忽略。</li>
</ol>
</li>
<li>ACC_SYNTHETIC标志意味着该类或接口是由编译器生成的，而不是由源代码生成的。</li>
<li>注解类型必须设置ACC_ANNOTATION标志。如果设置了ACC_ANNOTATION标志，那么也必须设置ACC_ INTERFACE标志。</li>
<li>ACC_ENUM标志表明该类或其父类为枚举类型。</li>
</ol>
</li>
</ul>
<h5 id="6、05-类索引、父类索引、接口索引集合"><a href="#6、05-类索引、父类索引、接口索引集合" class="headerlink" title="6、05-类索引、父类索引、接口索引集合"></a>6、05-类索引、父类索引、接口索引集合</h5><ul>
<li><p>在访问标记后，会指定该类的类别、父类类别以及实现的接口，格式如下：</p>
<table>
<thead>
<tr>
<th>长度</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>this_class</td>
</tr>
<tr>
<td>u2</td>
<td>super_class</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces_count</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces[interfaces_count]</td>
</tr>
</tbody></table>
</li>
<li><p>这三项数据来确定这个类的继承关系：</p>
<ul>
<li>类索引用于确定这个类的全限定名</li>
<li>父类索引用于确定这个类的父类的全限定名。由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0。</li>
<li>接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements语句(如果这个类本身是一个接口，则应当是extends 语句)后的接口顺序从左到右排列在接口索引集合中。</li>
</ul>
</li>
</ul>
<ol>
<li><strong>this_class (类索引)</strong><ul>
<li>2字节无符号整数，指向常量池的索引。它提供了类的全限定名, 如com/atguigu/java1/Demo。this_ class的值必须是对常量池表中某项的一个有效索引值。常量池在这个索引处的成员必须为CONSTANT_Class_info类型结构体，该结构体表示这个class文件所定义的类或接口。</li>
</ul>
</li>
<li><strong>super_class (父类索引)</strong><ul>
<li>2字节无符号整数，指向常量池的索引。它提供了当前类的父类的全限定名。如果我们没有继承任何类，其默认继承的是java/lang/Object类。同时，由于Java不支持多继承，所以其父类只有一个。</li>
<li>superclass指向的父类不能是final。</li>
</ul>
</li>
<li>interfaces<ul>
<li>指向常量池索引集合，它提供了一个符号引用到所有己实现的接口</li>
<li>由于一个类可以实现多个接口，因此需要以数组形式保存多个接口的索引，表示接口的每个索引也是一个指向常量池的CONSTANT_Class ( 当然这里就必须是接口，而不是类)。</li>
</ul>
</li>
</ol>
<ul>
<li>interfaces_count (接口计数器)：interfaces_ count 项的值表示当前类或接口的直接超接口数量。</li>
<li>interfaces []（接口索引集合）：<br>interfaces []中每个成员的值必须是对常量池表中某项的有效索引值，它的长度为interfaces_count。每个成员interfaces[i]必须为CONSTANT_Class_ info结构， 其中0 &lt;= i &lt; interfaces_count。 在interfaces []中，各成员所表示的接口顺序和对应的源代码中给定的接口顺序(从左至右)一样，即interfaces [0]对应的是源代码中最左边的接口。</li>
</ul>
<h5 id="7、06-字段表集合"><a href="#7、06-字段表集合" class="headerlink" title="7、06-字段表集合"></a>7、06-字段表集合</h5><h6 id="1、字段表集合"><a href="#1、字段表集合" class="headerlink" title="1、字段表集合"></a>1、字段表集合</h6><p>fields：</p>
<ul>
<li>用于描述接口或类中声明的变量。字段(field)包括类级变量以及实例级变量，但是不包括方法内部、代码块内部声明的局部变量。（local variables）</li>
<li>字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。</li>
<li>它指向常量池索引集合，它描述了每个字段的完整信息。比如**字段的标识符、访问修饰符(public、private或protected)、是类变量还是实例变量(static修饰符)、是否是常量(final修饰符)**等。</li>
</ul>
<p>注意事项：</p>
<ul>
<li>字段表集合中<strong>不会列出从父类或者实现的接口中继承而来的字段</strong>，但有可能列出<strong>原本Java代码之中不存在的字段。譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。</strong></li>
<li>在<strong>Java语言中</strong>字段是无法重载的，<strong>两个字段</strong>的数据类型、修饰符不管是否相同，都<strong>必须使用不一样的名称</strong>， 但是<strong>对于字节码</strong>来讲，如果两个字段的<strong>描述符不一致</strong>，那<strong>字段重名就是合法</strong>的。</li>
</ul>
<h6 id="2、fields-count-字段计数器"><a href="#2、fields-count-字段计数器" class="headerlink" title="2、fields_ count(字段计数器)"></a>2、fields_ count(字段计数器)</h6><ul>
<li>fields_count的值表示当前class文件fields表的成员个数。 <strong>使用两个字节来表示</strong>。</li>
<li>fields表中每个成员都是一个field_info结构， 用于表示该类或接口所声明的所有类字段或者实例字段，<strong>不包括方法内部声明的变量，也不包括从父类或父接口继承的那些字段</strong>。</li>
</ul>
<h6 id="3、fields-（字段表）"><a href="#3、fields-（字段表）" class="headerlink" title="3、fields []（字段表）"></a>3、fields []（字段表）</h6><ul>
<li><p>fields表中的每个成员都必须是个fields_info结构的数据项，用于表示当前类或接口中某个字段的完整描述。</p>
</li>
<li><p>一个字段的信息包括如下这些信息。<strong>这些信息中，各个修饰符都是布尔值，要么有，要么没有</strong>。</p>
<ul>
<li>作用域(public、private、protected修饰符)</li>
<li>是实例变量还是类变量(static修饰符)</li>
<li>可变性(final)</li>
<li>并发可见性(volatile修饰符，是否强制从主内存读写)</li>
<li>可否序列化(transient修饰符)</li>
<li>字段数据类型(基本数据类型、对象、数组)</li>
<li>字段名称</li>
</ul>
</li>
<li><p>字段表作为一个表，同样有他自己的结构：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>含义</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>access_flags</td>
<td>访问标志</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>字段名索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor_index</td>
<td>描述符索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>属性计数器</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>属性集合</td>
<td>attributes_count</td>
</tr>
</tbody></table>
</li>
<li><p>字段表访问标识</p>
<ul>
<li><p>我们知道，一 个字段可以被各种关键字去修饰，比如：作用域修饰符(public、private、protected) 、static修饰符 、final修饰符、volatile修饰符等等。因此，其可像类的访问标志那样，使用一些标志来标记字段。字段的访问标志有如下这些：</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>标志为public类型</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>标志被声明为final，只有类可以设置</td>
</tr>
<tr>
<td>ACC_SUPER</td>
<td>0x0020</td>
<td>标志允许使用invokespecial字节码指令的新语义，JDK1.0.2之后编译出来的类的这个标志默认为真。（使用增强的方法调用父类方法）</td>
</tr>
<tr>
<td>ACC_INTERFACE</td>
<td>0x0200</td>
<td>标志这是一个接口</td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0x0400</td>
<td>是否为abstract类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>标志此类并非由用户代码产生（即：由编译器产生的类，没有源码对应）</td>
</tr>
<tr>
<td>ACC_ANNOTATION</td>
<td>0x2000</td>
<td>标志这是一个注解</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>标志这是一个枚举</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>字段名索引：根据字段名索引的值，查询常量池中的指定索引项即可。</p>
</li>
<li><p>描述符索引</p>
<ul>
<li><p>描述符的作用是用来描述字段的数据类型、方法的参数列表(包括数量、类型以及顺序)和返回值。根据描述符规则，基本数据类型(byte, char, double, float，int，long, short , boolean)及代表无返回值的void类型都用一个大写字符来表示， 而对象则用字符L加对象的全限定名来表示，如下所示：</p>
<table>
<thead>
<tr>
<th>标志符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>B</td>
<td>基本数据类型byte</td>
</tr>
<tr>
<td>C</td>
<td>基本数据类型char</td>
</tr>
<tr>
<td>D</td>
<td>基本数据类型double</td>
</tr>
<tr>
<td>F</td>
<td>基本数据类型float</td>
</tr>
<tr>
<td>I</td>
<td>基本数据类型int</td>
</tr>
<tr>
<td>J</td>
<td>基本数据类型long</td>
</tr>
<tr>
<td>S</td>
<td>基本数据类型short</td>
</tr>
<tr>
<td>Z</td>
<td>基本数据类型boolean</td>
</tr>
<tr>
<td>V</td>
<td>代表void类型</td>
</tr>
<tr>
<td>L</td>
<td>对象类型，比如：<code>Ljava/lang/Object;</code></td>
</tr>
<tr>
<td>[</td>
<td>数组类型，代表一维数组。比如：<code>double[][][] is [[[D</code></td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>属性表集合</p>
<ul>
<li><p>一个字段还可能拥有一些属性，用于存储更多的额外信息。比如初始化值、一些注释信息等。属性个数存放在attribute_count中，属性具体内容存放在attributes数组中。</p>
</li>
<li><p>例子：以常量属性为例，结构为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ConstantValue_attribute&#123;</span><br><span class="line">	u2 attribute_name_index;</span><br><span class="line">	u4 attribute_length;</span><br><span class="line">	u2 constantvalue_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：对于常量属性而言，attribute_length值恒为2。</p>
<p>根据上面的例子，我们来实际分析一下，如下图：</p>
<p><img src="/2021/04/19/JVM/FA74699C-FC7C-4A8D-AAA9-989BDD67D75A.png" alt="img"> </p>
</li>
</ul>
</li>
</ul>
<h5 id="8、07-方法表集合"><a href="#8、07-方法表集合" class="headerlink" title="8、07-方法表集合"></a>8、07-方法表集合</h5><h6 id="1、方法表集合"><a href="#1、方法表集合" class="headerlink" title="1、方法表集合"></a>1、方法表集合</h6><p>methods：指向常量池索引集合，它完整描述了每个方法的签名。</p>
<ul>
<li>在字节码文件中，<strong>每一个method_info项都对应着个类或者接口中的方法信息</strong>。比如方法的访问修饰符(public、private或protected)，方法的返回值类型以及方法的参数信息等。</li>
<li>如果这个方法不是抽象的或者不是native的，那么字节码中会体现出来。</li>
<li>一方面，<strong>methods表</strong>只描述当前类或接口中声明的方法，<strong>不包括从父类或父接口继承的方法</strong>。另一方面，methods表<strong>有可能会出现由编译器自动添加的方法</strong>，最典型的便是编译器产生的方法信息(比如：<strong>类(接口)初始化方法<clinit>()**和</clinit></strong>实例初始化方法<init>()**)。</init></li>
</ul>
<p>使用注意事项：</p>
<ul>
<li><strong>在Java语言中</strong>，要重载(Overload)一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为<strong>返回值不会包含在特征签名之中</strong>，因此Java语言里无法仅仅依靠返回值的不同来对一个已有方法进行重载。</li>
<li>但在Class文件格式中， 特征签名的范围更大一些，只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个class文件中。</li>
<li>也就是说，尽管Java语法规范并不允许在一个类或者接口中声明多个方法签名相同的方法，但是和Java语法规范相反，<strong>字节码文件</strong>中却恰恰允许存放多个方法签名相同的方法，唯一的条件就是<strong>这些方法之间的返回值不能相同</strong>。</li>
</ul>
<h6 id="2、methods-count-方法计数器"><a href="#2、methods-count-方法计数器" class="headerlink" title="2、methods_ count(方法计数器)"></a>2、methods_ count(方法计数器)</h6><ul>
<li>methods_count的值表示当前class文件methods表的成员个数。<strong>使用两个字节来表示</strong>。</li>
<li>methods表中每个成员都是一个method_info结构</li>
</ul>
<h6 id="3、methods-方法表"><a href="#3、methods-方法表" class="headerlink" title="3、methods [] (方法表)"></a>3、methods [] (方法表)</h6><ul>
<li><p>methods表中的每个成员都必须是一个method_info结构， 用于表示当前类或接口中某个方法的完整描述。如果某个method_info结构的access_flags项既没有设置ACC_NATIVE标志，也没有设置ACC_ABSTRACT标志，那么该结构中也应包含实现这个方法所用的Java虚拟机指令。</p>
</li>
<li><p>method_info结构可以表示类和接口中定义的所有方法，包括实例方法、类方法、实例初始化方法和类或接口初始化方法</p>
</li>
<li><p>方法表的结构实际跟字段表是一样的，方法表结构如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>含义</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>access_flags</td>
<td>访问标志</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>字段名索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor_index</td>
<td>描述符索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>属性计数器</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>属性集合</td>
<td>attributes_count</td>
</tr>
</tbody></table>
</li>
<li><p>方法表访问标志</p>
<ul>
<li><p>跟字段表一样，方法表也有访问标志，而且他们的标志有部分相同，部分则不同，方法表的具体访问标志如下：</p>
<table>
<thead>
<tr>
<th>标记名</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>public，方法可以从包外访问</td>
</tr>
<tr>
<td>ACC_PRIVATE</td>
<td>0x0002</td>
<td>private，方法只能本类中访问</td>
</tr>
<tr>
<td>ACC_PROTECTED</td>
<td>0x0004</td>
<td>protected，方法在自身和子类可以访问</td>
</tr>
<tr>
<td>ACC_STATIC</td>
<td>0x0008</td>
<td>static，静态方法</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h5 id="9、08-属性表集合"><a href="#9、08-属性表集合" class="headerlink" title="9、08-属性表集合"></a>9、08-属性表集合</h5><h6 id="1、属性表集合-attributes"><a href="#1、属性表集合-attributes" class="headerlink" title="1、属性表集合(attributes)"></a>1、属性表集合(attributes)</h6><ul>
<li>方法表集合之后的属性表集合，<strong>指的是class 文件所携带的辅助信息</strong>，比如该class 文件的源文件的名称。以及任何带有RetentionPolicy.CLASS或者RetentionPolicy.RUNTIME的注解。这类信息通常被用于Java虚拟机的验证和运行，以及Java程序的调试，<strong>一般无须深入了解</strong>。</li>
<li>此外，字段表、方法表都可以有自己的属性表。用于描述某些场景专有的信息。</li>
<li>属性表集合的限制没有那么严格，不再要求各个属性表具有严格的顺序，并且<strong>只要不与已有的属性名重复</strong>，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，但<strong>Java虛拟机运行时会忽略掉它不认识的属性</strong>。</li>
</ul>
<h6 id="2、attributes-count-属性计数器"><a href="#2、attributes-count-属性计数器" class="headerlink" title="2、attributes_ count(属性计数器)"></a>2、attributes_ count(属性计数器)</h6><ul>
<li>attributes_count的值表示当前class文件属性表的成员个数。属性表中每一项都是个attribute_info结构。</li>
</ul>
<h6 id="3、attributes-属性表"><a href="#3、attributes-属性表" class="headerlink" title="3、attributes [] ( 属性表)"></a>3、attributes [] ( 属性表)</h6><ul>
<li><p>属性表的每个项的值必须是attribute_ info结构。属性表的结构比较灵活，各种不同的属性只要满足以下结构即可。</p>
</li>
<li><p>属性的通用格式：（即只需说明属性的名称以及占用位数的长度即可，属性表具体的结构可以去自定义）</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
<td>属性名索引</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
<td>属性长度</td>
</tr>
<tr>
<td>u1</td>
<td>info</td>
<td>attribute_length</td>
<td>属性表</td>
</tr>
</tbody></table>
</li>
<li><p>属性类型：</p>
<p>属性表实际上可以有很多类型，上面看到的Code属性只是其中一种，Java8里面定义了23种属性。下面这些是虚拟机中预定义的属性：</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>使用位置</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Code</td>
<td>方法表</td>
<td>Java代码编译成的字节码指令</td>
</tr>
<tr>
<td>ConstantValue</td>
<td>字段表</td>
<td>final关键字定义的常量池</td>
</tr>
<tr>
<td>Deprecated</td>
<td>类，方法，字段表</td>
<td>被声明为deprecated的方法和字段</td>
</tr>
<tr>
<td>Exceptions</td>
<td>方法表</td>
<td>方法抛出的异常</td>
</tr>
<tr>
<td>EnclosingMethod</td>
<td>类文件</td>
<td>仅当一个类为局部类或者匿名类是才能拥有这个属性,这个属性用于标识这个类所在的外围方法</td>
</tr>
<tr>
<td>InnerClass</td>
<td>类文件</td>
<td>内部类列表</td>
</tr>
<tr>
<td>LineNumberTable</td>
<td>Code属性</td>
<td>Java源码的行号与字节码指令的对应关系</td>
</tr>
<tr>
<td>LocalVariableTable</td>
<td>Code属性</td>
<td>方法的局部变量描述</td>
</tr>
<tr>
<td>StackMapTable</td>
<td>Code属性</td>
<td>JDK1.6中新增的属性.供新的类型检查检验器检查和处理目标方法的局部变量和操作数有所需要的类是否匹配</td>
</tr>
<tr>
<td>Signature</td>
<td>类，方法，字段表</td>
<td>用于支持泛型情况下的方法签名</td>
</tr>
<tr>
<td>Sourcefile</td>
<td>类文件</td>
<td>记录源文件名称</td>
</tr>
<tr>
<td>SourceDebugExtension</td>
<td>类文件</td>
<td>用于存储额外的调试信息</td>
</tr>
<tr>
<td>Synthetic</td>
<td>类，方法，字段表</td>
<td>标志方法或字段为编译器自动生成的</td>
</tr>
<tr>
<td>LocalVariableTypeTable</td>
<td>类</td>
<td>使用特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加</td>
</tr>
<tr>
<td>RuntimeVisibleAnnotations</td>
<td>类，方法，字段表</td>
<td>为动态注解提供支持</td>
</tr>
<tr>
<td>RuntimeInvisibleAnnotations</td>
<td>类，方法，字段表</td>
<td>用于指明哪些注解是运行时不可见的</td>
</tr>
<tr>
<td>RuntimeVisibleParameterAnnotation</td>
<td>方法表</td>
<td>作用与RuntimeVisibleAnnotations属性类似，只不过作用对象为方法</td>
</tr>
<tr>
<td>RuntimeInvisibleParameterAnnotation</td>
<td>方法表</td>
<td>作用与RuntimeInvisibleAnnotations属性类似，作用对象哪个为方法参数</td>
</tr>
<tr>
<td>AnnotationDefault</td>
<td>方法表</td>
<td>用于记录注解类元素的默认值</td>
</tr>
<tr>
<td>BootstrapMethods</td>
<td>类文件</td>
<td>用于保存invokeddynamic指令引用的引导方式限定符</td>
</tr>
</tbody></table>
<p>或者（查看官网）：</p>
<p><img src="/2021/04/19/JVM/53F23FBD-4E40-40C7-BC77-5E3E90AC27A1.png" alt="img"> </p>
</li>
<li><p>部分属性详解</p>
<ol>
<li><p>ConstantValue 属性：</p>
<p>ConstantValue 属性表示一个常量字段的值。位于field_info结构的属性表中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ConstantValue_attribute &#123;</span><br><span class="line">	u2 attribute_name_index;</span><br><span class="line">	u4 attribute_length;</span><br><span class="line">	u2 constantvalue_index;&#x2F;&#x2F;字段值在常量池中的索引，常量池在该索引处的项给出该属性表示的常量值。</span><br><span class="line">						   &#x2F;&#x2F;（例如，值是1ong型的， 在常量池中便是CONSTANT_ Long )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Deprecated 属性：</p>
<p>Deprecated属性是在JDK 1.1为了支持注释中的关键词@deprecated而引入的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Deprecated_attribute &#123;</span><br><span class="line">	u2 attribute name_index;</span><br><span class="line">	u4 attribute_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Code 属性：</p>
<p>Code属性就是存放方法体里面的代码。但是，并非所有方法表都有Code属性。像接口或者抽象方法，他们没有具体的方法体，因此也就不会有Code属性了。</p>
<p>Code属性表的结构，如下图：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
<td>属性名索引</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
<td>属性长度</td>
</tr>
<tr>
<td>u2</td>
<td>max_stack</td>
<td>1</td>
<td>操作数栈深度的最大值</td>
</tr>
<tr>
<td>u2</td>
<td>max_locals</td>
<td>1</td>
<td>局部变量表所需的存续空间</td>
</tr>
<tr>
<td>u4</td>
<td>code_length</td>
<td>1</td>
<td>字节码指令的长度</td>
</tr>
<tr>
<td>u1</td>
<td>code</td>
<td>code_length</td>
<td>存储字节码指令</td>
</tr>
<tr>
<td>u2</td>
<td>exception_table_length</td>
<td>1</td>
<td>异常表长度</td>
</tr>
<tr>
<td>exception_info</td>
<td>exception_table</td>
<td>exception_length</td>
<td>异常表</td>
</tr>
<tr>
<td>u2</td>
<td>attribute_count</td>
<td>1</td>
<td>属性集合计数器</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attribute_count</td>
<td>属性集合</td>
</tr>
</tbody></table>
<p>可以看到：Code属性表的前两项跟属性表是-致的，即Code属性表遵循属性表的结构，后面那些则是他自定义的结构。</p>
</li>
<li><p>InnerClasses 属性：</p>
<ul>
<li>为了方便说明特别定义一个表示类或接口的Class格式为C。如果C的常量池中包含某个CONSTANT_Class_info成员，且这个成员所表示的类或接口不属于任何一个包，那么C的ClassFile结构的属性表中就必须含有对应的InnerClasses属性。</li>
<li>InnerClasses属性是在JDK 1.1中为了支持内部类和内部接口而引入的，位于ClassFile结构的属性表。</li>
</ul>
</li>
<li><p>LineNumberTable 属性：</p>
<ul>
<li><p>LineNumberTable属性是可选变长属性，位于Code结构的属性表。</p>
</li>
<li><p>LineNumberTable属性是用来<strong>描述Java源码行号与字节码行号之间的对应关系</strong>。这个属性可以用来在调试的时候定位代码执行的行数。</p>
<ul>
<li><strong>start_pc，即字节码行号；</strong></li>
<li><strong>line_number，即Java源代码行号。</strong></li>
</ul>
</li>
<li><p>在Code属性的属性表中，LineNumberTable属性可以按照任意顺序出现，此外，多个LineNumberTable属性可以共同表示一个行号在源文件中表示的内容， 即LineNumberTable 属性不需要与源文件的行一对应。</p>
</li>
<li><p>LineNumberTable属性表结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LineNumberTable_attribute&#123;</span><br><span class="line">	u2 attribute_name_index:</span><br><span class="line">	u4 attribute_length;</span><br><span class="line">	u2 line_number_table_length;</span><br><span class="line">	&#123;</span><br><span class="line">		u2 start_pc;</span><br><span class="line">		u2 line_number;</span><br><span class="line">	&#125; line_number_table[line_number_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>LocalVariableTable 属性：</p>
<ul>
<li><p>LocalVariableTable 是可选变长属性，位于Code属性的属性表中。它被调试器<strong>用于确定方法在执行过程中局部变量的信息</strong>。</p>
</li>
<li><p>在Code属性的属性表中，LocalVariableTable 属性可以按照任意顺序出现。</p>
</li>
<li><p>Code属性中的每个局部变量最多只能有一个LocalVariableTable 属性。</p>
<ul>
<li><strong>startpc + length表示这个变量在字节码中的生命周期起始和结束的偏移位置(this生命周期从头0到结尾10)</strong></li>
<li><strong>index就是这个变量在局部变量表中的槽位(槽位可复用)</strong></li>
<li><strong>name就是变量名称</strong></li>
<li><strong>Descriptor表示局部变量类型描述</strong></li>
</ul>
</li>
<li><p>LocalVariableTable属性表结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LocalVariableTable_attribute&#123;</span><br><span class="line">	u2 attribute_name_index;</span><br><span class="line">	u4 attribute_length;</span><br><span class="line">	u2 local_variable_table_length;</span><br><span class="line">	&#123;</span><br><span class="line">		u2 start_pc;</span><br><span class="line">		u2 length;</span><br><span class="line">		u2 name_index;</span><br><span class="line">		u2 descriptor_index;</span><br><span class="line">		u2 index;</span><br><span class="line">	&#125; local_variable_table[local_variable_table_length] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Signature 属性</p>
<ul>
<li>Signature属性是可选的定长属性，位于ClassFile，field_info或method_info结构的属性表中。</li>
<li>在Java语言中，任何类、接口、 初始化方法或成员的泛型签名如果包含了类型变量(Type Variables) 或参数化类型 ( Parameterized Types) ，则Signature 属性会为它记录泛型签名信息。</li>
</ul>
</li>
<li><p>SourceFile 属性</p>
<ul>
<li><p>SourceFile属性结构：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
<td>属性名索引</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
<td>属性长度</td>
</tr>
<tr>
<td>u2</td>
<td>sourcefile_index</td>
<td>1</td>
<td>源码文件索引</td>
</tr>
</tbody></table>
<p>可以看到，其长度总是<strong>固定的8个字节</strong>。</p>
</li>
</ul>
</li>
<li><p>其他属性：</p>
<ul>
<li>Java虚拟机中预定义的属性有20多个，这里就不一一介绍了，通过上面几个属性的介绍，只要领会其精髓，其他属性的解读也是易如反掌。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h5 id="10、class字节码文件总结"><a href="#10、class字节码文件总结" class="headerlink" title="10、class字节码文件总结"></a>10、class字节码文件总结</h5><ul>
<li>主要介绍了Class文件的基本格式。</li>
<li>随着Java平台的不断发展，在将来，Class文件的内容也一定会做进一步的扩充，但是其基本的格式和结构不会做重大调整。</li>
<li>从Java虚拟机的角度看，通过Class文件，可以让更多的计算机语言支持Java虚拟机平台。因此，Class文件结构不仅仅是Java虛拟机的执行入口，更是Java生态圈的基础和核心。</li>
</ul>
<h4 id="4、使用javap指令解析Class文件"><a href="#4、使用javap指令解析Class文件" class="headerlink" title="4、使用javap指令解析Class文件"></a>4、使用javap指令解析Class文件</h4><h5 id="1、解析字节码的作用"><a href="#1、解析字节码的作用" class="headerlink" title="1、解析字节码的作用"></a>1、解析字节码的作用</h5><ul>
<li>自己分析类文件结构太麻烦了! oracle提供了javap工具。</li>
<li>javap是jdk自带的反解析工具。它的作用就是根据class字节码文件，反解析出当前类对应的code区(汇编指令)、本地变量表、异常表和代码行偏移量映射表、常量池等等信息。</li>
<li>通过反编译生成的汇编代码，我们可以深入的了解java代码的工作机制。比如我们可以查看i++；这行代码实际运行时是先获取变量i的值，然后将这个值加1，最后再将加1后的值赋值给变量i。</li>
<li>通过局部变量表，我们可以查看局部变量的作用域范围、所在槽位等信息，甚至可以看到槽位复用等信息。</li>
</ul>
<h5 id="2、javac-g操作"><a href="#2、javac-g操作" class="headerlink" title="2、javac -g操作"></a>2、javac -g操作</h5><ul>
<li>解析字节码文件得到的信息中，有些信息(如局部变量表、指令和代码行偏移量映射表、常量池中方法的参数名称等等)需要在使用javac编译成class文件时，指定参数才能输出。</li>
<li>比如，你直接javac xx. java, 就不会在生成对应的局部变量表等信息，如果你使用**<code>javac -g xx.java</code>**就可以生成所有相关信息了。如果你使用的eclipse或IDEA，则默认情况下，eclipse、 IDEA在编译时会帮你生成局部变量表、指令和代码行偏移量映射表等信息的。</li>
</ul>
<h5 id="3、javap的用法"><a href="#3、javap的用法" class="headerlink" title="3、javap的用法"></a>3、javap的用法</h5><ul>
<li><p>javap的用法格式：javap <options> <classes></classes></options></p>
<ul>
<li>其中，options就是需要输入的参数选项</li>
<li>classes就是你要反编译的class文件。</li>
</ul>
</li>
<li><p>在命令行中直接输入javap或javap -help可以看到javap的options有如下选项：</p>
<p><img src="/2021/04/19/JVM/image-20210520022957097.png" alt="image-20210520022957097"></p>
</li>
<li><p>相关代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavapTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 五大字段：private、默认、public、protected、final</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">boolean</span> flag;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">char</span> gender;</span><br><span class="line">    <span class="keyword">public</span> String info;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNTS = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 静态代码块</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        String url = <span class="string">&quot;www.atguigu.com&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 非静态代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        info = <span class="string">&quot;java&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 两种构造方法：无参(public)与有参(private)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JavapTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">JavapTest</span><span class="params">(<span class="keyword">boolean</span> flag)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 四大方法：private、默认、public、protected</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">methodPrivate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num + i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">char</span> <span class="title">showGender</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        System.out.println(info + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这里重组一下：</p>
<ul>
<li><p>-help / –help / -?：输出此用法消息</p>
</li>
<li><p>-version：版本信息，其实是当前javap所在jdk的版本信息，不是class在哪个jdk下生成的。（即javap -version == javap -version xx.class）</p>
<p><img src="/2021/04/19/JVM/image-20210520023638002.png" alt="image-20210520023638002"></p>
<p>以上的options与相关class文件无关，为javap本身的options</p>
</li>
<li><p>-public：仅显示公共类和成员</p>
<p><img src="/2021/04/19/JVM/image-20210520023707476.png" alt="image-20210520023707476"></p>
</li>
<li><p>-protected：显示受保护的/公共类和成员</p>
<p><img src="/2021/04/19/JVM/image-20210520024314713.png" alt="image-20210520024314713"></p>
</li>
<li><p><strong>-p / -private：显示所有类和成员</strong></p>
<p><img src="/2021/04/19/JVM/image-20210520024520373.png" alt="image-20210520024520373"></p>
</li>
<li><p>package：显示程序包/受保护的/公共类和成员(默认)</p>
<p><img src="/2021/04/19/JVM/image-20210520024729855.png" alt="image-20210520024729855"></p>
</li>
<li><p>-sysinfo：显示正在处理的类的系统信息(路径，大小，日期，MD5散列，源文件名)</p>
<p><img src="/2021/04/19/JVM/image-20210520024834421.png" alt="image-20210520024834421"></p>
</li>
<li><p>constants：显示静态最终常量</p>
<p><img src="/2021/04/19/JVM/image-20210520025014700.png" alt="image-20210520025014700"></p>
</li>
<li><p>以下options与代码的细节相关：</p>
</li>
<li><p>-s：输出内部类型签名</p>
<p><img src="/2021/04/19/JVM/image-20210520030031188.png" alt="image-20210520030031188"></p>
</li>
<li><p>-l：输出行号和本地变量表</p>
<p><img src="/2021/04/19/JVM/image-20210520030243299.png" alt="image-20210520030243299"></p>
<p>注意：<strong>如果使用的是javac xx. java编译生成的class字节码文件，里面本来就没有本地变量表。因此就是使用-l也看不到本地变量表的信息。</strong></p>
</li>
<li><p>-c：对代码进行反汇编</p>
<p><img src="/2021/04/19/JVM/image-20210520031140075.png" alt="image-20210520031140075"></p>
</li>
<li><p><strong>-v / -verbose：输出附加信息(包括行号、本地变量表，反汇编等详细信息)</strong></p>
<ul>
<li><p>注意：就算-v也依旧没有私有private的信息。如果需要加上私有private的信息，得到一份最全的信息，就需要加上-p：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v -p JavapTest.class</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>以下很少用到，了解即可。</p>
</li>
<li><p>-classpath <path></path>：指定查找用户类文件的位置</p>
</li>
<li><p>-cp <path></path>：指定查找用户类文件的位置</p>
</li>
</ul>
</li>
<li><p>总结：</p>
<ul>
<li><strong>一般常用的是-v、-l、-c三个选项</strong>：（<strong>重要的还是-v和-p</strong>）<ul>
<li>javap -l：会输出行号和本地变量表信息。</li>
<li>javap -c：会对当前class字节码进行反编译生成汇编代码。</li>
<li>javap -v classxx：除了包含-c内容外，还会输出行号、局部变量表信息、常量池等信息。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h5><ol>
<li>通过javap命令可以查看一个java类反汇编得到的Class文件版本号、常量池、访问标识、变量表、指令代码行号表等等信息。<strong>不显示类索引、父类索引、接口索引集合、<clinit>()、 <init>()等结构</init></clinit></strong>。其中<clinit>()、 <init>()这两个是因为javap太智能，帮我们反编译成了相关的构造方法和静态代码块，在class字节码文件依旧可以看到这两个结构。</init></clinit></li>
<li>通过对前面例子代码反汇编文件的简单分析，可以发现，一个方法的执行通常会涉及下面几块内存的操作：<ol>
<li>java栈中：局部变量表、操作数栈。</li>
<li>java堆：通过对象的地址引用去操作。</li>
<li>常量池。</li>
<li>其他如帧数据区（方法返回地址、动态链接、一些附加信息）、方法区的剩余部分等情况，测试中没有显示出来，这里说明一下。</li>
</ol>
</li>
<li>平常，我们比较关注的是java类中每个方法的反汇编中的指令操作过程，这些指令都是顺序执行的，可以参考<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html">官方文档查看每个指令</a>的含义。</li>
</ol>
<hr>
<h3 id="2、字节码指令集与解析举例"><a href="#2、字节码指令集与解析举例" class="headerlink" title="2、字节码指令集与解析举例"></a>2、字节码指令集与解析举例</h3><h4 id="1、概述-2"><a href="#1、概述-2" class="headerlink" title="1、概述"></a>1、概述</h4><ul>
<li>Java字节码对于虚拟机，就好像汇编语言对于计算机，属于基本执行指令。</li>
<li>Java虚拟机的指令由<strong>一个字节长度</strong>的、代表着某种特定操作含义的数字(称为**<code>操作码，Opcode</code><strong>) 以及跟随其后的零至多个代表此操作所需参数(称为</strong><code>操作数，Operands</code>**) 而构成。由于Java虚拟机采用面向操作数栈而不是寄存器的结构，所以大多数的指令都不包含操作数，只有一个操作码。</li>
<li>由于限制了Java虚拟机操作码的长度为一个字节(即0~255)，这意味着<strong>指令集的操作码总数不可能超过256条</strong>。</li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html">官方文档</a></li>
<li>熟悉虚拟机的指令对于动态字节码生成、反编译Class文件、Class文件修补都有着非常重要的价值。因此，阅读字节码作为了解Java虚拟机的基础技能，需要熟练掌握常见指令。</li>
</ul>
<h5 id="1、执行模型"><a href="#1、执行模型" class="headerlink" title="1、执行模型"></a>1、执行模型</h5><p>如果不考虑异常处理的话，那么Java虚拟机的解释器可以使用下面这个伪代码当做最基本的执行模型来理解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">	自动计算PC寄存器的值加1;</span><br><span class="line">	根据PC寄存器的指示位置，从字节码流中取出操作码;</span><br><span class="line">	if(字节码存在操作数)从字节码流中取出操作数;</span><br><span class="line">	执行操作码所定义的操作;</span><br><span class="line">&#125;while(字节码长度&gt;0);</span><br></pre></td></tr></table></figure>

<h5 id="2、字节码与数据类型"><a href="#2、字节码与数据类型" class="headerlink" title="2、字节码与数据类型"></a>2、字节码与数据类型</h5><ul>
<li>在Java虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。例如，iload指令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据。</li>
<li>对于大部分与数据类型相关的字节码指令，<strong>它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务</strong>：<ul>
<li>i代表对int类型的数据操作</li>
<li>l代表long</li>
<li>s代表short</li>
<li>b代表byte</li>
<li>c代表char</li>
<li>f代表float</li>
<li>d代表double</li>
<li>Boolean使用的是iconst_0或者iconst1</li>
<li>a代表对象</li>
</ul>
</li>
<li>也有一些指令的助记符中<strong>没有明确地指明操作类型的字母</strong>，如arraylength指令， 它没有代表数据类型的特殊字符，但操作数永远只能是一个数组类型的对象。</li>
<li>还有另外一些指令，如无条件跳转指令goto则是<strong>与数据类型无关的</strong>。</li>
<li>大部分的指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。编译器会在编译期或运行期将byte和short类型的数据带符号扩展(Sign-Extend) 为相应的int类型数据，将boolean和char类型数据零位扩展(Zero-Extend) 为相应的int类型数据。</li>
<li>与之类似，在处理<strong>boolean、byte、 short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理</strong>。因此，大多数对于boolean、 byte、 short和char类型数据的操作，实际上都是使用相应的int类型作为运算类型。</li>
</ul>
<h5 id="3、指令分析"><a href="#3、指令分析" class="headerlink" title="3、指令分析"></a>3、指令分析</h5><ul>
<li>由于完全介绍和学习这些指令需要花费大量时间。为了让大家能够更快地熟悉和了解这些基本指令，这里将JVM中的字节码指令集按用途大致分成9类。<ul>
<li>加载与存储指令</li>
<li>算术指令</li>
<li>类型转换指令</li>
<li>对象的创建与访问指令</li>
<li>方法调用与返回指令</li>
<li>操作数栈管理指令</li>
<li>比较控制指令</li>
<li>异常处理指令</li>
<li>同步控制指令</li>
</ul>
</li>
<li>(说在前面)在做值相关操作时：<ul>
<li>一个指令，可以从局部变量表、常量池、堆中对象、方法调用、系统调用中等取得数据，这些数据(可能是值可能是对象的引用)被压入操作数栈。</li>
<li>一个指令，也可以从操作数栈中取出一到多个值(pop多次)，完成赋值、加减乘除、方法传参、系统调用等等操作。</li>
</ul>
</li>
</ul>
<h4 id="2、加载与存储指令"><a href="#2、加载与存储指令" class="headerlink" title="2、加载与存储指令"></a>2、加载与存储指令</h4><ul>
<li>作用：加载和存储指令用于将数据从栈帧的局部变量表和操作数栈之间来回传递。<ul>
<li>其中数据压入操作数栈被称为加载</li>
<li>此时的数据可能来源于局部变量表，也有可能来自于常量池（分成具体的两个类指令）</li>
<li>把数据保存在局部变量表当中则被称为存储指令</li>
</ul>
</li>
<li>常用指令<ol>
<li>[<strong>局部变量压栈指令</strong>]将一个局部变量加载到操作数栈：xload、xload_<n> (其中x为i、l、f、d、a，n为0到3（不一定都是0~3，需要具体分析）)（<strong>load</strong>）</n></li>
<li>[<strong>常量入栈指令</strong>]将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_W、ldc2_W、aconst_null、iconst_ m1、iconst_ <i>、lconst_ <l>、fconst_ <f>、 dconst_ <d>。（<strong>push、ldc、const</strong>）</d></f></l></i></li>
<li>[<strong>出栈装入局部变量表指令</strong>]将一个数值从操作数栈存储到局部变量表：xstore、xstore_ <n> (其中x为i、l、f、d、a，n为0到3)；xastore ( 其中x为i、l、f、d、a、b、c、s)（<strong>store</strong>）</n></li>
<li>扩充局部变量表的访问索引的指令：wide。</li>
</ol>
</li>
<li>上面所列举的指令助记符中，有一部分是以尖括号结尾的 (例如iload_ <n>)。这些指令助记符实际上代表了一组指令(例如 iload_ <n>代表了iload_0、iload_1、iload_2和iload_3这几个指令) 。这几组指令都是某个带有一个操作数的通用指令(例如iload)的特殊形式，<strong>对于这若干组特殊指令来说，它们表面上没有操作数，不需要进行取操作数的动作，但操作数都隐含在指令中</strong>。<ul>
<li>比如：</li>
<li>iload_0：将局部变量表中索引为0位置上的数据压入操作数栈中。（占一个字节）</li>
<li>iload 0：将局部变量表中索引为0位置上的数据压入操作数栈中。（占三个字节）</li>
<li>iload 4：将局部变量表中索引为4位置上的数据压入操作数栈中。（占三个字节）</li>
<li>作用：节约空间，减少内存占用</li>
</ul>
</n></n></li>
<li>除此之外，它们的语义与原生的通用指令完全一致(例如iload_0的语义与操作数为0时的iload指令语义完全一致)。在尖括号之间的字母指定了指令隐含操作数的数据类型，<n>代表非负的整数， <i>代表是int类型数据，<l>代表1ong类型，<f>代表float类型， <d>代表double类型。</d></f></l></i></n></li>
<li>操作byte、char、short 和boolean类型数据时，经常用int类型的指令来表示。</li>
</ul>
<h5 id="0、复习：再谈操作数栈与局部变量表"><a href="#0、复习：再谈操作数栈与局部变量表" class="headerlink" title="0、复习：再谈操作数栈与局部变量表"></a>0、复习：再谈操作数栈与局部变量表</h5><h6 id="1、操作数栈-Operand-Stacks"><a href="#1、操作数栈-Operand-Stacks" class="headerlink" title="1、操作数栈(Operand Stacks )"></a>1、操作数栈(Operand Stacks )</h6><p>我们知道，Java字节码是Java虛拟机所使用的指令集。因此，它与Java虚拟机基于栈的计算模型是密不可分的。</p>
<p>在解释执行过程中，每当为Java方法分配栈桢时，Java虚拟机往往需要开辟块额外的空间作为<strong>操作数栈</strong>， 来<strong>存放计算的操作数以及返回结果</strong>。</p>
<p>具体来说便是：<strong>执行每一条指令之前，Java虚拟机要求该指令的操作数已被压入操作数栈中。在执行指令时，Java虚拟机会将该指令所需的操作数弹出，并且将指令的结果重新压入栈中</strong>。</p>
<p>例子：</p>
<p><img src="/2021/04/19/JVM/image-20210520222930557.png" alt="image-20210520222930557"></p>
<p>以加法指令iadd 为例。假设在执行该指令前，栈顶的两个元素分别为int值1和int值2，那么iadd指令将弹出这两个int, 并将求得的和int值3压入栈中。</p>
<p><img src="/2021/04/19/JVM/image-20210520222944844.png" alt="image-20210520222944844"></p>
<p>由于iadd指令只消耗栈项的两个元素，因此，对于离栈顶距离为2的元素，即图中的问号，iadd 指令并不关心它是否存在，更加不会对其进行修改。</p>
<h6 id="2、局部变量表-Local-Variables"><a href="#2、局部变量表-Local-Variables" class="headerlink" title="2、局部变量表(Local Variables)"></a>2、局部变量表(Local Variables)</h6><p>Java方法栈桢的另外一个重要组成部分则是局部变量区，<strong>字节码程序可以将计算的结果缓存在局部变量区之中</strong>。</p>
<p>实际上，Java虚拟机将局部变量区<strong>当成一个数组</strong>，依次存放this指针(仅非静态方法) ，所传入的参数， 以及字节码中的局部变量。</p>
<p>和操作数栈一样，long类型以及double类型的值将占据两个单元，其余类型仅占据一个单元。一个槽位就是一个单元，占4个字节。</p>
<p><img src="/2021/04/19/JVM/image-20210520223454201.png" alt="image-20210520223454201"></p>
<p>举例：</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">long</span> <span class="number">1</span>, <span class="keyword">float</span> f)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        String s = <span class="string">&quot;Hello, World&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的图示：(槽位复用)</p>
<p><img src="/2021/04/19/JVM/image-20210520223508191.png" alt="image-20210520223508191"></p>
<h5 id="1、局部变量压栈指令"><a href="#1、局部变量压栈指令" class="headerlink" title="1、局部变量压栈指令"></a>1、局部变量压栈指令</h5><p><strong>局部变量压栈指令将给定的局部变量表中的数据压入操作数栈</strong>。</p>
<p>这类指令大体可以分为：</p>
<ul>
<li>xload_ <n> (x为i、l、f、d、a，n为0到3)</n></li>
<li>xload (x为i、l、f、d、a)</li>
</ul>
<p>说明：在这里，x的取值表示数据类型。</p>
<p>指令xload_ n表示将第n个局部变量压入操作数栈，比如iload_1、 fload_0、aload_0等指令。其中aload_n表示将一个对象引用压栈。此时该字节码指令占用一个字节（包含一个操作码，一个字节）</p>
<p>指令xload通过指定参数的形式，把局部变量压入操作数栈，当使用这个命令时，表示局部变量的数量可能超过了4个，比如指令iload、fload等。此时该字节码指令占用三个字节（包含一个操作码，一个字节、一个操作数，两个字节）</p>
<p>举例：</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.局部变量压栈指令</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(<span class="keyword">int</span> num, Object obj,<span class="keyword">long</span> count,<span class="keyword">boolean</span> flag,<span class="keyword">short</span>[] arr)</span> </span>&#123;</span><br><span class="line">    System.out.println(num);</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">    System.out.println(count);</span><br><span class="line">    System.out.println(flag);</span><br><span class="line">    System.out.println(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码指令执行过程：</p>
<p><img src="/2021/04/19/JVM/image-20210520224306556.png" alt="image-20210520224306556"></p>
<h5 id="2、常量入栈指令"><a href="#2、常量入栈指令" class="headerlink" title="2、常量入栈指令"></a>2、常量入栈指令</h5><p>常量入栈指令的功能是将常数压入操作数栈，根据数据类型和入栈内容的不同，又可以分为<strong>const系列</strong>、<strong>push系列</strong>和<strong>ldc指令</strong>。</p>
<p><strong>指令const系列</strong>：用于对特定的常量入栈，入栈的常量隐含在指令本身里。</p>
<p>指令有: <code>iconst_ &lt;i&gt; (i从-1到5)</code>、<code>lconst_ &lt;l&gt; (l从0到1)</code>、<code>fconst_ &lt;f&gt; (f从0到2)</code>、<code>dconst_ &lt;d&gt; (d从0到1)</code>、<code>aconst_null</code>。</p>
<p>比如：</p>
<ul>
<li>iconst_m1将-1压入操作数栈；</li>
<li>iconst_x (x为0到5)将x压入栈；</li>
<li>lconst_0、lconst_1分别将长整数0和1压入栈；</li>
<li>fconst_0、fconst_1、 fconst_2分别将浮点数0、1、2压入栈；</li>
<li>dconst_0和dconst_1分别将double型0和1压入栈；</li>
<li>aconst_null将null压入操作数栈；</li>
</ul>
<p>从指令的命名上不难找出规律，指令助记符的第一个字符总是喜欢表示数据类型，<code>i表示整数</code>，<code>l表示长整数</code>，<code>f表示浮点数</code>，<code>d表示双精度浮点</code>，习惯上用<code>a表示对象引用</code>。如果指令隐含操作的参数，会以下划线形式给出。</p>
<p><strong>指令push系列</strong>：主要包括bipush和sipush。 它们的区别在于接收数据类型的不同，bipush接收8位整数作为参数，sipush接收16位整数，它们都将参数压入栈。</p>
<p><strong>指令ldc系列</strong>：如果以上指令都不能满足需求，那么可以使用万能的ldc指令，它可以接收一个8位的参数，该参数指向常量池中的int、float或者String的<strong>索引</strong>，将指定的内容压入堆栈。</p>
<p>类似的还有<code>ldc_w</code>，它接收两个8位参数，能支持的索引范围大于ldc。</p>
<p>如果要压入的元素是long或者double类型的，则使用<code>ldc2_w</code>指令，使用方式都是类似的。</p>
<p>总结如下：</p>
<p><img src="/2021/04/19/JVM/image-20210520234851493.png" alt="image-20210520234851493"></p>
<p>举例分析：</p>
<p><img src="/2021/04/19/JVM/566B9397-5AFE-4A3F-9E17-9EBF504DFC80.png" alt="img"></p>
<p><img src="/2021/04/19/JVM/B59702D2-4C93-44DF-87F1-01A5DFE53B61.png" alt="img"></p>
<p>注意：常量入栈指令中的n和局部变量压栈指令中的n不一样，<strong>常量入栈的n代表数值或者对象，而不是局部变量表中的下标</strong></p>
<h5 id="3、出栈入局部变量表指令"><a href="#3、出栈入局部变量表指令" class="headerlink" title="3、出栈入局部变量表指令"></a>3、出栈入局部变量表指令</h5><p><strong>出栈装入局部变量表指令</strong>用于<strong>将操作数栈中栈项元素弹出后，装入局部变量表的指定位置，用于给局部变量赋值</strong>。</p>
<p>这类指令主要以<code>store</code>的形式存在，比如xstore(x为i、l、f、d、a)、xstore_n(x为i、l、f、d、a，n为0至3)。</p>
<ul>
<li>其中，指令istore_n将从操作数栈中弹出一个整数，并把它赋值给局部变量<strong>索引n的位置</strong>。</li>
<li>指令xstore由于没有隐含参数信息，故需要提供一个<strong>byte类型的参数类</strong>指定目标局部变量表的位置。</li>
</ul>
<p>说明：</p>
<p><strong>一般说来，类似像store这样的命令需要带一个参数，用来指明将弹出的元素放在局部变量表的第几个位置</strong>。 但是，为了尽可能<strong>压缩指令大小</strong>，使用专门的istore_1指令表示将弹出的元素放置在局部变量表第1个位置。类似的还有istore_0、istore_2、 istore_3,它们分别表示从操作数栈顶弹出一个元素，存放在局部变量表第0、2、3个位置。</p>
<p>由于局部变量表前几个位置总是非常常用，因此<strong>这种做法虽然增加了指令数量，但是可以大大压缩生成的字节码的体积</strong>。如果局部变量表很大，需要存储的槽位大于3，那么可以使用istore指令，外加一个参数，用来表示需要存放的槽位位置。</p>
<p>举例分析：</p>
<p><img src="/2021/04/19/JVM/image-20210521000606437.png" alt="image-20210521000606437"></p>
<p>相关分析：</p>
<ol>
<li>首先该方法被调用的时候，形式参数k和d都是有确定的值，由于该方法不是静态方法，所以局部变量表中的第一个位置（槽位）存储this，而第二个位置存储k<strong>具体的值</strong>，由于老师只是分析，没有调用这个方法，所以老师全部使用的<strong>变量名称来代替具体的值</strong>，所以明白就好。</li>
<li>然后第三个和第四个位置储存d具体的值，由于d是double类型，所以需要占据两个槽位，数据已经准备好了，那就来看字节码<ol>
<li>首先iload_1是将局部变量表中下标为1的k值取出来压入操作数栈中</li>
<li>然后iconst_2是将常量池中的整型值2压入操作数栈，iadd让操作数栈弹出的k值和整型值2执行相加操作</li>
<li>之后将相加的结果值m压入操作数栈中，请注意老师的画法，在执行弹栈和压栈操作之后，老师并没有删除操作数栈中的k值和2，这是因为老师让我们知道具体的操作过程，所以故意为之，不过真正的操作是弹栈之后k值和2就会从操作数栈中弹出，之后操作数栈中就没有k值和2了，只有m值了</li>
</ol>
</li>
<li>然后istore_4是将操作数栈中的m值弹出栈，然后放在局部变量表中下标为4的位置</li>
<li>idc2_w #13代表将long型值12压入操作数栈，istore5是将值12弹栈之后放入局部变量表中下标为5的位置，由于12是long型，所以占据两个位置（槽位）</li>
<li>ldc #15代表将字符串atguigu压入操作数栈，astore 7代表将字符串atguigu弹栈之后放入局部变量表中下标为7的位置</li>
<li>idc #16代表将float类型数据10.0压入操作数栈，fstore 8代表将10.0弹出栈，然后放入局部变量表中下标为8的位置</li>
<li>idc2_w #17代表将10.0压入操作数栈，dstore2代表将10.0弹出栈，之后将10.0放入下标为2和3的操作，毕竟这是double类型数据。</li>
</ol>
<p><strong>槽位复用</strong>：</p>
<p><img src="/2021/04/19/JVM/DD6CCB19-DEDB-426F-815A-A5769ED22E62-1621527103113.png" alt="img"></p>
<p>注意：<strong>在方法没有运行的时候，根据字节码文件就可以计算出需要几个槽位</strong>。</p>
<h4 id="3、算术指令"><a href="#3、算术指令" class="headerlink" title="3、算术指令"></a>3、算术指令</h4><ol>
<li><p><strong>作用</strong>：算术指令用于对<strong>两个操作数栈上的值</strong>进行某种特定运算，并<strong>把结果重新压入操作数栈</strong>。</p>
</li>
<li><p><strong>分类</strong>：</p>
<ul>
<li>大体上算术指令可以分为两种：<ul>
<li>对<strong>整型数据</strong>进行运算的指令</li>
<li>对<strong>浮点类型数据</strong>进行运算的指令</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>byte、short、char和boolean类型说明：</strong></p>
<p>在每一大类中， 都有针对Java虚拟机具体数据类型的专用算术指令。但没有直接支持byte、short、char和boolean类型的算术指令，对于这些数据的运算，<strong>都使用int类型的指令来处理</strong>。此外，在<strong>处理boolean、byte、 short 和char类型的数组</strong>时，也会<strong>转换为使用对应的int类型的字节码指令</strong>来处理。</p>
<p><img src="/2021/04/19/JVM/image-20210521002838645.png" alt="image-20210521002838645"></p>
</li>
<li><p><strong>运算时的溢出</strong>：<br>数据运算可能会导致溢出，例如两个很大的正整数相加，结果可能是一个负数。其实Java虚拟机规范并无明确规定过整型数据溢出的具体结果，仅规定了在处理整型数据时，只有<strong>除法指令以及求余指令中当出现除数为0</strong>时会导致虚拟机抛出异常<code>ArithmeticException</code>。</p>
</li>
<li><p><strong>运算模式：</strong></p>
<ul>
<li>向最接近数舍入模式：JVM要求在进行浮点数计算时，所有的运算结果都必须舍入到适当的精度，非精确结果必须舍入为可被表示的最接近的精确值，如果有两种可表示的形式与该值一样接近， 将优先选择最低有效位为零的；（四舍五入）</li>
<li>向零舍入模式：将浮点数转换为整数时，采用该模式，该模式将在目标数值类型中选择一个最接近但是不大于原值的数字作为最精确的舍入结果。（截断法）</li>
</ul>
</li>
<li><p><strong>NaN值使用：</strong></p>
<p>当一个操作产生溢出时，将会使用有符号的无穷大（<code>Infinity</code>）表示，如果某个操作结果没有明确的数学定义的话，将会使用<code>NaN</code>值来表示。而且所有使用NaN值作为操作数的算术操作，结果都会返回NaN。</p>
<p>对于无穷大Infinity和NaN的举例：</p>
<p><img src="/2021/04/19/JVM/83FDD717-E615-45C8-B2E2-31C5CEB2BA4E.png" alt="img"></p>
<h5 id="1、所有算术指令"><a href="#1、所有算术指令" class="headerlink" title="1、所有算术指令"></a>1、所有算术指令</h5><p>所有的算术指令包括：</p>
<ul>
<li>加法指令：iadd、ladd、fadd、dadd</li>
<li>减法指令：isub、lsub、fsub、dsub</li>
<li>乘法指令：imul、lmul、fmul、dmul</li>
<li>除法指令：idiv、ldiv、fdiv、ddiv</li>
<li>求余指令：irem、lrem、frem、drem       //remainder:余数</li>
<li>取反指令：ineg、lneg、fneg、dneg       //negation:取反</li>
<li>自增指令：iinc</li>
<li>位运算指令， 又可分为：<ul>
<li>位移指令：ishl、 ishr、iushr、lshl、lshr、lushr</li>
<li>按位或指令：ior、lor</li>
<li>按位与指令：iand、land</li>
<li>按位异或指令：ixor、lxor</li>
</ul>
</li>
<li>比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp </li>
</ul>
</li>
</ol>
<p>相关举例的分析：</p>
<ul>
<li><p>对于 i = i + 10 与 i += 10 的区别：（假设i = 100）</p>
<ul>
<li><p>i = i + 10：</p>
<p><img src="/2021/04/19/JVM/image-20210521004835960.png" alt="image-20210521004835960"></p>
</li>
<li><p>i += 10：</p>
<p><img src="/2021/04/19/JVM/image-20210521005146519.png" alt="image-20210521005146519"></p>
</li>
</ul>
<p>结论：</p>
<ul>
<li>若i一开始为byte类型，与10相加之后转换为int类型；自增10之后编译不报错</li>
<li>如果short i = 10，那么i+=10不是在原位置上加10，而是进行了强转，其中用到了i2s</li>
</ul>
</li>
<li><p>JVM取反（~）操作的具体实现过程：（用<strong>异或</strong>实现）</p>
<ul>
<li>先取出操作数压入操作数栈</li>
<li>在将-1压入操作数栈（iconst_m1）</li>
<li><strong>将操作数与-1实现异或（xor）操作</strong></li>
<li>得到的操作数取反后的值在压入操作数栈</li>
</ul>
</li>
</ul>
<h6 id="1、举例"><a href="#1、举例" class="headerlink" title="1、举例"></a>1、举例</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bar</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span>) - <span class="number">2</span>) * <span class="number">3</span> / <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码指令对应的图示：</p>
<p><img src="/2021/04/19/JVM/A54C2AC8-DD36-49F4-A49D-9AFD725E8365.png" alt="img"></p>
<h6 id="2、一个曾经的案例"><a href="#2、一个曾经的案例" class="headerlink" title="2、一个曾经的案例"></a>2、一个曾经的案例</h6><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> a = x / y;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">50</span>;</span><br><span class="line">    System.out.println(a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码对应的内存解析：（省略了前面的解析，主要看一下println()方法：返回值为void）</p>
<p><img src="/2021/04/19/JVM/C43C0407-020F-4EC4-BD27-E4C109640B39.png" alt="img"></p>
<p><img src="/2021/04/19/JVM/04282DF1-4E52-4C3D-A47B-84023159B624.png" alt="img"></p>
<p>注意：</p>
<ul>
<li>执行System.out.printin()的时候，会在虚拟机栈当中新建一个System.out.printin方法栈帧，55作为参数传入println()方法当中；</li>
<li>println()方法栈帧的本地变量表中会放55，这样该方法就可以使用了。</li>
<li>println()方法执行结束之后，由于返回值为void，所以字节码指令直接return</li>
<li>进入main方法栈帧之后，也直接执行return。</li>
</ul>
<h6 id="3、关于i-与-i"><a href="#3、关于i-与-i" class="headerlink" title="3、关于i++与++i"></a>3、关于i++与++i</h6><p>在<strong>没有其他操作</strong>（如赋值）的情况下，i++与++i是一样的，没有区别：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关于(前)++和(后)++</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="comment">//++i;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码：<img src="/2021/04/19/JVM/image-20210521011319549.png" alt="image-20210521011319549"></p>
<p>与其他运算符(赋值运算符)结合运算的情况下，i++与++i就有区别了：</p>
<ul>
<li>i++：先赋值后自增</li>
<li>++i：先自增后赋值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method7</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> a = i++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> b = ++j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码：</p>
<p><img src="/2021/04/19/JVM/image-20210521014725284.png" alt="image-20210521014725284"></p>
<p>与println()方法结合的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method8</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    i = i++;</span><br><span class="line">    System.out.println(i);<span class="comment">//10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码：</p>
<p><img src="/2021/04/19/JVM/image-20210521020635532.png" alt="image-20210521020635532"></p>
<h5 id="2、比较指令的说明"><a href="#2、比较指令的说明" class="headerlink" title="2、比较指令的说明"></a>2、比较指令的说明</h5><ul>
<li><strong>比较指令</strong>的作用是<strong>比较栈顶两个元素的大小，并将比较结果入栈</strong>。</li>
<li><strong>比较指令有：dcmpg、dcmpl、 fcmpg、 fcmpl、 lcmp</strong>。<ul>
<li>与前面讲解的指令类似，首字符d表示double类型， f表示float , l表示long。</li>
</ul>
</li>
<li>对于double和float类型的数字，由于NaN的存在，各有两个版本的比较指令。以float为例，有fcmpg和fcmpl两个指令，它们的区别在于在数字比较时，若遇到NaN值，处理结果不同。</li>
<li>指令dcmpl和dcmpg也是类似的，根据其命名可以推测其含义，在此不再赘述。</li>
<li>指令lcmp针对long型整数，由于long型整数没有NaN值，故无需准备两套指令。</li>
</ul>
<p>举例：</p>
<ul>
<li>指令fcmpg和fcmpl都从栈中弹出两个操作数，并将它们做比较，设栈顶的元素为v2，栈顶顺位第2位的元素为v1<ul>
<li>若v1 = v2，则压入0；</li>
<li>若v1 &gt; v2，则压入1；</li>
<li>若v1 &lt; v2，则压入-1</li>
</ul>
</li>
<li>两个指令的不同之处在于，如果遇到NaN值，<strong>fcmpg会压入1</strong>，而<strong>fcmpl会压入-1</strong>。</li>
</ul>
<p><strong>数值类型的数据，才可以谈大小</strong>! boolean、引用数据类型不能比较大小。</p>
<p>注意：</p>
<ul>
<li>NaN(Not a Number)表示不是一个数字，比如0.0/0.0得到的可能是1.0（两个数相等），也可能是0.0（0.0是分子），也可能是无穷大（0.0是分母），所以老师给出的解释是NaN代表无法确定是什么数字，<strong>只有double和float类型中可能出现NaN的情况</strong>，而<strong>long类型不会出现NaN</strong>，所以只有<strong>lcmp</strong>。</li>
<li>为什么只存在long/float/double的比较指令，而没有char/byte/short/int类型的比较指令？<ul>
<li>仔细观察会发现long/float/double的比较指令的最后都会往操作数栈压入一个int类型的值（-1/1/0），而比较指令常常与跳转指令一起使用</li>
<li>而两种指令是通过int类型的值结合在一起使用的</li>
<li>所以也就不必要存在int等类型的比较指令</li>
<li>如果说是有int类型的比较指令的话就是比较条件跳转指令了</li>
</ul>
</li>
</ul>
<h4 id="4、类型转换指令"><a href="#4、类型转换指令" class="headerlink" title="4、类型转换指令"></a>4、类型转换指令</h4><p>类型转换指令说明：</p>
<ol>
<li><strong>类型转换指令</strong>可以<strong>将两种不同的数值类型进行相互转换</strong>。</li>
<li>这些转换操作一般用于实现用户代码中的<strong>显式类型转换操作</strong>，或者用来处理<strong>字节码指令集中数据类型相关指令无法与数据类型一一对应</strong>的问题。</li>
</ol>
<h5 id="1、宽化类型转换-Widening-Numeric-Conversions"><a href="#1、宽化类型转换-Widening-Numeric-Conversions" class="headerlink" title="1、宽化类型转换(Widening Numeric Conversions)"></a>1、宽化类型转换(Widening Numeric Conversions)</h5><h6 id="1、转换规则"><a href="#1、转换规则" class="headerlink" title="1、转换规则"></a>1、转换规则</h6><p>Java虚拟机直接支持以下数值的宽化类型转换(widening numeric conversion，小范围类型向大范围类型的安全转换)。也就是说，并不需要指令执行，包括：</p>
<ul>
<li>从int类型到long、float或者double类型。对应的指令为：<code>i2l</code>、<code>i2f</code>、<code>i2d</code></li>
<li>从long类型到float、double类型。对应的指令为：<code>l2f</code>、<code>l2d</code></li>
<li>从float类型到double类型。对应的指令为：<code>f2d</code></li>
</ul>
<p>简化为：int –&gt; long –&gt; float –&gt; double</p>
<h6 id="2、精度损失问题"><a href="#2、精度损失问题" class="headerlink" title="2、精度损失问题"></a>2、精度损失问题</h6><ul>
<li>宽化类型转换是<strong>不会因为超过目标类型最大值而丢失信息</strong>的，例如，从int转换到long，或者从int转换到double，都不会丢失任何信息，<strong>转换前后的值是精确相等</strong>的。</li>
<li>从<strong>int、long类型数值转换到float</strong>，或者<strong>long类型数值转换到double</strong>时，将可能发生精度丢失——可能<strong>丢失掉几个最低有效位上的值</strong>，转换后的浮点数值是根据IEEE754最接近舍入模式所得到的正确整数值。</li>
</ul>
<p>尽管宽化类型转换实际上是可能发生精度丢失的，但是<strong>这种转换永远不会导致Java虚拟机抛出运行时异常</strong>。</p>
<h6 id="3、补充说明"><a href="#3、补充说明" class="headerlink" title="3、补充说明"></a>3、补充说明</h6><ul>
<li>从<strong>byte、char 和short类型到int类型的宽化类型转换实际上是不存在</strong>的。对于byte类型转为int，虚拟机并没有做实质性的转化处理，只是简单地通过操作数栈交换了两个数据。而将byte转为long时，使用的是<code>i2l</code>,可以看到<strong>在内部byte在这里已经等同于int类型处理</strong>，类似的还有short类型，这种处理方式有两个特点：<ul>
<li>一方面可以减少实际的数据类型，如果为short和byte都准备一套指令，那么指令的数量就会大增，而<strong>虛拟机目前的设计上，只愿意使用一个字节表示指令，因此指令总数不能超过256个，为了节省指令资源，将short和byte当做int处理也在情理之中</strong>。</li>
<li>另一方面，由于<strong>局部变量表中的槽位固定为32位（4个字节，也是int的长度）</strong>，无论是byte或者short存入局部变量表，都会占用32位空间。从这个角度说，也没有必要特意区分这几种数据类型。</li>
</ul>
</li>
</ul>
<h5 id="2、窄化类型转换-Narrowing-Numeric-Conversion"><a href="#2、窄化类型转换-Narrowing-Numeric-Conversion" class="headerlink" title="2、窄化类型转换(Narrowing Numeric Conversion)"></a>2、窄化类型转换(Narrowing Numeric Conversion)</h5><h6 id="1、转换规则-1"><a href="#1、转换规则-1" class="headerlink" title="1、转换规则"></a>1、转换规则</h6><p>Java虚拟机也直接支持以下<strong>窄化类型转换</strong>：</p>
<ul>
<li>从int类型至byte、short或者char类型。对应的指令有：<code>i2b</code>、<code>i2c</code>、<code>i2s</code></li>
<li>从long类型到int类型。对应的指令有：<code>l2i</code></li>
<li>从float类型到int或者long类型。对应的指令有：<code>f2i</code>、<code>f2l</code></li>
<li>从double类型到int、long或者float类型。 对应的指令有：<code>d2i</code>、<code>d2l</code>、 <code>d2f</code></li>
</ul>
<p>注意：<strong>从float、double、long等类型往byte、short、char类型转换的时候，需要先把前面几种类型转换成int类型，然后在从int类型转换到后面这几种类型，所以int类型相等于一种过渡类型。</strong></p>
<h6 id="2、精度损失问题-1"><a href="#2、精度损失问题-1" class="headerlink" title="2、精度损失问题"></a>2、精度损失问题</h6><ul>
<li>窄化类型转换可能会导致转换结果具备不同的正负号、不同的数量级，因此，<strong>转换过程很可能会导致数值丢失精度</strong>。</li>
<li>尽管数据类型窄化转换可能会发生上限溢出、下限溢出和精度丢失等情况，但是<strong>Java虚拟机规范中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常</strong>。</li>
</ul>
<h6 id="3、补充说明-1"><a href="#3、补充说明-1" class="headerlink" title="3、补充说明"></a>3、补充说明</h6><ol>
<li>当将一个浮点值窄化转换为整数类型T（T限于int或long类型之一）的时候，将遵循以下转换规则：<ul>
<li>如果<strong>浮点值是NaN</strong>，那转换结果就是<strong>int或long类型的0</strong>。</li>
<li>如果<strong>浮点值不是无穷大</strong>的话，浮点值使用IEEE 754的向零舍入模式取整，获得整数值v，如果<strong>v在目标类型T(int或long)的表示范围之内，那转换结果就是v</strong>。否则，将<strong>根据v的符号，转换为T所能表示的最大或者最小正数</strong>。</li>
</ul>
</li>
<li>当将一个double类型窄化转换为float类型时，将遵循以下转换规则：<ul>
<li>通过向最接近数舍入模式舍入一个可以使用float类型表示的数字。最后结果根据下面这3条规则判断：<ul>
<li>如果<strong>转换结果的绝对值太小而无法使用float来表示</strong>， 将<strong>返回float类型的正负零</strong>。</li>
<li>如果<strong>转换结果的绝对值太大而无法使用float来表示</strong>，将<strong>返回float类型的正负无穷大</strong>。</li>
<li><strong>对于double类型的NaN值将按规定转换为float类型的NaN值。</strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<p>举例：</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downCast5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d1 = Double.NaN; <span class="comment">//0.0 / 0.0</span></span><br><span class="line">    <span class="keyword">int</span> i = (<span class="keyword">int</span>)d1;</span><br><span class="line">    System.out.println(d1); <span class="comment">// NaN</span></span><br><span class="line">    System.out.println(i); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> d2 = Double.POSITIVE_INFINITY;</span><br><span class="line">    <span class="keyword">long</span> l = (<span class="keyword">long</span>)d2;</span><br><span class="line">    <span class="keyword">int</span> j = (<span class="keyword">int</span>)d2;</span><br><span class="line">    System.out.println(l); <span class="comment">// 9223372036854775807</span></span><br><span class="line">    System.out.println(Long.MAX_VALUE); <span class="comment">// 92233720368547 75807</span></span><br><span class="line">    System.out.println(j); <span class="comment">// 2147483647</span></span><br><span class="line">    System.out.println(Integer.MAX_VALUE); <span class="comment">// 2147483647</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> f = (<span class="keyword">float</span>)d2;</span><br><span class="line">    System.out.println(f); <span class="comment">// infinity</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> f1 = (<span class="keyword">float</span>)d1;</span><br><span class="line">    System.out.println(f1); <span class="comment">// NaN</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5、对象的创建与访问指令"><a href="#5、对象的创建与访问指令" class="headerlink" title="5、对象的创建与访问指令"></a>5、对象的创建与访问指令</h4><p>Java是面向对象的程序设计语言，虚拟机平台从字节码层面就对面向对象做了深层次的支持。有一系列指令专门用于对象操作，可进一步细分为<strong>创建指令</strong>、<strong>字段访问指令</strong>、<strong>数组操作指令</strong>、<strong>类型检查指令</strong>。</p>
<h5 id="1、创建指令"><a href="#1、创建指令" class="headerlink" title="1、创建指令"></a>1、创建指令</h5><p>虽然类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令：</p>
<ol>
<li><p>创建类实例的指令：</p>
<ul>
<li><p><strong>创建类实例的指令：new</strong></p>
<ul>
<li>它<strong>接收一个操作数，为指向常量池的索引</strong>，表示要创建的类型，执行完成后，<strong>将对象的引用压入栈</strong>。</li>
</ul>
<p>例子：</p>
<p><img src="/2021/04/19/JVM/image-20210521031608842.png" alt="image-20210521031608842"></p>
</li>
</ul>
</li>
<li><p>创建数组的指令：</p>
<ul>
<li><p><strong>创建数组的指令：newarray、 anewarray、 multianewarray</strong></p>
<ul>
<li>newarray：创建<strong>基本类型数组</strong></li>
<li>anewarray：创建<strong>引用类型数组</strong></li>
<li>multianewarray：创建<strong>多维数组</strong></li>
</ul>
<p>例子：</p>
<p><img src="/2021/04/19/JVM/image-20210521032029716.png" alt="image-20210521032029716"></p>
</li>
</ul>
</li>
</ol>
<p>上述创建指令可以用于创建对象或者数组，由于对象和数组在Java中的广泛使用，这些指令的使用频率也非常高。</p>
<h5 id="2、字段访问指令"><a href="#2、字段访问指令" class="headerlink" title="2、字段访问指令"></a>2、字段访问指令</h5><p>对象创建后，就可以通过对象访问指令获取<strong>对象实例</strong>或<strong>数组实例</strong>中的<strong>字段或者数组元素</strong>。</p>
<ul>
<li><strong>访问类字段(static字段，或者称为类变量)的指令</strong>：<code>getstatic</code>、 <code>putstatic</code></li>
<li><strong>访问类实例字段(非static字段，或者称为实例变量)的指令</strong>：<code>getfield</code>、 <code>putfield</code></li>
</ul>
<p>举例1：<br>以getstatic指令为例，它含有一个操作数，为指向常量池的Fieldref索引，它的作用就是获取Fieldref指定的对象或者值，并将其压入操作数栈。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的字节码指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 getstatic #8 &lt;java&#x2F;lang&#x2F;System.out&gt;</span><br><span class="line">3 ldc #9 &lt;hello&gt;</span><br><span class="line">5 invokevirtual #10 &lt;java&#x2F;io&#x2F;PrintStream.println&gt;</span><br><span class="line">8 return</span><br></pre></td></tr></table></figure>

<p>图示：</p>
<p><img src="/2021/04/19/JVM/image-20210521033428524.png" alt="image-20210521033428524"></p>
<p>举例2：</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderId</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Order order = <span class="keyword">new</span> Order();</span><br><span class="line">    order.id = <span class="number">1001</span>;</span><br><span class="line">    System.out.println(order.id);</span><br><span class="line"></span><br><span class="line">    Order.name = <span class="string">&quot;ORDER&quot;</span>;</span><br><span class="line">    System.out.println(Order.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">static</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码指令执行过程：</p>
<p><img src="/2021/04/19/JVM/image-20210521034806188.png" alt="image-20210521034806188"></p>
<p> 注意：<strong>getxxx是入栈，而putxxx是出栈</strong></p>
<h5 id="3、数组操作指令"><a href="#3、数组操作指令" class="headerlink" title="3、数组操作指令"></a>3、数组操作指令</h5><h6 id="1、数组操作指令"><a href="#1、数组操作指令" class="headerlink" title="1、数组操作指令"></a>1、数组操作指令</h6><p>数组操作指令主要有：<code>xastore</code>和<code>xaload</code>指令。具体为：</p>
<ul>
<li>把<strong>一个数组元素加载到操作数栈的指令</strong>：<code>baload</code>、<code>caload</code>、<code>saload</code>、<code>iaload</code>、<code>laload</code>、<code>faload</code>、<code>daload</code>、<code>aaload</code></li>
<li>将<strong>一个操作数栈的值存储到数组元素中的指令</strong>：<code>bastore</code>、<code>castore</code>、<code>sastore</code>、<code>iastore</code>、 <code>lastore</code>、<code>fastore</code>、<code>dastore</code>、<code>aastore</code></li>
</ul>
<p>即：</p>
<p><img src="/2021/04/19/JVM/image-20210521171308285.png" alt="image-20210521171308285"></p>
<ul>
<li><strong>取数组长度的指令</strong>：<code>arraylength</code><ul>
<li>该指令<strong>弹出栈顶的数组元素，获取数组的长度，将长度压入栈</strong>。</li>
</ul>
</li>
</ul>
<h6 id="2、说明"><a href="#2、说明" class="headerlink" title="2、说明"></a>2、说明</h6><ul>
<li><p>一个操作数栈的值存储到数组元素中的指令，即xastore指令与xstore指令的区别：</p>
<ul>
<li>xstore指令是将值存放进<strong>局部变量表</strong>里面</li>
<li>xastore指令是将值存放进<strong>堆空间</strong>中对应的数组元素里面</li>
</ul>
</li>
<li><p>指令xaload表示将数组的元素压栈，比如saload、caload分别表示压入short数组和char数组。指令xaload在执行时，要求操作数中栈顶元素为数组索引i，栈顶顺位第2个元素为数组引用a，该指令会弹出栈顶这两个元素，并将a[i]重新压入栈。</p>
</li>
<li><p>xastore则专门针对数组操作，以iastore为例， 它用于给一个int数组的给定索引赋值。在iastore执行 ，操作数栈顶需要以此准备3个元素：</p>
<ul>
<li>值</li>
<li>索引</li>
<li>数组引用</li>
</ul>
<p>iastore会弹出这3个值，并将值赋给数组中指定索引的位置。</p>
<p><img src="/2021/04/19/JVM/image-20210521171926923.png" alt="image-20210521171926923"></p>
</li>
</ul>
<h5 id="4、类型检查指令"><a href="#4、类型检查指令" class="headerlink" title="4、类型检查指令"></a>4、类型检查指令</h5><p>检查类实例或数组类型的指令：<code>instanceof</code>、 <code>checkcast</code></p>
<ul>
<li>指令<code>checkcast</code>用于<strong>检查类型强制转换是否可以进行</strong>。如果可以进行，那么checkcast指令不会改变操作数栈，否则<strong>它会抛出<code>ClassCastException</code>异常</strong>。</li>
<li>指令<code>instanceof</code>用来<strong>判断给定对象是否是某一个类的实例</strong>，它会将<strong>判断结果压入操作数栈</strong>。</li>
</ul>
<h4 id="6、方法调用与返回指令"><a href="#6、方法调用与返回指令" class="headerlink" title="6、方法调用与返回指令"></a>6、方法调用与返回指令</h4><h5 id="1、方法调用指令"><a href="#1、方法调用指令" class="headerlink" title="1、方法调用指令"></a>1、方法调用指令</h5><p>方法调用指令：<code>invokevirtual</code>、<code>invokeinterface</code>、<code>invokespecial</code>、<code>invokestatic</code>、<code>invokedynamic</code></p>
<p>以下5条指令用于方法调用：</p>
<ul>
<li><code>invokevirtual</code>指令用于<strong>调用对象的实例方法</strong>，<strong>根据对象的实际类型进行分派(虚方法分派)，支持多态</strong>。（<strong>可被子类重写</strong>）这也是Java语言中最常见的方法分派方式。<ul>
<li>invokevirtual是调用类中的非静态普通方法，而这种实例方法可能调用的是子类重写的非静态普通方法，比如A a = new B();a.hello()，其中B类继承A类，并且B类重写了A类中的hello()方法，这种情况下就是invokevirtual了，但是有可能该类没有子类，调用的就是本类中的非静态普通方法，这种情况也是invokevirtual了</li>
</ul>
</li>
<li><code>invokeinterface</code>指令用于<strong>调用接口方法</strong>，它会<strong>在运行时搜索由特定对象所实现的这个接口方法，并找出适合的方法进行调用</strong>。<ul>
<li>invokeinterface是对接口而言的，用属于接口类型的对象调用方法的时候就是这个</li>
</ul>
</li>
<li><code>invokespecial</code>指令用于<strong>调用一些需要特殊处理的实例方法</strong>，包括<strong>实例初始化方法(构造器)**、</strong>私有方法<strong>和</strong>父类方法<strong>。这些方法都是</strong>静态类型绑定的<strong>，</strong>不会在调用时进行动态派发<strong>。（</strong>不能被子类重写**）<ul>
<li>invokespecial只有构造器、私有方法、super.方法名()调用父类方法这几种情况，其中调用父类方法这种情况可能出现其直接父类没有该方法，那就可以调用其父类继承的父类中的该方法，最终找到一个方法调用就是了。</li>
</ul>
</li>
<li><code>invokestatic</code>指令用于<strong>调用命名类中的类方法(static方法)。这是静态绑定的</strong>。<ul>
<li>invokestatic是调用static静态方法，无论是使用对象.静态方法名()还是类名.静态方法名()都是invokestatic，也不难理解</li>
</ul>
</li>
<li><code>invokedynamic</code>：调用动态绑定的方法，这个是JDK 1.7后新加入的指令。用于<strong>在运行时动态解析出调用点限定符所引用的方法，并执行该方法</strong>。前面4条调用指令的分派逻辑都固化在java虚拟机内部，而invokedynamic指令的分派逻辑是<strong>由用户所设定的引导方法决定</strong>的。具体可看博客：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wade-luffy/p/6058087.html">关于invokedynamic</a></li>
</ul>
<p>注意：</p>
<ul>
<li>当一个方法既是私有方法，又是静态方法。使用的是invokestatic指令</li>
<li>关于在接口当中的静态方法与默认方法<ul>
<li>静态方法：使用的是invokestatic指令</li>
<li>默认方法：使用的是invokeinterface指令</li>
</ul>
</li>
</ul>
<p>总结：</p>
<ul>
<li>除了static的接口的方法都是invokeinterface，如果是static那么都是invokestatic。</li>
<li>用static修饰的方法都是使用invokestatic</li>
<li>如果是用多态的话使用的是invokevirtual</li>
<li>如果是强转成接口类型的方法使用的是invokeinterface</li>
</ul>
<h5 id="2、方法返回指令"><a href="#2、方法返回指令" class="headerlink" title="2、方法返回指令"></a>2、方法返回指令</h5><p>方法调用结束前，需要进行返回。方法返回指令是根据返回值的类型区分的：</p>
<ul>
<li>包括<code>ireturn</code> (当返回值是boolean、 byte、char、short和int类型时使用)、<code>lreturn</code>、 <code>freturn</code>、<code>dreturn</code>和<code>areturn</code></li>
<li>另外还有一条<code>return</code>指令供<strong>声明为void的方法</strong>、实<strong>例初始化方法以及类和接口的类初始化方法</strong>使用。</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210521200452707.png" alt="image-20210521200452707"></p>
<p>说明：</p>
<ul>
<li>通过ireturn指令，将当前函数操作数栈的顶层元素弹出，并将这个元素压入调用者函数的操作数栈中(因为调用者非常关心函数的返回值)，<strong>所有在当前函数操作数栈中的其他元素都会被丢弃</strong>。</li>
<li><strong>如果当前返回的是synchronized方法，那么还会执行一个隐含的<code>monitorexit</code>指令，退出临界区（解锁的作用）</strong>。最后，会丢弃当前方法的整个帧，恢复调用者的帧，并将控制权转交给调用者。</li>
<li>当返回的变量与返回值不是同一个基本数据类型的话，会有一个<strong>使用类型转换指令</strong>的过程。</li>
</ul>
<p>举例：</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">methodReturn</span><span class="params">( )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">return</span>(i+j)/k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/19/JVM/image-20210521200909546.png" alt="image-20210521200909546"></p>
<h4 id="7、操作数栈管理指令"><a href="#7、操作数栈管理指令" class="headerlink" title="7、操作数栈管理指令"></a>7、操作数栈管理指令</h4><p>如同操作一个普通数据结构中的堆栈那样，JVM提供的操作数栈管理指令，可以用于直接操作操作数栈的指令。</p>
<p>这类指令包括如下内容：</p>
<ul>
<li>将一个或两个元素从栈顶弹出，并且直接废弃：<code>pop</code>, <code>pop2</code>；</li>
<li>复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈项：<code>dup</code>, <code>dup2</code>, <code>dup_x1</code>，<code>dup2_x1</code>, <code>dup_x2</code>, <code>dup2_x2</code>;</li>
<li>将<strong>栈最顶端的两个Slot数值位置交换</strong>：<code>swap</code>。<ul>
<li>Java虛拟机没有提供交换两个64位数据类型(long、double) 数值的指令。</li>
</ul>
</li>
<li>指令<code>nop</code>，是一个非常特殊的指令，它的<strong>字节码为0x00</strong>。和汇编语言中的nop一样，它表示什么都不做。这条指令<strong>一般可用于调试、占位</strong>等。</li>
</ul>
<p><strong>这些指令属于通用型，对栈的压入或者弹出无需指明数据类型</strong>。</p>
<p>说明：</p>
<ul>
<li>不带_x的指令是<strong>复制栈顶数据并压入栈顶</strong>。包括两个指令，<code>dup</code>和<code>dup2</code>。<ul>
<li>dup的系数代表要复制的Slot个数。</li>
<li>dup开头的指令用于复制1个Slot的数据。<ul>
<li>例如1个int或1个reference类型数据</li>
</ul>
</li>
<li>dup2开头的指令用于复制2个Slot的数据。 <ul>
<li>例如1个long，或2个int，或1个int+1个float类型数据</li>
</ul>
</li>
</ul>
</li>
<li>带_ x的指令是<strong>复制栈顶数据并<code>插入</code>栈顶以下的某个位置</strong>。共有4个指令，<code>dup_x1</code>，<code>dup2_x1</code>，<code>dup_x2</code>，<code>dup2_x2</code>。<ul>
<li>对于带x的复制插入指令，只要将指令的<strong>dup和x的系数相加</strong>，结果即为需要插入的位置。因此：<ul>
<li>dup_x1插入位置：1+1=2， 即栈顶2个Slot下面</li>
<li>dup_x2插入位置：1+2=3， 即栈顶3个Slot下面</li>
<li>dup2_x1插入位置：2+1=3， 即栈顶3个Slot下面</li>
<li>dup2_x2插入位置：2+2=4， 即栈顶4个Slot下面</li>
</ul>
</li>
</ul>
</li>
<li><code>pop</code>：将栈项的1个Slot数值出栈。例如1个short类型数值</li>
<li><code>pop2</code>：将栈顶的2个Slot数值出栈。例如1个double类型数值，或者2个int类型数值</li>
</ul>
<p>例子：</p>
<p><img src="/2021/04/19/JVM/image-20210521223947568.png" alt="image-20210521223947568"></p>
<h4 id="8、控制转义指令"><a href="#8、控制转义指令" class="headerlink" title="8、控制转义指令"></a>8、控制转义指令</h4><p>程序流程离不开条件控制，为了支持条件跳转，虚拟机提供了大量字节码指令，大体上可以分为：</p>
<ol>
<li>比较指令（在算术指令那里）</li>
<li>条件跳转指令</li>
<li>比较条件跳转指令</li>
<li>多条件分支跳转指令</li>
<li>无条件跳转指令等。</li>
</ol>
<h5 id="1、条件跳转指令"><a href="#1、条件跳转指令" class="headerlink" title="1、条件跳转指令"></a>1、条件跳转指令</h5><p>条件跳转指令通常和<strong>比较指令</strong>结合使用。在条件跳转指令执行前。一般可以先用比较指令进行栈顶元素的准备，然后进行条件跳转。</p>
<p>条件跳转指令有：<code>ifeq</code>，<code>iflt</code>，<code>ifle</code>，<code>ifne</code>，<code>ifgt</code>，<code>ifge</code>, <code>ifnull</code>, <code>ifnonnull</code>。</p>
<p>这些指令都接收两个字节的操作数，用于计算跳转的位置（16位符号整数作为当前位置的offset）。</p>
<p>它们的统一含义为：<strong>弹出栈顶元素，测试它是否满足某一条件，如果满足条件，则跳转到给定位置</strong>。</p>
<p>具体说明：</p>
<p><img src="/2021/04/19/JVM/image-20210521230336692.png" alt="image-20210521230336692"></p>
<p>注意：</p>
<ol>
<li>与前面运算规则一致：<ul>
<li>对于boolean、byte、char、short类型的条件分支比较操作，都是<strong>使用int类型</strong>的比较指令完成</li>
<li><strong>对于long、float、double类型的条件分支比较操作，则会先执行相应类型的比较运算指令，运算指令会返回一个整型值到操作数栈中，随后再执行int类型的条件分支比较操作来完成整个分支跳转。</strong></li>
</ul>
</li>
<li>由于<strong>各类型的比较最终都会转为int类型的比较操作</strong>，所以<strong>Java虚拟机提供的int类型的条件分支指令是最为丰富和强大</strong>的。</li>
</ol>
<p>例子：</p>
<p><img src="/2021/04/19/JVM/image-20210521232741411.png" alt="image-20210521232741411"></p>
<p>注意：</p>
<ol>
<li>对于float、double、long类型的比较，它们比较之后生成的是int类型的0、1、-1，这个过程可以使用比较指令和条件跳转指令来完成，虽然得到的是int类型的值，但是System.out.println(XXX)中的值是布尔类型，你可以在jclasslib中的常量池信息中看到写的是Z，代表布尔值类型。</li>
<li>int类型值（包含byte、char、short）比较和对象类型值比较需要使用<strong>比较条件跳转指令</strong>。</li>
<li>在比较当中，<strong>跳转指令的选择与代码里面的条件判断恰好相反</strong>。<ul>
<li>如题当中代码比较的是f1 &lt; f2，而字节码当中却使用了<code>ifge指令</code>（f1 &gt;= f2）</li>
<li>原因是该指令是<strong>跳转指令</strong>：也就是当满足条件才跳转，不满足的话就只是顺序执行。所以与代码执行顺序相反（代码是满足条件就顺序执行，不满足才跳转到相应的执行语句）</li>
</ul>
</li>
</ol>
<h5 id="2、比较条件跳转指令"><a href="#2、比较条件跳转指令" class="headerlink" title="2、比较条件跳转指令"></a>2、比较条件跳转指令</h5><p>比较条件跳转指令类似于比较指令和条件跳转指令的结合体，它将比较和跳转两个步骤合二为一。</p>
<p>这类指令有：<code>if_icmpeq</code>、<code>if_icmpne</code>、<code>if_icmplt</code>、<code>if_icmpgt</code>、<code>if_icmple</code>、<code>if_icmpge</code>、（之前的都是与int相关的比较条件跳转指令）<code>if_acmpeq</code>和<code>if_acmpne</code>。其中指令助记符加上”if”后，以字符”i”开头的指令针对int型整数操作(也包括short和byte类型)， 以字符”a”开头的指令表示对象引用的比较。</p>
<p>具体说明：</p>
<p><img src="/2021/04/19/JVM/image-20210521234455626.png" alt="image-20210521234455626"></p>
<p>这些指令都接收两个字节的操作数作为参数，用于计算跳转的位置。同时在执行指令时，栈顶需要准备两个元素进行比较。<br>指令执行完成后，栈顶的这两个元素被清空，且没有任何数据入栈。<strong>如果预设条件成立，则执行跳转，否则，继续执行下一条语句</strong>。</p>
<p>注意：</p>
<ul>
<li>上面所说的后者是栈顶元素，而前者是栈顶下面的元素</li>
<li>对于float、double、long类型的比较，它们比较之后生成的是int类型的0、1、-1，这个过程可以使用比较指令和条件跳转指令来完成。</li>
<li>而int类型值（包含byte、char、short）比较和对象类型值比较需要使用比较条件跳转指令，</li>
<li>其中对象类型值不是<strong>比较的地址</strong>，就是<strong>比较对象中的某些字段值</strong>，这又归咎到float、double、long、int类型的比较中比较条件跳转指令。</li>
</ul>
<h5 id="3、多条件分支跳转"><a href="#3、多条件分支跳转" class="headerlink" title="3、多条件分支跳转"></a>3、多条件分支跳转</h5><p>多条件分支跳转指令是专为switch-case语句设计的，主要有<code>tableswitch</code>和<code>lookupswitch</code>。</p>
<p><img src="/2021/04/19/JVM/image-20210522000649232.png" alt="image-20210522000649232"></p>
<p>从助记符上看，两者都是switch语句的实现，它们的区别：</p>
<ul>
<li><code>tableswitch</code>要求<strong>多个条件分支值是连续的</strong>，它内部只存放起始值和终止值，以及若干个跳转偏移量，通过给定的操作数index，可以立即定位到跳转偏移量位置，因此<strong>效率比较高</strong>。</li>
<li><code>lookupswitch</code>内部<strong>存放着各个离散的case-offset对</strong>，每次执行都要搜索全部的case-offset对，找到匹配的case值，并根据对应的offset计算跳转地址，<strong>因此效率较低</strong>。</li>
</ul>
<p><strong>指令tableswitch：</strong></p>
<p>指令tableswitch的示意图如下图所示。由于tableswitch的case值是连续的，因此只需要记录最低值和最高值，以及每一项对应的offset偏移量，根据给定的index值通过简单的计算即可直接定位到offset。</p>
<p><img src="/2021/04/19/JVM/image-20210522001143999.png" alt="image-20210522001143999"></p>
<p>举例：</p>
<p><img src="/2021/04/19/JVM/image-20210522002407044.png" alt="image-20210522002407044"></p>
<p>注意：<strong>代码的break语句对应的就是字节码指令里的goto指令</strong>，无条件跳转到return处。如果代码没有加上break语句的话就会发生switch穿透，其实对应到字节码指令就是缺少goto指令跳转到return，只能往下顺序执行。</p>
<p><strong>指令lookupswitch：</strong></p>
<p>指令lookupswitch处理的是离散的case值，但是出于效率考虑，<strong>将case-offset对按照case值大小排序</strong>，给定index时需要查找与index相等的case，获得其offset，如果找不到则跳转到default。指令lookupswitch如下图所示。</p>
<p><img src="/2021/04/19/JVM/image-20210522001304745.png" alt="image-20210522001304745"></p>
<p>举例：</p>
<p><img src="/2021/04/19/JVM/image-20210522003748294.png" alt="image-20210522003748294"></p>
<p><strong>关于String的switch语句</strong>：（使用的是指令lookupswitch和方法hashcode与equal）</p>
<p><img src="/2021/04/19/JVM/image-20210522004730384.png" alt="image-20210522004730384"></p>
<h5 id="4、无条件跳转"><a href="#4、无条件跳转" class="headerlink" title="4、无条件跳转"></a>4、无条件跳转</h5><p>目前主要的无条件跳转指令为<code>goto</code>。</p>
<ul>
<li>指令goto接收两个字节的操作数，共同组成一个带符号的整数，用于<strong>指定指令的偏移量</strong>，指令执行的目的就是<strong>跳转到偏移量给定的位置处</strong>。</li>
<li>如果指令偏移量太大，超过双字节的带符号整数的范围，则可以使用指令<code>goto_W</code>，它和goto有相同的作用，但是它<strong>接收4个字节的操作数</strong>，可以表示更大的地址范围。</li>
<li>指令<code>jsr</code>、<code>jsr_W</code>、<code>ret</code>虽然也是无条件跳转的，但<strong>主要用于<code>try-finally</code>语句</strong>，且<strong>已经被虚拟机逐渐废弃</strong>，故不在这里介绍这两个指令。</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210522005055555.png" alt="image-20210522005055555"></p>
<p>举例：</p>
<p>通过<strong>goto指令与条件比较指令实现循环</strong>：</p>
<p><img src="/2021/04/19/JVM/image-20210522005743194.png" alt="image-20210522005743194"></p>
<p>注意：</p>
<ul>
<li>这里使用的i为int类型，在代码执行<code>i++</code>的时候，字节码指令使用的是<code>iinc 1 by 1</code>；直接在局部变量表里面加。</li>
<li>如果使用的i为double类型，在代码执行<code>i++</code>的时候，字节码使用的是 <code>dload_x</code> + <code>dconst_1</code> + <code>dadd</code> + <code>dastore_x</code> 的指令组合实现的，需要在操作数栈中相加。（注意这里dload_x与dastore_x当中的x是一样的）</li>
<li>如果使用的i为short类型，在代码执行<code>i++</code>的时候，字节码使用的是 <code>iload_x</code> + <code>iconst_1</code> + <code>iadd</code> + <code>i2s</code> + <code>istore_x</code> 的指令组合实现的，需要在操作数栈中相加，并且在相加之后还需要将值从int窄化为short类型，才能存进局部变量表当中。</li>
<li>所以<strong>用于循环遍历的变量尽量使用int，能增加系统的执行速度（调优）</strong></li>
</ul>
<h4 id="9、异常处理指令"><a href="#9、异常处理指令" class="headerlink" title="9、异常处理指令"></a>9、异常处理指令</h4><p>异常及异常的处理：<br>过程一：异常对象的生成过程 —&gt; throw (手动/自动) —&gt; 指令: athrow<br>过程二：异常的处理：抓抛模型。try-catch-finally —&gt;使用异常表</p>
<h5 id="1、抛出异常指令"><a href="#1、抛出异常指令" class="headerlink" title="1、抛出异常指令"></a>1、抛出异常指令</h5><ol>
<li><p><code>athrow</code>指令</p>
<ul>
<li>在Java程序中显示抛出异常的操作(throw语句)都是由athrow指令来实现。</li>
<li>除了使用throw语句显示抛出异常情况之外，<strong>JVM规范还规定了许多运行时异常会在其他Java虚拟机指令检测到异常状况时自动抛出</strong>。<ul>
<li>例如，在之前介绍的整数运算时，当除数为零时，虚拟机会在<code>idiv</code>或<code>ldiv</code>指令中抛出ArithmeticException异常。</li>
</ul>
</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>正常情况下，操作数栈的压入弹出都是一条条指令完成的。唯一的例外情况是<strong>在抛异常时，Java虚拟机会清除操作数栈上的所有内容，而后将异常实例压入调用者操作数栈上</strong>。</li>
<li>如果使用<code>throw new 异常名称()</code>这种形式来抛出异常，那就会在代码中出现<code>athrow</code>指令，</li>
<li>而<code>在方法上面添加throw异常名称</code>这种形式来抛出异常，然后使用jclasslib的时候就会出现在方法下面多出现一个属性Exceptions。</li>
</ul>
</li>
<li><p>举例：</p>
<ul>
<li><p>throw new 异常名称()：</p>
<p><img src="/2021/04/19/JVM/image-20210522014446997.png" alt="image-20210522014446997"></p>
</li>
<li><p>在方法上面添加throw异常名称：</p>
<p><img src="/2021/04/19/JVM/CB2FC208-C399-498F-A44E-60E015AAA9A8.png" alt="img"></p>
</li>
<li><p>运行时异常没有athrow：</p>
<p><img src="/2021/04/19/JVM/image-20210522014923019.png" alt="image-20210522014923019"></p>
</li>
</ul>
</li>
</ol>
<h5 id="2、异常处理与异常表"><a href="#2、异常处理与异常表" class="headerlink" title="2、异常处理与异常表"></a>2、异常处理与异常表</h5><ol>
<li>处理异常：<ul>
<li>在Java虚拟机中，<strong>处理异常(catch语句)**不是由字节码指令来实现的(早期使用jsr、ret指令)，而是</strong>采用异常表来完成的**。</li>
</ul>
</li>
<li>异常表：<ul>
<li>如果一个方法定义了一个<strong>try-catch</strong>或者<strong>try-finally</strong>的异常处理，就会创建一个异常表。它包含了<strong>每个异常处理或者finally块的信息</strong>。</li>
<li>异常表保存了每个异常处理信息。比如：<ul>
<li>起始位置</li>
<li>结束位置</li>
<li>程序计数器记录的代码处理的偏移地址</li>
<li>被捕获的异常类在常量池中的索引</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li><strong>当一个异常被抛出时，JVM会在当前的方法里寻找一个匹配的处理，如果没有找到，这个方法会强制结束并弹出当前栈帧</strong>，并且异常会重新抛给上层调用的方法(在调用方法栈帧)。如果在所有栈帧弹出前仍然没有找到合适的异常处理，这个线程将终止。</li>
<li><strong>如果这个异常在最后一个非守护线程里抛出，将会导致JVM自己终止，比如这个线程是个main线程</strong>。</li>
<li><strong>不管什么时候抛出异常，如果异常处理最终匹配了所有异常类型，代码就会继续执行</strong>。在这种情况下，如果方法结束后没有抛出异常，仍然执行finally块，在return前，它直接跳到finally块来完成目标。</li>
</ul>
<p>异常表如下所示：</p>
<p><img src="/2021/04/19/JVM/89118A6D-DA70-49FA-8E4C-703C21994488.png" alt="img"></p>
<p>异常表的含义是如果在Start PC和End PC之间（大于等于Start PC，小于End PC（左闭右开））出现对应的Catch Type异常问题（出现异常就匹配对应的异常），将会在操作数栈中压入相应的异常类对象，之后跳转到Handler PC的位置去执行对应的字节码指令。</p>
<p>注意：</p>
<p><strong>当异常出现的时候也会压入操作数栈，之后还会存储局部变量表中</strong></p>
<p>举例1：</p>
<p><img src="/2021/04/19/JVM/image-20210522020333543.png" alt="image-20210522020333543"></p>
<p>举例2：</p>
<p><img src="/2021/04/19/JVM/image-20210522021858220.png" alt="image-20210522021858220"></p>
<h4 id="10、同步控制指令"><a href="#10、同步控制指令" class="headerlink" title="10、同步控制指令"></a>10、同步控制指令</h4><p>组成：</p>
<ul>
<li>java虚拟机支持两种同步结构：<ul>
<li><strong>方法级的同步</strong></li>
<li><strong>方法内部一段指令序列的同步</strong></li>
</ul>
</li>
<li>这两种同步都是使用<code>monitor</code>来支持的。</li>
</ul>
<h5 id="1、方法级的同步-添加synchronized的方法"><a href="#1、方法级的同步-添加synchronized的方法" class="headerlink" title="1、方法级的同步(添加synchronized的方法)"></a>1、方法级的同步(添加synchronized的方法)</h5><p>方法级的同步：<strong>是隐式的</strong>，即无须通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否声明为同步方法；</p>
<p>当调用方法时，调用指令将会检查方法的ACC_SYNCHRONIZED访 问标志是否设置。</p>
<ul>
<li>如果设置了，执行线程将先持有同步锁，然后执行方法。<strong>最后</strong>在方法完成(无论是正常完成还是非正常完成)时<strong>释放同步锁</strong>。</li>
<li>在方法执行期间，执行线程持有了同步锁，其他任何线程都无法再获得同一个锁。</li>
<li>如果一个同步方法执行期间<strong>抛出了异常，并且在方法内部无法处理此异常</strong>，那这个同步方法所持有的<strong>锁将在异常抛到同步方法之外时自动释放</strong>。</li>
</ul>
<p>说明：</p>
<p>这段代码和普通的无同步操作的代码没有什么不同，没有使用monitorenter和monitorexit进行同步区控制。这是因为，对于同步方法而言，<strong>当虚拟机通过方法的访问标示符判断是一个同步方法时，会自动在方法调用前进行加锁</strong>，当同步方法执行完毕后，不管方法是正常结束还是有异常抛出，均会<strong>由虚拟机释放这个锁</strong>。因此，对于同步方法而言，<code>monitorenter</code>和<code>monitorexit</code>指令是<strong>隐式存在</strong>的，并未直接出现在字节码中。</p>
<p>举例：一个方法无论是否添加synchronized，你都无法在字节码中看出区别</p>
<p><img src="/2021/04/19/JVM/5CBBB95D-5AFB-4876-BF22-D846C36D942D.png" alt="img"></p>
<p>是否是同步方法在字节码文件中你是无法看出区别的，但是可以在<strong>方法访问标识</strong>中看出区别</p>
<h5 id="2、方法内部一段指令序列的同步"><a href="#2、方法内部一段指令序列的同步" class="headerlink" title="2、方法内部一段指令序列的同步"></a>2、方法内部一段指令序列的同步</h5><p>同步一段指令集序列：通常是由java中的synchronized语句块来表示的。jvm的指令集有<code>monitorenter</code>和<code>monitorexit</code>两条指令来支持synchronized关键字的语义。</p>
<ul>
<li>当一个线程进入同步代码块时，它使用<code>monitorenter</code>指令请求进入。如果当前对象的监视器计数器为0，则它会被准许进入</li>
<li>若为1，则判断持有当前监视器的线程是否为自己，如果是，则进入，否则进行等待，直到对象的监视器计数器为0,才会被允许进入同步块。</li>
<li>当线程退出同步块时，需要使用<code>monitorexit</code>声明退出。在Java虚拟机中，任何对象都有一个监视器与之相关联，用来判断对象是否被锁定，当监视器被持有后，对象处于锁定状态。</li>
<li>指令<code>monitorenter</code>和<code>monitorexit</code>在执行时，都需要<strong>在操作数栈项压入对象</strong>，之后<code>monitorenter</code>和<code>monitorexit</code>的锁定和释放都是针对这个对象的监视器进行的。</li>
</ul>
<p>下图展示了监视器如何保护临界区代码不同时被多个线程访问，只有当线程4离开临界区后，线程1、2、3才有可能进入。</p>
<p><img src="/2021/04/19/JVM/image-20210522024144096.png" alt="image-20210522024144096"></p>
<p>编译器必须确保无论方法通过何种方式完成，方法中调用过的每条monitorenter指令都必须执行其对应的monitorexit指令，而无论这个方法是正常结束还是异常结束。</p>
<p>为了保证在方法异常完成时monitorenter和monitorexit指令依然可以正确配对执行，<strong>编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常</strong>，它的目的就是用来<strong>执行monitorexit指令</strong>。</p>
<p>举例：</p>
<p><img src="/2021/04/19/JVM/EBE13A8E-3107-47D5-9296-C66C49553C0A.png" alt="img"></p>
<p>过程分析：</p>
<ol>
<li>操作数栈中的<strong>对象和<code>monitorenter</code>结合起来可以让线程获取锁</strong>，做法就是<strong>让对象的监视器标记从0变成1，这就代表该线程上锁了</strong>；</li>
<li>然后<strong>在操作数栈的<code>aload_1</code>和<code>monitorexit</code>结合起来就可以让线程解锁</strong>，做法就是<strong>让对象的监视器标记从1变成0</strong>；</li>
<li>这个<strong>解锁需要在方法退出之前完成</strong>，如果方法执行过程中出现了任何异常，将会跳到异常处理的字节码处执行相关代码；</li>
<li>如果异常处理的字节码部分出现了问题，那就<strong>重新执行异常处理的字节码</strong>。</li>
</ol>
<p>这些内容都在异常表中写的很明确，其中异常表也在上面截图中。</p>
<hr>
<h3 id="3、类的加载过程详解"><a href="#3、类的加载过程详解" class="headerlink" title="3、类的加载过程详解"></a>3、类的加载过程详解</h3><h4 id="1、概述-3"><a href="#1、概述-3" class="headerlink" title="1、概述"></a>1、概述</h4><p>类的加载过程详解：这里的类指的是Class。泛指java当中的<strong>类Class、接口Interface、注解类Annotation、枚举Enum</strong>等等。</p>
<p>在Java中数据类型分为基本数据类型和引用数据类型：</p>
<ul>
<li><strong>基本数据类型由虚拟机预先定义</strong></li>
<li><strong>引用数据类型则需要进行类的加载</strong></li>
</ul>
<p>按照Java虛拟机规范，从class文件到加载到内存中的类，到类卸载出内存为止，它的整个生命周期包括如下7个阶段：</p>
<p><img src="/2021/04/19/JVM/%E4%B8%AD%E7%AF%87_%E7%AC%AC3%E7%AB%A0%EF%BC%9A%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt="中篇_第3章：类的生命周期"></p>
<p>其中，<strong>验证、准备、解析3个部分统称为链接(Linking)</strong></p>
<p>注意：我们所说的<strong>加载完毕包括：加载、链接、初始化三个阶段都完成之后类进入方法区中</strong>。</p>
<p>从<strong>程序中类的使用过程</strong>看：</p>
<p><img src="/2021/04/19/JVM/%E4%B8%AD%E7%AF%87_%E7%AC%AC3%E7%AB%A0%EF%BC%9A%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.jpg" alt="中篇_第3章：类的加载过程"></p>
<h4 id="2、过程一：Loading（加载）阶段"><a href="#2、过程一：Loading（加载）阶段" class="headerlink" title="2、过程一：Loading（加载）阶段"></a>2、过程一：Loading（加载）阶段</h4><h5 id="1、加载完成的操作"><a href="#1、加载完成的操作" class="headerlink" title="1、加载完成的操作"></a>1、加载完成的操作</h5><h6 id="1、加载的理解"><a href="#1、加载的理解" class="headerlink" title="1、加载的理解"></a>1、加载的理解</h6><p><strong>所谓加载，简而言之就是将Java类的字节码文件加载到机器内存中，并在内存中构建出Java类的原型——类模板对象</strong>。 </p>
<p>所谓<strong>类模板对象</strong>，其实就是<strong>Java类在JVM内存中的一个快照</strong>，JVM将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中，这样JVM在运行期便能通过类模板而获取Java类中的任意信息，能够对Java类的成员变量进行遍历，也能进行Java方法的调用。</p>
<p><strong>反射的机制即基于这一基础</strong>。 如果JVM没有将Java类的声明信息存储起来，则JVM在运行期也无法反射。</p>
<h6 id="2、加载完成的操作"><a href="#2、加载完成的操作" class="headerlink" title="2、加载完成的操作"></a>2、加载完成的操作</h6><p><strong>加载阶段，简言之，查找并加载类的二进制数据，生成Class的实例</strong>。</p>
<p>在加载类时，Java虚拟机必须完成以下3件事情：</p>
<ul>
<li><strong>通过类的全名，获取类的二进制数据流</strong>。</li>
<li><strong>解析类的二进制数据流为方法区内的数据结构(Java类模型)</strong></li>
<li><strong>创建java.lang.Class类的实例，表示该类型。作为方法区这个类的各种数据的访问入口</strong>。</li>
</ul>
<h5 id="2、二进制流的获取方式"><a href="#2、二进制流的获取方式" class="headerlink" title="2、二进制流的获取方式"></a>2、二进制流的获取方式</h5><p>对于类的二进制数据流，虚拟机可以通过多种途径产生或获得：(只要所读取的字节码符合JVM规范即可)</p>
<ul>
<li>虚拟机可能通过<strong>文件系统读入一个class后缀的文件</strong>(<strong>最常见</strong>)</li>
<li><strong>读入jar、zip等归档数据包</strong>，提取类文件。</li>
<li>事先存放在<strong>数据库中的类</strong>的二进制数据</li>
<li>使用类似于HTTP之类的协议通过网络进行加载（序列化与反序列化）</li>
<li>在<strong>运行时生成</strong>段Class的二进制信息等</li>
</ul>
<p>在获取到类的二进制信息后，Java虛拟机就会处理这些数据，并最终转为一个<strong>java.lang.Class的实例</strong>。</p>
<p>如果输入数据不是ClassFile的结构， 则会抛出<code>ClassFormatError</code>。</p>
<h5 id="3、类模型与Class实例的位置"><a href="#3、类模型与Class实例的位置" class="headerlink" title="3、类模型与Class实例的位置"></a>3、类模型与Class实例的位置</h5><ol>
<li><p>类模型的位置：加载的类在JVM中创建相应的类结构，类结构会存储在<strong>方法区</strong>(JDK1.8之前：永久代；JDK1.8及之后：元空间)。</p>
</li>
<li><p>Class实例的位置：</p>
<ul>
<li>类将.class文件加载至元空间后，会在堆中创建一个Java.lang.Class对象，用来封装类位于方法区内的数据结构；</li>
<li>该Class对象是在加载类的过程中创建的，每个类都对应有一个Class类型的对象。(instanceKlass –&gt; mirror：Class的实例）</li>
</ul>
</li>
<li><p>图示：</p>
<p><img src="/2021/04/19/JVM/%E4%B8%AD%E7%AF%87_%E7%AC%AC3%E7%AB%A0%EF%BC%9AClass%E5%AE%9E%E4%BE%8B.jpg" alt="中篇_第3章：Class实例"></p>
</li>
<li><p>说明：</p>
<ul>
<li><strong>Class类的构造方法是私有的，只有JVM能够创建</strong>。</li>
<li>java.lang.Class实例是<strong>访问类型元数据的接口</strong>，也是<strong>实现反射的关键数据、入口</strong>。</li>
<li>通过Class类提供的接口，可以获得目标类所关联的.class文件中具体的数据结构：方法、字段等信息。</li>
</ul>
</li>
</ol>
<h5 id="4、数组类的加载"><a href="#4、数组类的加载" class="headerlink" title="4、数组类的加载"></a>4、数组类的加载</h5><ul>
<li>创建数组类的情况稍微有些特殊，因为<strong>数组类本身并不是由类加载器负责创建</strong>，而是由<strong>JVM在运行时根据需要而直接创建的</strong>；</li>
<li>但<strong>数组的元素类型仍然需要依靠类加载器去创建</strong>。</li>
<li>创建数组类(下述简称A)的过程：<ol>
<li>如果数组的元素类型是<strong>引用类型</strong>，那么就遵循<strong>定义的加载过程递归加载和创建数组A的元素类型</strong>；</li>
<li><strong>JVM使用指定的元素类型和数组维度来创建新的数组类</strong>。</li>
</ol>
</li>
<li>如果数组的元素类型是<strong>引用类型</strong>，数组类的可访问性就<strong>由元素类型的可访问性决定</strong>。否则数组类的可访问性将<strong>被缺省定义为public</strong>。</li>
</ul>
<h4 id="3、过程二：Linking（链接）阶段"><a href="#3、过程二：Linking（链接）阶段" class="headerlink" title="3、过程二：Linking（链接）阶段"></a>3、过程二：Linking（链接）阶段</h4><h5 id="1、环节1：链接阶段之Verification（验证）"><a href="#1、环节1：链接阶段之Verification（验证）" class="headerlink" title="1、环节1：链接阶段之Verification（验证）"></a>1、环节1：链接阶段之Verification（验证）</h5><p>当类加载到系统后，就开始链接操作，验证是链接操作的第一步。</p>
<p>它的目的是<strong>保证加载的字节码是合法、合理并符合规范的</strong>。</p>
<p>验证的步骤比较复杂，实际要验证的项目也很繁多，大体上Java虚拟机需要做以下检查，如图所示：</p>
<p><img src="/2021/04/19/JVM/%E4%B8%AD%E7%AF%87_%E7%AC%AC3%E7%AB%A0%EF%BC%9A%E9%AA%8C%E8%AF%81%E9%98%B6%E6%AE%B5%E7%9A%84%E6%A3%80%E6%9F%A5.jpg" alt="中篇_第3章：验证阶段的检查"></p>
<p><strong>整体说明</strong>：验证的内容则涵盖了<strong>类数据信息的格式验证</strong>、<strong>语义检查</strong>、<strong>字节码验证</strong>，以及<strong>符号引用验证</strong>等。</p>
<ul>
<li>其中<strong>格式验证会和加载阶段一起执行</strong>。验证通过之后，类加载器才会成功将类的二进制数据信息加载到方法区中。</li>
<li><strong>格式验证之外的验证操作将会在方法区中进行。</strong></li>
</ul>
<p><strong>链接阶段的验证虽然拖慢了加载速度，但是它避免了在字节码运行时还需要进行各种检查</strong>。(磨刀不误砍柴工)</p>
<p><strong>具体说明</strong>：</p>
<ol>
<li><p><strong>格式验证</strong>：</p>
<ul>
<li><strong>是否以魔数0xCAFEBABE开头</strong></li>
<li><strong>主版本和副版本号是否在当前Java虚拟机的支持范围内</strong></li>
<li>数<strong>据中每一个项是否都拥有正确的长度</strong>等。</li>
</ul>
</li>
<li><p>Java虚拟机会进行字节码的<strong>语义检查</strong>，但凡在语义上不符合规范的，虚拟机也不会给予验证通过。比如：</p>
<ul>
<li><strong>是否所有的类都有父类的存在</strong>(在Java里， 除了object外， 其他类都应该有父类)</li>
<li><strong>是否一些被定义为final的方法或者类被重写或继承</strong>了</li>
<li><strong>非抽象类是否实现了所有抽象方法或者接口方法</strong></li>
<li><strong>是否存在不兼容的方法</strong>。比如：<ul>
<li>方法的签名除了返回值不同，其他都一样，这种方法会让虚拟机无从下手调度</li>
<li>abstract情况下的方法，就不能是final的了</li>
</ul>
</li>
</ul>
</li>
<li><p>Java虚拟机还会进行<strong>字节码验证</strong>，字节码验证也是验证过程中<strong>最为复杂的一个过程</strong>。它试图通过对字节码流的分析，<strong>判断字节码是否可以被正确地执行</strong>。比如:</p>
<ul>
<li>在字节码的执行过程中，<strong>是否会跳转到一条不存在的指令</strong></li>
<li><strong>函数的调用是否传递了正确类型的参数</strong></li>
<li>变量的赋值是不是给了正确的数据类型等</li>
</ul>
<p><strong>栈映射帧(StackMapTable)**就是在这个阶段，用于</strong>检测在特定的字节码处，其局部变量表和操作数栈是否有着正确的数据类型<strong>。但遗憾的是，</strong>100%准确地判断一段字节码是否可以被安全执行是无法实现的<strong>，因此，该过程只是尽可能地检查出可以预知的明显的问题。如果在这个阶段无法通过检查，虛拟机也不会正确装载这个类。但是，</strong>如果通过了这个阶段的检查，也不能说明这个类是完全没有问题的<strong>。在前面3次检查中，已经排除</strong>子文件格式错误<strong>、</strong>语义错误<strong>以及</strong>字节码的不正确性<strong>。</strong>但是依然不能确保类是没有问题的**。</p>
<p><img src="/2021/04/19/JVM/image-20210522144342032.png" alt="image-20210522144342032"></p>
</li>
<li><p>校验器还将进行<strong>符号引用</strong>的验证。Class文件在其常量池会通过字符串记录自己将要使用的其他类或者方法。因此，在验证阶段，<strong>虚拟机就会检查这些类或者方法确实是存在的</strong>，并且<strong>当前类有权限访问这些数据</strong>，如果一个需要使用类无法在系统中找到，则会抛出<code>NoClassDefFoundError</code>,如果一个方法无法被找到，则会抛出<code>NoSuchMethodError</code>。<strong>此阶段在解析环节才会执行</strong>。</p>
</li>
</ol>
<h5 id="2、环节2：链接阶段之Preparation（准备）"><a href="#2、环节2：链接阶段之Preparation（准备）" class="headerlink" title="2、环节2：链接阶段之Preparation（准备）"></a>2、环节2：链接阶段之Preparation（准备）</h5><p>准备阶段(Preparation)，简言之，**为类的<code>静态变量</code>分配内存，并将其初始化为<code>默认值</code>**。</p>
<p>当一个类验证通过时，虚拟机就会进入准备阶段。在这个阶段，<strong>虚拟机就会为这个类分配相应的内存空间，并设置默认初始值</strong>。</p>
<p>Java虛拟机为各类型变量默认的初始值如表所示：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>默认初始值</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>(byte)0</td>
</tr>
<tr>
<td>short</td>
<td>(short)0</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>float</td>
<td>0.0f</td>
</tr>
<tr>
<td>double</td>
<td>0.0</td>
</tr>
<tr>
<td>char</td>
<td>\u0000</td>
</tr>
<tr>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>reference</td>
<td>null</td>
</tr>
</tbody></table>
<p>注意：Java并不支持boolean类型，对于boolean类型，内部实现是int，<strong>由于int的默认值是0，故对应的，boolean的默认值就是false</strong>。</p>
<p>注意：</p>
<ol>
<li>**这里不包含基本数据类型的字段用static final修饰（常量）的情况， 因为final在<code>编译</code>的时候就会分配了，<code>准备阶段会显式赋值</code>**。</li>
<li>注意这里<strong>不会为实例变量分配初始化</strong>，类变量会分配在方法区中，而<strong>实例变量是会随着对象一起分配到Java堆中</strong>，会在使用类时候才会初始化。</li>
<li>在<strong>准备阶段并不会像初始化阶段中那样会有初始化或者代码被执行</strong>。</li>
</ol>
<p>对注意中的第1点与第3点分析：</p>
<ul>
<li>基本数据类型：<ul>
<li><strong>非final修饰的<code>变量</code>，在准备环节进行<code>默认初始化赋值</code>。</strong></li>
<li>**final修饰以后就是<code>常量</code>了，不能在进行赋值，所以在<code>编译阶段</code>会<code>初始化赋值</code>，然后在<code>准备阶段</code>就会<code>显示赋值</code>**。</li>
</ul>
</li>
<li>如果<strong>使用字面量的方式定义一个字符串的常量</strong>的话(public static final String constStr = “CONST”;)，也是在<code>编译阶段</code>会<code>初始化赋值</code>，然后在<code>准备阶段</code>就会<code>显示赋值</code>。</li>
<li><strong>引用数据类型的静态常量，尤其是new String(“XXX”)这种形式</strong>，如：public static final String constStr1 = new String(“CONST”);<strong>都是在初始化中的中进行显示赋值的</strong>（即在方法<clinit>当中进行初始化的显示赋值，是在初始化阶段使用代码<clinit>的方式才会进行的显示赋值，然而在准备阶段不会有代码的执行）</clinit></clinit></li>
<li>如果<strong>在static静态代码块中具有显示赋值操作（定义的后面没有赋值），那肯定就是在<code>初始化中的方法&lt;clinit&gt;</code>中显示赋值</strong></li>
</ul>
<h5 id="3、环节3：链接阶段之Resolution（解析）"><a href="#3、环节3：链接阶段之Resolution（解析）" class="headerlink" title="3、环节3：链接阶段之Resolution（解析）"></a>3、环节3：链接阶段之Resolution（解析）</h5><p>在准备阶段完成后，就进入了解析阶段。</p>
<p>解析阶段(Resolution)，简言之：<strong>将类、接口、字段和方法的符号引用转为直接引用</strong>。</p>
<p><strong>具体描述</strong>：</p>
<p><strong>符号引用就是一些字面量的引用，和虚拟机的内部数据结构和和内存布局无关</strong>。比较容易理解的就是在Class类文件中，通过常量池进行了大量的符号引用。但是在程序实际运行时，只有符号引用是不够的，比如当如下println()方法被调用时，系统需要明确知道该方法的位置。</p>
<p>举例：输出操作System.out.println()对应的字节码：invokevirtual #24 &lt;java/io/PrintStream. println&gt;</p>
<p><img src="/2021/04/19/JVM/%E4%B8%AD%E7%AF%87_%E7%AC%AC3%E7%AB%A0%EF%BC%9A%E8%BE%93%E5%87%BA%E8%AF%AD%E5%8F%A5%E7%9A%84%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8.jpg" alt="中篇_第3章：输出语句的符号引用"></p>
<p>以方法为例，Java虚拟机为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。<strong>通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用。</strong></p>
<p><strong>小结</strong>：</p>
<p>所谓<strong>解析就是将符号引用转为直接引用，也就是得到类、字段、方法在内存中的指针或者偏移量</strong>。因此，可以说，如果<strong>直接引用存在，那么可以肯定系统中存在该类、方法或者字段</strong>。但<strong>只存在符号引用，不能确定系统中一定存在该结构</strong>。</p>
<p>不过Java虚拟机规范并<strong>没有明确要求解析阶段一定要按照顺序执行</strong>。在HotSpotVM中，<strong>加载、验证、准备和初始化会按照顺序有条不紊地执行，但链接阶段中的解析操作往往会伴随着JVM在执行完初始化之后再执行</strong>。</p>
<p><strong>字符串的复习</strong>：</p>
<p>最后，再来看一下CONSTANT_ String的解析。 由于字符串在程序开发中有着重要的作用，因此，读者有必要了解一下。</p>
<p>String在Java虚拟机中的处理。<strong>当在Java代码中直接使用字符串常量时，就会在类中出现CONSTANT_String</strong>，它表示字符串常量，并且会引用一个CONSTANT_UTF8的常量项。<strong>在Java虚拟机内部运行中的常量池中，会维护一张字符串拘留表(intern)，它会保存所有出现过的字符串常量，并且没有重复项</strong>。只要以CONSTANT_String形式出现的字符串也都会在这张表中。使用String.intern()方法可以得到一个字符串在拘留表中的引用，<strong>因为该表中没有重复项，所以任何字面相同的字符串的String.intern()方法返回总是相等的</strong>。</p>
<h4 id="4、过程三：Initialization（初始化）阶段"><a href="#4、过程三：Initialization（初始化）阶段" class="headerlink" title="4、过程三：Initialization（初始化）阶段"></a>4、过程三：Initialization（初始化）阶段</h4><p>初始化阶段，简言之：<strong>为类的<code>静态变量</code>赋于正确的初始值（显示赋值）</strong>。</p>
<p><strong>具体描述：</strong></p>
<p>类的初始化是类装载的最后一个阶段。如果前面的步骤都没有问题，那么表示类可以顺利装载到系统中。此时，类才会开始执行Java字节码。(即: <strong>到了初始化阶段，才真正开始执行类中定义的Java 程序代码</strong>。)</p>
<p>初始化阶段的重要工作是<strong>执行类的初始化方法：<clinit>()方法</clinit></strong>：</p>
<ul>
<li>该方法<strong>仅能由Java编译器生成并由JVM调用</strong>， 程序开发者无法自定义一个同名的方法，更无法直接在Java程序中调用该方法，虽然该方法也是由字节码指令所组成。</li>
<li>它是由**<code>类静态成员的赋值语句</code>以及<code>static语句块</code>合并产生的**。</li>
</ul>
<p><strong>说明</strong>：</p>
<ol>
<li><p>在加载一个类之前，虚拟机总是会试图加载该类的父类，因此父类的<clinit>总是在子类<clinit>之前被调用。也就是说，<strong>父类的static块优先级高于子类</strong>。口诀：<strong>由父及子，静态先行</strong></clinit></clinit></p>
</li>
<li><p>Java编译器并不会为所有的类都产生<clinit>()初始化方法。哪些类在编译为字节码后，字节码文件中将不会包含<clinit>()方法：</clinit></clinit></p>
<ul>
<li><p><strong>一个类中并没有声明任何的类变量，也没有静态代码块时</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//场景1：对应非静态的字段，不管是否进行了显式赋值，都不会生成&lt;clinit&gt;()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个类中<strong>声明类变量</strong>，但是没<strong>有明确使用类变量的初始化语句以及静态代码块来执行初始化操作</strong>时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//场景2：静态的字段，没有显式的赋值，不会生成&lt;clinit&gt;()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num1;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个类中<strong>包含static final修饰的基本数据类型的字段</strong>，这些类字段初始化语句采用编译时常量表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//场景3：比如对于声明为static final的基本数据类型的字段，不管是否进行了显式赋值，都不会生成&lt;clinit&gt;()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num2 = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h5 id="1、static与final的搭配问题（显示初始化问题）"><a href="#1、static与final的搭配问题（显示初始化问题）" class="headerlink" title="1、static与final的搭配问题（显示初始化问题）"></a>1、static与final的搭配问题（显示初始化问题）</h5><p>问题研究：使用<code>static + final</code>修饰的字段的显式赋值的操作，到底是在哪个阶段进行的赋值？</p>
<ul>
<li>情况1：在链接阶段的准备环节赋值</li>
<li>情况2：在初始化阶段<clinit>()中赋值</clinit></li>
</ul>
<p>实例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializationTest2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INT_CONSTANT = <span class="number">10</span>;<span class="comment">//在链接阶段的准备环节赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer INTEGER_CONSTANT1 = Integer.valueOf(<span class="number">100</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer INTEGER_CONSTANT2 = Integer.valueOf(<span class="number">1000</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String s0 = <span class="string">&quot;helloworld0&quot;</span>;<span class="comment">//在链接阶段的准备环节赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String s1 = <span class="keyword">new</span> String(<span class="string">&quot;helloworld1&quot;</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初步结论：</p>
<ul>
<li>在链接阶段的准备环节赋值的情况：<ul>
<li>对于基本数据类型的字段来说，如果使用static final修饰，则显式赋值(直接赋值常量，而非调用方法进行动态赋值）通常是在链接阶段的准备环节进行</li>
<li>对于String来说，如果使用字面量的方式赋值，使用static final修饰的话，则显式赋值通常是在链接阶段的准备环节进行</li>
</ul>
</li>
<li>在初始化阶段<clinit>()中赋值的情况：<ul>
<li>排除上述的在准备环节赋值的情况之外的情况。</li>
</ul>
</clinit></li>
</ul>
<p>实例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializationTest2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INT_CONSTANT = <span class="number">10</span>;<span class="comment">//在链接阶段的准备环节赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer INTEGER_CONSTANT1 = Integer.valueOf(<span class="number">100</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer INTEGER_CONSTANT2 = Integer.valueOf(<span class="number">1000</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String s0 = <span class="string">&quot;helloworld0&quot;</span>;<span class="comment">//在链接阶段的准备环节赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String s1 = <span class="keyword">new</span> String(<span class="string">&quot;helloworld1&quot;</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String s2 = <span class="string">&quot;helloworld2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM1 = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终结论：</p>
<ul>
<li>在链接阶段的准备环节赋值的情况：<ul>
<li>使用<code>static+final</code>修饰，并且<strong>进行显示赋值（定义的时候后面就已经附了确定的初始值）</strong>，还<strong>不涉及到<code>方法</code>或者<code>构造器调用</code>的基本数据类型或者<code>String类型字面量</code></strong>(“XXX”这种形式，而不是new String(“XXX”)这种形式)<strong>的字段</strong>，将在准备中的链接阶段进行显示赋值</li>
<li>对于<strong>准备阶段就完成赋值</strong>的，**其字段下面的有属性<code>ConstantValue</code>**，在初始化阶段<clinit>()中赋值的字段是没有属性ConstantValue的。</clinit></li>
</ul>
</li>
<li>在初始化阶段<clinit>()中赋值的情况：<ul>
<li>已经进行显示赋值的<strong>静态常量</strong>（<code>static+final</code>修饰）（<strong>包括引用类型，尤其是new String(“XXX”)这种类型的，还有调用其他方法获得的值，比如new Random().nextInt(10)等</strong>）或者<strong>静态变量</strong>（这是肯定在初始化方法中显示赋值）<strong>都将在初始化中的方法中进行显示赋值</strong></li>
</ul>
</clinit></li>
<li><strong>使用<code>static + final</code>修饰，且显示赋值中不涉及到<code>方法</code>或<code>构造器调用的基本数据类型</code>或<code>String类型的显式赋值</code>，是在链接阶段的准备环节进行。</strong></li>
</ul>
<p>补充：</p>
<ol>
<li>换个角度思考下，只有<strong>在常量池中已经确定的值，才会在链接中的准备阶段赋值</strong>，像对象在常量池存储的一般都是符号引用，而并非是对象，仅仅是描述对象一个字符串，真正的对象还需通过字节码进行new，这一new不就得用类构造方法，不就得需要在初始化阶段<clinit>()中赋值了吗</clinit></li>
<li>计算中1/0，即<code>public static final int INT_CONSTANT = 1/0</code>，也不能在链接阶段的准备环节赋值，因为它会要抛异常，<strong>需要使用到代码</strong></li>
<li>这里说的能够用常量池中数据表示是按照结果论，所以2/2这种的结果是一个int值可以表示</li>
<li>而new String(“”)是个特例，<strong>String的引用是可以在常量池中表示的，但是new String是在初始化阶段赋值</strong>的</li>
<li>也不能单纯看是不是字面量，如果是<code>static final Integer a = 1</code>,也是在初始化阶段<clinit>()中赋值，只能说<strong>能尽量能在准备阶段赋值的就在准备阶段，实在不行才在初始化阶段<clinit>()中赋值</clinit></strong></clinit></li>
<li>另外一个角度：在链接阶段的准备环节赋值是不能动用代码的，因为真正开始执行类中定义的Java 程序代码是在到了初始化阶段才开始的。因此：<strong>可以在不使用java代码就能进行显示赋值的就在链接阶段的准备环节进行赋值，而赋值需要java代码参与的就只能在初始化阶段<clinit>()中进行显示赋值</clinit></strong>。</li>
</ol>
<h5 id="2、-的线程安全性"><a href="#2、-的线程安全性" class="headerlink" title="2、()的线程安全性"></a>2、<client>()的线程安全性</client></h5><ul>
<li><p>对于<clinit>()方法的调用，也就是类的初始化，虚拟机会在内部确保其多线程环境中的安全性。</clinit></p>
</li>
<li><p>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步。如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。</clinit></clinit></clinit></p>
</li>
<li><p>正是因为<strong>函数<clinit>( )带锁线程安全的</clinit></strong>，因此，如果在一个类的<clinit>()方法中有耗时很长的操作，就可能造成多个线程阻塞，引发死锁。并且<strong>这种死锁是很难发现的，因为看起来它们并没有可用的锁信息</strong>。</clinit></p>
<ul>
<li><p>函数<clinit>( )带的锁是隐式的锁，并不是使用sychronized进行加锁的。</clinit></p>
<p><img src="/2021/04/19/JVM/image-20210522204628093.png" alt="image-20210522204628093"></p>
</li>
</ul>
</li>
<li><p>如果之前的线程成功加载了类，则等在队列中的线程就没有机会再执行<clinit>()方法了。那么，当<strong>需要使用这个类时虚拟机会直接返回给它已经准备好的信息</strong>。（<strong>一个类只需要加载一次</strong>）</clinit></p>
</li>
</ul>
<p>死锁的相关代码：（<strong>使用两个进程让A、B交叉加载</strong>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.atguigu.java1.StaticB&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;StaticA init OK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.atguigu.java1.StaticA&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;StaticB init OK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDeadLockMain</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> flag;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticDeadLockMain</span><span class="params">(<span class="keyword">char</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">        <span class="keyword">this</span>.setName(<span class="string">&quot;Thread&quot;</span> + flag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.atguigu.java1.Static&quot;</span> + flag);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot; over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        StaticDeadLockMain loadA = <span class="keyword">new</span> StaticDeadLockMain(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">        loadA.start();</span><br><span class="line">        StaticDeadLockMain loadB = <span class="keyword">new</span> StaticDeadLockMain(<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">        loadB.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此得出结论：</p>
<ul>
<li>编写代码的时候要尽量<strong>避免让类进行交叉加载或循环加载/依赖</strong>。</li>
</ul>
<h5 id="3、类的初始化情况：主动使用vs被动使用"><a href="#3、类的初始化情况：主动使用vs被动使用" class="headerlink" title="3、类的初始化情况：主动使用vs被动使用"></a>3、类的初始化情况：主动使用vs被动使用</h5><p>Java程序对类的使用分为两种：</p>
<ul>
<li>主动使用（调用了<clinit>()方法）</clinit></li>
<li>被动使用（没有调用了<clinit>()方法）</clinit></li>
</ul>
<p>注意：<strong>没有调用了<clinit>()方法只是没有进入初始化阶段，并不代表该类没有加载</clinit></strong></p>
<h6 id="1、主动使用"><a href="#1、主动使用" class="headerlink" title="1、主动使用"></a>1、主动使用</h6><p>Class只有在必须要首次使用的时候才会被装载，Java虚拟机不会无条件地装载Class类型。Java虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的“使用”，是指主动使用，主动使用只有下列几种情况：(即: 如果出现如下的情况，则会对类进行初始化操作。而初始化操作之前的加载、验证、准备已经完成。)</p>
<ol>
<li><p>当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化。</p>
<ul>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveUse1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用new关键字</span></span><br><span class="line">        Order order = <span class="keyword">new</span> Order();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//序列化的过程：</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;order.dat&quot;</span>));</span><br><span class="line"></span><br><span class="line">            oos.writeObject(<span class="keyword">new</span> Order());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (oos != <span class="keyword">null</span>)</span><br><span class="line">                    oos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反序列化的过程：（验证）</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;order.dat&quot;</span>));</span><br><span class="line"></span><br><span class="line">            Order order = (Order) ois.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ois != <span class="keyword">null</span>)</span><br><span class="line">                    ois.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Order类的初始化过程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>当调用类的静态方法时，即当使用了字节码<code>invokestatic</code>指令。</p>
<ul>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Order.method();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Order类的初始化过程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Order method()....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>当使用类、接口的静态字段时(final修饰特殊考虑)，比如，使用getstatic或者putstatic指令。( 对应访问变量武值变量操作)</p>
<ul>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveUse2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//        System.out.println(User.num); // User类的初始化过程 </span></span><br><span class="line"><span class="comment">//        System.out.println(User.num1); // 1</span></span><br><span class="line">        System.out.println(User.num2); <span class="comment">// User类的初始化过程 8</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//        System.out.println(CompareA.NUM1); // 1</span></span><br><span class="line">        System.out.println(CompareA.NUM2); <span class="comment">// CompareA的初始化 5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User类的初始化过程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;  <span class="comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num1 = <span class="number">1</span>; <span class="comment">// 在链接阶段的准备环节赋值,不需要调用&lt;clinit&gt;()</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num2 = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>); <span class="comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CompareA</span></span>&#123;</span><br><span class="line">    <span class="comment">// 通过一个静态内部方法展示有没有JVM调用&lt;clinit&gt;()方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thread t = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;CompareA的初始化&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM1 = <span class="number">1</span>; <span class="comment">// 在链接阶段的准备环节赋值,不需要调用&lt;clinit&gt;()</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM2 = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>); <span class="comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>当使用java.lang.reflect包中的方法反射类的方法时。比如：Class.forName(“com.atguigu.java.Test”);</p>
<ul>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;com.atguigu.java1.Order&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Order类的初始化过程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</p>
<ul>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Father类的初始化过程</span></span><br><span class="line">    <span class="comment">// Son类的初始化过程</span></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    System.out.println(Son.num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father类的初始化过程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> <span class="keyword">implements</span> <span class="title">CompareB</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son类的初始化过程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>其实在加载Father类之前，JVM还会加载Father的父类java.lang.Object。但是这里不好展示。可以通过JVM参数<code>-XX:+TraceClassLoading</code>可以追踪类的加载信息并打印出来。在当中可以看到JVM有先加载java.lang.Object。</p>
</li>
<li><p>关于采用Junit进行测试时JVM参数的设置：</p>
<p><img src="/2021/04/19/JVM/E899EC31-01FB-484E-9894-40E777C0B08A.png" alt="img"></p>
</li>
</ul>
</li>
<li><p>如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化。</p>
<ul>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Father类的初始化过程</span></span><br><span class="line">    <span class="comment">// CompareB的初始化</span></span><br><span class="line">    <span class="comment">// Son类的初始化过程</span></span><br><span class="line">    <span class="comment">// 1 </span></span><br><span class="line">    System.out.println(Son.num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father类的初始化过程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> <span class="keyword">implements</span> <span class="title">CompareB</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son类的初始化过程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CompareB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;CompareB的初始化&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你好！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果Son还被其他类继承的话，当Son的子类初始化的时候，对应的Son，CompareB，Father也会被初始化。</p>
</li>
</ul>
</li>
<li><p>当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的那个类)，虚拟机会先初始化这个主类。</p>
<ul>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveUse3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ActiveUse3的初始化过程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ActiveUse3的初始化过程</span></span><br><span class="line">        <span class="comment">// hello</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。( 涉及解析REF_getStatic、REF_putStatic、REF_invokeStatic方法句柄对应的类)</p>
</li>
</ol>
<p>针对5，补充说明：</p>
<p>当Java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口。</p>
<ul>
<li><p>在初始化一个类时，并<strong>不会先初始化它所实现的接口</strong></p>
<ul>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Father类的初始化过程</span></span><br><span class="line">    <span class="comment">// Son类的初始化过程</span></span><br><span class="line">    <span class="comment">// 1 </span></span><br><span class="line">    System.out.println(Son.num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father类的初始化过程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> <span class="keyword">implements</span> <span class="title">CompareB</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son类的初始化过程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CompareB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;CompareB的初始化&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>虽然接口CompareB没有初始化，但是它已经被加载进JVM当中了</strong>。</p>
</li>
</ul>
</li>
<li><p>在初始化一个接口时，并<strong>不会先初始化它的父接口</strong></p>
<ul>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// CompareC的初始化</span></span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    System.out.println(CompareC.NUM1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CompareB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;CompareB的初始化&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CompareC</span> <span class="keyword">extends</span> <span class="title">CompareB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;CompareC的初始化&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM1 = <span class="keyword">new</span> Random().nextInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p>因此，<strong>一个父接口并不会因为它的子接口或者实现类的初始化而初始化</strong>。只有当程序首次使用特定接口的静态字段时，才会导致该接口的初始化。</p>
<p>针对7，说明：</p>
<p>JVM启动的时候通过引导类加载器加载一个初始类。这个类在调用public static void main(String[])方法之前被链接和初始化。这个方法的执行将依次导致所需的类的加载，链接和初始化。</p>
<h6 id="2、被动使用"><a href="#2、被动使用" class="headerlink" title="2、被动使用"></a>2、被动使用</h6><p>除了以上的情况属于主动使用，其他的情况均属于被动使用。<strong>被动使用不会引起类的初始化</strong>。</p>
<p>也就是说：<strong>并不是在代码中出现的类，就一定会被加载或者初始化。如果不符合主动使用的条件，类就不会初始化</strong>。</p>
<ol>
<li><p>当访问一个静态字段时，只有真正声明这个字段的类才会被初始化。</p>
<ul>
<li><p>当通过子类引用父类的静态变量，不会导致子类初始化</p>
</li>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(Child.num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent的初始化过程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child的初始化过程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>通过数组定义类引用，不会触发此类的初始化</p>
<ul>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// [空]</span></span><br><span class="line">    Parent[] parents = <span class="keyword">new</span> Parent[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// class [Lcom.atguigu.java1.Parent;</span></span><br><span class="line">    System.out.println(parents.getClass());</span><br><span class="line">    <span class="comment">// class java.lang.Object</span></span><br><span class="line">    System.out.println(parents.getClass().getSuperclass());</span><br><span class="line">	<span class="comment">// Parent的初始化过程</span></span><br><span class="line">    parents[<span class="number">0</span>] = <span class="keyword">new</span> Parent();</span><br><span class="line">    parents[<span class="number">1</span>] = <span class="keyword">new</span> Parent();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent的初始化过程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>只是定义不赋值的话，不会触发类初始化。但是只要赋上一次值就会执行类的初始化，之后就不会执行类的初始化了。（<clinit>()这样一个类构造器方法只会初始化一次）</clinit></p>
</li>
</ul>
</li>
<li><p>引用常量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了。</p>
<ul>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// System.out.println(Person.NUM); // 1</span></span><br><span class="line">    <span class="comment">// SerialA的初始化</span></span><br><span class="line">    <span class="comment">// 3 </span></span><br><span class="line">    System.out.println(Person.NUM1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// System.out.println(SerialA.ID); // 1</span></span><br><span class="line">    <span class="comment">// Person类的初始化</span></span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    System.out.println(SerialA.ID1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person类的初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM = <span class="number">1</span>;<span class="comment">//在链接过程的准备环节就被赋值为1了。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM1 = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);<span class="comment">//此时的赋值操作需要在&lt;clinit&gt;()中执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SerialA</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;SerialA的初始化&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> ID = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ID1 = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);<span class="comment">//此时的赋值操作需要在&lt;clinit&gt;()中执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>调用ClassLoader类的loadClass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化。</p>
<ul>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class clazz = ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;com.atguigu.java1.Person&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person类的初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM = <span class="number">1</span>;<span class="comment">//在链接过程的准备环节就被赋值为1了。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM1 = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);<span class="comment">//此时的赋值操作需要在&lt;clinit&gt;()中执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h6 id="3、注意"><a href="#3、注意" class="headerlink" title="3、注意"></a>3、注意</h6><ul>
<li>ClassLoader.getSystemClassLoader().loadClass()方法与Class.forName()方法<ul>
<li>Class.forName()方法：类自动使用</li>
<li>ClassLoader.getSystemClassLoader().loadClass()方法：类被动使用</li>
</ul>
</li>
</ul>
<h4 id="5、过程四：类的Using（使用）"><a href="#5、过程四：类的Using（使用）" class="headerlink" title="5、过程四：类的Using（使用）"></a>5、过程四：类的Using（使用）</h4><p>任何一个类型在使用之前都必须经历过<strong>完整的加载、链接和初始化3个类加载步骤</strong>。一旦一个类型成功经历过这3个步骤之后，就应经加载成功了。便“万事俱备，只欠东风”，就等着开发者使用了。</p>
<p>开发人员可以在程序中访问和调用它的静态类成员信息(比如：静态字段、静态方法)，或者使用new关键字为其创建对象实例。</p>
<h4 id="6、过程五：类的Unloading（卸载）"><a href="#6、过程五：类的Unloading（卸载）" class="headerlink" title="6、过程五：类的Unloading（卸载）"></a>6、过程五：类的Unloading（卸载）</h4><h5 id="1、类、类的加载器、类的实例之间的引用关系"><a href="#1、类、类的加载器、类的实例之间的引用关系" class="headerlink" title="1、类、类的加载器、类的实例之间的引用关系"></a>1、类、类的加载器、类的实例之间的引用关系</h5><p>在类加载器的内部实现中，<strong>用一个Java集合来存放所加载类的引用</strong>。另一方面，一个Class对象总是会引用它的类加载器，调用Class对象的getClassLoader()方法， 就能获得它的类加载器。由此可见，<strong>代表某个类的Class实例与其类的加载器之间为双向关联关系</strong>。</p>
<p><strong>一个类的实例总是引用代表这个类的Class对象</strong>。在Object类中定义了getClass()方法， 这个方法返回代表对象所属类的Class对象的引用。</p>
<p>此外，<strong>所有的Java类都有一个静态属性class，它引用代表这个类的Class对象</strong>。</p>
<h5 id="2、类的生命周期"><a href="#2、类的生命周期" class="headerlink" title="2、类的生命周期"></a>2、类的生命周期</h5><p>当Sample类被加载、链接和初始化后，它的生命周期就开始了。当代表Sample类的Class对象不再被引用，即<strong>不可触及</strong>时，Class对象就会结束生命周期，Sample类在方法区内的数据也会被卸载，从而结束Sample类的生命周期。</p>
<p><strong>一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期</strong>。</p>
<h5 id="3、具体例子"><a href="#3、具体例子" class="headerlink" title="3、具体例子"></a>3、具体例子</h5><p><img src="/2021/04/19/JVM/image-20210523011825913.png" alt="image-20210523011825913"></p>
<p>loader1变量和obj变量间接引用代表Sample类的Class对象，而objClass变量则直接引用它。</p>
<ul>
<li>关于方法区的垃圾回收（回顾）：方法区的垃圾收集主要回收两部分内容：**<code>常量池中废弃的常量</code><strong>和</strong><code>不再使用的类型</code>**。(可对应上面的图)<ul>
<li>HotSpot虚拟机对常量池的回收策略是很明确的，<strong>只要常量池中的常量没有被任何地方引用，就可以被回收</strong>。</li>
<li>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于 “不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：<ul>
<li><strong>该类所有的实例都已经被回收</strong>。也就是Java堆中不存在该类及其任何派生子类的实例。</li>
<li><strong>加载该类的类加载器已经被回收</strong>。这个条件<strong>除非是经过精心设计的可替换类加载器的场景，如<code>OSGi</code>、<code>JSP</code>的重加载</strong>等，否则通常是很难达成的。</li>
<li><strong>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</strong>。</li>
</ul>
</li>
<li>Java虚拟机**被允许(不是必然)**对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。</li>
</ul>
</li>
</ul>
<p>如果程序运行过程中，将上图左侧三个引用变量都置为null，此时Sample对象结束生命周期，MyClassLoader对象结束生命周期，代表Sample类的Class对象也结束生命周期，Sample类在方法区内的二进制数据被卸载。</p>
<p>当再次有需要时，会检查Sample类的Class对象是否存在，<strong>如果存在会直接使用，不再重新加载</strong>；<strong>如果不存在Sample类会被重新加载，在Java 虚拟机的堆区会生成一个新的代表Sample类的Class实例</strong>(可以通过哈希码查看是否是同一个实例)。</p>
<h5 id="4、类的卸载"><a href="#4、类的卸载" class="headerlink" title="4、类的卸载"></a>4、类的卸载</h5><ol>
<li><strong><code>启动类加载器加载的类型</code>在整个运行期间是不可能被卸载的</strong>(jvm和jls规范)</li>
<li><strong>被系统类加载器和扩展类加载器加载的类型在运行期间不太可能被卸载</strong>，因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到，其达到unreachable的可能性极小。</li>
<li><strong>被开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到</strong>。可以预想，稍微复杂点的应用场景中(比如：很多时候用户在开发自定义类加载器实例的时候<strong>采用<code>缓存</code>的策略以提高系统性能</strong>)，被加载的类型在运行期间也是几乎不太可能被卸载的(至少卸载的时间是不确定的)。</li>
</ol>
<p>综合以上三点，<strong>一个已经加载的类型被卸载的几率很小至少被卸载的时间是不确定的</strong>。同时我们可以看的出来，<strong>开发者在开发代码时候，不应该对虚拟机的类型卸载做任何假设的前提下，来实现系统中的特定功能</strong>。</p>
<h4 id="7、相关大厂面试题"><a href="#7、相关大厂面试题" class="headerlink" title="7、相关大厂面试题"></a>7、相关大厂面试题</h4><ul>
<li>蚂蚁金服：<ul>
<li>描述一下JVM加载Class文件的原理机制?</li>
<li>一面：类加载过程</li>
</ul>
</li>
<li>百度：<ul>
<li>类加载的时机</li>
<li>java类加载过程?</li>
<li>简述java类加载机制?</li>
</ul>
</li>
<li>腾讯：<ul>
<li>JVM中类加载机制，类加载过程? </li>
</ul>
</li>
<li>滴滴：<ul>
<li>JVM类加载机制</li>
</ul>
</li>
<li>美团：<ul>
<li>Java类加载过程</li>
<li>描述一下jvm加载class文件的原理机制</li>
</ul>
</li>
<li>京东：<ul>
<li>什么是类的加载?</li>
<li>哪些情况会触发类的加载?</li>
<li>讲一下JVM加载一个类的过程</li>
<li>JVM的类加载机制是什么?</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4、再谈类的加载器"><a href="#4、再谈类的加载器" class="headerlink" title="4、再谈类的加载器"></a>4、再谈类的加载器</h3><h4 id="1、概述-4"><a href="#1、概述-4" class="headerlink" title="1、概述"></a>1、概述</h4><p><strong>类加载器是JVM执行类加载机制的前提</strong>。</p>
<p>ClassLoader的作用：</p>
<p><strong>ClassLoader是Java的核心组件，所有的Class都是由ClassLoader进行加载的</strong>，ClassLoader 负责通过各种方式将Class信息的二进制数据流读入JVM内部，转换<strong>为一个与目标类对应的java.lang.Class对象实例</strong>。然后交给Java虚拟机进行链接、初始化等操作。因此，<strong>ClassLoader在整个装载阶段，只能影响到类的加载</strong>，而无法通过ClassLoader去改变类的链接和初始化行为。<strong>至于它是否可以运行，则由<code>Execution Engine（执行引擎）</code>决定</strong>。</p>
<p><img src="/2021/04/19/JVM/%E4%B8%AD%E7%AF%87_%E7%AC%AC4%E7%AB%A0%EF%BC%9A%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8.jpg" alt="中篇_第4章：类的加载器"></p>
<p>类加载器最早出现在Java1.0版本中，那个时候只是单纯地为了满足Java Applet应用而被研发出来。但如今类加载器却在<strong>OSGi、字节码加解密领域</strong>大放异彩。这主要归功于Java虚拟机的设计者们当初在设计<strong>类加载器</strong>的时候，并<strong>没有</strong>考虑<strong>将它绑定在JVM内部</strong>，这样做的好处就是<strong>能够更加灵活和动态地执行类加载操作</strong>。</p>
<h5 id="1、类加载器的分类"><a href="#1、类加载器的分类" class="headerlink" title="1、类加载器的分类"></a>1、类加载器的分类</h5><p>类的加载分类：**<code>显式加载</code>** vs <strong><code>隐式加载</code></strong></p>
<p>class文件的显式加载与隐式加载的方式是指<strong>JVM加载class文件到内存的方式</strong>。</p>
<ul>
<li><strong>显式加载</strong>：指的是<strong>在代码中通过调用ClassLoader加载class对象</strong>，如直接使用Class.forName(name)或this.getClass().getClassLoader().loadClass(name)加载class对象。</li>
<li><strong>隐式加载</strong>：则是<strong>不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中</strong>，如在加载某个类的class文件时，该类的class 文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中（例如User user = new User()）。（常用）</li>
</ul>
<p>在<strong>日常开发以上两种方式一般会混合使用</strong>。</p>
<h5 id="2、类加载器的必要性"><a href="#2、类加载器的必要性" class="headerlink" title="2、类加载器的必要性"></a>2、类加载器的必要性</h5><p>一般情况下，Java开发人员并不需要在程序中显式地使用类加载器，但是了解类加载器的加载机制却显得至关重要。从以下几个方面说：</p>
<ul>
<li>避免在开发中遇到<code>java.lang.ClassNotFoundException</code>异常或<code>java.lang.NoClassDefFoundError</code>异常时手足无措。只有了解类加载器的加载机制才能够在出现异常的时候快速地根据错误异常日志定位问题和解决问题。</li>
<li>需要<strong>支持类的动态加载</strong>或<strong>需要对编译后的字节码文件进行加解密操作</strong>时，就需要与类加载器打交道了。</li>
<li>开发人员可以在程序中编写自定义类加载器来重新定义类的加载规则，以便实现一些自定义的处理逻辑。（自己定义的类加载器可以不遵从沙箱安全模型，因为沙箱安全模型有它的缺点）</li>
</ul>
<h5 id="3、命名空间"><a href="#3、命名空间" class="headerlink" title="3、命名空间"></a>3、命名空间</h5><ol>
<li>何为类的唯一性：<br>对于任意一个类，<strong>都需要由加载它的类加载器和这个类本身一同确认其在Java虚拟机中的唯一性</strong>。每一个类加载器，都拥有一个独立的类名称空间：<strong>比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义</strong>。否则，即使这两个类源自同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。</li>
<li>命名空间：<ul>
<li>每个类加载器都有自己的命名空间，<strong>命名空间由该加载器及所有的父加载器所加载的类组成</strong></li>
<li><strong>在同一命名空间中，不会出现类的完整名字(包括类的包名)相同的两个类</strong></li>
<li><strong>在不同的命名空间中，有可能会出现类的完整名字(包括类的包名)相同的两个类</strong></li>
</ul>
</li>
</ol>
<p>在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。</p>
<p>代码解释：</p>
<p><img src="/2021/04/19/JVM/A45F46DE-73EC-4B6B-BCD1-9BAB9DE15C51.png" alt="img"></p>
<p>结果：</p>
<p><img src="/2021/04/19/JVM/4D382A73-1DF4-4223-9CB9-C7B45D8071A9.png" alt="img"></p>
<p>解释：</p>
<p>rootDir后面的地址是我们使用javac User.class指令生成的class文件地址，然后loader1和loader2是两个用户自定义类加载器（如果自定义的不必理解），之后使用这两个用户自定义类加载器加载同一类型的User类，获得的Class对象不是同一个，可以通过Class对象调用getClassLoader()方法获取对应的类加载器了，最后通过系统类加载器获取的Class对象也是独特的，也可以通过该Class对象获取系统类加载器</p>
<h5 id="4、类加载机制的基本特征"><a href="#4、类加载机制的基本特征" class="headerlink" title="4、类加载机制的基本特征"></a>4、类加载机制的基本特征</h5><p>通常类加载机制有三个基本特征：</p>
<ul>
<li><strong>双亲委派模型</strong><ul>
<li>但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如JDK内部的ServiceProvider/ServiceLoader机制，用户可以在标准API框架上，提供自己的实现，JDK也需要提供些默认的参考实现。</li>
<li>例如，Java 中JNDI、JDBC、文件系统、Cipher 等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。</li>
<li>安全  避免重复加载 保护程序 防止核心api被串改</li>
</ul>
</li>
<li><strong>可见性</strong><ul>
<li><strong>子类加载器可以访问父加载器加载的类型，但是反过来是不允许的</strong>。不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。</li>
</ul>
</li>
<li><strong>单一性</strong><ul>
<li>由于父加载器的类型对于子加载器是可见的，所以<strong>父加载器中加载过的类型，就不会在子加载器中重复加载</strong>。但是注意，<strong>类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相并不可见</strong>。</li>
</ul>
</li>
</ul>
<h4 id="2、复习：类的加载器分类"><a href="#2、复习：类的加载器分类" class="headerlink" title="2、复习：类的加载器分类"></a>2、复习：类的加载器分类</h4><p>JVM支持两种类型的类加载器，分别为<strong>引导类加载器</strong>(Bootstrap ClassLoader) 和<strong>自定义类加载器</strong>（User-Defined ClassLoader) 。</p>
<p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是<strong>将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</strong>。无论类加载器的类型如何划分，在程序中我们最常见的类加载器结构主要是如下情况：</p>
<p><img src="/2021/04/19/JVM/image-20210523150158667.png" alt="image-20210523150158667"></p>
<ul>
<li>除了顶层的启动类加载器外，其余的类加载器都应当有自己的“父类”加载器。</li>
<li>不同类加载器看似是继承(Inheritance)关系，<strong>实际上是包含关系。在下层加载器中，包含着上层加载器的引用</strong>。</li>
</ul>
<p>父类加载器和子类加载器的关系：</p>
<p><img src="/2021/04/19/JVM/image-20210523150646271.png" alt="image-20210523150646271"></p>
<p>正是由于子类加载器中<strong>包含着父类加载器的引用</strong>，所以可以通过子类加载器的方法获取对应的父类加载器</p>
<p>注意：</p>
<p>启动类加载器通过C/C++语言编写，而自定义类加载器都是由Java语言编写的，虽然扩展类加载器和应用程序类加载器是被jdk开发人员使用java语言来编写的，但是也是由java语言编写的，所以也被称为自定义类加载器。</p>
<h5 id="1、启动类加载器-引导类加载器，Bootstrap-ClassLoader"><a href="#1、启动类加载器-引导类加载器，Bootstrap-ClassLoader" class="headerlink" title="1、启动类加载器(引导类加载器，Bootstrap ClassLoader)"></a>1、启动类加载器(引导类加载器，Bootstrap ClassLoader)</h5><ul>
<li>这个类加载<strong>使用C/C++语言实现</strong>的，<strong>嵌套在JVM内部</strong>。</li>
<li>它用来加载Java的核心库(JAVA_HOME/jre/lib/<code>rt.jar</code>或<code>sun.boot.class.path</code>路径下的内容)。用于提供JVM自身需要的类。</li>
<li>并不继承自java.lang.ClassLoader，<strong>没有父加载器</strong>。</li>
<li>出于安全考虑，Bootstrap启动类加载器<strong>只加载包名为<code>java</code>、<code>javax</code>、 <code>sun</code> 等开头的类</strong></li>
<li><strong>加载扩展类和应用程序类加载器</strong>，并<strong>指定为他们的父类加载器</strong>。（聚合）</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210523152412581.png" alt="image-20210523152412581"></p>
<p><img src="/2021/04/19/JVM/image-20210523152438385.png" alt="image-20210523152438385"></p>
<p>使用<code>-XX: +TraceClassloading</code>参数得到。</p>
<p>启动类加载器使用C++编写的? Yes!</p>
<ul>
<li>C/C++E 指针函数&amp;函数指针、C++支持多继承、更加高效</li>
<li>Java: 由C++演变而来， (C++)–版，单继承</li>
</ul>
<p>引导类加载器需要加载的jar包文件：</p>
<p>代码：</p>
<p><img src="/2021/04/19/JVM/C38CE122-2D25-4E14-B5BE-220FDBDEF84A.png" alt="img"></p>
<p>结果：</p>
<p><img src="/2021/04/19/JVM/C9DD335C-6A70-45A3-9091-431DA8C2FBCD.png" alt="img"></p>
<h5 id="2、扩展类加载器-Extension-ClassLoader"><a href="#2、扩展类加载器-Extension-ClassLoader" class="headerlink" title="2、扩展类加载器(Extension ClassLoader)"></a>2、扩展类加载器(Extension ClassLoader)</h5><ul>
<li>Java语言编写，由<code>sun.misc.Launcher$ExtClassLoader</code>实现。</li>
<li>继承于ClassLoader类</li>
<li>父类加载器为启动类加载器。(聚合)</li>
<li>从<code>java.ext.dirs</code>系统属性所指定的目录中加载类库，或从JDK的安装目录的<code>jre/lib/ext子目录</code>下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210523152834151.png" alt="image-20210523152834151"></p>
<p><img src="/2021/04/19/JVM/image-20210523155350716.png" alt="image-20210523155350716"></p>
<p>注意：扩展类加载器与系统类加载器是<strong>属于同一级的</strong>，都是继承与<code>URLClassLoader</code>，只是扩展类加载器当中有系统类加载器的引用，所以才称系统类加载器是扩展类加载器的”父类”加载器。（<strong>两者并不是继承关系，而是一种聚合关系</strong>）</p>
<p><strong>无法通过扩展类加载器获得引导类加载器</strong>，因为引导类加载器是用C/C++语言编写的，<strong>所以获取的值是null</strong></p>
<p>扩展类加载器：</p>
<p>代码：</p>
<p><img src="/2021/04/19/JVM/15C91D65-CF15-467B-877A-FBF37796246D.png" alt="img"></p>
<p>结果：</p>
<p><img src="/2021/04/19/JVM/DE7EBEFA-D191-4069-B6C9-B88FE6071584.png" alt="img"></p>
<h5 id="3、应用程序类加载器-系统类加载器，AppClassLoader"><a href="#3、应用程序类加载器-系统类加载器，AppClassLoader" class="headerlink" title="3、应用程序类加载器(系统类加载器，AppClassLoader)"></a>3、应用程序类加载器(系统类加载器，AppClassLoader)</h5><ul>
<li>java语言编写，由<code>sun.misc.Launcher$AppClassLoader</code>实现</li>
<li>继承于ClassLoader类</li>
<li>父类加载器为扩展类加载器。(聚合)</li>
<li>它负责加载<code>环境变量classpath</code>或系统属性<code>java.class.path指定路径</code>下的类库</li>
<li><strong>应用程序中的类加载器默认是系统类加载器</strong>。</li>
<li>它是<strong>用户自定义类加载器的默认父加载器</strong></li>
<li>通过<strong>ClassLoader的getSystemClassLoader( )方法</strong>可以获取到该类加载器</li>
</ul>
<p><img src="/2021/04/19/JVM/blog\XGH-blog\source_posts\JVM\image-20210523155305052.png" alt="image-20210523155305052"></p>
<h5 id="4、用户自定义类加载器"><a href="#4、用户自定义类加载器" class="headerlink" title="4、用户自定义类加载器"></a>4、用户自定义类加载器</h5><ul>
<li>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式。</li>
<li>体现Java语言强大生命力和巨大魅力的关键因素之一便是：<strong>Java开发者可以自定义类加载器来实现<code>类库的动态加载</code>，加载源可以是本地的JAR包，也可以是网络上的远程资源</strong>。</li>
<li><strong>通过类加载器可以实现非常绝妙的插件机制</strong>，这方面的实际应用案例举不胜举。例如，<strong>著名的OSGI组件框架</strong>，再如<strong>Eclipse的插件机制</strong>。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无须重新打包发布应用程序就能实现。</li>
<li>同时，<strong>自定义加载器能够实现应用隔离</strong>，例如Tomcat，Spring等中间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比C/C++程序要好太多，想不修改C/C++程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡住所有美好的设想。</li>
<li>自定义类加载器通常需要继承于ClassLoader.</li>
</ul>
<h4 id="3、测试不同的类的加载器"><a href="#3、测试不同的类的加载器" class="headerlink" title="3、测试不同的类的加载器"></a>3、测试不同的类的加载器</h4><p><strong>每个Class对象都会包含一个定义它的ClassLoader的一个引用</strong>。</p>
<p>获取ClassLoader的途径</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得当前类的ClassLoader</span></span><br><span class="line">clazz. getClassLoader();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得当前线程上下文的ClassLoader</span></span><br><span class="line">Thread.currentThread().getContextClassLoader();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得系统的ClassLoader</span></span><br><span class="line">ClassLoader.getSystemClassLoader();</span><br></pre></td></tr></table></figure>

<p>说明：<br>站在程序的角度看，引导类加载器与另外两种类加载器(系统类加载器和扩展类加载器)并不是同一个层次意义上的加载器，引导类加载器是使用C++语言编写而成的，而另外两种类加载器则是使用Java语言编写而成的。由于<strong>引导类加载器压根儿就不是一个Java类，因此在Java程序中只能打印出空值</strong>。</p>
<p><strong>数组类的Class对象</strong>，不是由类加载器去创建的，而<strong>是在Java运行期JVM根据需要自动创建</strong>的。对于数组类的类加载器来说，是<strong>通过Class.getClassLoader( )返回的，与数组当中元素类型的类加载器是一样</strong>的；如果<strong>数组当中的元素类型是基本数据类型，数组类是没有类加载器的</strong>。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关于数组类型的加载:使用的类的加载器与数组元素的类的加载器相同</span></span><br><span class="line">String[] arrStr = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">System.out.println(arrStr.getClass().getClassLoader());<span class="comment">//null:表示使用的是引导类加载器</span></span><br><span class="line"></span><br><span class="line">ClassLoaderTest1[] arr1 = <span class="keyword">new</span> ClassLoaderTest1[<span class="number">10</span>];</span><br><span class="line">System.out.println(arr1.getClass().getClassLoader());<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">System.out.println(arr2.getClass().getClassLoader());<span class="comment">//null:不需要类的加载器</span></span><br></pre></td></tr></table></figure>

<p>**获取当前线程上下文的ClassLoader的结果就是<code>系统类加载器</code>**，这个可以在Launcher.java中被代码证明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this.loader &#x3D; Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">Thread.currentThread().setContextClassLoader(this.loader);</span><br><span class="line">this.loader &#x3D; Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">Thread.currentThread().setContextClassLoader(this.loader);</span><br></pre></td></tr></table></figure>

<p>代码： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取系统该类加载器</span></span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">        <span class="comment">//获取扩展类加载器</span></span><br><span class="line">        ClassLoader extClassLoader = systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extClassLoader);<span class="comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span></span><br><span class="line">        <span class="comment">//试图获取引导类加载器：失败</span></span><br><span class="line">        ClassLoader bootstrapClassLoader = extClassLoader.getParent();</span><br><span class="line">        System.out.println(bootstrapClassLoader);<span class="comment">//null</span></span><br><span class="line">        <span class="comment">//###########################</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassLoader classLoader = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>).getClassLoader();</span><br><span class="line">            System.out.println(classLoader);</span><br><span class="line">            <span class="comment">//自定义的类默认使用系统类加载器</span></span><br><span class="line">            ClassLoader classLoader1 = Class.forName(<span class="string">&quot;com.atguigu.java.ClassLoaderTest1&quot;</span>).getClassLoader();</span><br><span class="line">            System.out.println(classLoader1);</span><br><span class="line">            <span class="comment">//关于数组类型的加载:使用的类的加载器与数组元素的类的加载器相同</span></span><br><span class="line">            String[] arrStr = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">            System.out.println(arrStr.getClass().getClassLoader());<span class="comment">//null:表示使用的是引导类加载器</span></span><br><span class="line"></span><br><span class="line">            ClassLoaderTest1[] arr1 = <span class="keyword">new</span> ClassLoaderTest1[<span class="number">10</span>];</span><br><span class="line">            System.out.println(arr1.getClass().getClassLoader());<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">			<span class="comment">// 关于数组当中的元素类型是基本数据类型</span></span><br><span class="line">            <span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">            System.out.println(arr2.getClass().getClassLoader());<span class="comment">//null:不需要类的加载器</span></span><br><span class="line">            </span><br><span class="line">            System.out.println(Thread.currentThread().getContextClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/2021/04/19/JVM/54EBA795-A6B6-42D4-AEA2-97DB51CBBC26.png" alt="img"></p>
<h4 id="4、ClassLoader源码解析"><a href="#4、ClassLoader源码解析" class="headerlink" title="4、ClassLoader源码解析"></a>4、ClassLoader源码解析</h4><p>ClassLoader与现有类加载器的关系：</p>
<p><img src="/2021/04/19/JVM/image-20210523193421376.png" alt="image-20210523193421376"></p>
<p>除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。Java提供了抽象类java.lang.ClassLoader, 所有用户自定义的类加载器都应该继承ClassLoader类。</p>
<h5 id="1、类加载器之间的关系"><a href="#1、类加载器之间的关系" class="headerlink" title="1、类加载器之间的关系"></a>1、类加载器之间的关系</h5><p>Launcher.class：</p>
<p><img src="/2021/04/19/JVM/20200924233838830.png" alt="img"></p>
<p>ExtClassLoader和AppClassLoader是Launcher类的两个内部类：</p>
<p><img src="/2021/04/19/JVM/2020092423393671.png" alt="img"></p>
<p><img src="/2021/04/19/JVM/20200924234038891.png" alt="img"></p>
<p>分析：</p>
<ol>
<li>验证扩展类加载器的父类是null<ul>
<li>先看：var1 = Launcher.ExtClassLoader.<code>getExtClassLoader</code>();</li>
<li>获取到扩展类加载器，点击该方法往里面追溯，在最后找到：return new Launcher.<code>ExtClassLoader</code>(var0);</li>
<li>我们在点击该方法往里面追溯，在找到：<code>super</code>(getExtURLs(var1), (ClassLoader)null, Launcher.factory);</li>
<li>然后点击super，往里面追溯，在找到：public URLClassLoader(URL[] urls, ClassLoader parent,URLStreamHandlerFactory factory){<code>super</code>(parent)}</li>
<li>点击其中的parent（也就是null值），我们点击super，往里面追溯，在找到：protected SecureClassLoader(ClassLoader parent) { <code>super</code>(parent);}</li>
<li>点击其中的parent就是null，我们点击super，往里面追溯，在找到：protected ClassLoader(ClassLoader parent) { <code>this</code>(checkCreateClassLoader(), parent);} </li>
<li>点击其中的parent就是null，我们点击this，往里面追溯，在找到：private ClassLoader(Void unused, ClassLoader parent) { this.<code>parent</code> = parent;}</li>
<li>点击其中的parent就是null，可以看到是：private final ClassLoader <code>parent</code>;<ul>
<li>就是ClassLoader.java定义的属性：父类加载器</li>
</ul>
</li>
<li>由于<strong>parent就是null</strong>，所以<strong>扩展类加载器的父类是null</strong>，也就是<strong>引导类加载器</strong>，因此我们调用获取扩展类加载器父类的方法获得的结果是null</li>
</ul>
</li>
<li>验证系统类加载器的父类是扩展类加载器<ul>
<li>先看：this.loader = Launcher.AppClassLoader.<code>getAppClassLoader</code>(var1);</li>
<li>获取到系统类加载器，点击该方法往里面追溯，在最后找到：return new Launcher.<code>AppClassLoader</code>(var1x, var0);</li>
<li>其中var0就是扩展类加载器，点击AppClassLoader，往里面追溯，在找到：AppClassLoader(URL[] var1, ClassLoader var2) { <code>super</code>(var1, var2, Launcher.factory); this.ucp.initLookupCache(this);} </li>
<li>其中var2就是扩展类加载器，我们点击super，往里面追溯，在找到：public URLClassLoader(URL[] urls, ClassLoader parent,URLStreamHandlerFactory factory) {<code>super</code>(parent);}</li>
<li>里面的parent就是扩展类加载器，我们点击super，往里面追溯，在找到：protected SecureClassLoader(ClassLoader parent) { <code>super</code>(parent);}</li>
<li>里面的parent就是扩展类加载器，我们点击super，往里面追溯，在找到：protected ClassLoader(ClassLoader parent) { <code>this</code>(checkCreateClassLoader(), parent);}</li>
<li>里面的parent就是扩展类加载器，我们点击this，往里面追溯，在找到：private ClassLoader(Void unused, ClassLoader parent) { this.<code>parent</code> = parent;}</li>
<li>点击其中的parent就是扩展类加载器，可以看到是：private final ClassLoader <code>parent</code>;<ul>
<li>就是ClassLoader.java定义的属性：父类加载器</li>
</ul>
</li>
<li>由于<strong>parent就是扩展类加载器</strong>，所以<strong>系统类加载器的父类是扩展类加载器</strong>，因此我们调用获取系统类加载器父类的方法获得的结果是扩展类加载器</li>
</ul>
</li>
<li>当前线程上下文的ClassLoader就是系统类加载器<ul>
<li>Thread.currentThread().setContextClassLoader(this.loader)：就是将系统类加载器设置为当前线程的上下文加载器，所以Thread.currentThread().getContextClassLoader()获取到的就是系统类加载器</li>
</ul>
</li>
</ol>
<p>注意：</p>
<ul>
<li>Launcher源码里定义了static的扩展类加载器ExtClassLoader， static的系统类加载器AppClassLoader。</li>
<li>它们都是<strong>默认包级别的</strong>，它们都是继承URLClassLoader，这就意味着我们的代码里，<strong>不能定义ExtClassLoader laoder =  …或AppClassLoader loader = …。</strong>我们只能ClassLoader loader =  …，而在实际运行时，我们应当能辨别这个loader到底是哪个具体类型。</li>
<li>在ExtClassLoader构造器里，并没有指定parent，或者说ExtClassLoader的parent为null。<strong>因为ExtClassLoader的parent是BootstrapLoader，而BootstrapLoader不存在于Java Api里，只存在于JVM里，我们是看不到的</strong>，所以请正确理解”ExtClassLoader的parent为null”的含义。</li>
<li>在AppClassLoader构造器里，有了parent。<strong>实例化AppClassLoader的时候，传入的parent就是一个ExtClassLoader实例</strong>。</li>
<li>看看Launcher的构造方法：<ul>
<li>**先实例化ExtClassLoader，从java.ext.dirs系统变量里获得URL[]**。</li>
<li>**用这个ExtClassLoader作为parent去实例化AppClassLoader，从java.class.path系统变量里获得URL[]**。Launcher getClassLoader()就是返回的这个AppClassLoader。</li>
<li><strong>设置AppClassLoader为ContextClassLoader</strong>。</li>
</ul>
</li>
</ul>
<h5 id="2、ClassLoader的主要方法"><a href="#2、ClassLoader的主要方法" class="headerlink" title="2、ClassLoader的主要方法"></a>2、ClassLoader的主要方法</h5><p>抽象类ClassLoader的主要方法：(内部没有抽象方法)</p>
<ul>
<li><p>public final ClassLoader getParent()：</p>
<ul>
<li>返回该类加载器的超类加载器</li>
</ul>
</li>
<li><p>public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException：</p>
<ul>
<li>加载名称为name的类，返回结果为java.lang.Class类的实例。如果找不到类，则返回ClassNotFoundException异常。<strong>该方法中的逻辑就是双亲委派模式的实现</strong>。</li>
</ul>
</li>
<li><p>protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException：</p>
<ul>
<li>查找二进制名称为name的类，返回结果为java.lang.Class类的实例。这是一个受保护的方法， JVM鼓励我们重写此方法，需要自定义加载器遵循双亲委托机制，该方法会在检查完父类加载器之后被loadClass()方法调用。<ul>
<li>在JDK1.2之前，在自定义类加载时，总会去继承ClassLoader类并重写loadClass方法，从而实现自定义的类加载类。</li>
<li>但是在JDK1. 2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在findClass()方法中，从前面的分析可知，<strong>findClass()方法是在loadClass()方法中被调用的，当loadClass()方法中父加载器加载失败后，则会调用自的findClass()方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委托模式</strong>。</li>
<li>需要注意的是ClassLoader类中并没有实现findClass()方法的具体代码逻辑，取而代之的是抛ClassNotFoundException异常，同时应该知道的是findClass 方法通常是和defineClass方法起使用的。<strong>一般情况下，在自定义类加载器时，会直接覆盖ClassLoader 的findClass()方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defineClass()方法生成类的Class对象</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p>protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len)：</p>
<ul>
<li><p>根据给定的字节数组b转换为Class的实例，off和len参数表示实际Class信息在byte数组中的位置和长度，其中byte数组b是ClassLoader从外部获取的。这是受保护的方法，只有在自定义ClassLoader子类中可以使用。</p>
<ul>
<li><p>defineClass()方法是用来将byte字节流解析成JVM能够识别的Class对象(ClassLoader中已实现该方法逻辑)，通过这个方法不仅能够通过class文件实例化class对象， 也可以通过其他方式实例化class对象， 如通过网络接收一个类的字节码，然后转换为byte 字节流创建对应的Class对象。</p>
</li>
<li><p><strong>defineClass()方法通常与findClass()方法起使用，一般情况下，在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法并编写加载规则， 取得要加载类的字节码后转换成流， 然后调用defineClass()方法生成类的Class对象。</strong></p>
</li>
<li><p>简单举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">//获取类的字节数组</span></span><br><span class="line">    <span class="keyword">byte</span>[] classData = getClassData(name);</span><br><span class="line">    <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//使用defineClass生成class对象</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData. length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>protected final void resolveClass(Class&lt;?&gt; c)：</p>
<ul>
<li><strong>链接指定的一个Java类</strong>。使用该方法可以<strong>使用类的Class对象创建完成的同时也被解析</strong>。前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用。</li>
</ul>
</li>
<li><p>protected final Class&lt;?&gt; findLoadedClass(String name)：</p>
<ul>
<li>查找名称为name的已经被加载过的类，返回结果为java.lang.Class类的实例。<strong>这个方法是final方法，无法被修改</strong>。</li>
</ul>
</li>
<li><p>private final ClassLoader parent;</p>
<ul>
<li>它也是一个ClassLoader的实例，这个字段所表示的ClassLoader也称为<strong>这个ClassLoader的双亲</strong>。<strong>在类加载的过程中, ClassLoader可能会将某些请求交予自己的双亲处理</strong>。</li>
</ul>
</li>
</ul>
<h6 id="关于loadClass-方法的剖析："><a href="#关于loadClass-方法的剖析：" class="headerlink" title="关于loadClass()方法的剖析："></a>关于loadClass()方法的剖析：</h6><p><strong>loadClass()方法是ClassLoader.java类中的主要方法</strong>。</p>
<p>测试代码：ClassLoader.getSystemClassLoader().loadClass(“com.atguig.java.User”); </p>
<p>涉及到对如下方法的调用：(模板方法模式的实现，抽象类提供基本的方法框架，子类需要重写具体的方法)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="comment">//resolve: true-加载class的同时进行解析操作。默认为false</span></span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123; <span class="comment">//同步操作，保证只能加载一次。</span></span><br><span class="line">        <span class="comment">// First, check if the class has already been Loaded</span></span><br><span class="line">        <span class="comment">//首先，在缓在中判断是否已经加载同名的类。</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == nu1l) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取当前类加载器的父类加载器</span></span><br><span class="line">                <span class="keyword">if</span> (parent != nu1l) &#123;</span><br><span class="line">                    <span class="comment">// 如果存在父类加载器，则调用父类加载器进行类的加载（递归）（双亲委派机制）</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// parent为null:父类加载器是引导类加载器</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent cLass Loader</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c == nu11) &#123; <span class="comment">// 当前类的加载器的父类加载器未加载此类or当前类的加载器未加载此类</span></span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="comment">// 调用当前ClassLoader的findCLass()</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                C =findClass(name);</span><br><span class="line">                <span class="comment">// this is the defining class Loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindCLassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;<span class="comment">//是否进行解析操作</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ol>
<li><p><code>findLoadedClass(name)</code>，查找类是否已经被加载过，如果加载过直接返回该Class类型的对象。如果没有被加载则继续第三的操作！</p>
</li>
<li><p><code>c = findBootstrapClassOrNull(name);</code>和<code>c = parent.loadClass(name, false);</code>如果父加载器不为空，那么调用父加载器的<code>loadClass</code>方法加载类，如果父加载器为空，那么调用虚拟机的加载器来加载类。(此过程当中是通过递归的方法改变c的类型为父类加载器的类型，体现了双亲委派机制)</p>
<p>如果以上两个步骤都没有成功的加载到类，进入第三；</p>
</li>
<li><p><code>c = findClass(name);</code>使用自定义的<code>findClass(name)</code>方法来加载类。（递归回最初的那一层）</p>
<p>这个时候，我们已经得到了加载之后的类，那么就根据<code>resolve</code>的值决定是否调用<code>resolveClass</code>方法。进入第五！</p>
</li>
<li><p><code>resolveClass(c);</code> <strong>链接指定的类。</strong>这个方法给<code>Classloader</code>用来链接一个类，如果这个类已经被链接过了，那么这个方法只做一个简单的返回。否则，这个类将被按照 <code>Java™</code>规范中的<code>Execution</code>描述进行链接……</p>
</li>
<li><p>其中使用到了设计模式的<strong>模板方法模式</strong></p>
<ul>
<li><strong>模板方法模式用于定义构建某个对象的步骤与顺序，或者定义一个算法的骨架</strong>。</li>
<li>模板方法模式的使用的方式，给子类足够的自由度，提供一些方法供子类覆盖，去实现一些骨架中不是必须但却可以有自定义实现的步骤。模板方法模式是一种基础继承的代码复用技术。如ClassLoader中的findClass方法！</li>
</ul>
</li>
<li><p>总结一下：在ClassLoader中定义的算法顺序是</p>
<ol>
<li>首先看<strong>是否有已经加载好的类</strong>。</li>
<li>如果<strong>父类加载器不为空</strong>，则首先<strong>从父类类加载器加载</strong>。</li>
<li>如果<strong>父类加载器为空</strong>，则尝试<strong>从启动加载器加载</strong>。</li>
<li>如果<strong>两者都失败</strong>，才尝试<strong>从findClass方法加载</strong>。</li>
</ol>
</li>
</ol>
<h5 id="3、SecureClassLoader与URLClassLoader"><a href="#3、SecureClassLoader与URLClassLoader" class="headerlink" title="3、SecureClassLoader与URLClassLoader"></a>3、SecureClassLoader与URLClassLoader</h5><ul>
<li>SecureClassLoader：<ul>
<li>接着SecureClassLoader扩展了ClassLoader, 新增了几个<strong>与使用相关的代码源</strong>(对代码源的位置及其证书的验证)和<strong>权限定义类验证</strong>(主要指对class源码的访问权限)的方法，一般我们不会直接跟这个类打交道，更多是与它的子类URLClassLoader有所关联。</li>
</ul>
</li>
<li>URLClassLoader：<ul>
<li>前面说过，ClassLoader是一个抽象类， 很多<strong>方法是空的没有实现</strong>，比如findClass()、findResource()等（模板方法模式）。而URLClassLoader这个实现类为这些方法提供了具体的实现。并新增了URLClassPath类协助取得Class字节码流等功能，<strong>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类， 这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁</strong>。</li>
</ul>
</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210523221840016.png" alt="image-20210523221840016"></p>
<h5 id="4、ExtClassLoader与AppClassLoader"><a href="#4、ExtClassLoader与AppClassLoader" class="headerlink" title="4、ExtClassLoader与AppClassLoader"></a>4、ExtClassLoader与AppClassLoader</h5><p>了解完URLClassLoader后接着看看剩余的两个类加载器，即<strong>拓展类加载器ExtClassLoader</strong>和<strong>系统类加载器AppClassLoader</strong>, 这两个类都<strong>继承自URLClassLoader, 是sun.misc.Launcher的静态内部类</strong>。</p>
<p>sun.misc.Launcher主要被系统用于启动主应用程序，ExtClassLoader 和AppClassLoader都是由sun.misc.Launcher创建的，其类主要类结构如下：</p>
<p><img src="/2021/04/19/JVM/0979521B-B4F6-4FA9-AE69-99F740449416.png" alt="img"></p>
<p>我们发现<strong>ExtClassLoader</strong>并没有重写loadClass()方法，这足矣说明其<strong>遵循双亲委派模式</strong>，而<strong>AppClassLoader重载了loadClass()方法，但最终调用的还是父类loadClass()方法，因此依然遵守双亲委派模式</strong>。</p>
<h5 id="5、Class-forName-与ClassLoader-loadClass"><a href="#5、Class-forName-与ClassLoader-loadClass" class="headerlink" title="5、Class.forName()与ClassLoader.loadClass()"></a>5、Class.forName()与ClassLoader.loadClass()</h5><ul>
<li><code>Class.forName()</code>：是一个<strong>静态方法</strong>，最常用的是Class.forName(String className)；根据传入的类的全限定名返回一个Class对象。<strong>该方法在将Class文件加载到内存的同时，会执行类的初始化</strong>。如：Class.forName(“com. atguigu. java.HelloWorld”);</li>
<li><code>ClassLoader.loadClass()</code>：这是一个<strong>实例方法</strong>，需要一个ClassLoader 对象来调用该方法。<strong>该方法将Class 文件加载到内存时，并不会执行类的初始化，直到这个类第一次使用时才进行初始化（loadClass()方法当中的resolve: true-加载class的同时进行解析操作。默认为false）</strong>。该方法因为需要得到一个ClassLoader 对象，所以可以根据需要指定使用哪个类加载器。如：ClassLoader c1=…….;c1. loadClass(“com. atguigu. java . HelloWorld”);</li>
</ul>
<h4 id="5、双亲委派模型"><a href="#5、双亲委派模型" class="headerlink" title="5、双亲委派模型"></a>5、双亲委派模型</h4><h5 id="1、定义与本质"><a href="#1、定义与本质" class="headerlink" title="1、定义与本质"></a>1、定义与本质</h5><p>类加载器用来把类加载到Java虚拟机中。从JDK1. 2版本开始，<strong>类的加载过程采用双亲委派机制，这种机制能更好地保证Java平台的安全</strong>。</p>
<ol>
<li><p>定义：</p>
<p><strong>如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回。只有父类加载器无法完成此加载任务时，才自己去加载</strong>。</p>
</li>
<li><p>本质：</p>
<p>规定了类加载的顺序是：<strong>引导类加载器先加载，若加载不到，由扩展类加载器加载，若还加载不到，才会由系统类加载器或自定义的类加载器进行加载</strong>。</p>
<p><img src="/2021/04/19/JVM/image-20210421103744316.png" alt="image-20210421103744316"></p>
</li>
</ol>
<p><img src="/2021/04/19/JVM/image-20210524135243252.png" alt="image-20210524135243252"></p>
<h5 id="2、优势与劣势"><a href="#2、优势与劣势" class="headerlink" title="2、优势与劣势"></a>2、优势与劣势</h5><h6 id="1、双亲委派机制优势"><a href="#1、双亲委派机制优势" class="headerlink" title="1、双亲委派机制优势"></a>1、双亲委派机制优势</h6><ul>
<li><strong>避免类的重复加载，确保一个类的全局唯一性</strong>；<ul>
<li><strong>Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载</strong>，当父亲已经加载了该类时，就没有必要于ClassLoader再加载一次。</li>
</ul>
</li>
<li><strong>保护程序安全，防止核心API被随意篡改</strong></li>
</ul>
<h6 id="2、代码支持"><a href="#2、代码支持" class="headerlink" title="2、代码支持"></a>2、代码支持</h6><p>双亲委派机制在java.lang.ClassLoader.loadClass(String, boolean)接口中体现。该接口的逻辑如下：</p>
<ol>
<li>先在<strong>当前加载器的缓存中查找</strong>有无目标类，如果有，直接返回。</li>
<li><strong>判断当前加载器的父加载器是否为空</strong>，如果不为空，则调用parent.loadClass(name, false)接口进行加载。</li>
<li>反之，<strong>如果当前加载器的父类加载器为空</strong>，则调用findBootstrapClassOrNull(name)接口， <strong>让引导类加载器进行加载</strong>。</li>
<li><strong>如果通过以上3条路径都没能成功加载，则调用findClass(name)接口进行加载</strong>。 该接口最终会调用java.lang.ClassLoader接口的defineClass系列的native接口加载目标Java类。</li>
</ol>
<p>双亲委派的模型就隐藏在这第2和第3步的递归调用当中</p>
<h6 id="3、举例："><a href="#3、举例：" class="headerlink" title="3、举例："></a>3、举例：</h6><p>假设当前加载的是java.lang.Object这个类，很显然，该类属于JDK中核心得不能再核心的一个类，因此一定只能由引导类加载器进行加载。当JVM准备加载java.lang.Object时，JVM默认会使用系统类加载器去加载，按照上面4步加载的逻辑，在第1步从系统类的缓存中肯定查找不到该类，于是进入第2步。由于从系统类加载器的父加载器是扩展类加载器，于是扩展类加载器继续从第1步开始重复。由于扩展类加载器的缓存中也一定查找不到该类，因此进入第2步。扩展类的父加载器是null，因此系统调用findClass(String)，最终通过引导类加载器进行加载。</p>
<h6 id="4、思考："><a href="#4、思考：" class="headerlink" title="4、思考："></a>4、思考：</h6><p>如果在自定义的类加载器中重写java.lang.ClassLoader.loadClass(String)或java.lang.ClassLoader.loadClass(String, boolean)方法， 抹去其中的双亲委派机制，仅保留上面这4步中的第1步与第4步，那么是不是就能够加载核心类库了呢?</p>
<p>这也不行！因为JDK还为核心类库提供了一层保护机制。不管是自定义的类加载器，还是系统类加载器抑或扩展类加载器，最终都必须调用java.lang.ClassLoader .<code>defineClass</code>(String, byte[], int, int, ProtectionDomain)方法，而该方法会执行<code>preDefineClass()</code>接口，<strong>该接口中提供了对JDK核心类库的保护</strong>。</p>
<h6 id="5、双亲委派模型的弊端："><a href="#5、双亲委派模型的弊端：" class="headerlink" title="5、双亲委派模型的弊端："></a>5、双亲委派模型的弊端：</h6><p><strong>检查类是否加载的委托过程是<code>单向的</code>**，这个方式虽然从结构上说比较清晰，使各个ClassLoader的职责非常明确，但是同时会带来一个问题，即</strong>顶层的ClassLoader无法访问底层的ClassLoader所加载的类**。</p>
<p>通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，<strong>应用类访问系统类自然是没有问题，但是系统类访问应用类就会出现问题</strong>。比如在系统类中提供了一个接口，该接口需要在应用类中得以实现，该接口还绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类加载器中。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题。</p>
<p>由双亲委派模型的优势可以看出：Java类随着它的类加载器一起具备了一种带有优先级的层次关系——双亲委派很好地解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载），基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的API。但世事往往没有绝对的完美，如果基础类又要调用回用户的代码，由于BootstrapClassloader是顶级类加载器，BootstrapClassloader无法委派AppClassLoader来加载类，也就是说BootstrapClassloader中加载的类中无法使用由AppClassLoader加载的类。</p>
<p>举例：（java.sql与驱动接口：com.mysql.jdbc.Driver）</p>
<p>接口：java.sql.Driver，定义在java.sql包中，包所在的位置是：jdk\jre\lib\rt.jar中，java.sql包中还提供了其它相应的类和接口比如管理驱动的类：DriverManager类，很明显java.sql包是由BootstrapClassloader加载器加载的；而接口的实现类com.mysql.jdbc.Driver是由第三方实现的类库，由AppClassLoader加载器进行加载的，我们的问题是DriverManager再获取链接的时候必然要加载到com.mysql.jdbc.Driver类，这就是由BootstrapClassloader加载的类使用了由AppClassLoader加载的类，很明显和双亲委托机制的原理相悖。</p>
<h6 id="6、结论："><a href="#6、结论：" class="headerlink" title="6、结论："></a>6、结论：</h6><p>由于<strong>Java虛拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型，只是建议采用这种方式而已</strong>。比如在<code>Tomcat</code>中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，<strong>当缺省的类加载器接收到一个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行</strong>，这同时<strong>也是Servlet规范推荐的一种做法</strong>。</p>
<h5 id="3、破坏双亲委派机制"><a href="#3、破坏双亲委派机制" class="headerlink" title="3、破坏双亲委派机制"></a>3、破坏双亲委派机制</h5><p>双亲委派模型并不是一个具有强制性约束的模型，而是Java设计者推荐给开发者们的类加载器实现方式。</p>
<p>在Java的世界中大部分的类加载器都遵循这个模型，但也有例外的情况，直到Java模块化出现为止，双亲委派模型主要出现过3次较大规模“被破坏”的情况。</p>
<h6 id="1、破坏双亲委派机制1——兼容JDK1-2之前的版本"><a href="#1、破坏双亲委派机制1——兼容JDK1-2之前的版本" class="headerlink" title="1、破坏双亲委派机制1——兼容JDK1.2之前的版本"></a>1、破坏双亲委派机制1——兼容JDK1.2之前的版本</h6><p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK 1.2面世以前的 “远古” 时代。</p>
<p>由于双亲委派模型在JDK 1.2之后才被引入，但是类加载器的概念和抽象类java.lang.ClassLoader则在Java的第一个版本中就已经存在，面对已经存在的用户自定义类加载器的代码，Java设计者们引入双亲委派模型时不得不做出一些妥协，<strong>为了兼容这些已有代码，无法再以技术手段避免loadClass()被子类覆盖的可能性</strong>，只能在JDK1.2之后的java.lang.ClassLoader中添加一个新的protected方法findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在loadClass()中编写代码。</p>
<p>上节我们已经分析过loadClass()方法，双亲委派的具体逻辑就实现在这里面，按照loadClass()方法的逻辑， 如果父类加载失败，会自动调用自己的findClass()方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。</p>
<p>以上简单来说就是jdk1.2之前还没引入双亲委派机制，所以jdk1.2之前就是破坏双亲委派机制的情况。</p>
<h6 id="2、破坏双亲委派机制2——线程上下文类加载器（解决双亲委派机制的弊端：上层类加载器加载的类不能使用由下层类加载器加载的类）"><a href="#2、破坏双亲委派机制2——线程上下文类加载器（解决双亲委派机制的弊端：上层类加载器加载的类不能使用由下层类加载器加载的类）" class="headerlink" title="2、破坏双亲委派机制2——线程上下文类加载器（解决双亲委派机制的弊端：上层类加载器加载的类不能使用由下层类加载器加载的类）"></a>2、破坏双亲委派机制2——线程上下文类加载器（解决双亲委派机制的弊端：上层类加载器加载的类不能使用由下层类加载器加载的类）</h6><p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题(<strong>越基础的类由越上层的加载器进行加载</strong>)，基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变的完美规则，<strong>如果有基础类型又要调用回用户的代码，那该怎么办呢</strong>?</p>
<p>这并非是不可能出现的事情，一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器来完成加载(在JDK 1.3时加入到rt.jar的)，肯定属于Java中很基础的类型了。但<strong>JNDI 存在的目的就是对资源进行查找和集中管理</strong>，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口(Service Provider Interface, SPI) 的代码，现在问题来了，<strong>启动类加载器是绝不可能认识、加载这些代码的，那该怎么办?</strong>(SPI：在Java平台中， 通常把核心类rt.jar中提供外部服务、可由应用层自行实现的接口称为SPI)</p>
<p>为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计：<strong>线程上下文类加载器(Thread Context ClassLoader)**。这个类加载器可以通过java.lang. Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器</strong>默认就是应用程序类加载器**。</p>
<p>有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，<strong>这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则</strong>，但也是无可奈何的事情。Java中涉及SPI的加载基本上都采用这种方式来完成，例如JNDI、JDBC、JCE、JAXB和JBl等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK 6时，JDK提供了java.util.ServiceLoader类，**以META-INF/services中的配置信息，辅以<code>责任链模式</code>**，这才算是给SPI的加载提供了一种相对合理的解决方案。</p>
<p><img src="/2021/04/19/JVM/image-20210524154710225.png" alt="image-20210524154710225"></p>
<p><strong>默认上下文加载器就是应用类加载器，这样以上下文加载器为中介，使得启动类加载器中的代码也可以访问应用类加载器中的类</strong>。</p>
<p>简单来说就是线程上下文类加载器让启动类加载器和系统类加载器直接联系起来了，中间的扩展类加载器被省略了，所以这破坏了双亲委派机制，其中线程上下文类加载器就是系统类加载器，这个证明在之前的ClassLoader &gt;&gt;&gt; 类加载器之间的关系中 有相关代码的解释。</p>
<h6 id="3、破坏双亲委派机制3——用户对程序动态性的追求：代码热替换-Hot-Swap-、模块热部署-Hot-Deployment-等"><a href="#3、破坏双亲委派机制3——用户对程序动态性的追求：代码热替换-Hot-Swap-、模块热部署-Hot-Deployment-等" class="headerlink" title="3、破坏双亲委派机制3——用户对程序动态性的追求：代码热替换(Hot Swap)、模块热部署(Hot Deployment) 等"></a>3、破坏双亲委派机制3——用户对程序动态性的追求：代码热替换(Hot Swap)、模块热部署(Hot Deployment) 等</h6><p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的。如：代码热替换(Hot Swap)、模块热部署(Hot Deployment) 等</p>
<p>IBM公司主导的JSR-291 (即OSGi R4.2)实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块(OSGi中称为Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起 换掉以实现代码的热替换。在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的<strong>网状结构</strong>。</p>
<p>当收到类加载请求时，OSGi将按照下面的顺序进行类搜索：</p>
<ol>
<li>将以<code>java.*</code>开头的类，<strong>委派给父类加载器加载</strong>。</li>
<li>否则，将<strong>委派列表名单内的类，委派给父类加载器加载</strong>。</li>
<li>否则，<strong>将Import列表中的类， 委派给Export这个类的Bundle的类加载器加载</strong>。</li>
<li>否则，查找<strong>当前Bundle的ClassPath, 使用自己的类加载器加载</strong>。</li>
<li>否则，查找<strong>类</strong>是否<strong>在自己的Fragment Bundle</strong>中， 如果在，则<strong>委派给Fragment Bundle的类加载器加载</strong>。</li>
<li>否则，查找<strong>Dynamic Import列表的Bundle， 委派给对应Bundle的类加载器加载</strong>。</li>
<li>否则，<strong>类查找失败</strong>。</li>
</ol>
<p>说明：<strong>只有开头两点仍然符合双亲委派模型的原则，其余的类查找都是在平级的类加载器中进行的</strong></p>
<p>小结：</p>
<p>这里，我们使用了“被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但<strong>这里“被破坏”并不一定是带有贬义的。只要有明确的目的和充分的理由，突破旧有原则无疑是一种创新</strong>。</p>
<p>正如：OSGi中的类加载器的设计不符合传统的双亲委派的类加载器架构，且业界对其为了实现热部署而带来的额外的高复杂度还存在不少争议，但对这方面有了解的技术人员基本还是能达成一个共识，认为<strong>OSGi中对类加载器的运用是值得学习的，完全弄懂了OSGi的实现，就算是掌握了类加载器的精粹</strong>。</p>
<h6 id="4、-补充-破坏双亲委派机制4——JDK9引入了Java模块化系统（具体在下文JDK9的新特性详细说明）"><a href="#4、-补充-破坏双亲委派机制4——JDK9引入了Java模块化系统（具体在下文JDK9的新特性详细说明）" class="headerlink" title="4、(补充)破坏双亲委派机制4——JDK9引入了Java模块化系统（具体在下文JDK9的新特性详细说明）"></a>4、(补充)破坏双亲委派机制4——JDK9引入了Java模块化系统（具体在下文JDK9的新特性详细说明）</h6><p><strong>JDK9引入了Java模块化系统(Java Platform Module System)来实现可配置的封装隔离机制</strong>，同时<strong>JVM对类加载的架构也做出了调整</strong>，也就是双亲委派模型的第四次破坏。</p>
<p>传统的双亲委派加机制：（图示）这里的敌人就是我们要加载的jar包</p>
<p><img src="/2021/04/19/JVM/d62a6059252dd42a4c0e5baa0c9d2bb3c8eab8dc.jpeg" alt="img"></p>
<p><strong>缺点</strong>：</p>
<p>通过上面的漫画不言而喻，当真正的敌人来了，靠这种<strong>低效</strong>的传达机制，怎么可能打一场胜仗呢？</p>
<ul>
<li>启动类加载器负责加载<JAVA_HOME>\jre\lib目录</JAVA_HOME></li>
<li>扩展类加载器负责加载<JAVA_HOME>\jre\lib\ext目录</JAVA_HOME></li>
<li>应用类加载器负责加载ClassPath目录。</li>
</ul>
<p>既然一切都是各司其职，为什么不能加载类的时候一步到位呢？</p>
<p>通过分析JDK9的类加载器源码，我发现最新的类加载器结构在一定程度上是缓解了这种情况的</p>
<p><strong>JDK的模块化</strong>：</p>
<p>在JDK9之前，<strong>JVM的基础类以前都是在rt.jar这个包里，这个包也是JRE运行的基石</strong>。这不仅是<strong>违反了单一职责原则</strong>，同样程序在编译的时候会将很多无用的类也一并打包，造成<strong>臃肿</strong>。</p>
<p>在JDK9中，整个JDK都基于模块化进行构建，<strong>以前的rt.jar, tool.jar被拆分成数十个模块，编译的时候只编译实际用到的模块</strong>，同时各个类加载器各司其职，只加载自己负责的模块。</p>
<p><img src="/2021/04/19/JVM/902397dda144ad34bc59b9aadd047cf230ad8561.jpeg" alt="img"></p>
<p><strong>模块化加载源码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; c = findLoadedClass(cn); </span><br><span class="line"><span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123; </span><br><span class="line">    <span class="comment">// 找到当前类属于哪个模块 </span></span><br><span class="line">    LoadedModule loadedModule = findLoadedModule(cn); </span><br><span class="line">    <span class="keyword">if</span> (loadedModule != <span class="keyword">null</span>) &#123; </span><br><span class="line">        <span class="comment">//获取当前模块的类加载器 </span></span><br><span class="line">        BuiltinClassLoader loader = loadedModule.loader(); </span><br><span class="line">        <span class="comment">//进行类加载 </span></span><br><span class="line">        c = findClassInModuleOrNull(loadedModule, cn); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 找不到模块信息才会进行双亲委派 </span></span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            c = parent.loadClassOrNull(cn); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面代码就是破坏双亲委派模型的“铁证”，而当我们继续跟进<code>findLoadedModule</code>，会发现是根据路径名找到对应的模块，而维护这一数据结构的就是下面这个Map：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, LoadedModule&gt; packageToModule = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure>

<p>可以看到LoadedModule里面不仅有该模块的loader信息，还有用于描述依赖模块，对外暴露模块的信息的mref，<strong>LoadedModule也是模块化实现封装隔离机制的一块重要实现</strong>。</p>
<p><img src="/2021/04/19/JVM/72f082025aafa40f5bae9f15a6c2734979f0193d.jpeg" alt="img"></p>
<p>每一个module信息都有一个<code>BuiltinClassloader</code>，这个类有三个子类，我们通过源码分析他们的父子关系：</p>
<p><img src="/2021/04/19/JVM/dbb44aed2e738bd4035b63a7ac2df7d0267ff95f.jpeg" alt="img"></p>
<p>在ClassLoaders类中可以发现，<strong>PlatformClassLoader的parent是BootClassLoader，而AppClassLoader的parent则是PlatformClassLoader</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaders</span> </span>&#123;</span><br><span class="line">    <span class="comment">// the built-in class loaders </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BootClassLoader BOOT_LOADER; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> PlatformClassLoader PLATFORM_LOADER; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AppClassLoader APP_LOADER; </span><br><span class="line">    <span class="keyword">static</span> &#123; </span><br><span class="line">        BOOT_LOADER = <span class="keyword">new</span> BootClassLoader((append != <span class="keyword">null</span> &amp;&amp; !append.isEmpty()) ? <span class="keyword">new</span> URLClassPath(append, <span class="keyword">true</span>) : <span class="keyword">null</span>); </span><br><span class="line">        PLATFORM_LOADER = <span class="keyword">new</span> PlatformClassLoader(BOOT_LOADER);</span><br><span class="line">        ...; </span><br><span class="line">        APP_LOADER = <span class="keyword">new</span> AppClassLoader(PLATFORM_LOADER, ucp); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结论</strong>：</p>
<ol>
<li>经过破坏后的双亲委派模型更加高效，<strong>减少了很多类加载器之间不必要的委派操作</strong></li>
<li>JDK9的模块化可以<strong>减少Java程序打包的体积，同时拥有更好的隔离线与封装性</strong></li>
<li>每个module拥有专属的类加载器，程序<strong>在并发性上也会更加出色</strong></li>
</ol>
<h5 id="4、热替换的实现"><a href="#4、热替换的实现" class="headerlink" title="4、热替换的实现"></a>4、热替换的实现</h5><p>热替换是指在程序的运行过程中，不停止服务，只通过替换程序文件来修改程序的行为。<strong>热替换的关键需求在于服务不能中断，修改必须立即表现正在运行的系统之中</strong>。基本上大部分脚本语言都是天生支持热替换的，比如：PHP， 只要替换了PHP源文件，这种改动就会立即生效，而无需重启Web服务器。</p>
<p>但对Java来说，热替换并非天生就支持，<strong>如果一个类已经加载到系统中，通过修改类文件，并无法让系统再来加载并重定义这个类</strong>。因此，在Java中实现这一功能的一个可行的方法就是灵活运用ClassLoader。</p>
<p>注意：由不同ClassLoader加载的同名类属于不同的类型，不能相互转换和兼容。即<strong>两个不同的ClassLoader加载同一个类</strong>，在虚拟机内部，会认为<strong>这两个类是完全不同的</strong>。根据这个特点，可以用来模拟热替换的实现，基本思路如下图所示：</p>
<p><img src="/2021/04/19/JVM/%E4%B8%AD%E7%AF%87_%E7%AC%AC4%E7%AB%A0%EF%BC%9A%E7%83%AD%E6%9B%BF%E6%8D%A2.jpg" alt="中篇_第4章：热替换"></p>
<p><strong>每次调用方法之前都要加载字节码文件，然后创建对象，我们可以把字节码文件变成最新的，那么创建的对象肯定是最新的，所以这就完成了热替换</strong></p>
<h4 id="6、沙箱安全机制"><a href="#6、沙箱安全机制" class="headerlink" title="6、沙箱安全机制"></a>6、沙箱安全机制</h4><p>沙箱安全机制：</p>
<ul>
<li><strong>保证程序安全</strong></li>
<li><strong>保护Java原生的JDK代码</strong></li>
</ul>
<p>**Java安全模型的核心就是Java沙箱(sandbox)**。什么是沙箱?</p>
<ul>
<li><strong>沙箱是一个限制程序运行的环境</strong>。</li>
</ul>
<p>沙箱机制就是将Java代码<strong>限定在虚拟机(JVM)特定的运行范围中，并且严格限制代码对本地系统资源访问</strong>。通过这样的措施来保证对代码的有限隔离，防止对本地系统造成破坏。</p>
<p><strong>沙箱主要限制系统资源访问</strong>，那系统资源包括什么? </p>
<ul>
<li>CPU</li>
<li>内存</li>
<li>文件系统</li>
<li>网络</li>
</ul>
<p>不同级别的沙箱对这些资源访问的限制也可以不一样。</p>
<p>所有的Java程序运行都可以指定沙箱，可以定制安全策略。</p>
<h5 id="1、JDK1-0时期"><a href="#1、JDK1-0时期" class="headerlink" title="1、JDK1.0时期"></a>1、JDK1.0时期</h5><p>在Java中将执行程序分成<strong>本地代码</strong>和<strong>远程代码</strong>两种：</p>
<ul>
<li><strong>本地代码默认视为可信任的，对于授信的本地代码，可以访问一切本地资源。</strong></li>
<li><strong>远程代码则被看作是不受信的。 而对于非授信的远程代码在早期的Java实现中， 安全依赖于沙箱(Sandbox)机制。</strong></li>
</ul>
<p>如下图所示JDK1 .0安全模型：</p>
<p><img src="/2021/04/19/JVM/image-20210524160050558.png" alt="image-20210524160050558"></p>
<h5 id="2、JDK1-1时期"><a href="#2、JDK1-1时期" class="headerlink" title="2、JDK1.1时期"></a>2、JDK1.1时期</h5><p>JDK1.0中如此严格的安全机制也给程序的功能扩展带来障碍，比如<strong>当用户希望远程代码访问本地系统的文件时候，就无法实现</strong>。因此在后续的Java1.1版本中，针对安全机制做了改进，<strong>增加了安全策略</strong>。<strong>允许用户指定代码对本地资源的访问权限</strong>。</p>
<p>如下图所示JDK1.1安全模型：</p>
<p><img src="/2021/04/19/JVM/image-20210524160203739.png" alt="image-20210524160203739"></p>
<h5 id="3、JDK1-2时期"><a href="#3、JDK1-2时期" class="headerlink" title="3、JDK1.2时期"></a>3、JDK1.2时期</h5><p>在Java1.2版本中，再次改进了安全机制，<strong>增加了代码签名</strong>。不论本地代码或是远程代码，都会按照<strong>用户的安全策略设定</strong>，<strong>由类加载器加载到虛拟机中权限不同的运行空间，来实现差异化的代码执行权限控制</strong>。</p>
<p>如下图所示JDK1.2安全模型：</p>
<p><img src="/2021/04/19/JVM/image-20210524160319450.png" alt="image-20210524160319450"></p>
<h5 id="4、JDK1-6时期"><a href="#4、JDK1-6时期" class="headerlink" title="4、JDK1.6时期"></a>4、JDK1.6时期</h5><p>当前最新的安全机制实现，则引入了**<code>域(Domain)</code>**的概念。</p>
<p><strong>虚拟机会把所有代码加载到不同的系统域和应用域</strong>：</p>
<ul>
<li>**<code>系统域部分专门负责与关键资源进行交互</code>**；</li>
<li><strong>各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问</strong>。</li>
<li><strong>虚拟机中不同的受保护域(ProtectedDomain)，对应不一样的权限(Permission)**。</strong>存在于不同域中的类文件就具有了当前域的全部权限**。</li>
</ul>
<p>如下图所示，最新的安全模型(jdk1.6)：</p>
<p><img src="/2021/04/19/JVM/image-20210524160541465.png" alt="image-20210524160541465"></p>
<h4 id="7、自定义类的加载器"><a href="#7、自定义类的加载器" class="headerlink" title="7、自定义类的加载器"></a>7、自定义类的加载器</h4><h5 id="1、为什么要自定义类加载器"><a href="#1、为什么要自定义类加载器" class="headerlink" title="1、为什么要自定义类加载器?"></a>1、为什么要自定义类加载器?</h5><ul>
<li><strong>隔离加载类</strong><ul>
<li><strong>在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境</strong>。</li>
<li>比如：阿里内某容器框架通过自定义类加载器确保<strong>应用中依赖的jar包不会影响到中间件运行时使用的jar包</strong>。</li>
<li>再比如：<strong>Tomcat</strong>这类Web应用服务器，内部自定义了好几种类加载器，<strong>用于隔离同一个Web应用服务器上的不同应用程序</strong>。</li>
</ul>
</li>
<li><strong>修改类加载的方式</strong><ul>
<li>类的加载模型并非强制，除Bootstrap外， 其他的加载并非一定要引入，或者<strong>根据实际情况在某个时间点进行按需进行动态加载</strong></li>
</ul>
</li>
<li><strong>扩展加载源</strong><ul>
<li>比如<strong>从数据库、网络、甚至是电视机机顶盒进行加载</strong></li>
</ul>
</li>
<li><strong>防止源码泄漏</strong><ul>
<li>Java代码容易被编译和篡改，可以进行编译加密。那么类加载也需要自定义，<strong>还原加密的字节码</strong>。</li>
</ul>
</li>
</ul>
<h5 id="2、常见的场景："><a href="#2、常见的场景：" class="headerlink" title="2、常见的场景："></a>2、常见的场景：</h5><ul>
<li>实现类似<strong>进程内隔离</strong>，<strong>类加载器实际上用作不同的命名空间，以提供类似容器、模块化的效果</strong>。例如，两个模块依赖于某个类库的不同版本，如果分别被不同的容器加载，就可以互不干扰。这个方面的集大成者是<code>Java EE</code>和<code>OSGI</code>、<code>JPMS</code>等框架。</li>
<li><strong>应用需要从不同的数据源获取类定义信息</strong>，例如<strong>网络数据源</strong>，而不是本地文件系统。或者是需要<strong>自己操纵字节码，动态修改或者生成类型</strong>。</li>
</ul>
<h5 id="3、注意-1"><a href="#3、注意-1" class="headerlink" title="3、注意"></a>3、注意</h5><p>在一般情况下，<strong>使用不同的类加载器去加载不同的功能模块，会提高应用程序的安全性</strong>。但是，如果涉及<strong>Java类型转换</strong>则加载器反而容易产生不美好的事情。<strong>在做Java类型转换时，只有两个类型都是由同一个加载器所加载，才能进行类型转换，否则转换时会发生异常</strong>。(两个不同的类加载器加载同一个class文件，得到的两个类，虽然表面上看上去是一样的，但是却是不一样的两个类。当在进行类型转换的时候会抛异常)。</p>
<h5 id="4、自定义类加载器的实现方式"><a href="#4、自定义类加载器的实现方式" class="headerlink" title="4、自定义类加载器的实现方式"></a>4、自定义类加载器的实现方式</h5><p>用户通过定制自己的类加载器，这样可以重新定义类的加载规则，以便实现一些自定义的处理逻辑。</p>
<h6 id="1、实现方式："><a href="#1、实现方式：" class="headerlink" title="1、实现方式："></a>1、实现方式：</h6><ul>
<li>Java提供了抽象类java.lang.ClassLoader，<strong>所有用户自定义的类加载器都应该继承ClassLoader类</strong>。</li>
<li>在自定义ClassLoader的子类时候，我们常见的会有两种做法：<ol>
<li>方式一：<strong>重写loadClass()方法</strong>（JDK1.2以前）</li>
<li>方式二：<strong>重写findClass()方法</strong> –&gt;推荐（JDK1.2以后）</li>
</ol>
</li>
</ul>
<h6 id="2、对比"><a href="#2、对比" class="headerlink" title="2、对比"></a>2、对比</h6><p>这两种方法本质上差不多，毕竟loadClass()也会调用findClass()， 但是从逻辑上讲我们最好不要直接修改loadClass()的内部逻辑。建议的做法是只在findClass()里重写自定义类的加载方法，根据参数指定类的名字，返回对应的Class对象的引用。</p>
<ul>
<li><strong>loadClass()这个方法是实现双亲委派模型逻辑的地方</strong>，擅自修改这个方法会导致模型被破坏，容易造成问题。<strong>因此我们最好是在双亲委派模型框架内进行小范围的改动，不破坏原有的稳定结构</strong>。同时，也避免了自己重写loadClass()方法的过程中必须写双亲委托的重复代码，从代码的复用性来看，不直接修改这个方法始终是比较好的选择。</li>
<li>当编写好自定义类加载器后，便可以<strong>在程序中调用loadClass()方法来实现类加载操作</strong>。</li>
</ul>
<h6 id="3、说明"><a href="#3、说明" class="headerlink" title="3、说明"></a>3、说明</h6><ul>
<li><strong>其父类加载器是系统类加载器</strong></li>
<li><strong>JVM中的所有类加载都会使用java.lang.ClassLoader.loadClass(String)接口</strong>(自定义类加载器并重写java.lang.ClassLoader.loadClass(String)接口的除外)，连JDK的核心类库也不能例外。</li>
<li>如果你不想重写findClass()当中流相关的代码，同时也没什么需要改动的地方。可以尝试不去继承ClassLoader抽象类，而去继承抽象类ClassLoader的子类URLClassLoader，里面帮我们重写了findClass()方法。</li>
</ul>
<h6 id="4、实现代码"><a href="#4、实现代码" class="headerlink" title="4、实现代码"></a>4、实现代码</h6><p>自定义类加载器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class文件存放的目录</span></span><br><span class="line">    <span class="keyword">private</span> String byteCodePath;</span><br><span class="line">	<span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String byteCodePath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.byteCodePath = byteCodePath;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(ClassLoader parent, String byteCodePath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.byteCodePath = byteCodePath;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自定义类加载器的重点：重写findClass()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        BufferedInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取字节码文件的完整路径</span></span><br><span class="line">            String fileName = byteCodePath + className + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">            <span class="comment">//获取一个输入流</span></span><br><span class="line">            bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(fileName));</span><br><span class="line">            <span class="comment">//获取一个输出流</span></span><br><span class="line">            baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="comment">//具体读入数据并写出的过程</span></span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = bis.read(data)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(data, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取内存中的完整的字节数组的数据</span></span><br><span class="line">            <span class="keyword">byte</span>[] byteCodes = baos.toByteArray();</span><br><span class="line">            <span class="comment">//调用defineClass()，将字节数组的数据转换为Class的实例。</span></span><br><span class="line">            Class clazz = defineClass(<span class="keyword">null</span>, byteCodes, <span class="number">0</span>, byteCodes.length);</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123; <span class="comment">// 关闭流的操作</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (baos != <span class="keyword">null</span>)</span><br><span class="line">                    baos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (bis != <span class="keyword">null</span>)</span><br><span class="line">                    bis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试自定义类加载器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将class文件放在了D盘下</span></span><br><span class="line">        MyClassLoader loader = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;d:/&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 需要加载的class文件名：Demo1</span></span><br><span class="line">            Class clazz = loader.loadClass(<span class="string">&quot;Demo1&quot;</span>);</span><br><span class="line">            <span class="comment">// 加载此类的类的加载器为: com.atguigu.java2.MyClassLoader</span></span><br><span class="line">            System.out.println(<span class="string">&quot;加载此类的类的加载器为：&quot;</span> + clazz.getClassLoader().getClass().getName());</span><br><span class="line">			<span class="comment">// 加载当前Demo1类的类的加载器的父类加载器为: sun.misc.Launcher$AppClassLoader(系统类加载器)</span></span><br><span class="line">            System.out.println(<span class="string">&quot;加载当前Demo1类的类的加载器的父类加载器为：&quot;</span> + clazz.getClassLoader().getParent().getClass().getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>需要将要加载的字节码文件放在一个文件下，或者重新javac编译一下源文件</li>
<li>不然的话JVM依旧会使用系统加载器去加载你的class文件（因为你的class文件在系统加载器的加载的目录下）</li>
</ul>
<h4 id="8、Java9新特性"><a href="#8、Java9新特性" class="headerlink" title="8、Java9新特性"></a>8、Java9新特性</h4><p>为了保证兼容性，JDK 9没有从根本上改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行，仍然发生了一些值得被注意的变动。</p>
<ol>
<li><p><strong>扩展机制被移除</strong>，<strong>扩展类加载器</strong>由于向后兼容性的原因被保留，不过<strong>被重命名为平台类加载器</strong>(platform class loader)。<strong>可以通过ClassLoader的新方法getPlatformClassLoader()来获取</strong>。(JDK9之前只能获取到系统类加载器，再通过系统类获取扩展类加载器，现在是直接可以获取到平台类加载器)</p>
<ul>
<li>JDK 9时基于模块化进行构建(原来的rt.jar和tools.jar被拆分成数十个JMOD文件)，其中的Java类库就已天然地满足了可扩展的需求，那自然无须再保留<JAVA_HOME>\lib\ext目录，此前使用这个目录或者java.ext.dirs 系统变量来扩展JDK功能的机制已经没有继续存在的价值了。</JAVA_HOME></li>
</ul>
</li>
<li><p><strong>平台类加载器和应用程序类加载器都不再继承自java.net.URLClassLoader</strong>。</p>
<ul>
<li><p>现在**启动类加载器、平台类加载器、应用程序类加载器全都继承于<code>jdk.internal.loader.BuiltinClassLoader</code>**。</p>
<p><img src="/2021/04/19/JVM/image-20210524172221156.png" alt="image-20210524172221156"></p>
</li>
<li><p><strong>如果有程序直接依赖了这种继承关系，或者依赖了URLClassLoader 类的特定方法，那代码很可能会在JDK 9及更高版本的JDK中崩溃</strong>。</p>
</li>
</ul>
</li>
<li><p>在Java 9中，<strong>类加载器有了名称。该名称在构造方法中指定，可以通过getName()方法来获取</strong>。</p>
<ul>
<li>平台类加载器的名称是platform</li>
<li>应用类加载器的名称是app</li>
</ul>
<p>类加载器的名称<strong>在调试与类加载器相关的问题时会非常有用</strong>。</p>
</li>
<li><p><strong>启动类加载器现在是在jvm内部和java类库共同协作实现的类加载器(以前是C++实现)，但为了与之前代码兼容在获取启动类加载器的场景中仍然会返回null，而不会得到BootClassLoader实例</strong>。</p>
</li>
<li><p>类加载的委派关系也发生了变动：</p>
<ul>
<li>当平台及应用程序类加载器收到类加载请求，<strong>在委派给父加载器加载前</strong>，要<strong>先判断该类是否能够归属到某一个系统模块中</strong>，如果可以找到这样的归属关系，就要<strong>优先委派给负责那个模块的加载器完成加载</strong>。</li>
</ul>
</li>
<li><p>双亲委派模式示意图：</p>
<p><img src="/2021/04/19/JVM/29CF69BE-5F92-444B-82CE-6B1AE51C023D.png" alt="img"></p>
</li>
<li><p>相关代码：（环境：JDK9）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// jdk.internal.loader.ClassLoaders$AppClassLoader@726f3b58</span></span><br><span class="line">        System.out.println(ClassLoaderTest.class.getClassLoader());</span><br><span class="line">        <span class="comment">// jdk.internal.loader.ClassLoaders$PlatformClassLoader@e73f9ac</span></span><br><span class="line">        System.out.println(ClassLoaderTest.class.getClassLoader().getParent());</span><br><span class="line">        <span class="comment">// null</span></span><br><span class="line">        System.out.println(ClassLoaderTest.class.getClassLoader().getParent().getParent());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取系统类加载器</span></span><br><span class="line">        System.out.println(ClassLoader.getSystemClassLoader());</span><br><span class="line">        <span class="comment">//获取平台类加载器</span></span><br><span class="line">        System.out.println(ClassLoader.getPlatformClassLoader());</span><br><span class="line">        <span class="comment">//获取类的加载器的名称 app</span></span><br><span class="line">        System.out.println(ClassLoaderTest.class.getClassLoader().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>附加：在Java模块化系统明确规定了三个类加载器负责各自加载的模块：</p>
<ul>
<li><p>启动类加载器负责加载的模块：</p>
<p><img src="/2021/04/19/JVM/image-20210524173906468.png" alt="image-20210524173906468"></p>
</li>
<li><p>平台类加载器负责加载的模块：</p>
<p><img src="/2021/04/19/JVM/image-20210524174130765.png" alt="image-20210524174130765"></p>
</li>
<li><p>应用程序类加载器负责加载的模块：</p>
<p><img src="/2021/04/19/JVM/image-20210524174026119.png" alt="image-20210524174026119"></p>
</li>
</ul>
</li>
</ol>
<h4 id="9、大厂面试题"><a href="#9、大厂面试题" class="headerlink" title="9、大厂面试题"></a>9、大厂面试题</h4><ul>
<li>蚂蚁金服：<ul>
<li>深入分析ClassLoader，双亲委派机制</li>
<li>类加载器的双亲委派模型是什么?</li>
<li>一面：双亲委派机制及使用原因</li>
</ul>
</li>
<li>百度：<ul>
<li>都有哪些类加载器，这些类加载器都加载哪些文件?</li>
<li>手写一个类加载器Demo</li>
<li>Class的forName(“java.lang.String”)和Class的getClassLoader()的loadClass(“java.lang.String”)有什么区别?</li>
</ul>
</li>
<li>腾讯：<ul>
<li>什么是双亲委派模型?</li>
<li>类加载器有哪些?</li>
</ul>
</li>
<li>小米：<ul>
<li>双亲委派模型介绍一下</li>
</ul>
</li>
<li>滴滴：<ul>
<li>简单说说你了解的类加载器</li>
<li>一面：讲一下双亲委派模型，以及其优点</li>
</ul>
</li>
<li>字节跳动：<ul>
<li>什么是类加载器，类加载器有哪些?</li>
</ul>
</li>
<li>京东：<ul>
<li>类加载器的双亲委派模型是什么?</li>
<li>双亲委派机制可以打破吗?为什么</li>
</ul>
</li>
</ul>
<h2 id="下篇：性能监控与调优篇"><a href="#下篇：性能监控与调优篇" class="headerlink" title="下篇：性能监控与调优篇"></a>下篇：性能监控与调优篇</h2><h3 id="1、概述篇"><a href="#1、概述篇" class="headerlink" title="1、概述篇"></a>1、概述篇</h3><h4 id="1、背景说明"><a href="#1、背景说明" class="headerlink" title="1、背景说明"></a>1、背景说明</h4><ol>
<li>生产环境中的问题<ul>
<li>生产环境发生了内存溢出该如何处理</li>
<li>生产环境应该给服务器分配多少内存合适？</li>
<li>如何对垃圾回收器的性能进行调优？</li>
<li>生产环境CPU负载飙高该如何处理？</li>
<li>生产环境应该给应用分配多少线程合适？</li>
<li>不加log，如何确定请求是否执行了某一行代码？</li>
<li>不加log，如何实时查看某个方法的入参与返回值？</li>
</ul>
</li>
<li>为什么要调优<ul>
<li>防止出现OOM</li>
<li>解决OOM</li>
<li>减少Full GC出现的频率</li>
</ul>
</li>
<li>不同阶段的考虑<ul>
<li>上线前</li>
<li>项目运行阶段</li>
<li>线上出现OOM</li>
</ul>
</li>
</ol>
<h4 id="2、调优概述"><a href="#2、调优概述" class="headerlink" title="2、调优概述"></a>2、调优概述</h4><ol>
<li>监控的依据<ul>
<li>运行日志</li>
<li>异常堆栈</li>
<li>GC日志</li>
<li>线程快照</li>
<li>堆转储快照</li>
</ul>
</li>
<li>调优的大方向<ul>
<li>合理地编写代码</li>
<li>充分并合理的使用硬件资源</li>
<li>合理地进行JVM调优</li>
</ul>
</li>
</ol>
<h4 id="3、性能优化的步骤"><a href="#3、性能优化的步骤" class="headerlink" title="3、性能优化的步骤"></a>3、性能优化的步骤</h4><h5 id="1、第1步（发现问题）：性能监控"><a href="#1、第1步（发现问题）：性能监控" class="headerlink" title="1、第1步（发现问题）：性能监控"></a>1、第1步（发现问题）：性能监控</h5><p>一种以<strong>非强行</strong>或者入侵方式<strong>收集或查看</strong>应用运营性能数据的活动。<br>监控通常是指一种在生产、 质量评估或者开发环境下实施的带有<strong>预防或主动性</strong>的活动。<br>当应用相关干系人提出性能问题却<strong>没有提供足够多的线索</strong>时，首先我们需要进行性能监控，随后是性能分析。</p>
<p>主要的问题有：</p>
<ul>
<li>GC频繁</li>
<li>cpu load过高</li>
<li>OOM</li>
<li>内存泄露</li>
<li>死锁</li>
<li>程序响应时间较长</li>
</ul>
<h5 id="2、第2步（排查问题）：性能分析"><a href="#2、第2步（排查问题）：性能分析" class="headerlink" title="2、第2步（排查问题）：性能分析"></a>2、第2步（排查问题）：性能分析</h5><p>一种以<strong>侵入方式</strong>收集运行性能数据的活动，它会影响应用的吞吐量或响应性。<br>性能分析是针对性能问题的答复结果，关注的范围通常比性能监控更加集中。<br>性能分析很少在生产环境下进行，通常是在<strong>质量评估、系统测试或者开发环境</strong>下进行，是性能监控之后的步骤。</p>
<p>主要的手段：</p>
<ul>
<li>打印GC日志，通过GCviewer或者<a target="_blank" rel="noopener" href="http://gceasy.io来分析异常信息/">http://gceasy.io来分析异常信息</a></li>
<li>灵活运用命令行工具、jstack、jmap、jinfo等</li>
<li>dump出堆文件，使用内存分析工具分析文件</li>
<li>使用阿里Arthas、jconsole、JVisualVM来实时查看JVM状态</li>
<li>jstack查看堆栈信息</li>
</ul>
<h5 id="3、第3步（解决问题）：性能调优"><a href="#3、第3步（解决问题）：性能调优" class="headerlink" title="3、第3步（解决问题）：性能调优"></a>3、第3步（解决问题）：性能调优</h5><p>一种为改善应用响应性或香吐量而更改参数、源代码、属性配置的活动，性能调优<br>是在性能监控、性能分析之后的活动。</p>
<h4 id="4、性能评价-测试指标"><a href="#4、性能评价-测试指标" class="headerlink" title="4、性能评价/测试指标"></a>4、性能评价/测试指标</h4><ol>
<li><p><strong>停顿时间（或响应时间）</strong></p>
<p>提交请求和返回该请求的响应之间使用的时间，一般比较关注平均响应时间常用操作的响应时间列表：</p>
<p><img src="/2021/04/19/JVM/image-20210712014649029.png" alt="image-20210712014649029"></p>
<p>在垃圾回收环节中：暂停时间：<strong>执行垃圾收集时，程序的工作线程被暂停的时间（STW）</strong>。</p>
<ul>
<li>XX: MaxGCPauseMillis</li>
</ul>
</li>
<li><p><strong>吞吐量</strong></p>
<p>对单位时间内完成的工作量（请求）的量度</p>
<p>在GC中：运行用户代码的事件占总运行时间的比例（总运行时间：程序的运行时间 + 内存回收的时间）</p>
<p><strong>吞吐量为1-1/(1+n)，其中-XX::GCTimeRatio=n</strong>（这个参数只有在G1才能设置）</p>
</li>
<li><p>并发数</p>
<p>同一时刻，对服务器有实际交互的请求数</p>
<p>大概的标准：1000个人同时在线，估计并发数在5% - 15%之间，也就是同时并发量： 50 - 150之间。</p>
</li>
<li><p>内存占用</p>
<p>Java堆区所占的内存大小</p>
</li>
</ol>
<ul>
<li>主要的指标有：响应时间和吞吐量</li>
<li>对于一个web应用关注的是：响应时间、吞吐量和并发数</li>
<li>对于GC的时候在意的数据</li>
</ul>
<p>响应时间、吞吐量和并发数相互间的关系（以高速公路通行状况为例）：</p>
<ul>
<li>吞吐量：每天通过高速公路收费站的车辆的数据(也可以理解为收费站收取的高速费)</li>
<li>并发数：高速公路上正在行驶的车辆的数目</li>
<li>响应时间：车速</li>
</ul>
<p>一开始的时候，高速公路上的车辆较少，车速较快，高速公路收费站收取的高速费较少——并发数少，响应时间快，吞吐量低</p>
<p>接着高速公路的车辆越来越多，车速变慢，高速公路收费站收取的高速费提高——并发数变多，响应时间变慢，吞吐量升高</p>
<p>随着高速公路的车辆越来越多，车速越来越慢，高速公路收费站收取的高速费降低——并发数越来越多，响应时间越来越慢，吞吐量降低</p>
<p>当高速公路的车辆发生事故，车速为0，高速公路收费站收取的高速费为0——并发数到顶，响应时间为0，吞吐量为0</p>
<h3 id="2、JVM监控及诊断工具——命令行篇"><a href="#2、JVM监控及诊断工具——命令行篇" class="headerlink" title="2、JVM监控及诊断工具——命令行篇"></a>2、JVM监控及诊断工具——命令行篇</h3><h4 id="1、概述-5"><a href="#1、概述-5" class="headerlink" title="1、概述"></a>1、概述</h4><p>性能诊断是软件工程师在日常工作中需要经常面对和解决的问题，在用户体验至上的今天，解决好应用的性能问题能带来非常大的收益。</p>
<p>Java作为最流行的编程语言之一，其应用性能诊断一直受到业界广泛关注。可能造成Java应用出现性能问题的因素非常多，例如<strong>线程控制</strong>、<strong>磁盘读写</strong>、<strong>数据库访问</strong>、<strong>网络I/O</strong>、<strong>垃圾收集</strong>等。想要定位这些问题，一款优秀的性能诊断工具必不可少。</p>
<ul>
<li>体会1：<strong>使用数据说明问题，使用知识分析问题，使用工具处理问题</strong>。</li>
<li>体会2：<strong>无监控、不调优!</strong></li>
</ul>
<p><strong>简单命令行工具：</strong></p>
<p>在我们刚接触java学习的时候，大家肯定最先了解的两个命令就是javac、java，那么除此之外，还有没有其他的命令可以供我们使用呢?</p>
<p>我们进入到安装jdk的bin目录，发现还有一系列辅助工具。这些辅助工具用来获取目标JVM不同方面、不同层次的信息，帮助开发人员很好地解决Java应用程序的一些疑难杂症。这些辅助工具都是一个.exe的可执行文件的方式，若想要找到他的来源：jdk &gt; jdk1.8.0_131 &gt; lib &gt; tool.jar包当中（都是一些.class文件）。<a target="_blank" rel="noopener" href="https://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/jdk.jcmd/share/classes/sun/tools">相关源码</a>：一般不需要我们去查看源码，除非你有特殊需求，需要自己书写修改源码。</p>
<p>mac系统：</p>
<p><img src="/2021/04/19/JVM/image-20210712021836021.png" alt="image-20210712021836021"></p>
<p>windows系统：</p>
<p><img src="/2021/04/19/JVM/image-20210712021909775.png" alt="image-20210712021909775"></p>
<h4 id="2、jps：查看正在运行的Java进程"><a href="#2、jps：查看正在运行的Java进程" class="headerlink" title="2、jps：查看正在运行的Java进程"></a>2、jps：查看正在运行的Java进程</h4><h5 id="1、基本介绍"><a href="#1、基本介绍" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h5><p>jps(Java Process Status)：显示指定系统内所有的HotSpot虚拟机进程(查看虚拟机进程信息)，可用于查询正在运行的虚拟机进程。</p>
<p>说明：</p>
<ul>
<li>对于本地虛拟机进程来说，<strong>进程的本地虚拟机ID与操作系统的进程ID是一致的，是唯一的</strong>。</li>
<li>jps只对于在java HotSpot虚拟机运行的进程。</li>
</ul>
<h5 id="2、基本语法"><a href="#2、基本语法" class="headerlink" title="2、基本语法"></a>2、基本语法</h5><p>它的基本使用语法为：jps [options] [hostid]</p>
<p>我们还可以通过追加参数，来打印额外的信息。可以通过 <code>jps -help</code> 来查看对应的参数信息</p>
<ul>
<li><p>options参数</p>
<ul>
<li><p><code>-q</code>：<strong>仅仅显示</strong>LVMID (local virtual machine id)， 即<strong>本地虚拟机唯一id。不显示主类的名称等</strong></p>
<p><img src="/2021/04/19/JVM/image-20210712024008753.png" alt="image-20210712024008753"></p>
</li>
<li><p><code>-l</code>：输出<strong>应用程序主类的全类名</strong>或如果进程执行的是jar包，则输出<strong>jar完整路径</strong></p>
<p><img src="/2021/04/19/JVM/image-20210712024035710.png" alt="image-20210712024035710"></p>
</li>
<li><p><code>-m</code>：输出<strong>虚拟机进程启动时传递给主类main()的参数</strong></p>
<p><img src="/2021/04/19/JVM/image-20210712024528755.png" alt="image-20210712024528755"></p>
<p><img src="/2021/04/19/JVM/image-20210712024311552.png" alt="image-20210712024311552"></p>
<p><img src="/2021/04/19/JVM/image-20210712024430556.png" alt="image-20210712024430556"></p>
</li>
<li><p><code>-v</code>：列出<strong>虚拟机进程启动时的JVM参数</strong>。</p>
<ul>
<li>比如：- Xms20m - Xmx50m是启动程序指定的jvm参数。</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210712024613610.png" alt="image-20210712024613610"></p>
<p><img src="/2021/04/19/JVM/image-20210712024715127.png" alt="image-20210712024715127"></p>
</li>
<li><p>说明：以上参数可以综合使用：</p>
<ul>
<li>-q指令单独使用（效果与其他三个相反），-lmv可以一起使用</li>
<li>jps -l -m 等价于 jps -lm</li>
<li>jps -l -m -v 等价于 jps -lmv</li>
<li>如果-q与其他三个指令综合使用的话：（以-l为例，其他两个类似）<ul>
<li>jps -q -l 等价于 jps -q（所以没什么必要，直接执行jps -q就行）</li>
<li>jps -ql：指令错误</li>
</ul>
</li>
<li>如何将信息输出到同级文件中：<ul>
<li>语法：命令 &gt; 文件名称</li>
<li>例如：jps -l &gt; a.txt</li>
</ul>
</li>
</ul>
</li>
<li><p>补充：</p>
<ul>
<li><p>如果某Java进程关闭了默认开启的UsePerfData参数(即使用参数<code>-XX: -UsePerfData</code>)，那么jps命令(以及下面介绍的jstat)将无法探知该<br>Java进程。</p>
<p><img src="/2021/04/19/JVM/image-20210712025059507.png" alt="image-20210712025059507"></p>
<p><img src="/2021/04/19/JVM/image-20210712025219254.png" alt="image-20210712025219254"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>hostid参数</p>
<ul>
<li>RMI注册表中注册的主机名。如果想要远程监控主机上的java 程序，需要安装jstatd。 </li>
<li>对于具有更严格的安全实践的网络场所而言，可能使用一个自定义的策略文件来显示对特定的可信主机或网络的访问，尽管<strong>这种技术容易受到IP地址欺诈攻击</strong>。</li>
<li>如果安全问题无法使用一个定制的策略文件来处理，那么最安全的操作是不运行jstatd服务器，而是在本地使用jstat和jps工具。</li>
</ul>
</li>
</ul>
<h5 id="3、相关测试"><a href="#3、相关测试" class="headerlink" title="3、相关测试"></a>3、相关测试</h5><p><img src="/2021/04/19/JVM/image-20210712022534826.png" alt="image-20210712022534826"></p>
<ul>
<li>10292：后面为空，查看任务管理器得知10292为操作系统为IDEA分配的进程ID，说明jps中后面为空的进程ID代表的就是IDEA进程（说明IDEA也是由java编写，运行在JVM虚拟机当中）</li>
<li>6328 ScannerTest：自己写的测试程序</li>
<li>14604 Jps：Jps本身的进程ID（说明在使用Jps的时候，Jps本身会创建一个进程）</li>
<li>2732 Launcher：JVM虚拟机的进程ID</li>
</ul>
<h4 id="3、jstat：查看JVM统计信息"><a href="#3、jstat：查看JVM统计信息" class="headerlink" title="3、jstat：查看JVM统计信息"></a>3、jstat：查看JVM统计信息</h4><h5 id="1、基本介绍-1"><a href="#1、基本介绍-1" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h5><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html">官方文档</a></p>
<p>jstat(JVM Statistics Monitoring Tool)：用于监视虚拟机各种运行状态信息的命令行工具。它可以显示<strong>本地或者远程虚拟机进程中的类装载、内存、垃圾收集、</strong><br><strong>JIT编译等运行数据</strong>。</p>
<p>在没有GUI图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。<strong>常用于检测垃圾回收问题以及内存泄漏问题</strong>。</p>
<h5 id="2、基本语法-1"><a href="#2、基本语法-1" class="headerlink" title="2、基本语法"></a>2、基本语法</h5><p>它的基本使用语法为：jstat -<option> [-t] [-h<lines>] <vmid> [ <interval> [ <count>]]</count></interval></vmid></lines></option></p>
<p>其中vmid是进程id号，也就是jps之后看到的前面的号码，如下：</p>
<p><img src="/2021/04/19/JVM/C0FE3B08-B6B9-4FF1-AB1A-CEEDCB5EFECF.png" alt="img"></p>
<p>查看命令相关参数：<code>jstat -h</code>或<code>jstat -help</code></p>
<ul>
<li><p>option参数</p>
<ul>
<li><p>类装载相关的：</p>
<ul>
<li><p><code>-class</code>：<strong>显示ClassLoader的相关信息</strong>：<strong>类的装载</strong>、<strong>卸载数量</strong>、<strong>总空间</strong>、<strong>类装载所消耗的时间</strong>等</p>
<p><img src="/2021/04/19/JVM/image-20210712225650046.png" alt="image-20210712225650046"></p>
<p>9000为进程ID（<vmid>）</vmid></p>
</li>
</ul>
</li>
<li><p>垃圾回收相关的：</p>
<ul>
<li><p><code>-gc</code>：<strong>显示与GC相关的堆信息</strong>。包括<strong>Eden区</strong>、<strong>两个Survivor区</strong>、<strong>老年代</strong>、<strong>永久代</strong>等的<strong>容量</strong>、<strong>已用空间</strong>、<strong>GC时间合计</strong>等信息。</p>
<p>其中设置了JVM参数：-Xms60m -Xmx60m -XX:SurvivorRatio=8</p>
<p><img src="/2021/04/19/JVM/image-20210712231844604.png" alt="image-20210712231844604"></p>
<ul>
<li>C：总容量\次数、U：使用的容量、S1\0：Survivor0\1区、E：伊甸园区、O：老年代、M：方法区、CCS：压缩类、YG：young GC、FG：full GC、GC：GC、T：时间</li>
<li>由于设置了-Xms60m -Xmx60m -XX:SurvivorRatio=8，即60M = 40M(Old) + 20M(young) 20M(young) = 16M(伊甸园区) + 2M(S0) + 2M(S1)</li>
<li>S0C：Survivor0区的容量：2M =2048</li>
<li>S1C：Survivor1区的容量：2M = 2048</li>
<li>S0U：Survivor0区使用的容量</li>
<li>S1U：Survivor1区使用的容量</li>
<li>EC：伊甸园区的容量:16M = 16384</li>
<li>EU：伊甸园区使用的容量</li>
<li>OC：老年代的容量：40M = 40960</li>
<li>OU：老年代使用的容量</li>
<li>MC：方法区的容量</li>
<li>MU：方法区使用的容量</li>
<li>CCSC：压缩类的容量</li>
<li>CCSU：压缩类使用的容量</li>
<li>YGC：young GC发生的次数</li>
<li>YGCT：发生young GC花费的时间</li>
<li>FGC：full GC发生的次数</li>
<li>FGCT：发生full GC花费的时间</li>
<li>GCT：用于GC的时间</li>
</ul>
</li>
<li><p><code>-gccapacity</code>：<strong>显示内容与<code>-gc</code>基本相同</strong>，但输出主要关注<strong>Java堆各个区域使用到的最大、最小空间</strong>。</p>
</li>
<li><p><code>-gcutil</code>：<strong>显示内容与<code>-gc</code>基本相同</strong>，但输出主要关注<strong>已使用空间占总空间的百分比</strong>。</p>
<p><img src="/2021/04/19/JVM/image-20210712234001136.png" alt="image-20210712234001136"></p>
</li>
<li><p><code>-gccause</code>：<strong>与<code>-gcutil</code>功能一样</strong>，但是会额外输出<strong>导致最后一次或当前正在发生的GC产生的原因</strong>。</p>
<p><img src="/2021/04/19/JVM/image-20210712234235632.png" alt="image-20210712234235632"></p>
</li>
<li><p><code>-gcnew</code>：<strong>显示新生代GC状况</strong></p>
</li>
<li><p><code>-gcnewcapacity</code>：<strong>显示内容与<code>-gcnew</code>基本相同</strong>，输出主要关注<strong>使用到的最大、最小空间</strong></p>
</li>
<li><p><code>-geold</code>：<strong>显示老年代GC状况</strong></p>
</li>
<li><p><code>-gcoldcapacity</code>：<strong>显示内容与<code>-gcold</code>基本相同</strong>，输出主要关注<strong>使用到的最大、最小空间</strong></p>
</li>
<li><p><code>-gcpermcapacity</code>：显示<strong>永久代使用到的最大、最小空间</strong>。</p>
</li>
</ul>
</li>
<li><p>JIT相关的：</p>
<ul>
<li><p><code>-compiler</code>：<strong>显示JIT编译器编译过的方法、耗时等信息</strong></p>
<p><img src="/2021/04/19/JVM/image-20210712231535247.png" alt="image-20210712231535247"></p>
</li>
<li><p><code>-printcompilation</code>：<strong>输出已经被JIT编译的方法</strong></p>
<p><img src="/2021/04/19/JVM/image-20210712231557164.png" alt="image-20210712231557164"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>interval参数：用于指定输出统计数据的周期，单位为毫秒。即：查询间隔。如果没加的话，<strong>默认查询1次</strong>，如果后面的count没有加的话，<strong>默认一直查询</strong>。</p>
<p><img src="/2021/04/19/JVM/image-20210712230907909.png" alt="image-20210712230907909"></p>
</li>
<li><p>count参数：用于指定查询的总次数。在加上interval参数的情况下，没加count参数，默认一直查询</p>
<p><img src="/2021/04/19/JVM/image-20210712230944650.png" alt="image-20210712230944650"></p>
<p>每1s显示一次ClassLoader的相关信息，显示10次。</p>
</li>
<li><p>-t参数：可以在输出信息前加上一个Timestamp列，显示程序的运行时间。单位：秒</p>
<p><img src="/2021/04/19/JVM/image-20210712231131085.png" alt="image-20210712231131085"></p>
<p><img src="/2021/04/19/JVM/image-20210712231246385.png" alt="image-20210712231246385"></p>
<ul>
<li><p>经验：</p>
<ul>
<li><p>我们可以比较Java进程的启动时间以及总GC时间(GCT列)，或者两次测量的间隔时间以及总GC时间的增量，来得出GC时间占运行时间的比例。</p>
</li>
<li><p>如果该比例超过20%，则说明目前堆的压力较大;如果该比例超过90%，则说明堆里几乎没有可用空间，随时都可能抛出OOM异常。</p>
</li>
<li><p>我们执行jstat -gc -t 13152 1000 10，这代表1秒打印出1行，一共10行，-t代表打印出Timestamp总运行时间，结果如下所示：</p>
<p><img src="/2021/04/19/JVM/CB135068-C793-480B-9070-B48159AC6BC1.png" alt="img"></p>
<p>上方红色框框中代表Timestamp，而蓝色框框中代表垃圾回收时间，单位都是秒，如果让红色框框中的某两个值相减，假设这个值是num1，然后让对应行的蓝色框框中的另外两个值相减，假设这个值是num2，之后让num2/num1，得出的差值就是上述所说的GC时间占运行时间的比例</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>h参数：可以在周期性数据输出时，输出多少行数据后输出一个表头信息</p>
<p><img src="/2021/04/19/JVM/image-20210712231441369.png" alt="image-20210712231441369"></p>
</li>
</ul>
<h5 id="3、补充"><a href="#3、补充" class="headerlink" title="3、补充"></a>3、补充</h5><p>jstat还可以用来判断是否出现内存泄漏。</p>
<ol>
<li>第1步：在长时间运行的Java程序中，我们可以运行jstat命令连续获取多行性能数据，<strong>并取这几行数据中OU列(即己占用的老年代内存)的最小值</strong>。</li>
<li>第2步：然后，我们<strong>每隔一段较长的时间重复一次上述操作</strong>，来<strong>获得多组OU最小值</strong>。如果这些值<strong>呈上涨趋势</strong>，则说明<strong>该Java程序的老年代内存已使用量在不断上涨</strong>，这意味着<strong>无法回收的对象在不断增加</strong>，因此很<strong>有可能存在内存泄漏</strong>。</li>
</ol>
<h4 id="4、jinfo：实时查看和修改JVM配置参数"><a href="#4、jinfo：实时查看和修改JVM配置参数" class="headerlink" title="4、jinfo：实时查看和修改JVM配置参数"></a>4、jinfo：实时查看和修改JVM配置参数</h4><h5 id="1、基本介绍-2"><a href="#1、基本介绍-2" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h5><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/tools/jinfo.html">官方文档</a></p>
<p>jinfo(Configuration Info for Java)：<strong>查看虚拟机配置参数信息，也可用于调整虚拟机的配置参数</strong>。</p>
<p>在很多情况下，Java应用程序不会指定所有的Java虚拟机参数。而此时，开发人员可能不知道某一个具体的Java虚拟机参数的默认值。在这种情况下，可能需要通过查找文档获取某个参数的默认值。这个查找过程可能是非常艰难的。但有了jinfo工具，开发人员可以很方便地找到Java虛拟机参数的当前值。</p>
<p><img src="/2021/04/19/JVM/image-20210713000744298.png" alt="image-20210713000744298"></p>
<h5 id="2、基本语法-2"><a href="#2、基本语法-2" class="headerlink" title="2、基本语法"></a>2、基本语法</h5><p>它的基本使用语法为：jinfo [ options ] pid</p>
<p>说明：java进程ID必须要加上。</p>
<p>[options] :</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>选项说明</th>
</tr>
</thead>
<tbody><tr>
<td>no option</td>
<td>输出全部的参数和系统属性</td>
</tr>
<tr>
<td>-flag name</td>
<td>输出对应名称的参数</td>
</tr>
<tr>
<td>-flag [+-]name</td>
<td>开启或关闭对应名称的参数<br>只有被标记为manageable的参数才可以被动态修改</td>
</tr>
<tr>
<td>-flag name=value</td>
<td>设定对应名称的参数</td>
</tr>
<tr>
<td>-flags</td>
<td>输出全部的参数</td>
</tr>
<tr>
<td>-sysprops</td>
<td>输出系统属性</td>
</tr>
</tbody></table>
<ul>
<li><p>查看</p>
<ul>
<li><p>jinfo -sysprops 进程id：可以查看由System.getProperties()取得的参数</p>
<p>进程id可以通过jps命令查看，操作结果如下：（其中13152代表进程id）</p>
<p><img src="/2021/04/19/JVM/4512D1D8-6DD0-4602-A589-8F076993F3AB.png" alt="img"></p>
</li>
<li><p>jinfo -flags 进程id：查看曾经赋过值的一些参数</p>
<p>进程id可以通过jps命令查看，参数赋值的一部分是我们自己设置的，另外一部分是系统自动优化设置的参数信息，具体操作如下：（其中13152代表进程id）</p>
<p><img src="/2021/04/19/JVM/0FD1835A-DCB5-436F-9D51-650D789F530F.png" alt="img"></p>
</li>
<li><p>jinfo -flag 参数名称 进程id：查看某个java进程的具体参数信息</p>
<p>进程id可以通过jps命令查看具体操作如下：（其中3540代表进程id）</p>
<p><img src="/2021/04/19/JVM/image-20210713001051530.png" alt="image-20210713001051530"></p>
</li>
</ul>
</li>
<li><p>修改</p>
<ul>
<li><p>jinfo不仅可以查看运行时某一个Java虚拟机参数的实际取值，甚至可以在运行时修改部分参数，并使之立即生效。但是，并非所有参数都支持动态修改。参数只有被标记为<code>manageable</code>的flag可以被实时修改其实，这个修改能力是极其有限的。</p>
</li>
<li><p>#可以查看被标记为manageable的参数：java -XX:+PrintFlagsFinal -version | grep manageable</p>
<p><img src="/2021/04/19/JVM/image-20210713001449847.png" alt="image-20210713001449847"></p>
</li>
<li><p>针对boolean类型</p>
<ul>
<li><p>jinfo -flag [+|-]参数名称 进程id</p>
<p><img src="/2021/04/19/JVM/image-20210713001553125.png" alt="image-20210713001553125"></p>
</li>
</ul>
</li>
<li><p>针对非boolean类型</p>
<ul>
<li><p>jinfo -flag 参数名称=参数值 进程id</p>
<p><img src="/2021/04/19/JVM/image-20210713001642300.png" alt="image-20210713001642300"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="3、拓展"><a href="#3、拓展" class="headerlink" title="3、拓展"></a>3、拓展</h5><ul>
<li><p>java -XX:+PrintFlagsInitial</p>
<p>查看所有JVM参数启动的初始值</p>
</li>
<li><p>java -XX:+PrintFlagsFinal</p>
<p>查看所有JVM参数的最终值</p>
<p><img src="/2021/04/19/JVM/image-20210713001929389.png" alt="image-20210713001929389"></p>
<p>值前面添加冒号<code>:</code>的是修改之后的值，没有添加的都是没有发生改变的初始值</p>
</li>
<li><p>java -参数名称:+PrintCommandLineFlags</p>
<p>查看那些已经被用户或者JVM设置过的详细的XX参数的名称和值</p>
</li>
</ul>
<h4 id="5、jmap：导出内存映像文件-amp-内存使用情况"><a href="#5、jmap：导出内存映像文件-amp-内存使用情况" class="headerlink" title="5、jmap：导出内存映像文件&amp;内存使用情况"></a>5、jmap：导出内存映像文件&amp;内存使用情况</h4><h5 id="1、基本介绍-3"><a href="#1、基本介绍-3" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h5><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/tools/jmap.html">官方帮助文档</a></p>
<p>jmap(JVM Memory Map)：作用方面是<strong>获取dump文件</strong> (堆转储快照文件，<strong>二进制文件</strong>)，它还可以获取<strong>目标Java进程的内存相关信息</strong>，包括<strong>Java堆各区域的使用情况</strong>、<strong>堆中对象的统计信息</strong>、<strong>类加载信息</strong>等。</p>
<p>开发人员可以在控制台中输入命令“jmap -help” 查阅jmap工具的具体使用方式和一些标准选项配置。</p>
<p><img src="/2021/04/19/JVM/image-20210713003354636.png" alt="image-20210713003354636"></p>
<h5 id="2、基本语法-3"><a href="#2、基本语法-3" class="headerlink" title="2、基本语法"></a>2、基本语法</h5><p>它的基本使用语法为：</p>
<ul>
<li>jmap [option] <pid></pid></li>
<li>jmap [option] &lt;executable <core></core></li>
<li>jmap [option] [server_ id@]<remote server ip or hostname></remote></li>
</ul>
<p>其中的option包括：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-dump</td>
<td>生成dump文件</td>
</tr>
<tr>
<td>-finalizerinfo</td>
<td>显示在F-Queue中等待Finalizer线程执行finalize方法的对象</td>
</tr>
<tr>
<td>-heap</td>
<td>输出整个堆空间的详细信息，包括GC的使用、堆配置信息，以及内存的使用信息等等</td>
</tr>
<tr>
<td>-histo</td>
<td>输出堆空间中对象的统计信息，包括类、实例数量和合计容量</td>
</tr>
<tr>
<td>-permstat</td>
<td>以ClassLoader为统计口径输出永久代的内存状态信息</td>
</tr>
<tr>
<td>-F</td>
<td>当虚拟机对-dump选项没有任何响应的时候，强制执行生成dump文件</td>
</tr>
</tbody></table>
<ol>
<li>使用语法可以通过在DOS窗口中使用jmap/jmap -h/jmap -help查看jmap使用语法</li>
<li>文件名称代表可执行的代码，比如使用&gt; 文件名称来指定生成的dump文件的生成位置</li>
<li>[server_id@]是为远程连接准备的</li>
</ol>
<p>指令描述：</p>
<ul>
<li>**<code>-dump</code>**：生成Java堆转储快照：dump文件<ul>
<li>特别的：<code>-dump:live</code>只保存堆中的存活对象</li>
</ul>
</li>
<li>**<code>-heap</code>**：输出整个堆空间的详细信息，包括GC的使用、堆配置信息，以及内存的使用信息等</li>
<li>**<code>-histo</code>**：输出堆中对象的同级信息，包括类、实例数量和合计容量<ul>
<li>特别的：<code>-histo:live</code>只统计堆中的存活对象</li>
</ul>
</li>
<li><code>-permstat</code>：以ClassLoader为统计口径输出永久代的内存状态信息<ul>
<li><strong>仅linux/solaris平台有效</strong></li>
</ul>
</li>
<li><code>-finalizerinfo</code>：显示在F-Queue中等待Finalizer线程执行finalize方法的对象<ul>
<li><strong>仅linux/solaris平台有效</strong></li>
</ul>
</li>
<li><code>-F</code>：当虚拟机进程对-dump选项没有任何响应时，可使用此选项强制执行生成dump文件<ul>
<li><strong>仅linux/solaris平台有效</strong></li>
</ul>
</li>
<li><code>-h | -help</code>：jamp工具使用的帮助命令</li>
<li><code>-J &lt;flag&gt;</code>：传递参数给jmap启动的jvm</li>
</ul>
<h5 id="3、基本使用"><a href="#3、基本使用" class="headerlink" title="3、基本使用"></a>3、基本使用</h5><h6 id="1、使用1：导出内存映像文件"><a href="#1、使用1：导出内存映像文件" class="headerlink" title="1、使用1：导出内存映像文件"></a>1、使用1：导出内存映像文件</h6><p>一般来说，使用jmap指令生成dump文件的操作算得上是最常用的jmap命令之一，将堆中所有存活对象导出至一个文件之中。</p>
<p>Heap Dump又叫做堆存储文件，指一个Java进程在某个时间点的内存快照。Heap Dump在触发内存快照的时候会保存此刻的信息如下:</p>
<ul>
<li>All Objects<br>Class,fields,primitive values and references</li>
<li>All Classes<br>ClassLoader,name,super class,static fields</li>
<li>Garbage Collection Roots<br>Objects defined to be reachable by the JVM</li>
<li>Thread Stacks and Local Variables<br>The call-stacks of threads at the moment of the snapshot，and per-frame information about local objects</li>
</ul>
<p>说明：</p>
<ol>
<li>通常在写Heap Dump文件前会触发一次Full GC， 所以heap dump文件里保存的都是Full GC后留下的对象信息。</li>
<li>由于生成dump文件比较耗时，因此大家需要耐心等待，尤其是大内存镜像生成dump文件则需要耗费更长的时间来完成。</li>
</ol>
<p>注意：</p>
<ol>
<li>对于以上说明中的第1点是自动方式才会这样做，而手动不会在Full GC之后生成Dump</li>
<li>使用手动方式生成dump文件，一般指令执行之后就会生成，不用等到快出现OOM的时候</li>
<li>使用自动方式生成dump文件，当出现OOM之前先生成dump文件</li>
<li>如果使用手动方式，一般使用第2种，毕竟生成堆中存活对象的dump文件是比较小的，便于传输和分析</li>
</ol>
<p>生成dump文件的方式：</p>
<ul>
<li><p>手动的方式</p>
<ul>
<li>jmap -dump:format=b,file=&lt;filename.hprof&gt; <pid></pid></li>
<li><strong>jmap -dump:live,format=b,file=&lt;filename.hprof&gt; <pid></pid></strong><ul>
<li>小结的内容</li>
</ul>
</li>
</ul>
<p>说明：</p>
<ul>
<li>其中file=后面的是生成的dump文件地址，最后的11696是进程id，可以通过jps查看</li>
<li>filename中的filename是文件名称，而.hprof是后缀名，代表该值可以省略</li>
<li>format=b表示生成的是标准的dump文件，用来进行格式限定</li>
<li>一般使用的是第二种方式，也就是生成堆中存活对象的快照，毕竟这种方式生成的dump文件更小，我们传输处理都更方便</li>
</ul>
<p>具体例子如下：</p>
<p><img src="/2021/04/19/JVM/image-20210713010601073.png" alt="image-20210713010601073"></p>
</li>
<li><p>自动的方式</p>
<p>当程序发生OOM退出系统时，一些瞬时信息都随着程序的终止而消失，而重现OOM问题往往比较困难或者耗时。此时若能在OOM时，自动导出dump文件就显得非常迫切。这里介绍一种比较常用的取得堆快照文件的方法，即使用：</p>
<ul>
<li><code>-XX: +HeapDumpOnOutOfMemoryError</code>：<strong>在程序发生OOM时，导出应用程序的当前堆快照</strong>。</li>
<li><code>-XX:HeapDumpPath</code>：可以<strong>指定堆快照的保存位置</strong>。</li>
<li>比如：<ul>
<li>-Xmx100m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=D: \m. hprof</li>
</ul>
</li>
<li>具体使用如下：</li>
</ul>
</li>
</ul>
<h6 id="2、使用2：显示堆内存相关信息"><a href="#2、使用2：显示堆内存相关信息" class="headerlink" title="2、使用2：显示堆内存相关信息"></a>2、使用2：显示堆内存相关信息</h6><ul>
<li><p>jmap -heap 进程id</p>
<ul>
<li><p><code>jmap -heap 进程id</code>只是时间点上的堆信息，而<code>jstat</code>后面可以添加参数，可以指定时间动态观察数据改变情况，而图形化界面工具，例如<code>jvisualvm</code>等，它们可以用图表的方式动态展示出相关信息，更加直观明了。</p>
</li>
<li><p>使用例子：</p>
<p><img src="/2021/04/19/JVM/image-20210713012001093.png" alt="image-20210713012001093"></p>
<p><img src="/2021/04/19/JVM/image-20210713012319564.png" alt="image-20210713012319564"></p>
<p><img src="/2021/04/19/JVM/image-20210713012602069.png" alt="image-20210713012602069"></p>
</li>
</ul>
</li>
<li><p>jmap -histo 进程id</p>
<ul>
<li><p>输出<strong>堆中对象的同级信息</strong>，包括<strong>类、实例数量和合计容量</strong>，也是<strong>这一时刻的内存中的对象信息</strong></p>
</li>
<li><p>使用例子：</p>
<p><img src="/2021/04/19/JVM/image-20210713012043421.png" alt="image-20210713012043421"></p>
<p><img src="/2021/04/19/JVM/image-20210713012836602.png" alt="image-20210713012836602"></p>
</li>
</ul>
</li>
</ul>
<h6 id="3、使用3：其他作用"><a href="#3、使用3：其他作用" class="headerlink" title="3、使用3：其他作用"></a>3、使用3：其他作用</h6><ul>
<li>jmap -permstat 进程id<ul>
<li>查看系统的ClassLoader信息(永久代)</li>
</ul>
</li>
<li>jmap -finalizerinfo<ul>
<li>查看堆积在finalizer队列中的对象</li>
</ul>
</li>
</ul>
<p>这两个指令仅linux/solaris平台有效，所以无法在windows操作平台上演示，并且使用比较小众，不在多说</p>
<h5 id="4、小结"><a href="#4、小结" class="headerlink" title="4、小结"></a>4、小结</h5><p>由于jmap将访问堆中的所有对象，为了保证在此过程中不被应用线程干扰，jmap需要<strong>借助安全点机制</strong>，让所有线程停留在不改变堆中数据的状态。也就是说，<strong>由jmap导出的堆快照必定是安全点位置的</strong>。这可能导致<strong>基于该堆快照的分析结果存在偏差</strong>。</p>
<p>举个例子，假设在编译生成的机器码中，某些对象的生命周期在两个安全点之间，那么<code>-dump:live</code>选项将无法探知到这些对象。</p>
<p>另外，如果某个线程长时间无法跑到安全点，jmap将一直等下去。</p>
<p>与前面讲的jstat则不同，<strong>垃圾回收器会主动将jstat所需要的摘要数据保存至固定位置之中，而jstat只需直接读取即可</strong>。</p>
<h4 id="6、jhat：JDK自带堆分析工具"><a href="#6、jhat：JDK自带堆分析工具" class="headerlink" title="6、jhat：JDK自带堆分析工具"></a>6、jhat：JDK自带堆分析工具</h4><p>jhat命令在jdk9及其之后就被移除了，官方建议使用VisualVm代替jhat，所以该指令只需简单了解一下即可</p>
<h5 id="1、基本介绍-4"><a href="#1、基本介绍-4" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h5><p>jhat(JVM Heap Analysis Tool)：Sun JDK提供的<strong>jhat命令与jmap命令搭配使用</strong>，**用于分析jmap生成的heap dump文件(堆转储快照)**。</p>
<p>jhat内置了一个微型的HTTP/HTML服务器（会CPU造成一定的压力），生成dump文件的分析结果后，用户可以在浏览器中查看分析结果(分析虚拟机转储快照信息)。</p>
<p>使用了jhat命令， 就启动了一个http服务，端口是7000， 即<a target="_blank" rel="noopener" href="http://localhost:7000/%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8C%E5%88%86%E6%9E%90%E3%80%82">http://localhost:7000/，就可以在浏览器里分析。</a></p>
<p>说明：jhat 命令在JDK9、JDK10中已经被删除，官方建议用<code>VisualVM</code>代替。</p>
<p><img src="/2021/04/19/JVM/image-20210713015031277.png" alt="image-20210713015031277"></p>
<h5 id="2、基本语法-4"><a href="#2、基本语法-4" class="headerlink" title="2、基本语法"></a>2、基本语法</h5><p>它的基本使用语法为：jhat [option] [dumpfile]</p>
<p>其中dumpfile代表dump文件的地址以及名称，例如：jhat d:\1.hprof</p>
<p>option参数：</p>
<ul>
<li><code>-stack false|true</code>：关闭|打开对象分配调用栈跟踪</li>
<li><code>-refs false|true</code>：关闭|打开对象引用跟踪</li>
<li><code>-port port-number</code>：设置jhat HTTP Server的端口号，默认7000。例子：jhat -port 6565</li>
<li><code>-exclude exclude-file</code>：执行对象查询时需要排除的数据成员</li>
<li><code>-debug int</code>：设置debug级别</li>
<li><code>-version</code>：启动后显示版本信息就退出</li>
<li><code>-J&lt;flag&gt;</code>：传入启动参数，比如-J -Xmx512m</li>
</ul>
<p>例子：</p>
<p><img src="/2021/04/19/JVM/image-20210713020055637.png" alt="image-20210713020055637"></p>
<p><img src="/2021/04/19/JVM/image-20210713020318845.png" alt="image-20210713020318845"></p>
<p><img src="/2021/04/19/JVM/image-20210713020411853.png" alt="image-20210713020411853"></p>
<p>注意：</p>
<ul>
<li><strong>使用jhat一次只能分析一个.hprof文件</strong>，如果要分析另外一个.hprof文件的话，需要将之前打开的jhat关闭。</li>
</ul>
<h4 id="7、jstack：打印JVM中线程快照"><a href="#7、jstack：打印JVM中线程快照" class="headerlink" title="7、jstack：打印JVM中线程快照"></a>7、jstack：打印JVM中线程快照</h4><h5 id="1、基本介绍-5"><a href="#1、基本介绍-5" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h5><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/tools/jstack.html">官方帮助文档</a></p>
<p>jstack(JVM Stack Trace)：用于生成虚拟机指定进程当前时刻的线程快照(虚拟机堆栈跟踪)。线程快照就是当前虚拟机内指定进程的每一条线程正在执行的方法堆栈的集合。</p>
<p>生成线程快照的作用：可用于<strong>定位线程出现长时间停顿的原因</strong>，如<strong>线程间死锁、死循环、请求外部资源导致的长时间等待</strong>等问题。这些都是导致线程长时间停顿的常见原因。<strong>当线程出现停顿时，就可以用jstack显示各个线程调用的堆栈情况</strong>。</p>
<p>在thread dump中，要留意下面几种状态：</p>
<ul>
<li><strong>死锁：Deadlock (重点关注)</strong></li>
<li><strong>等待资源：Waiting on condition (重点关注)</strong></li>
<li><strong>等待获取监视器：Waiting on monitor entry (重点关注)</strong></li>
<li><strong>阻塞：Blocked (重点关注)</strong></li>
<li>执行中：Runnable</li>
<li>暂停：Suspended</li>
<li>对象等待中：Object.wait() 或 TIMED_WAITING</li>
<li>停止：Parked</li>
</ul>
<h5 id="2、基本语法-5"><a href="#2、基本语法-5" class="headerlink" title="2、基本语法"></a>2、基本语法</h5><p><img src="/2021/04/19/JVM/image-20210713022747670.png" alt="image-20210713022747670"></p>
<p>它的基本使用语法为：jstack option pid</p>
<p>jstack管理远程进程的话，需要在远程程序的启动参数中增加：</p>
<ul>
<li>-Djava.rmi.server.hostname=……</li>
<li>-Dcom.sun.management.jmxremote</li>
<li>-Dcom.sun.management.jmxremote.port=8888</li>
<li>-Dcom.sun.management.jmxremote.authenticate=false</li>
<li>-Dcom.sun.management.jmxremote.ssl=false</li>
</ul>
<p>总结：如果程序出现等待问题，可以使用该指令去查看问题所在，结果中也会提示你问题所在</p>
<p>option参数：</p>
<ul>
<li><code>-F</code>：当正常输出的请求不被响应时，强制输出线程堆栈</li>
<li><code>-l</code>：除堆栈外，显示关于锁的附加信息</li>
<li><code>-m</code>：如果调用本地方法的话，可以显示C/C++的堆栈</li>
<li><code>-h</code>：帮助操作</li>
</ul>
<p>在java层面实现jstack功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Thread, StackTraceElement[]&gt; all = Thread.getAllStackTraces(); <span class="comment">//追踪当前进程中的所有的线程</span></span><br><span class="line">Set&lt;Map.Entry&lt;Thread, StackTraceElement[]&gt;&gt; entries = all.entrySet();</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Thread, StackTraceElement[]&gt; en : entries)&#123;</span><br><span class="line">	Thread t = en.getKey();</span><br><span class="line">    StackTraceElement[] v = en.getValue();</span><br><span class="line">    System.out.println(<span class="string">&quot;【Thread name is :&quot;</span> + t.getName() + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(StackTraceElement s : v)&#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;\t&quot;</span> + s.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<p>死锁问题：</p>
<p><img src="/2021/04/19/JVM/image-20210713023139008.png" alt="image-20210713023139008"></p>
<p><img src="/2021/04/19/JVM/image-20210713025908544.png" alt="image-20210713025908544"></p>
<p><img src="/2021/04/19/JVM/image-20210713030226778.png" alt="image-20210713030226778"></p>
<p>使用sleep：</p>
<p><img src="/2021/04/19/JVM/image-20210713030341435.png" alt="image-20210713030341435"></p>
<p>同步问题：</p>
<p><img src="/2021/04/19/JVM/image-20210713030512538.png" alt="image-20210713030512538"></p>
<h4 id="8、jcmd：多功能命令行"><a href="#8、jcmd：多功能命令行" class="headerlink" title="8、jcmd：多功能命令行"></a>8、jcmd：多功能命令行</h4><h5 id="1、基本介绍-6"><a href="#1、基本介绍-6" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h5><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/tools/jcmd.html">官方帮助文档</a></p>
<p>在JDK 1.7以后，新增了一个命令行工具jcmd。</p>
<p>它是一个多功能的工具，可以用来实现前面除了jstat之外的所有命令的功能。比如：用它来导出堆、内存使用、查看java进程、导出线程信息、执行GC、JVM运行时间等等。</p>
<p>jcmd拥有jmap的大部分功能，并且在Oracle的官方网站上也推荐使用jcmd命令代替jmap命令。</p>
<h5 id="2、基本语法-6"><a href="#2、基本语法-6" class="headerlink" title="2、基本语法"></a>2、基本语法</h5><p><img src="/2021/04/19/JVM/image-20210713034508974.png" alt="image-20210713034508974"></p>
<ul>
<li><p>jcmd -l：列出所有的JVM进程</p>
</li>
<li><p>jcmd 进程号 help：针对指定的进程，列出支持的所有具体命令</p>
<ul>
<li><p>执行效果：</p>
<p><img src="/2021/04/19/JVM/CAAD6BF7-147F-4BA5-9FCF-D2C3CE80AEB4.png" alt="img"></p>
</li>
</ul>
</li>
<li><p>jcmd 进程号 具体命令：显示指定进程的指令命令的数据</p>
<ul>
<li>首先通过jcmd 进程号 help得出以下命令列表</li>
<li>根据以上命令来替换之前的那些操作：<ul>
<li>Thread.print 可以替换 jstack指令</li>
<li>GC.class_histogram 可以替换 jmap中的-histo操作</li>
<li>GC.heap_dump 可以替换 jmap中的-dump操作</li>
<li>GC.run 可以查看GC的执行情况</li>
<li>VM.uptime 可以查看程序的总执行时间，可以替换jstat指令中的-t操作</li>
<li>VM.system_properties 可以替换 jinfo -sysprops 进程id</li>
<li>VM.flags 可以获取JVM的配置参数信息</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="9、jstatd：远程主机信息收集"><a href="#9、jstatd：远程主机信息收集" class="headerlink" title="9、jstatd：远程主机信息收集"></a>9、jstatd：远程主机信息收集</h4><p>之前的指令只涉及到监控本机的Java应用程序，而在这些工具中，一些监控工具也支持对远程计算机的监控(如jps、jstat)。为了启用远程监控，则需要配合使用jstatd 工具。</p>
<p>命令jstatd是一个RMI服务端程序，它的作用相当于代理服务器，建立本地计算机与远程监控工具的通信。 jstatd服务器将本机的Java应用程序信息传递到远程计算机。</p>
<p><img src="/2021/04/19/JVM/jstatd%E7%9A%84%E7%90%86%E8%A7%A3.png" alt="jstatd的理解"></p>
<h3 id="3、JVM监控及诊断工具——GUI篇"><a href="#3、JVM监控及诊断工具——GUI篇" class="headerlink" title="3、JVM监控及诊断工具——GUI篇"></a>3、JVM监控及诊断工具——GUI篇</h3><h4 id="1、工具概述"><a href="#1、工具概述" class="headerlink" title="1、工具概述"></a>1、工具概述</h4><p>使用上一章命令行工具或组合能帮您获取目标Java应用性能相关的基础信息，但它们存在下列局限：</p>
<ol>
<li>无法获取<strong>方法级别</strong>的分析数据，如<strong>方法间的调用关系</strong>、<strong>各方法的调用次数</strong>和<strong>调用时间</strong>等(这对定位应用性能瓶颈至关重要)</li>
<li>要求用户登录到目标Java应用所在的宿主机上，使用起来不是很方便。</li>
<li>分析数据通过终端输出，结果展示不够直观。</li>
</ol>
<p>为此，JDK提供 了一些内存泄漏的分析工具，如jconsole、jvisualvm等， 用于辅助开发人员定位问题，但是这些工具很多时候并不足以满足快速定位的需求。所以这里我们介绍的工具相对多一些、丰富一些。</p>
<p><strong>图形化综合诊断工具</strong>：</p>
<ul>
<li>JDK自带的工具<ul>
<li><code>jconsole</code>：JDK自带的可视化监控工具。<strong>查看Java应用程序的运行概况、监控堆信息、永久区(或元空间)使用情况、类加载情况</strong>等<ul>
<li>位置：jdk\bin\jconsole.exe</li>
</ul>
</li>
<li><code>Visual VM</code>：Visual VM是一个工具，它提供了一个可视界面，<strong>用于查看Java虚拟机上运行的基于Java技术的应用程序的详细信息</strong>。<ul>
<li>位置: jdk\bin\jvisualvm.exe</li>
</ul>
</li>
<li><code>JMC</code>：Java Mission Control，<strong>内置<code>Java Flight Recorder</code>**。能够</strong>以极低的性能开销收集Java虚拟机的性能数据**。</li>
</ul>
</li>
<li>第三方工具<ul>
<li><code>MAT</code>：MAT(Memory Analyzer Tool) 是基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们<strong>查找内存泄漏和减少内存消耗</strong><ul>
<li>Eclipse的插件形式</li>
</ul>
</li>
<li><code>JProfiler</code>：商业软件，需要付费。功能强大。<ul>
<li>与VisualVM类似</li>
</ul>
</li>
<li><code>Arthas</code>：<strong>Alibaba开源的Java诊断工具</strong>。深受开发者喜爱。</li>
<li><code>Btrace</code>：Java运行时追踪工具。<strong>可以在不停机的情况下，跟踪指定的方法调用、构造函数调用和系统内存等信息</strong>。</li>
</ul>
</li>
</ul>
<h4 id="2、JConsole"><a href="#2、JConsole" class="headerlink" title="2、JConsole"></a>2、JConsole</h4><h5 id="1、基本概述"><a href="#1、基本概述" class="headerlink" title="1、基本概述"></a>1、基本概述</h5><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html">官方教程</a></p>
<p>jconsole：</p>
<ul>
<li>从Java5开始，在JDK中自带的java监控和管理控制台。</li>
<li>用于对JVM中内存、线程和类等的监控，是一个基于JMX(java management extensions )的GUI性能监控工具。</li>
</ul>
<h5 id="2、启动"><a href="#2、启动" class="headerlink" title="2、启动"></a>2、启动</h5><ul>
<li>在jdk安装目录中找到jconsole.exe，双击该可执行文件就可以</li>
<li>打开DOS窗口，直接输入jconsole就可以了</li>
</ul>
<h5 id="3、三种连接方式"><a href="#3、三种连接方式" class="headerlink" title="3、三种连接方式"></a>3、三种连接方式</h5><ul>
<li><p>Local</p>
<ul>
<li><p>使用JConsole连接一个正在本地系统运行的JVM，并且执行程序的和运行JConsole的需要是<strong>同一个用户</strong>。</p>
</li>
<li><p>JConsole使用文件系统的授权通过RMI连接起链接到平台的MBean的服务器上。这种从本地连接的监控能力只有Sun的JDK具有。</p>
</li>
<li><p>注意：本地连接要求 <strong>启动jconsole的用户</strong> 和 <strong>运行当前程序的用户</strong> 是<strong>同一个用户</strong></p>
</li>
<li><p>具体操作如下：</p>
<ol>
<li><p>在DOS窗口中输入jconsole</p>
<p><img src="/2021/04/19/JVM/A0E6C592-F80C-46EF-9CD8-23255A6B1345.png" alt="img"></p>
</li>
<li><p>在控制台上填写相关信息</p>
<p><img src="/2021/04/19/JVM/868C881D-5F82-440F-B003-DD32C76BFF1D.png" alt="img"></p>
</li>
<li><p>选择“不安全的连接”</p>
<p><img src="/2021/04/19/JVM/D561C7B9-0F68-4DFC-AEB1-5F2526224F7D.png" alt="img"></p>
</li>
<li><p>进入控制台页面</p>
<p><img src="/2021/04/19/JVM/BE7AB453-2FD4-4173-A849-7D3848CB8076.png" alt="img"></p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>Remote</p>
<ul>
<li>使用下面的URL通过RMI连接器连接到一个JMX代理，service:jmx:rmi:///jndi/rmi://hostName:portNum/jmxrmi。</li>
<li>JConsole为建立连接，需要在环境变量中设置mx.remote.credentials来指定用户名和密码，从而进行授权。</li>
</ul>
</li>
<li><p>Advanced</p>
<ul>
<li>使用一个特殊的URL连接JMX代理。</li>
<li>一般情况使用自己定制的连接器而不是RMI提供的连接器来连接JMX代理，或者是一个使用JDK1.4的实现了JMX和JMX Rmote的应用</li>
</ul>
</li>
</ul>
<h5 id="4、主要作用"><a href="#4、主要作用" class="headerlink" title="4、主要作用"></a>4、主要作用</h5><ol>
<li><p>概览</p>
<p><img src="/2021/04/19/JVM/325B8E74-20E5-4289-A7C6-145D73501D7E.png" alt="img"></p>
</li>
<li><p>内存</p>
<p><img src="/2021/04/19/JVM/image-20210716160243770.png" alt="image-20210716160243770"></p>
</li>
<li><p>根据线程检测死锁</p>
<p><img src="/2021/04/19/JVM/1F2A8CD4-75F7-48CF-8009-88508BDAB8C9.png" alt="img"></p>
</li>
<li><p>线程</p>
<p><img src="/2021/04/19/JVM/E617AFA7-4D51-41B9-97D4-2DA665C649B0.png" alt="img"></p>
</li>
<li><p>VM 概要</p>
<p><img src="/2021/04/19/JVM/799061CC-841C-475A-8B05-9DB923786A25.png" alt="img"></p>
</li>
</ol>
<h4 id="3、Visual-VM"><a href="#3、Visual-VM" class="headerlink" title="3、Visual VM"></a>3、Visual VM</h4><h5 id="1、基本概述-1"><a href="#1、基本概述-1" class="headerlink" title="1、基本概述"></a>1、基本概述</h5><ul>
<li><p>VisualVM是一个功能强大的多合一故障诊断和性能监控的可视化工具。</p>
</li>
<li><p>它集成了多个JDK命令行工具，使用VisualVM可用于显示虚拟机进程及进程的配置和环境信息(jps、jinfo)，监视应用程序的CPU、GC、堆、方法区及线程的信息(jstat、jstack)等， 也可以代替JConsole。</p>
</li>
<li><p>在JDK 6 Update 7以后，Visual VM便作为JDK的一部分发布(VisualVM在JDK/bin目录下)</p>
<ul>
<li>即:它完全免费。</li>
</ul>
</li>
<li><p>此外，Visual VM也可以作为独立的软件安装：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://visualvm.github.io/index.html">首页</a></p>
<p><img src="/2021/04/19/JVM/image-20210713172559297.png" alt="image-20210713172559297"></p>
</li>
</ul>
</li>
<li><p>使用：</p>
<ol>
<li>在jdk安装目录中找到jvisualvm.exe，然后双击执行即可</li>
<li>打开DOS窗口，输入jvisualvm就可以打开该软件</li>
</ol>
</li>
</ul>
<h5 id="2、插件的安装"><a href="#2、插件的安装" class="headerlink" title="2、插件的安装"></a>2、插件的安装</h5><ul>
<li><p>Visual VM的一大特点是支持插件扩展，并且插件安装非常方便。我们既可以通过离线下载插件文件*.nbm，然后在Plugin对话框的已下载页面下，添加已下载的插件。也可以在可用插件页面下，在线安装插件。(这里建议安装上：VisualGC)</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://visualvm.github.io/pluginscenters.html">插件地址</a></li>
<li><img src="/2021/04/19/JVM/image-20210713173016278.png" alt="image-20210713173016278"></li>
</ul>
</li>
<li><p>IDEA安装VisualVM Launcher插件：Preferences –&gt; Plugins –&gt; 搜索VisualVM Launcher，安装重启即可。</p>
<ol>
<li><p>在IDEA中安装插件：首先在IDEA中搜索VisualVM Launcher插件并安装</p>
<p><img src="/2021/04/19/JVM/7A9DB07F-B142-443B-AE82-3D622F681CBB.png" alt="img"></p>
</li>
<li><p>重启IDEA，然后配置该插件：</p>
<p><img src="/2021/04/19/JVM/2E657142-FEFF-46CA-9772-630EF5F6625B.png" alt="img"></p>
</li>
<li><p>使用两种方式来运行程序：</p>
<p><img src="/2021/04/19/JVM/341C9DA7-8275-45B7-B3E3-4FBF924B3C14.png" alt="img"></p>
</li>
<li><p>运行效果：还是打开jvisualvm界面，只是不需要我们手动打开jvisualvm而已</p>
</li>
</ol>
</li>
</ul>
<h5 id="3、连接方式"><a href="#3、连接方式" class="headerlink" title="3、连接方式"></a>3、连接方式</h5><ul>
<li>本地连接<ul>
<li>监控本地Java进程的CPU、类、线程等</li>
</ul>
</li>
<li>远程连接<ol>
<li>确定远程服务器的ip地址</li>
<li>添加JMX（通过JMX技术具体监控远程服务器哪个Java进程）</li>
<li><strong>修改bin/catalina.sh文件，连接远程的tomcat</strong></li>
<li>在…/conf中添加jmxremote.access和jmxremote.password文件</li>
<li><strong>将服务器地址改成公网ip地址</strong></li>
<li>设置阿里云安全策略和防火墙策略</li>
<li><strong>启动tomcat，查看tomcat启动日志和端口监听</strong></li>
<li><strong>JMX中输入端口号、用户名、密码登录</strong></li>
</ol>
</li>
</ul>
<h5 id="4、主要功能"><a href="#4、主要功能" class="headerlink" title="4、主要功能"></a>4、主要功能</h5><ol>
<li><p>生成/读取/对比堆内存快照</p>
<ul>
<li><p>生成堆内存快照：</p>
<ol>
<li><p>方式1：</p>
<p><img src="/2021/04/19/JVM/CE28D8DD-9A19-493F-95F7-9BD7B90988F3.png" alt="img"></p>
</li>
<li><p>方式2：</p>
<p><img src="/2021/04/19/JVM/CBC75128-C200-4DE3-A4B0-5DB55CB31DB5.png" alt="img"></p>
<p>注意：</p>
<p>生成堆内存快照如下图：<img src="/2021/04/19/JVM/C05DD49F-02F5-4718-87FD-0FB5823860BD.png" alt="img"></p>
<p>这些快照存储在内存中，当线程停止的时候快照就会丢失，如果还想利用，可以将快照进行另存为操作，如下图：</p>
<p><img src="/2021/04/19/JVM/A441FACD-AAB9-4EC2-B81E-3413BF211421.png" alt="img"></p>
</li>
</ol>
</li>
<li><p>装入堆内存快照</p>
<p><img src="/2021/04/19/JVM/ED1AC2B2-9CF5-41BD-A261-9C7685316D70-1626169886879.png" alt="img"></p>
</li>
<li><p>dump文件对比</p>
<p><img src="/2021/04/19/JVM/image-20210716164337161.png" alt="image-20210716164337161"></p>
</li>
</ul>
</li>
<li><p>查看JVM参数和系统属性</p>
</li>
<li><p>查看运行中的虚拟机进程</p>
</li>
<li><p>生成/读取线程快照</p>
<ul>
<li><p>生成线程快照</p>
<ol>
<li><p>方式1：</p>
<p><img src="/2021/04/19/JVM/1FCBDF6F-9E41-4631-A0F8-9032E3B610F7.png" alt="img"></p>
</li>
<li><p>方式2：</p>
<ul>
<li><p>注意：</p>
<p>生成线程快照如下图：<img src="/2021/04/19/JVM/EBBFD997-9D8C-4B7C-BEAE-763BD685E5C3.png" alt="img"></p>
<p>这些快照存储在内存中，当线程停止的时候快照就会丢失，如果还想利用，可以将快照进行另存为操作，如下图：</p>
<p><img src="/2021/04/19/JVM/77171DE3-C335-4934-B071-4567BCB30DB9.png" alt="img"></p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>装入线程快照</p>
<p><img src="/2021/04/19/JVM/E882B309-4E74-4877-B6F0-D6A0EE176B71.png" alt="img"></p>
</li>
</ul>
</li>
<li><p>程序资源的实时监控</p>
</li>
<li><p>抽样器</p>
<ul>
<li><p>CPU</p>
<p><img src="/2021/04/19/JVM/image-20210716162615803.png" alt="image-20210716162615803"></p>
<p><img src="/2021/04/19/JVM/image-20210716163047115.png" alt="image-20210716163047115"></p>
<p><img src="/2021/04/19/JVM/image-20210716163251126.png" alt="image-20210716163251126"></p>
</li>
<li><p>内存</p>
<p><img src="/2021/04/19/JVM/image-20210716163651100.png" alt="image-20210716163651100"></p>
<p><img src="/2021/04/19/JVM/image-20210716163925557.png" alt="image-20210716163925557"></p>
</li>
</ul>
</li>
<li><p>其他功能</p>
<ol>
<li>JMX代理连接</li>
<li>远程环境监控</li>
<li>CPU分析和内存分析</li>
</ol>
</li>
</ol>
<h4 id="4、Eclipse-MAT"><a href="#4、Eclipse-MAT" class="headerlink" title="4、Eclipse MAT"></a>4、Eclipse MAT</h4><h5 id="1、基本概述-2"><a href="#1、基本概述-2" class="headerlink" title="1、基本概述"></a>1、基本概述</h5><p>MAT(Memory Analyzer Tool)工具是一款功能强大的Java堆内存分析器。可以用于查找内存泄漏以及查看内存消耗情况</p>
<p>MAT是基于Eclipse开发的， 不仅可以单独使用，还可以作为插件的形式嵌入在Eclipse中使用。是一款免费的性能分析工具，使用起来非常方便。大家可以在<br><a target="_blank" rel="noopener" href="https://www.eclipse.org/mat/downloads.php">下载</a>并使用MAT。</p>
<p><img src="/2021/04/19/JVM/image-20210713175646382.png" alt="image-20210713175646382"></p>
<p>只要确保机器上装有JDK并配置好相关的环境变量，MAT可正常启动。还可以在Eclipse中以插件的方式安装：</p>
<p><img src="/2021/04/19/JVM/image-20210713175744891.png" alt="image-20210713175744891"></p>
<p>注意：如果单独使用，那么解压即可用，不需要安装即可</p>
<h5 id="2、获取堆dump文件"><a href="#2、获取堆dump文件" class="headerlink" title="2、获取堆dump文件"></a>2、获取堆dump文件</h5><h6 id="1、dump文件内存"><a href="#1、dump文件内存" class="headerlink" title="1、dump文件内存"></a>1、dump文件内存</h6><p>MAT可以分析heap dump文件。 在进行内存分析时，只要获得了反映当前设备内存映像的hprof文件，通过MAT打开就可以直观地看到当前的内存信息。</p>
<p>一般说来，这些内存信息包含：</p>
<ul>
<li><strong>所有的对象信息</strong>，包括对象实例、成员变量、存储于栈中的基本类型值和存储于堆中的其他对象的引用值。</li>
<li><strong>所有的类信息</strong>，包括classloader、 类名称、父类、静态变量等GCRoot到所有的这些对象的引用路径</li>
<li><strong>线程信息</strong>，包括线程的调用栈及此线程的线程局部变量(TLS)</li>
</ul>
<h6 id="2、两点说明"><a href="#2、两点说明" class="headerlink" title="2、两点说明"></a>2、两点说明</h6><ul>
<li><p>说明1：缺点：<br>MAT 不是一个万能工具，它并不能处理所有类型的堆存储文件。但是比较主流的厂家和格式，例如 Sun，HP，SAP所采用的HPROF二进制堆存储文件，以及IBM的PHD堆存储文件等都能被很好的解析。</p>
</li>
<li><p>说明2：<br>最吸引人的还是能够快速为开发人员生成<strong>内存泄漏报表</strong>，方便定位问题和分析问题。虽然MAT有如此强大的功能，但是内存分析也没有简单到一键完成的程度，很多内存问题还是需要我们从MAT展现给我们的信息当中通过经验和直觉来判断才能发现。</p>
<p><img src="/2021/04/19/JVM/image-20210713180221126.png" alt="image-20210713180221126"></p>
</li>
</ul>
<h6 id="3、获取dump文件"><a href="#3、获取dump文件" class="headerlink" title="3、获取dump文件"></a>3、获取dump文件</h6><ol>
<li><p>方法一：通过前一章介绍的jmap工具生成，可以生成任意一个java进程的dump文件；</p>
</li>
<li><p>方法二：通过配置JVM参数生成。</p>
<ul>
<li>选项”<code>-XX:+HeapDumpOnOutOfMemoryError</code>“ 或”<code>-XX:+HeapDumpBeforeFullGC</code>“</li>
<li>选项”<code>-XX:HeapDumpPath</code>“所代表的含义就是当程序出现0utofMemory时， 将会在相应的目录下生成一份dump文件。如果不指定选项“<code>-XX:HeapDumpPath</code>“ 则在当前目录下生成dump文件。</li>
<li>对比：考虑到生产环境中几乎不可能在线对其进行分析，大都是采用离线分析，因此<strong>使用jmap+MAT工具是最常见的组合</strong>。</li>
</ul>
</li>
<li><p>方法三：使用VisualVM可以导出堆dump文件</p>
</li>
<li><p>方法四：使用MAT既可以打开一个已有的堆快照，也可以通过MAT直接从活动Java程序中导出堆快照。该功能将借助jps列出当前正在运行的Java进程，以供选择并获取快照。</p>
<p><img src="/2021/04/19/JVM/image-20210713180452468.png" alt="image-20210713180452468"></p>
</li>
</ol>
<h5 id="4、加载dump文件"><a href="#4、加载dump文件" class="headerlink" title="4、加载dump文件"></a>4、加载dump文件</h5><p><img src="/2021/04/19/JVM/image-20210716175656605.png" alt="image-20210716175656605"></p>
<p><img src="/2021/04/19/JVM/image-20210716175803107.png" alt="image-20210716175803107"></p>
<p><img src="/2021/04/19/JVM/image-20210716180242326.png" alt="image-20210716180242326"></p>
<p>相关解释：</p>
<p><img src="/2021/04/19/JVM/image-20210716180320235.png" alt="image-20210716180320235"></p>
<ul>
<li>Leak Suspects Report（堆泄露疑点报告）：<ul>
<li>自动检查堆转储是否存在泄漏嫌疑。 报告哪些对象保持活动状态以及为什么它们没有被垃圾回收器回收。</li>
</ul>
</li>
<li>Component Report（组件报告）：<ul>
<li>分析一组对象是否存在疑似内存问题：重复字符串、空集合、终结器、弱引用等</li>
</ul>
</li>
<li>Re-open previously run reports（重新打开以前运行的报告）：<ul>
<li>现有报告存储在堆dump同一目录下的 ZIP 文件中</li>
</ul>
</li>
</ul>
<h5 id="4、分析堆dump文件"><a href="#4、分析堆dump文件" class="headerlink" title="4、分析堆dump文件"></a>4、分析堆dump文件</h5><p>相关图例：</p>
<p><img src="/2021/04/19/JVM/B41B4FEA-D55D-442D-A163-E5D7F1BFC720.png" alt="img"><img src="/2021/04/19/JVM/EC747FF8-CCC3-4F57-8C68-59E5819C76A4.png" alt="img"><img src="/2021/04/19/JVM/D4FED4A9-A16E-4E4A-9ECB-69986F952F89.png" alt="img"></p>
<p>通过分析堆dump文件可以得到：</p>
<ul>
<li><p>是否存在类的重复加载：</p>
<p><img src="/2021/04/19/JVM/image-20210716183006378.png" alt="image-20210716183006378"></p>
</li>
<li><p>相关的报告：</p>
<p><img src="/2021/04/19/JVM/image-20210716181822026.png" alt="image-20210716181822026"></p>
<ul>
<li><p>Heap Dump Overview（堆dump的概述）：</p>
<p><img src="/2021/04/19/JVM/image-20210716182152051.png" alt="image-20210716182152051"></p>
</li>
<li><p>Leak Suspects（堆泄露疑点）:</p>
<p><img src="/2021/04/19/JVM/image-20210716182746036.png" alt="image-20210716182746036"></p>
</li>
<li><p>Top Components（顶级组件）：通过图形列举出最大对象的情况</p>
<p><img src="/2021/04/19/JVM/image-20210716182455029.png" alt="image-20210716182455029"></p>
</li>
</ul>
</li>
<li><p>histogram：展示了各个类的实例数目以及这些实例的Shallow heap或者Retained heap的总和</p>
<ul>
<li><p>使用：</p>
<ul>
<li><p>图标：</p>
<p><img src="/2021/04/19/JVM/87E5409D-B6AA-40E5-B033-6E92EB196C96.png" alt="img"></p>
</li>
<li><p>具体内容：</p>
<p><img src="/2021/04/19/JVM/287C8259-7835-4EF6-A81E-7C369B8D3336.png" alt="img"></p>
</li>
<li><p>查找一个类：</p>
<ol>
<li><p>Group by package (根据包进行分组)：（默认是Group by class）</p>
<p><img src="/2021/04/19/JVM/image-20210716223222052.png" alt="image-20210716223222052"></p>
<p><img src="/2021/04/19/JVM/image-20210716223315860.png" alt="image-20210716223315860"></p>
</li>
<li><p>排序：</p>
<p><img src="/2021/04/19/JVM/image-20210716223613860.png" alt="image-20210716223613860"></p>
</li>
<li><p>正则表达式：（精准搜索）</p>
<p><img src="/2021/04/19/JVM/image-20210716223803061.png" alt="image-20210716223803061"></p>
</li>
</ol>
</li>
<li><p>若一个对象可能存在内存泄露（内存泄露疑点），怎么查看？</p>
<p><img src="/2021/04/19/JVM/image-20210716224553500.png" alt="image-20210716224553500"></p>
</li>
<li><p>将两份内存映像文件的直方图进行对比：（以下图片的”树状图”修改为”直方图”）</p>
<p><img src="/2021/04/19/JVM/image-20210716225637523.png" alt="image-20210716225637523"></p>
<p><img src="/2021/04/19/JVM/image-20210716230023991.png" alt="image-20210716230023991"></p>
<p><img src="/2021/04/19/JVM/image-20210716230040409.png" alt="image-20210716230040409"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>thread overview</p>
<ul>
<li><p>查看系统中的Java线程</p>
</li>
<li><p>查看局部变量的信息</p>
</li>
<li><p>使用：</p>
<ul>
<li><p>图标：</p>
<p><img src="/2021/04/19/JVM/E9E4312D-A369-4C56-B612-DF6C90BD9A18.png" alt="img"></p>
</li>
<li><p>具体内容：</p>
<p><img src="/2021/04/19/JVM/9D534AD4-631B-4D78-865B-C793FC61B7C6.png" alt="img"></p>
<p><img src="/2021/04/19/JVM/image-20210716232006164.png" alt="image-20210716232006164"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>获得对象互相引用的关系</p>
<ul>
<li><p>with outgoing references（出引用）</p>
<ul>
<li><p>图示：</p>
<p><img src="/2021/04/19/JVM/ECADFB9B-708C-4CCC-82C5-8ECDFC6C8E98.png" alt="img"></p>
</li>
<li><p>结果：</p>
<p><img src="/2021/04/19/JVM/F9D58850-F866-4BA6-B5FB-B8508276B4C6.png" alt="img"></p>
</li>
</ul>
</li>
<li><p>with incoming references（入引用）</p>
<ul>
<li><p>图示：</p>
<p><img src="/2021/04/19/JVM/1EE1EDA8-FE05-4FBA-8D19-2518FCFCFD32.png" alt="img"></p>
</li>
<li><p>结果：</p>
<p><img src="/2021/04/19/JVM/9BA2E3BF-8700-4610-8A4D-45A3B662ACB1.png" alt="img"></p>
</li>
<li><p>分析：</p>
<ul>
<li>若发现此时该对象只有一些生命周期较短的线程(方法/方法里的引用变量)去引用它，则该对象就是可以被GC进行回收，不会存在内存泄露问题</li>
<li>若发现此时该对象还有另外一些生命周期较长的线程(方法/方法里的引用变量)去引用它，则该对象就不能被GC回收，就存在了内存泄露问题。</li>
<li>解决方法：可以将该引用从强引用修改为软引用或弱引用。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>浅堆与深堆（与浅拷贝与深拷贝一一对应）</p>
<ul>
<li><p>shallow heap</p>
<ul>
<li><p>浅堆(Shallow Heap)是指一个对象所消耗的内存。在32位系统中，一个对象引用会占据4个字节，一个int类型会占据4个字节，long型变量会占据8个字节，每个对象头需要占用8个字节。根据堆快照格式不同，对象的大小可能会向8字节进行对齐。</p>
</li>
<li><p>以String为例：2个int值共占8字节，对象引用占用4字节，对象头8字节，合计20字节，向8字节对齐，故占24字节。(jdk7中)</p>
<p><img src="/2021/04/19/JVM/image-20210713181653120.png" alt="image-20210713181653120"></p>
</li>
<li><p>这24字节为String对象的浅堆大小。它与String的value实际取值无关，无论字符串长度如何，浅堆大小始终是24字节。</p>
</li>
<li><p>对象头代表根据类创建的对象的对象头，还有对象的大小不是可能向8字节对齐，而是就向8字节对齐(一定)。</p>
</li>
<li><p>注意一下：这里对象头除去类型指针的大小为8字节，然后类型指针看是否启用了引用压缩，如果启用了，对象头总共就是12字节，否则就是16字节。（32位机是不支持指针压缩的）</p>
</li>
</ul>
</li>
<li><p>retained heap</p>
<ul>
<li>保留集(Retained Set)：<ul>
<li>对象A的保留集指当对象A被垃圾回收后，可以被释放的所有的对象集合(包括对象A本身)，即对象A的保留集可以被认为是<strong>只能通过</strong>对象A被直接或间接访问到的所有对象的集合。通俗地说，就是指<strong>仅被对象A所持有的对象的集合</strong>。</li>
</ul>
</li>
<li>深堆(Retained Heap)：<ul>
<li>深堆是指<strong>对象的保留集中所有的对象的浅堆大小之和</strong>。</li>
<li>注意：<ul>
<li><strong>浅堆指对象本身占用的内存，不包括其内部引用对象的大小</strong>。<strong>一个对象的深堆指只能通过该对象访问到的(直接或间接)所有对象的浅堆之和，即对象被回收后，可以释放的真实空间</strong>。</li>
<li><strong>当前深堆大小 = 当前对象的浅堆大小 + 对象中所包含对象的深堆大小</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>补充：对象实际大小</p>
<ul>
<li><p>另外一个常用的概念是对象的实际大小。这里，对象的实际大小定义为一个对象<strong>所能触及的</strong>（这里要与<strong>深堆的”只有通过”**相区分）所有对象的浅堆大小之和，也就是通常意义上我们说的</strong>对象大小<strong>。与深堆相比，似乎这个在日常开发中更为直观和被人接受，</strong>但实际上，这个概念和垃圾回收无关**。</p>
</li>
<li><p>下图显示了一个简单的对象引用关系图，对象A引用了C和D，对象B引用了C和E。那么<strong>对象A的<code>浅堆</code>大小只是A本身</strong>，不含C和D，而<strong>A的<code>实际大小</code>为A、C、D三者之和</strong>。而<strong>A的<code>深堆</code>大小为A与D之和</strong>，由于对象C还可以通过对象B访问到，因此不在对象A的深堆范围内。</p>
<p><img src="/2021/04/19/JVM/image-20210713182436604.png" alt="image-20210713182436604"></p>
</li>
</ul>
</li>
<li><p>练习</p>
<ul>
<li><p>看图理解Retained Size</p>
<p><img src="/2021/04/19/JVM/image-20210713182530946.png" alt="image-20210713182530946"></p>
</li>
<li><p>解答：</p>
<ul>
<li>上图中，GC Roots直接引用了A和B两个对象。</li>
<li>A对象的Retained Size = A对象的Shallow Size</li>
<li>B对象的Retained Size = B对象的Shallow Size + C对象的Shallow Size</li>
<li>这里不包括D对象，因为D对象被GC Roots直接引用。</li>
</ul>
</li>
<li><p>如果GC Roots不引用D对象呢?</p>
<ul>
<li>那么B对象的Retained Size = B对象的Shallow Size + C对象的Shallow Size + D对象的Shallow Size</li>
<li>因为此时的D对象只有通过B对象进行引用</li>
</ul>
</li>
</ul>
</li>
<li><p>案例分析：StudentTrace</p>
<ul>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有一个学生浏览网页的记录程序，它将记录 每个学生访问过的网站地址。</span></span><br><span class="line"><span class="comment"> * 它由三个部分组成：Student、WebPage和StudentTrace三个类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  -XX:+HeapDumpBeforeFullGC -XX:HeapDumpPath=d:\student.hprof</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 16:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTrace</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;WebPage&gt; webpages = <span class="keyword">new</span> ArrayList&lt;WebPage&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createWebPages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            WebPage wp = <span class="keyword">new</span> WebPage();</span><br><span class="line">            wp.setUrl(<span class="string">&quot;http://www.&quot;</span> + Integer.toString(i) + <span class="string">&quot;.com&quot;</span>);</span><br><span class="line">            wp.setContent(Integer.toString(i));</span><br><span class="line">            webpages.add(wp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        createWebPages();<span class="comment">//创建了100个网页</span></span><br><span class="line">        <span class="comment">//创建3个学生对象</span></span><br><span class="line">        Student st3 = <span class="keyword">new</span> Student(<span class="number">3</span>, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        Student st5 = <span class="keyword">new</span> Student(<span class="number">5</span>, <span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">        Student st7 = <span class="keyword">new</span> Student(<span class="number">7</span>, <span class="string">&quot;Lily&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; webpages.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % st3.getId() == <span class="number">0</span>)</span><br><span class="line">                st3.visit(webpages.get(i));</span><br><span class="line">            <span class="keyword">if</span> (i % st5.getId() == <span class="number">0</span>)</span><br><span class="line">                st5.visit(webpages.get(i));</span><br><span class="line">            <span class="keyword">if</span> (i % st7.getId() == <span class="number">0</span>)</span><br><span class="line">                st7.visit(webpages.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        webpages.clear();</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;WebPage&gt; history = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;WebPage&gt; <span class="title">getHistory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> history;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHistory</span><span class="params">(List&lt;WebPage&gt; history)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.history = history;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(WebPage wp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (wp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            history.add(wp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebPage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUrl</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>图示：</p>
<p><img src="/2021/04/19/JVM/69656EBC-5090-4781-A02A-E1584AC06230.png" alt="img"></p>
</li>
<li><p>结论：</p>
<ul>
<li>这里三个学生对象的浅堆大小都是24字节：4(id) + 4(name) + 4(history) + 8(对象头) = 20 –&gt; 24（向8字节对齐）<ul>
<li>其实这里如果是32位虚拟机，需要补对齐填充。</li>
<li>但如果不是是32位虚拟机，而且存在类型指针压缩的话：对象头应该有12字节 –&gt; 4 + 4 + 4 + 12 = 24</li>
<li>普通Java对象头的大小为12字节或16字节，默认采用了指针压缩则为12字节，没有采用则为16字节（数组还需要加上数组长度）</li>
<li>同理每一个网页的浅堆大小也都是24字节4(url) + 4(content) + 12(对象头) = 20 –&gt; 24（向8字节对齐）</li>
</ul>
</li>
</ul>
</li>
<li><p>解释：（为什么elementData数组的深堆为1288个字节）</p>
<ul>
<li>普通Java对象头的大小为12字节或16字节。默认采用了指针压缩则为12字节，没有采用则为16字节（数组还需要加上数组长度）。详情参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/shangshanzixu/article/details/114828860?spm=1001.2014.3001.5501">博客</a>。</li>
<li>为什么有152字节和144字节：<ul>
<li>因为我们的URL和content存在两种情况（个位数与十位数）<ul>
<li>URL：<a target="_blank" rel="noopener" href="http://www.7.com/">http://www.7.com</a>    content：7</li>
<li>URL：<a target="_blank" rel="noopener" href="http://www.14.com/">http://www.14.com</a>    content：14</li>
</ul>
</li>
<li>第一种URL长度为16，底层的char数组的占用空间为(【】方括号里面整个都属于对象头，分开写方便大家理解)<ul>
<li>【普通对象头(12) + 数组长度(4)】 + 16个字符(32) = 48字节，符合8字节对齐</li>
<li>同理content 占用 【普通对象头(12) +数组长度(4)】+ 一个字符(2) = 18字节，八字节对齐 = 24字节</li>
</ul>
</li>
<li>第二种URL长度为17，底层的插入数组的占用空间为<ul>
<li>【普通对象头(12) + 数组长度(4)】 + 17个字符(34) = 50字节，不符合8字节对齐，对齐为56</li>
<li>同理content 占用 【普通对象头(12) +数组长度(4)】+ 两个字符(4) = 20字节，八字节对齐 = 24字节</li>
</ul>
</li>
<li>所以第一种总字节为48 + 24 = 72，第二种总字节为56 + 24 = 80。因此第二种比第一种多了8字节，所以是152和144</li>
<li>为什么总大小是152而不是72？<ul>
<li>因为我们只计算了String底层的char数组的区别没有计算各变量本身的浅堆，因为结构都相同，所以差别就差在内容的占用上</li>
</ul>
</li>
</ul>
</li>
<li>为什么最终结果是1288？<ul>
<li>首先ElementData数组本身的浅堆大小为：【普通对象头(12) + 数组长度(4)】 + 数组内容【15个Obejct引用 = 15 * 4】 = 76，八字节对齐 = 80字节</li>
<li>15个Object分为13个152字节 + 2个144字节，总大小为 = 2264字节</li>
<li>7号和其他student重复的有0、21、42、63、84、35、70总计6个152和1一个144</li>
<li>所以2264 - 6 * 152 - 144 = 1208字节</li>
<li>所以ElementData本身的浅堆80 + 仅能通过它到达的浅堆1208 = 1288</li>
</ul>
</li>
<li>为什么ArrayList的长度是15？（并不是因为ArrayList的内容是15个，对于Jerry同学来说：ArrayList的长度是22，但是ArrayList的内容只有21）<ul>
<li>这是和ArrayList的扩容有关</li>
<li>ArrayList默认的长度为10，当长度超过10的时候，ArrayList就会自动扩容，扩容系数是0.5</li>
<li>即ArrayList的长度 = 10 * 1.5 = 15</li>
<li>当超过扩容后的长度（15），ArrayList会再次扩容：15 * 1.5 = 22</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>支配树</p>
<ul>
<li><p>支配树(Dominator Tree )(支配树的概念源自图论（统计学）)</p>
</li>
<li><p>MAT提供了一个称为支配树(Dominator Tree) 的对象图。支配树体现了对象实例间的支配关系。在对象引用图中，<strong>所有指向对象B的路径都经过对象A，则认为对象A支配对象B</strong>。如果对象A是离对象B最近的一个支配对象，则认为对象A为对象B的直接支配者。支配树是基于对象间的引用图所建立的，它有<br>以下基本性质：</p>
<ul>
<li>对象A的子树(所有被对象A支配的对象集合)表示对象A的保留集(retained set)，即深堆。</li>
<li>如果对象A支配对象B，那么对象A的直接支配者也支配对象B。</li>
<li>支配树的边与对象引用图的边不直接对应。</li>
</ul>
</li>
<li><p>如下图所示：左图表示对象引用图，右图表示左图所对应的支配树。对象A和B由根对象直接支配，由于在到对象C的路径中，可以经过A，也可以经过B，因此对象C的直接支配者也是根对象。对象F与对象D相互引用，因为到对象F的所有路径必然经过对象D，因此，对象D是对象F的直接支配者。而到对象D的所有路径中，必然经过对象C，即使是从对象F到对象D的引用，从根节点出发，也是经过对象C的，所以，对象D的直接支配者为对象C。同理，对象E支配对象G。到达对象H的可以通过对象D，也可以通过对象E，因此对象D和E都不能支配对<br>象H，而经过对象C既可以到达D也可以到达E，因此对象C为对象H的直接支配者。</p>
<p><img src="/2021/04/19/JVM/image-20210713185747798.png" alt="image-20210713185747798"></p>
</li>
<li><p>注意：</p>
<ul>
<li>跟随我一起来理解如何从“对象引用图—》支配树”，首先需要理解支配者（如果要到达对象B，毕竟经过对象A，那么对象A就是对象B的支配者，可以想到支配者大于等于1），</li>
<li>然后需要理解直接支配者（在支配者中距离对象B最近的对象A就是对象B的直接支配者，你要明白直接支配者不一定就是对象B的上一级，然后直接支配者只有一个），</li>
<li>然后还需要理解支配树是怎么画的，其实支配树中的对象与对象之间的关系就是直接支配关系，也就是上一级是下一级的直接支配者，只要按照这样的方式来作图，肯定能从“对象引用图 —》支配树”</li>
</ul>
</li>
<li><p>在Eclipse MAT工具中如何查看支配树：</p>
<ul>
<li><p>在MAT中，单击工具栏上的对象支配树按钮，可以打开对象支配树视图。</p>
<p><img src="/2021/04/19/JVM/image-20210714000259424.png" alt="image-20210714000259424"></p>
</li>
<li><p>下图显示了对象支配树视图的一部分。该截图显示部分Lily学生的history队列的直接支配对象。即当Lily对象被回收，也会一并回收的所有对象。显然能被3或者5整除的网页不会出现在该列表中，因为它们同时被另外两名学生对象引用。（15(总) - 7(被其他引用) = 8(可回收)）</p>
<p><img src="/2021/04/19/JVM/image-20210714000337354.png" alt="image-20210714000337354"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="4、案例：Tomcat堆溢出分析"><a href="#4、案例：Tomcat堆溢出分析" class="headerlink" title="4、案例：Tomcat堆溢出分析"></a>4、案例：Tomcat堆溢出分析</h5><ul>
<li><p>说明：</p>
<ul>
<li>Tomcat是最常用的Java Servlet容器之一 ， 同时也可以当做单独的Web服务器使用。Tomcat本身使用Java实现，并运行于Java虚拟机之上。在大规模请求时，Tomcat有可能会因为无法承受压力而发生内存溢出错误。这里根据一个被压垮的Tomcat的堆快照文件， 来分析Tomcat在崩溃时的内部情况。</li>
</ul>
</li>
<li><p>分析过程：</p>
<ul>
<li><p>查看大对象（主要分析的对象）：</p>
<p><img src="/2021/04/19/JVM/image-20210717034430939.png" alt="image-20210717034430939"></p>
</li>
<li><p>查看当前最大的对象它到底引用了哪些具体的内部结构：</p>
<p><img src="/2021/04/19/JVM/image-20210717034529989.png" alt="image-20210717034529989"></p>
</li>
<li><p>查看该大对象中哪一部分占用了大部分内存：</p>
<p><img src="/2021/04/19/JVM/image-20210717034627788.png" alt="image-20210717034627788"></p>
</li>
<li><p>继续往里查看：</p>
<p><img src="/2021/04/19/JVM/image-20210717034749850.png" alt="image-20210717034749850"></p>
</li>
<li><p>继续往里查看：</p>
<p><img src="/2021/04/19/JVM/image-20210717034836025.png" alt="image-20210717034836025"></p>
</li>
<li><p>找到出现问题的对象后，可以通过OOL语句查询出想要的对象</p>
<p><img src="/2021/04/19/JVM/C5ECFB6C-0D51-4735-964B-53A8E96BA1FB.png" alt="img"></p>
<p><img src="/2021/04/19/JVM/D6A4483C-4844-4025-A499-C0A2AAC65C9E.png" alt="img"></p>
</li>
<li><p>查看该对象的创建时间与结束时间，判断他是不是一个生命周期短的对象：</p>
<p><img src="/2021/04/19/JVM/2E17C8C1-34ED-48A7-BDAA-3CB7AC33C1A6.png" alt="img"></p>
</li>
<li><p>根据找到的信息进行分析：</p>
<p><img src="/2021/04/19/JVM/57EE2C6A-DB93-46D3-9BD4-36799EA74836.png" alt="img"></p>
</li>
</ul>
</li>
</ul>
<h5 id="5、支持使用OQL语言查询对象信息"><a href="#5、支持使用OQL语言查询对象信息" class="headerlink" title="5、支持使用OQL语言查询对象信息"></a>5、支持使用OQL语言查询对象信息</h5><p><img src="/2021/04/19/JVM/image-20210716181538800.png" alt="image-20210716181538800"></p>
<ul>
<li>SELECT子句</li>
<li>FROM子句</li>
<li>WHERE子句</li>
<li>内置对象与方法</li>
</ul>
<h4 id="5、JProfiler"><a href="#5、JProfiler" class="headerlink" title="5、JProfiler"></a>5、JProfiler</h4><h5 id="1、基本概述-3"><a href="#1、基本概述-3" class="headerlink" title="1、基本概述"></a>1、基本概述</h5><h6 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h6><p><a target="_blank" rel="noopener" href="https://www.ej-technologies.com/products/jprofiler/overview.html">官网下载地址</a></p>
<p>在运行Java的时候有时候想测试运行时占用内存情况，这时候就需要使用测试工具查看了。在eclipse里面有Eclipse Memory Analyzer tool (MAT)插件可以测试，而在IDEA中也有这么一个插件，就是JProfiler。</p>
<p>JProfiler是由ej-technologies公司开发的一款Java应用性能诊断工具。功能强大，但是收费。</p>
<h6 id="2、特点"><a href="#2、特点" class="headerlink" title="2、特点"></a>2、特点</h6><ul>
<li>使用方便、界面操作友好( 简单且强大)</li>
<li>对被分析的应用影响小(提供模板)</li>
<li>CPU, Thread , Memory分析功能尤其强大</li>
<li>支持对jdbc、noSql、jsp、servlet、socket等进行分析</li>
<li>支持多种模式(离线，在线)的分析</li>
<li>支持监控本地、远程的JVM</li>
<li>跨平台，拥有多种操作系统的安装版本</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210717185256510.png" alt="image-20210717185256510"></p>
<h6 id="3、主要功能"><a href="#3、主要功能" class="headerlink" title="3、主要功能"></a>3、主要功能</h6><ol>
<li>方法调用<ul>
<li>对方法调用的分析可以帮助您了解应用程序正在做什么，并找到提高其性能的方法</li>
</ul>
</li>
<li>内存分配<ul>
<li>通过分析堆上对象、引用链和垃圾收集能帮您修复内存泄露问题，优化内存使用</li>
</ul>
</li>
<li>线程和锁<ul>
<li>JProfiler提供多种针对线程和锁的分析视图助您发现多线程问题</li>
</ul>
</li>
<li>高级子系统<ul>
<li>许多性能问题都发生在更高的语义级别上。例如，对于JDBC调用，您可能希望找出执行最慢的SQL语句。JProfiler支持对这些子系统进行集成分析</li>
</ul>
</li>
</ol>
<h5 id="2、安装与配置"><a href="#2、安装与配置" class="headerlink" title="2、安装与配置"></a>2、安装与配置</h5><h6 id="1、下载与安装"><a href="#1、下载与安装" class="headerlink" title="1、下载与安装"></a>1、下载与安装</h6><p><a target="_blank" rel="noopener" href="https://www.ej-technologies.com/download/jprofiler/version_100">下载</a></p>
<p><img src="/2021/04/19/JVM/image-20210717190718552.png" alt="image-20210717190718552"></p>
<p><img src="/2021/04/19/JVM/image-20210717195706559.png" alt="image-20210717195706559"></p>
<h6 id="2、JProfiler中配置IDEA"><a href="#2、JProfiler中配置IDEA" class="headerlink" title="2、JProfiler中配置IDEA"></a>2、JProfiler中配置IDEA</h6><ol>
<li><p>IDE Integrations</p>
<p><img src="/2021/04/19/JVM/53F0D68B-B76A-42C8-B206-FBFBD8E96F86.png" alt="img"></p>
</li>
<li><p>选择合适的IDE版本</p>
<p><img src="/2021/04/19/JVM/7CCE5194-2D54-498E-A2B7-F2C52CB9FA44.png" alt="img"></p>
</li>
<li><p>开始集成</p>
<p><img src="/2021/04/19/JVM/2A83AB30-9586-4BA2-83C3-2CACA634B79B.png" alt="img"></p>
</li>
<li><p>正式集成</p>
<p><img src="/2021/04/19/JVM/2E384249-A75D-4F05-8921-D09FD08873D9.png" alt="img"></p>
</li>
<li><p>集成成功</p>
<p><img src="/2021/04/19/JVM/B8B68437-CC8B-4DA5-A498-4F8F784656B6.png" alt="img"></p>
</li>
<li><p>点击OK即可</p>
</li>
</ol>
<h6 id="3、IDEA集成JProfiler"><a href="#3、IDEA集成JProfiler" class="headerlink" title="3、IDEA集成JProfiler"></a>3、IDEA集成JProfiler</h6><ol>
<li><p>安装JProfiler插件</p>
<ol>
<li><p>方式1：在线安装</p>
<p><img src="/2021/04/19/JVM/74BCBC29-1574-45C9-9DAD-B02B2D93493C.png" alt="img"></p>
</li>
<li><p>方式2、离线安装</p>
<ol>
<li><p>首先下载插件：</p>
<p><img src="/2021/04/19/JVM/A496B566-DFF9-41E6-9F7E-C4665BF3D95C.png" alt="img"></p>
</li>
<li><p>准备离线安装：</p>
<p><img src="/2021/04/19/JVM/D2914CF9-9808-4C59-BADE-9C9ADBCAB41E.png" alt="img"></p>
</li>
<li><p>正式离线安装：</p>
<p><img src="/2021/04/19/JVM/947592B8-3F3F-4A6F-93BD-5443EB76F603.png" alt="img"></p>
</li>
</ol>
<p>注意：无论采用方式1还是方式2都需要重启IDEA</p>
</li>
</ol>
</li>
<li><p>将JProfiler配置到IDEA中</p>
<p><img src="/2021/04/19/JVM/D3C2F36C-E12B-45D2-8FA4-F9D8E4F95625.png" alt="img"></p>
</li>
</ol>
<h5 id="3、具体使用"><a href="#3、具体使用" class="headerlink" title="3、具体使用"></a>3、具体使用</h5><ul>
<li><p>启动：</p>
<p><img src="/2021/04/19/JVM/image-20210717220513329.png" alt="image-20210717220513329"></p>
<ul>
<li>相关说明：<ul>
<li>Profile a demo session or a saved session(配置demo会话或保存一个会话)：<ul>
<li>JProfiler附带了几个预先配置的演示会话。你可以让他们开始探索JProfiler的特征。</li>
</ul>
</li>
<li>Attach to a running JVM(连接到正在运行的JVM)：<ul>
<li>JProfiler可以连接到本地或远程运行的jvm，并动态地分析它们。一些附加模式下不支持功能。</li>
</ul>
</li>
<li>Profile an application server, locally or remotely(本地或远程配置应用程序服务器)：<ul>
<li>JProfiler提供了对所有主要应用服务器的广泛支持。两个应用服务器支持在此计算机和远程计算机上运行。</li>
</ul>
</li>
<li>Open a snapshot(打开快照)：<ul>
<li>JProfiler可以保存快照以及以后可以打开的所有分析结果。而且，它可以打开HPROF和PHD快照。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>数据采集方式</p>
<p><img src="/2021/04/19/JVM/image-20210717221829151.png" alt="image-20210717221829151"></p>
<ul>
<li>JProfier数据采集方式分为两种：<code>Sampling</code>(样本采集)和<code>Instrumentation</code> (重构模式)<ul>
<li><code>Instrumentation</code>：这是JProfiler全功能模式。在class加载之前，JProfier把相关功能代码写入到需要分析的class的bytecode中，对正在运行的jvm有一定影响。<ul>
<li>优点：功能强大。在此设置中，调用堆栈信息是准确的。</li>
<li>缺点：若要分析的class较多，则对应用的性能影响较大，CPU开销可能很高(取决于Filter的控制)。因此使用此模式一般配合Filter使用，只对特定的类或包进行分析</li>
</ul>
</li>
<li><code>Sampling</code>：类似于样本统计，每隔一定时间(5ms )将每个线程栈中方法栈中的信息统计出来。<ul>
<li>优点：对CPU的开销非常低，对应用影响小(即使你不配置任何Filter)</li>
<li>缺点：一些数据/特性不能提供(例如：方法的调用次数、执行时间)</li>
</ul>
</li>
<li>注：JProfiler本身没有指出数据的采集类型，这里的采集类型是针对方法调用的采集类型。因为JProfiler的绝大多数核心功能都依赖方法调用采集的数据，所以可以直接认为是JProfiler的数据采集类型。</li>
<li>推荐使用Sampling方式，足够用来分析OOM问题了</li>
</ul>
</li>
</ul>
</li>
<li><p>遥感监测 Telemetries</p>
<p><img src="/2021/04/19/JVM/85704C41-F30E-4ED9-B48B-605C3102B485.png" alt="img"></p>
<ul>
<li>其中Telemetries就是遥感监测的意思</li>
</ul>
</li>
<li><p>内存视图 Live Memory</p>
<ul>
<li><p>Live memory（内存剖析）：class/class instance的相关信息。例如对象的个数， 大小，对象创建的方法执行栈，对象创建的热点。</p>
<ul>
<li><p><strong>所有对象All Objects</strong>：显示所有加载的类的列表和在堆上分配的实例数。只有Java 1.5 (JVMTI)才会显示此视图。(浅堆)</p>
<p><img src="/2021/04/19/JVM/image-20210717192307939.png" alt="image-20210717192307939"></p>
</li>
<li><p><strong>记录对象Record Objects</strong>：查看特定时间段对象的分配，并记录分配的调用堆栈。</p>
<ul>
<li><p>注意：默认关闭，若开启的话，会导致系统的性能急剧的降低。</p>
</li>
<li><p>开启的时机：判断内存泄露的时候开启</p>
</li>
<li><p>使用：</p>
<p><img src="/2021/04/19/JVM/image-20210717223524175.png" alt="image-20210717223524175"></p>
</li>
</ul>
</li>
<li><p><strong>分配访问树Allocation Call Tree</strong>：显示一棵请求树或者方法、 类、包或对己选择类有带注释的分配信息的J2EE组件。</p>
</li>
<li><p><strong>分配热点Allocation Hot Spots</strong>：显示一个列表，包括方法、类、包或分配已选类的J2EE组件。你可以标注当前值并且显示差异值。对<br>于每个热点都可以显示它的跟踪记录树。<br><strong>类追踪器Class Tracker</strong>：类跟踪视图可以包含任意数量的图表,显示选定的类和包的实例与时间。</p>
</li>
</ul>
</li>
<li><p>分析：内存中的对象的情况</p>
<ul>
<li>频繁创建的Java对象：死循环、循环次数过多</li>
<li>存在大的对象：读取文件时，byte[]应该边读边写。–&gt; 如果长时间不写出的话，导致byte[]过大</li>
<li>存在内存泄漏</li>
</ul>
</li>
<li><p>注意：</p>
<ol>
<li>All Objects后面的Size大小是浅堆大小</li>
<li>Record Objects在判断内存泄露的时候使用，可以通过观察Telemetries中的Memory，如果里面出现垃圾回收之后的内存占用逐步提高，这就有可能出现内存泄露问题，所以可以使用Record Objects查看，但是该分析默认不开启，毕竟占用CPU性能太多</li>
</ol>
</li>
</ul>
</li>
<li><p>堆遍历 heap walker</p>
<ul>
<li><p>如果通过内存视图 Live Memory已经分析出哪个类的对象不能进行垃圾回收，并且有可能导致内存溢出，如果想进一步分析，我们可以在该对象上点击右键，选择Show Selection In Heap Walker，如下图：</p>
<p><img src="/2021/04/19/JVM/C1C2C2AB-C31F-41A5-B0D2-7335030ECD2A.png" alt="img"></p>
</li>
<li><p>之后进行溯源，操作如下：</p>
<p><img src="/2021/04/19/JVM/64A630C1-126E-4C35-8088-4EEDDCF63FAE.png" alt="img"></p>
</li>
<li><p>查看结果，并根据结果去看对应的图表：</p>
<p><img src="/2021/04/19/JVM/1677A939-BCE7-45BC-901F-9BDA9846910D.png" alt="img"></p>
</li>
<li><p>以下是图表的展示情况：</p>
<p><img src="/2021/04/19/JVM/A3E2654E-81FF-4912-A588-549D817C69E0.png" alt="img"></p>
</li>
<li><p>对于堆快照：</p>
<p><img src="/2021/04/19/JVM/image-20210717224343240.png" alt="image-20210717224343240"></p>
</li>
</ul>
</li>
<li><p>cpu视图 cpu views</p>
<p><img src="/2021/04/19/JVM/image-20210717224827793.png" alt="image-20210717224827793"></p>
<ol>
<li><p>具体使用：</p>
<ol>
<li><p>访问树</p>
<p><img src="/2021/04/19/JVM/image-20210717225913334.png" alt="image-20210717225913334"></p>
</li>
<li><p>记录方法统计信息</p>
<p><img src="/2021/04/19/JVM/01B9832E-145E-485B-A877-6B6395B7FAA1.png" alt="img"></p>
</li>
<li><p>方法统计</p>
<p><img src="/2021/04/19/JVM/5FC6EA0C-FAF0-455C-94B6-8D9736E52657.png" alt="img"></p>
</li>
<li><p>具体分析</p>
<p><img src="/2021/04/19/JVM/510A019F-0C86-47FD-AC0B-CFEBC1B6C91C.png" alt="img"></p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>线程视图 threads</p>
<ul>
<li><p>JProfiler通过对线程历史的监控判断其运行状态，并监控是否有线程阻塞产生，还能将一个线程所管理的方法以树状形式呈现。对线程剖析。</p>
<ul>
<li><strong>线程历史Thread History</strong>：显示一个与线程活动和线程状态在一起的活动时间表。</li>
<li><strong>线程监控Thread Monitor</strong>：显示一个列表，包括所有的活动线程以及它们目前的活动状况。</li>
<li><strong>线程转储Thread Dumps</strong>：显示所有线程的堆栈跟踪。</li>
</ul>
</li>
<li><p>线程分析主要关心三个方面：</p>
<ol>
<li>web容器的线程最大数。比如: Tomcat的线程容量应该略大于最大并发数。</li>
<li>线程阻塞</li>
<li>线程死锁</li>
</ol>
</li>
<li><p>具体使用：</p>
<ol>
<li><p>查看线程运行情况</p>
<p><img src="/2021/04/19/JVM/62CB25DD-4C43-4B99-ADA7-00D4C52B1130.png" alt="img"></p>
</li>
<li><p>新建线程dump文件</p>
<p><img src="/2021/04/19/JVM/C7A7BFF7-D6E6-49D4-8718-4AADD60A24B3.png" alt="img"></p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>监视器&amp;锁 Monitors&amp;locks</p>
<ul>
<li><strong>监控和锁Monitors &amp; Locks</strong>所有线程持有锁的情况以及锁的信息。</li>
<li>观察JVM的内部线程并查看状态：<ul>
<li><strong>死锁探测图表Current Locking Graph</strong>：显示JVM中的当前死锁图表。</li>
<li><strong>目前使用的监测器CurrentMonitors</strong>：显示目前使用的监测器并且包括它们的关联线程。</li>
<li><strong>锁定历史图表Locking History Graph</strong>：显示记录在JVM中的锁定历史。</li>
<li><strong>历史检测记录MonitorHistory</strong>：显示重大的等待事件和阻塞事件的历史记录。</li>
<li><strong>监控器使用统计Monitor Usage Statistics</strong>：显示分组监测，线程和监测类的统计监测数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="4、案例分析"><a href="#4、案例分析" class="headerlink" title="4、案例分析"></a>4、案例分析</h5><h6 id="1、案例1（较为安全）"><a href="#1、案例1（较为安全）" class="headerlink" title="1、案例1（较为安全）"></a>1、案例1（较为安全）</h6><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JProfilerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">                Data data = <span class="keyword">new</span> Data();</span><br><span class="line">                list.add(data);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//1mb</span></span><br><span class="line">    <span class="keyword">private</span> String info = <span class="string">&quot;hello,atguigu&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2、案例2（内存泄露）"><a href="#2、案例2（内存泄露）" class="headerlink" title="2、案例2（内存泄露）"></a>2、案例2（内存泄露）</h6><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryLeak</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            ArrayList beanList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">                Bean data = <span class="keyword">new</span> Bean();</span><br><span class="line">                data.list.add(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">10</span>]);<span class="comment">//10kb</span></span><br><span class="line">                beanList.add(data);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">10</span>;</span><br><span class="line">    String info = <span class="string">&quot;hello,atguigu&quot;</span>;</span><br><span class="line">    <span class="comment">// ArrayList list = new ArrayList(); // 解决方法</span></span><br><span class="line">    <span class="keyword">static</span> ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<p>我们通过JProfiler来看一下，如下：</p>
<p><img src="/2021/04/19/JVM/E54DCC19-FD9D-4BC6-8A3A-45CED67B278B.png" alt="img"></p>
<p>你可以看到内存一个劲的往上涨，但是就是没有下降的趋势，说明这肯定有问题，过不了多久就会出现OOM，我们来到Live memory中，先标记看一下到底是哪些对象在进行内存增长，等一小下看看会不会触发垃圾回收，如果不触发的话，我们自己来触发垃圾回收，之后观察哪些对象没有被回收掉，如下：</p>
<p><img src="/2021/04/19/JVM/6D1D07AA-AC1C-4F26-8321-3A554F3B2F86.png" alt="img"></p>
<p>我上面点击了Mark Current，发现有些对象在持续增长，然后点击了一下Run GC，结果如下所示：</p>
<p><img src="/2021/04/19/JVM/F80A4EC9-9AF9-4DA1-8DDE-7442F34754CE.png" alt="img"></p>
<p>可以看出byte[]没有被回收，说明它是有问题的，我们点击Show Selection In Heap Walker，如下：</p>
<p><img src="/2021/04/19/JVM/3A3BE60F-7FC9-473B-B793-9B9C12186B0C.png" alt="img"></p>
<p>然后看一下该对象被谁引用，如下：</p>
<p><img src="/2021/04/19/JVM/CC9DBA1E-B6B1-4497-A27F-A2043E47E6B8.png" alt="img"></p>
<p>结果如下：</p>
<p><img src="/2021/04/19/JVM/C2335263-0DE6-4351-9B4A-F2DACE4AEDC3.png" alt="img"></p>
<p>可以看出byte[]来自于Bean类是的list中，并且这个list是ArrayList类型的静态集合，所以找到了：static ArrayList list = new ArrayList();</p>
<p>发现list是静态的，这不妥，因为我们的目的是while结束之后Bean对象被回收，并且Bena对象中的所有字段都被回收，但是list是静态的，那就是类的，众所周知，类变量随类而生，随类而灭，因此每次我们往list中添加值，都是往同一个list中添加值，这会造成list不断增大，并且不能回收，所以最终会导致OOM</p>
<h4 id="6、Arthas"><a href="#6、Arthas" class="headerlink" title="6、Arthas"></a>6、Arthas</h4><h5 id="1、基本概述-4"><a href="#1、基本概述-4" class="headerlink" title="1、基本概述"></a>1、基本概述</h5><h6 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h6><p>前面，我们介绍了jdk自带的jvisualvm等免费工具，以及商业化工具Jprofiler。</p>
<p>jvisualvm界面：</p>
<p><img src="/2021/04/19/JVM/image-20210718010802170.png" alt="image-20210718010802170"></p>
<p>Jprofiler界面：</p>
<p><img src="/2021/04/19/JVM/image-20210718010823344.png" alt="image-20210718010823344"></p>
<p>这两款工具在业界知名度也比较高，他们的优点是<strong>可以图形界面上看到各维度的性能数据</strong>，使用者根据这些数据进行综合分析，然后判断哪里出现了性能问题。</p>
<p>但是这两款工具也有个<strong>缺点</strong>，都必须在服务端项目进程中配置相关的监控参数。然后工具通过远程连接到项目进程，获取相关的数据。这样就会带来一些不便，比如线上环境的网络是隔离的，本地的监控工具根本连不上线上环境。并且类似于Jprofiler这样的商业工具，是需要付费的。</p>
<p>那么有没有一款工具<strong>不需要远程连接</strong>，也<strong>不需要配置监控参数</strong>，同时也<strong>提供了丰富的性能监控数据</strong>呢?</p>
<p>今天跟大家介绍一款<strong>阿里巴巴开源的性能分析神器Arthas (阿尔萨斯)</strong></p>
<h6 id="2、概述"><a href="#2、概述" class="headerlink" title="2、概述"></a>2、概述</h6><p><img src="/2021/04/19/JVM/image-20210718011032691.png" alt="image-20210718011032691"></p>
<p>Arthas (阿尔萨斯)是Alibaba开源的Java诊断工具， 深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p>
<p>Arthas支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的Tab自动补全功能，进-步方便进行问题的定位和诊断。</p>
<p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p>
<ul>
<li>这个类从哪个jar包加载的？为什么会报各种类相关的Exception？</li>
<li>我改的代码为什么没有执行到？难道是我没commit?分支搞错了？</li>
<li>遇到问题无法在线上debug，难道只能通过加日志再重新发布吗？</li>
<li>线上遇到某个用户的数据处理有问题，但线上同样无法debug，线下无法重现！</li>
<li>是否有一个全局视角来查看系统的运行状况？</li>
<li>有什么办法可以监控到JVM的实时运行状态？</li>
<li>怎么快速定位应用的热点，生成火焰图？</li>
</ul>
<h6 id="3、基于哪些工具开发而来"><a href="#3、基于哪些工具开发而来" class="headerlink" title="3、基于哪些工具开发而来"></a>3、基于哪些工具开发而来</h6><ul>
<li><strong>greys-anatomy</strong>：<strong>Arthas代码基于Greys二次开发而来</strong>，非常感谢Greys之前所有的工作，以及Greys原作者对Arthas提出的意见和建议！</li>
<li><strong>termd</strong>：<strong>Arthas的命令行实现基于termd开发</strong>，是一款优秀的命令行程序开发框架，感谢termd提供了优秀的框架。</li>
<li><strong>crash</strong>：<strong>Arthas的文本渲染功能基于crash中的文本渲染功能开发</strong>，可以从这里看到源码，感谢crash在这方面所做的优秀工作。</li>
<li><strong>cli</strong>：<strong>Arthas的命令行界面基于vert.x提供的cli库进行开发</strong>，感谢vert. x在这方面做的优秀工作。</li>
<li><strong>compiler</strong>：Arthas里的<strong>内存编绎器代码</strong>来源</li>
<li><strong>Apache Commons Net</strong>：Arthas里的<strong>Telnet Client</strong>代码来源</li>
<li><strong>JavaAgent</strong>：运行在main方法之前的<strong>拦截器</strong>，它内定的方法名叫premain ，也就是说先执行premain方法然后再执行main方法</li>
<li>ASM：一个通用的Java字节码操作和分析框架。它可以用于修改现有的类或直接以二进制形式动态生成类。ASM提供了一些常见的字节码转换和分析算法，可以从它们构建定制的复杂转换和代码分析工具。ASM提供了与其他Java字节码框架类似的功能，但是主要关注性能。因为它被设计和实现得尽可能小和快，所以非常适合在动态系统中使用(当然也可以以静态方式使用，例如在编译器中)</li>
</ul>
<h6 id="4、官方使用文档"><a href="#4、官方使用文档" class="headerlink" title="4、官方使用文档"></a>4、官方使用文档</h6><p><a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/quick-start.html">https://arthas.aliyun.com/doc/quick-start.html</a></p>
<h5 id="2、安装与使用"><a href="#2、安装与使用" class="headerlink" title="2、安装与使用"></a>2、安装与使用</h5><h6 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h6><ol>
<li><p>安装方式一：可以直接在Linux 上通过命令下载</p>
<ul>
<li><p>可以在官方Github 上进行下载，如果速度较慢，可以尝试国内的码云Gitee 下载。</p>
<ul>
<li><p>github 下载</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://alibaba.github.io/arthas/arthas-boot.jar</span><br></pre></td></tr></table></figure>
</li>
<li><p>Gitee下载</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.gitee.io/arthas-boot.jar</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>安装方式二：</p>
<ul>
<li><p>也可以在浏览器<a target="_blank" rel="noopener" href="https://alibaba.github.io/arthas/arthas-boot.jar">直接访问</a>，等待下载成功后，上传到Linux服务器上。（可以放在opt文件目录下）</p>
<p><img src="/2021/04/19/JVM/image-20210718011406059.png" alt="image-20210718011406059"></p>
</li>
</ul>
</li>
</ol>
<p>卸载：</p>
<ul>
<li><p>在Linux/Unix/Mac 平台</p>
</li>
<li><p>删除下面文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf ~/.arthas/I</span><br><span class="line">rm -rf ~/logs/arthas</span><br></pre></td></tr></table></figure>
</li>
<li><p>Windows平台直接删除user home下面的.arthas和logs/arthas目录</p>
</li>
</ul>
<h6 id="2、工程目录"><a href="#2、工程目录" class="headerlink" title="2、工程目录"></a>2、工程目录</h6><ul>
<li>arthas-agent：基于JavaAgent技术的代理</li>
<li>bin：一些启动脚本</li>
<li>arthas-boot：Java版本的一键安装启动脚本</li>
<li>arthas-client：telnet client代码</li>
<li>arthas-common：一些共用的工具类和枚举类</li>
<li>arthas-core：核心库，各种arthas命令的交互和实现</li>
<li>arthas-demo：示例代码</li>
<li>arthas-memorycompiler：内存编绎器代码，Fork from <a target="_blank" rel="noopener" href="https://github.com/skalogs/SkaETL/tree/master/compiler">https://github.com/skalogs/SkaETL/tree/master/compiler</a></li>
<li>arthas-packaging：maven打包相关的</li>
<li>arthas-site：arthas站点</li>
<li>arthas-spy：编织到目标类中的各个切面</li>
<li>static：静态资源</li>
<li>arthas-testcase：测试</li>
</ul>
<h6 id="3、启动"><a href="#3、启动" class="headerlink" title="3、启动"></a>3、启动</h6><p>Arthas只是一个java程序，所以可以直接用java -jar 运行。</p>
<p>执行成功后，arthas提供了一种命令行方式的交互方式，arthas 会检测当前服务器上的Java进程，并将进程列表展示出来，用户输入对应的编号(1、2、3、4……)进行选择，然后回车。</p>
<p>比如：</p>
<ol>
<li><p>方式1：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure>

<p>#选择进程(输入[]内编号(不是PID)回车)<br>[INFO] arthas-boot version: 3.1.4<br>[INFO] Found existing java process, please choose one and hit RETURN.</p>
<p>* [1]: 11616 com.Arthas</p>
<p>  [2]: 8676</p>
<p>  [3]: 16200 org. jetbrains. jps . cmdline . Launcher</p>
<p>  [4]: 21032 org. jetbrains. idea . maven. server . RemoteMavenServer</p>
</li>
<li><p>方式2：</p>
<p>运行时选择Java进程PID：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar [PID]</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><img src="/2021/04/19/JVM/image-20210718011816040.png" alt="image-20210718011816040"></p>
<h6 id="4、查看进程"><a href="#4、查看进程" class="headerlink" title="4、查看进程"></a>4、查看进程</h6><p>jps</p>
<h6 id="5、查看日志"><a href="#5、查看日志" class="headerlink" title="5、查看日志"></a>5、查看日志</h6><p>cat ~/logs/arthas/arthas.log</p>
<h6 id="6、查看帮助"><a href="#6、查看帮助" class="headerlink" title="6、查看帮助"></a>6、查看帮助</h6><p>java -jar arthas-boot.jar -h</p>
<h6 id="7、web-console"><a href="#7、web-console" class="headerlink" title="7、web console"></a>7、web console</h6><p>除了在命令行查看外，Arthas目前还支持Web Console。在成功启动连接进程之后就已经自动启动，可以直接访问<a target="_blank" rel="noopener" href="http://127.0.0.1:8563/">http://127.0.0.1:8563/</a> 访问，页面上的操作模式和控制台完全一样。</p>
<p><img src="/2021/04/19/JVM/image-20210718012104569.png" alt="image-20210718012104569"></p>
<h6 id="8、退出"><a href="#8、退出" class="headerlink" title="8、退出"></a>8、退出</h6><p>最后一行[arthas@7457]$， 说明打开进入了监控客户端，在这里就可以执行相关命令进行查看了。</p>
<ul>
<li>使用<code>quit\exit</code>：退出当前客户端</li>
<li>使用<code>stop\shutdown</code>：关闭arthas服务端，并退出所有客户端。</li>
</ul>
<h5 id="3、相关诊断指令"><a href="#3、相关诊断指令" class="headerlink" title="3、相关诊断指令"></a>3、相关诊断指令</h5><h6 id="1、基础指令"><a href="#1、基础指令" class="headerlink" title="1、基础指令"></a>1、基础指令</h6><p><img src="/2021/04/19/JVM/image-20210718012307430.png" alt="image-20210718012307430"></p>
<h6 id="2、jvm相关"><a href="#2、jvm相关" class="headerlink" title="2、jvm相关"></a>2、jvm相关</h6><p>命令列表：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/commands.html#id1">https://arthas.aliyun.com/doc/commands.html#id1</a></p>
<p><img src="/2021/04/19/JVM/image-20210718012842725.png" alt="image-20210718012842725"></p>
<ul>
<li><p><strong>dashboard</strong>（常用）</p>
<ul>
<li><p>链接：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/dashboard.html">https://arthas.aliyun.com/doc/dashboard.html</a></p>
</li>
<li><p>作用：当前系统的实时数据面板</p>
</li>
<li><p>options：</p>
<ul>
<li><p><code>-i</code>：打印的时间间隔（单位：ms）</p>
<ul>
<li><p>使用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dashboard -i 500</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>-n</code>：打印的次数</p>
<ul>
<li><p>使用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dashboard -n 30</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>若没有填写options，则会在默认时间间隔下不断地打印</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>thread</p>
<ul>
<li>链接：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/thread.html">https://arthas.aliyun.com/doc/thread.html</a></li>
<li>作用：查看当前线程信息，查看线程的堆栈</li>
</ul>
</li>
<li><p>jvm</p>
<ul>
<li>链接：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/jvm">https://arthas.aliyun.com/doc/jvm</a></li>
<li>作用：查看jvm详细的性能数据</li>
</ul>
</li>
<li><p>其他</p>
<ul>
<li>sysprop<ul>
<li>链接：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/sysprop">https://arthas.aliyun.com/doc/sysprop</a></li>
<li>作用：查看和修改JVM的系统属性</li>
</ul>
</li>
<li>sysenv<ul>
<li>链接：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/sysenv">https://arthas.aliyun.com/doc/sysenv</a></li>
<li>作用：查看JVM的环境变量</li>
</ul>
</li>
<li>getstatic<ul>
<li>链接：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/getstatic">https://arthas.aliyun.com/doc/getstatic</a></li>
<li>作用：查看类的静态属性</li>
</ul>
</li>
<li>heapdump<ul>
<li>链接：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/heapdump">https://arthas.aliyun.com/doc/heapdump</a></li>
<li>作用：类似jmap 命令的heap dump功能</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="3、class-classloader相关"><a href="#3、class-classloader相关" class="headerlink" title="3、class/classloader相关"></a>3、class/classloader相关</h6><p><img src="/2021/04/19/JVM/image-20210718014201542.png" alt="image-20210718014201542"></p>
<ul>
<li><p>sc</p>
<ul>
<li>作用：查看JVM已加载的类信息</li>
<li>链接：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/sc">https://arthas.aliyun.com/doc/sc</a></li>
<li>常用参数：<ul>
<li><strong>class- pattern</strong>：类名表达式匹配</li>
<li><strong>-d</strong>：输出当前类的详细信息，包括这个类所加载的原始文件来源、类的声明、加载的ClassLoader等详细信息。如果一个类被多个ClassLoader所<br>加载，则会出现多次</li>
<li><strong>-E</strong>：开启正则表达式匹配，默认为通配符匹配</li>
<li><strong>-f</strong>：输出当前类的成员变量信息(需要配合参数-d一起使用)</li>
<li><strong>-x</strong>：指定输出静态变量时属性的遍历深度，默认为0，即直接使用toString输出</li>
</ul>
</li>
<li>补充：<ol>
<li>class-pattern支持全限定名， 如com.test.AAA，也支持com/test/AAA这样的格式，这样，我们从异常堆栈里面把类名拷贝过来的时候，不需要在手动把<code>/</code>替换为<code>.</code>了。</li>
<li>sc默认开启了子类匹配功能，也就是说所有当前类的子类也会被搜索出来，想要精确的匹配，请打开options disable-sub-class true开关 </li>
</ol>
</li>
</ul>
</li>
<li><p>sm</p>
<ul>
<li>作用：查看己加载类的方法信息</li>
<li>链接：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/sm">https://arthas.aliyun.com/doc/sm</a></li>
<li><strong>sm命令只能看到由当前类所声明(declaring) 的方法，父类则无法看到</strong>。</li>
<li>常用参数：<ul>
<li><strong>class-pattern</strong>：类名表达式匹配</li>
<li><strong>method-pattern</strong>：方法名表达式匹配</li>
<li><strong>-d</strong>：展示每个方法的详细信息</li>
<li><strong>-E</strong>：开启正则表达式匹配，默认为通配符匹配</li>
</ul>
</li>
</ul>
</li>
<li><p>jad</p>
<ul>
<li><p>作用：反编译指定己加载类的源码</p>
</li>
<li><p>链接：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/jad">https://arthas.aliyun.com/doc/jad</a></p>
</li>
<li><p>在Arthas Console 上，反编译出来的源码是带语法高亮的，阅读更方便</p>
</li>
<li><p>当然，反编译出来的java代码可能会存在语法错误，但不影响你进行阅读理解</p>
</li>
<li><p>编译java.lang.String</p>
<p><img src="/2021/04/19/JVM/image-20210718004243898.png" alt="image-20210718004243898"></p>
</li>
</ul>
</li>
<li><p>mc、redefine</p>
<ul>
<li><p>mc命令：Memory Compiler/内存编译器，编译.java文件生成.class</p>
</li>
<li><p>链接：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/mc">https://arthas.aliyun.com/doc/mc</a></p>
</li>
<li><p>使用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mc /tmp/Test.java</span><br></pre></td></tr></table></figure>
</li>
<li><p>redefine命令：加载外部的.class文件，redefine jvm已加载的类。</p>
</li>
<li><p>链接：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/redefine">https://arthas.aliyun.com/doc/redefine</a></p>
</li>
<li><p>推荐使用retransform命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redefine /tmp/Test.class </span><br><span class="line">redefine -c 327a647b /tmp/Test.class  /tmp/Test\$Inner.class</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>classloader</p>
<ul>
<li>作用：查看classloader 的继承树，urls，类加载信息</li>
<li>链接：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/classloader">https://arthas.aliyun.com/doc/classloader</a></li>
<li>了解当前系统中有多少类加载器，以及每个加载器加载的类数量，帮助您判断是否有类加载器泄漏。</li>
<li>常用参数：<ul>
<li><strong>-t</strong>：查看ClassLoader的继承树</li>
<li><strong>-l</strong>：按类加载实例查看统计信息</li>
<li><strong>-c</strong>：用classloader对应的hashcode来查看对应的jar urls</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="4、monitor-watch-trace相关"><a href="#4、monitor-watch-trace相关" class="headerlink" title="4、monitor/watch/trace相关"></a>4、monitor/watch/trace相关</h6><p>命令列表：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/commands.html#id1">https://arthas.aliyun.com/doc/commands.html#id1</a></p>
<p><img src="/2021/04/19/JVM/image-20210718014942945.png" alt="image-20210718014942945"></p>
<ul>
<li><p>monitor</p>
<ul>
<li><p>monitor命令：方法执行监控</p>
</li>
<li><p>对匹配class-pattern / method-pattern的类、方法的调用进行监控。涉及方法的调用次数、执行时间、失败率等</p>
</li>
<li><p>链接：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/monitor">https://arthas.aliyun.com/doc/monitor</a></p>
</li>
<li><p>monitor命令是一个非实时返回命令</p>
</li>
<li><p>常用参数：</p>
<ul>
<li><strong>class-pattern</strong>：类名表达式匹配</li>
<li><strong>method-pattern</strong>：方法名表达式匹配</li>
<li><strong>-c</strong>：统计周期，默认值为120秒</li>
</ul>
</li>
<li><p>监控项：</p>
<p><img src="/2021/04/19/JVM/image-20210718015103331.png" alt="image-20210718015103331"></p>
</li>
</ul>
</li>
<li><p>watch</p>
<ul>
<li>watch命令：方法执行数据观测</li>
<li>链接：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/watch">https://arthas.aliyun.com/doc/watch</a></li>
<li>作用：让你能方便的观察到指定方法的调用情况。能观察到的范围为：返回值、抛出异常、入参，通过编写groovy表达式进行对应变量的查看。</li>
<li>常用参数：<ul>
<li><strong>class-pattern</strong>：类名表达式匹配</li>
<li><strong>method-pattern</strong>：方法名表达式匹配</li>
<li><strong>express</strong>：观察表达式</li>
<li><strong>condition-express</strong>：条件表达式</li>
<li><strong>-b</strong>：在方法调用之前观察(默认关闭)</li>
<li><strong>-e</strong>：在方法异常之后观察(默认关闭)</li>
<li><strong>-s</strong>：在方法返回之后观察(默认关闭)</li>
<li><strong>-f</strong>：在方法结束之后(正常返回和异常返回)观察(默认开启)</li>
<li><strong>-x</strong>：指定输出结果的属性遍历深度，默认为0</li>
<li><strong>#cost</strong>：方法执行耗时</li>
</ul>
</li>
<li>说明：这里重点要说明的是<strong>观察表达式</strong>，观察表达式的构成主要由<strong>ognl 表达式</strong>组成，所以你可以这样写”{params, returnObj}”,只要是一个合法的ognl表达式，都能被正常支持。</li>
<li>举例：watch全限定类名 方法名returnObj</li>
</ul>
</li>
<li><p>trace</p>
<ul>
<li>trace命令：方法内部调用路径，并输出方法路径上的每个节点上耗时</li>
<li>链接：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/trace">https://arthas.aliyun.com/doc/trace</a></li>
<li>补充说明：<ul>
<li>trace命令能主动搜索class-pattern / method- pattern 对应的方法调用路径，渲染和统计整个调用链路上的所有性能开销和追踪调用链路。</li>
<li>trace能方便的帮助你定位和发现因RT高而导致的性能问题缺陷，但其每次只能跟踪一级方法的调用链路</li>
<li>trace 在执行的过程中本身是会有一定的性能开销，在统计的报告中并未像JProfiler一样预先减去其自身的统计开销。所以这统计出来有些许的不准，渲染路径上调用的类、方法越多，性能偏差越大。但还是能让你看清一些事情的。</li>
</ul>
</li>
<li>参数说明：<ul>
<li><strong>class-pattern</strong>：类名表达式匹配</li>
<li><strong>method-pattern：</strong>方法名表达式匹配</li>
<li><strong>condition-express</strong>：条件表达式</li>
<li><strong>-n</strong>：命令执行次数</li>
<li><strong>#cost</strong>：方法执行耗时</li>
</ul>
</li>
</ul>
</li>
<li><p>stack</p>
<ul>
<li>stack命令：输出当前方法被调用的调用路径</li>
<li>链接：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/stack">https://arthas.aliyun.com/doc/stack</a></li>
<li>常用参数：<ul>
<li><strong>class-pattern</strong>：类名表达式匹配</li>
<li><strong>method-pattern</strong>：方法名表达式匹配</li>
<li><strong>condition-express</strong>：条件表达式</li>
<li><strong>-n</strong>：执行次数限制</li>
<li><strong>#cost</strong>：方法执行耗时</li>
</ul>
</li>
</ul>
</li>
<li><p>tt</p>
<ul>
<li>tt命令：方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测。</li>
<li>链接：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/tt">https://arthas.aliyun.com/doc/tt</a></li>
<li>TimeTunnel的缩写</li>
<li>常用参数：<ul>
<li><strong>-t</strong>：表明希望记录下类 *Test 的 print 方法的每次执行情况。</li>
<li><strong>-n 3</strong>：指定你需要记录的次数，当达到记录次数时Arthas会主动中断tt命令的记录过程，避免人工操作无法停止的情况。</li>
<li><strong>-s</strong>：筛选指定方法的调用信息</li>
<li><strong>-i</strong>：参数后边跟着对应的INDEX编号查看到它的详细信息</li>
<li><strong>-p</strong>：重做一次调用，通过<code>--replay-times</code> 指定调用次数，通过<code>--replay- interval</code> 指定多次调用间隔(单位ms，默认1000ms)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="5、其他"><a href="#5、其他" class="headerlink" title="5、其他"></a>5、其他</h6><p>使用&gt;将结果重写到日志文件，使用&amp;指令命令是后台运行，session断开不影响任务执行(生命周期默认为1天)</p>
<ul>
<li><strong>jobs</strong>：列出所有job</li>
<li><strong>kill</strong>：强制终止任务</li>
<li><strong>fg</strong>：将暂停的任务拉到前台执行</li>
<li><strong>bg</strong>：将暂停的任务放到后台执行</li>
<li><strong>grep</strong>：搜索满足条件的结果</li>
<li><strong>plaintext</strong>：将命令的结果去除ANSI颜色</li>
<li><strong>wc</strong>：按行统计输出结果</li>
<li><strong>options</strong>：查看或设置Arthas全局开关<ul>
<li>链接：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/options.html">https://arthas.aliyun.com/doc/options.html</a></li>
</ul>
</li>
<li><strong>profiler</strong>：使用async-profiler对应用采样，生成火焰图<ul>
<li>链接：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/profiler.html">https://arthas.aliyun.com/doc/profiler.html</a></li>
</ul>
</li>
</ul>
<h4 id="7、Java-Misssion-Control"><a href="#7、Java-Misssion-Control" class="headerlink" title="7、Java Misssion Control"></a>7、Java Misssion Control</h4><h5 id="1、历史"><a href="#1、历史" class="headerlink" title="1、历史"></a>1、历史</h5><p>在Oracle 收购Sun之前，Oracle 的JRockit 虚拟机提供了一款叫做JRockitMission Control的虛拟机诊断工具。</p>
<p>在Oracle收购Sun之后，Oracle公司同时拥有了Sun Hotspot和JRockit两款虚拟机。根据Oracle对于Java的战略，在今后的发展中，会将JRockit的优秀特性移植到Hotspot上。其中一个重要的改进就是在Sun的JDK中加入了JRockit的支持。</p>
<p>在Oracle JDK 7u40之后，Mission Control这款工具已经绑定在Oracle JDK中发布。</p>
<p>自Java 11开始，本节介绍的JFR已经开源。但在之前的Java版本，JFR属于Commercial Feature，可要通过Java虚拟机参数<code>-XX: +UnlockCommercialFeatures</code>开启。</p>
<p>如果你有兴趣请可以查看OpenJDK的<a target="_blank" rel="noopener" href="https://github.com/JDKMissionControl/jmc">Mission Control项目</a>。</p>
<h5 id="2、启动-1"><a href="#2、启动-1" class="headerlink" title="2、启动"></a>2、启动</h5><p>Mission Control位于%JAVA_ HOME%/bin/jmc.exe，打开这款软件。</p>
<p><img src="/2021/04/19/JVM/image-20210718021714996.png" alt="image-20210718021714996"></p>
<h5 id="3、概述"><a href="#3、概述" class="headerlink" title="3、概述"></a>3、概述</h5><p>Java Mission Control (简称JMC) Java官方提供的性能强劲的工具，是一个用于对Java 应用程序进行管理、监视、概要分析和故障排除的工具套件。</p>
<p>它包含一个GUI客户端，以及众多用来收集Java虚拟机性能数据的插件，如JMX Console(能够访问用来存放虚拟机各个子系统运行数据的<code>MXBeans</code>)，以及虚拟机内置的高效profiling 工具<code>Java Flight Recorder (JFR)</code>。</p>
<p>JMC 的另一个优点就是：<strong>采用取样，而不是传统的代码植入技术，对应用性能的影响非常非常小</strong>，完全可以开着JMC来做压测(唯一影响可能是full gc多了)。</p>
<h5 id="4、功能：实时监控JVM运行时的状态"><a href="#4、功能：实时监控JVM运行时的状态" class="headerlink" title="4、功能：实时监控JVM运行时的状态"></a>4、功能：实时监控JVM运行时的状态</h5><p>如果是远程服务器，使用前要开JMX。</p>
<p>-Dcom. sun. management . jmxremote . port=${YOUR PORT}<br>-Dcom. sun. management . jmxremote<br>-Dcom. sun. management . imxremote . authenticate=false<br>-Dcom. sun . management . jmxremote. ss1=false<br>-Djava. rmi. server . hostname=${YOUR HOST/IP}</p>
<p>文件 -&gt; 连接 -&gt;创建新连接，填入上面JMX参数的host和port</p>
<p><img src="/2021/04/19/JVM/image-20210718022620212.png" alt="image-20210718022620212"></p>
<h5 id="5、Java-Flight-Recorder"><a href="#5、Java-Flight-Recorder" class="headerlink" title="5、Java Flight Recorder"></a>5、Java Flight Recorder</h5><p>Java Flight Recorder是JMC 的其中一个组件。</p>
<p>Java Flight Recorder能够以极低的性能开销收集Java虚拟机的性能数据。</p>
<p>JFR的性能开销很小，在默认配置下平均低于<strong>1%**。与其他工具相比，JFR能够直接访问虚拟机内的数据，并且不会影响虚拟机的优化。因此，它</strong>非常适用于生产环境下满负荷运行的Java程序**。</p>
<p>Java Flight Recorder和JDK Mission Control共同创建了一个完整的工具链。JDK Mission Control可对Java Flight Recorder连续收集低水平和详细的运行时信息进行高效详细的分析。</p>
<ul>
<li><p>事件类型</p>
<ul>
<li>当启用时，JFR 将记录运行过程中发生的一系列事件。其中包括Java层面的事件，如线程事件、锁事件，以及Java 虚拟机内部的事件，如新建对象、垃圾回收和即时编译事件。</li>
<li>按照发生时机以及持续时间来划分，JFR 的事件共有四种类型，它们分别为以下四种：<ol>
<li>**瞬时事件(Instant Event)**：用户关心的是它们发生与否，例如异常、线程启动事件。</li>
<li>**持续事件(Duration Event)**：用户关心的是它们的持续时间，例如垃圾回收事件。</li>
<li>**计时事件(Timed Event)**：是时长超出指定阈值的持续事件。</li>
<li>**取样事件(Sample Event)**：是周期性取样的事件。</li>
</ol>
</li>
<li>取样事件的其中一个常见例子便是<strong>方法抽样</strong>(Method Sampling)，即每隔一段时间统计各个线程的栈轨迹。如果在这些<strong>抽样取得的栈轨迹中存在一个反复出现的方法，那么我们可以推测该方法是热点方法</strong>。</li>
</ul>
</li>
<li><p>启动方式</p>
<ol>
<li><p>方式1：使用<code>-XX:StartFlightRecording=参数</code></p>
<ul>
<li><p>比如：下面命令中，JFR将会在Java虚拟机启动5s后(对应delay=5s)收集数据，持续20s (对应duration=20s)。当收集完毕后，JFR 会将收集得到的数据保存至指定的文件中(对应filename=myrecording . jfr)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line">-XX:StartFlightRecording=delay=5s,duration=20s,filename=myrecording.jfr,setting s=profile MyApp</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于JFR将持续收集数据，如果不加以限制，那么JFR可能会填满硬盘的所有空间。因此，我们有必要对这种模式下所收集的数据进行限制。</p>
<ul>
<li><p>比如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:StartFlightRecording=maxage=10m, maxsize=100m, name=SomeLabel MyApp</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>方式2：使用<code>jcmd的JFR.*子命令</code></p>
<ul>
<li><p>通过jcmd来让JFR开始收集数据、停止收集数据，或者保存所收集的数据，对应的子命令分别为<code>JFR.start</code>、<code>JFR.stop</code>以及<code>JFR.dump</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jcmd &lt;PID&gt; JFR.start settings=profile maxage=10m maxsize=150m name=SomeLabel</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>上述命令运行过后，目标进程中的JFR已经开始收集数据。此时，我们可以通过下述命令来导出己经收集到的数据：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jcmd &lt;PID&gt; JFR.dump name=SomeLabel filename=myrecording.jfr</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，我们可以通过下述命令关闭目标进程中的JFR：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jcmd &lt;PID&gt; JFR.stop name=SomeLabel</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>方式3：JMC的<code>JFR插件</code></p>
<p><img src="/2021/04/19/JVM/71F5A9C6-31CB-44AA-9414-D64D25F5098E.png" alt="img"></p>
<ul>
<li><p>具体使用：</p>
<ol>
<li><p>启动飞行记录仪</p>
<p><img src="/2021/04/19/JVM/5CCE5317-A223-4B43-8A31-4CC35A5F0EC4.png" alt="img"></p>
</li>
<li><p>启动飞行记录</p>
<p><img src="/2021/04/19/JVM/44614069-2B6C-46F1-BC08-8CEDB3552550.png" alt="img"></p>
</li>
<li><p>正式启动</p>
<p><img src="/2021/04/19/JVM/56BF6BA6-FBD4-4C2A-B38C-26DD8CD63E8F.png" alt="img"></p>
<p><img src="/2021/04/19/JVM/E8EE12B7-FE3F-4D17-ACB6-7D9C7E06AB59.png" alt="img"></p>
<p><img src="/2021/04/19/JVM/EF74F519-69A7-4D42-B255-1B7FF4F59208.png" alt="img"></p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><p>Java Flight Recorder 取样分析</p>
<ul>
<li><p>要采用取样，必须先添加参数：</p>
<ul>
<li><code>-XX: +UnlockCommercialFeatures</code></li>
<li><code>-XX: +Flight Recorder</code></li>
</ul>
</li>
<li><p>否则：</p>
<p><img src="/2021/04/19/JVM/image-20210718170905047.png" alt="image-20210718170905047"></p>
</li>
<li><p>取样时间默认1分钟，可自行按需调整，事件设置选为profiling，然后可以设置取样profile哪些信息，比如：</p>
<ul>
<li>加上对象数量的统计：Java Virtual Machine -&gt; GC -&gt; Detailed -&gt; Object Count/Object Count after GC</li>
<li>方法调用采样的间隔从10ms改为1ms(但不能低于 1ms,否则会影响性能了)：Java Virtual Machine -&gt; Profiling -&gt; Method Profiling Sample/Method Sampling Information</li>
<li>Socket与File采样，10ms 太久，但即使改为1ms也未必能抓住什么，可以干脆取消掉：Java Application -&gt; File Read/FileWrite/Socket Read/Socket Write</li>
</ul>
<p><img src="/2021/04/19/JVM/image-20210718171442960.png" alt="image-20210718171442960"></p>
</li>
<li><p>然后就开始Profile，到时间后Profile 结束，会自动把记录下载回来，在JMC中展示。</p>
<p><img src="/2021/04/19/JVM/image-20210718171510051.png" alt="image-20210718171510051"></p>
</li>
<li><p>从展示信息中，我们大致可以读到内存和CPU信息、代码、线程和IO等比较重要的信息展示。</p>
</li>
</ul>
</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -XX:+PrintFlagsFinal -Xms600m -Xmx600m</span></span><br><span class="line"><span class="comment"> *  -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment"> * 默认情况下，新生代占 1/3 ： 200m，老年代占2/3 : 400m</span></span><br><span class="line"><span class="comment"> *   其中，Eden默认占新生代的8/10 : 160m ,Survivor0，Survivor1各占新生代的1/10 ： 20m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Picture&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(<span class="keyword">new</span> Picture(<span class="keyword">new</span> Random().nextInt(<span class="number">100</span> * <span class="number">50</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Picture</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] pixels;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Picture</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pixels = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getPixels() &#123;</span><br><span class="line">        <span class="keyword">return</span> pixels;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPixels</span><span class="params">(<span class="keyword">byte</span>[] pixels)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pixels = pixels;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<ol>
<li><p>一般信息</p>
<p><img src="/2021/04/19/JVM/EE0FD730-64E5-4F07-8D0B-CF2B7F6ECA8A.png" alt="img"></p>
</li>
<li><p>内存</p>
<p><img src="/2021/04/19/JVM/71F0F847-36CE-409F-8690-4D69E5ADB552.png" alt="img"></p>
</li>
<li><p>代码</p>
<p><img src="/2021/04/19/JVM/CE8E8DE1-00EC-45C4-AE5C-7B6E888F3748.png" alt="img"></p>
</li>
<li><p>线程</p>
<p><img src="/2021/04/19/JVM/F2A47ADC-177C-4723-923E-48D654D2CCA9.png" alt="img"></p>
</li>
<li><p>I/O</p>
<p><img src="/2021/04/19/JVM/DA9DF354-EF7F-481E-B1EA-C45D418E9327.png" alt="img"></p>
</li>
<li><p>系统</p>
<p><img src="/2021/04/19/JVM/CEF36242-1EB0-44E8-96E9-60E3A729C56F.png" alt="img"></p>
</li>
<li><p>事件</p>
<p><img src="/2021/04/19/JVM/5F2A69FF-BDBE-44D2-912E-81CB6E7782A2.png" alt="img"></p>
</li>
</ol>
<h4 id="8、其他工具"><a href="#8、其他工具" class="headerlink" title="8、其他工具"></a>8、其他工具</h4><h5 id="1、Flame-Graphs（火焰图）"><a href="#1、Flame-Graphs（火焰图）" class="headerlink" title="1、Flame Graphs（火焰图）"></a>1、Flame Graphs（火焰图）</h5><p>在追求极致性能的场景下，了解你的程序运行过程中cpu在干什么很重要，火焰图就是一种非常直观的展示cpu在程序整个生命周期过程中时间分配的工具。</p>
<p>火焰图对于现代的程序员不应该陌生，这个工具可以非常直观的显示出调用栈中的CPU消耗瓶颈。</p>
<p>网上的关于java火焰图的讲解大部分来自于<a target="_blank" rel="noopener" href="http://www.brendangregg.com/flamegraphs.html">Brendan Gregg的博客</a></p>
<p><img src="/2021/04/19/JVM/image-20210718172030880.png" alt="image-20210718172030880"></p>
<p>火焰图简单通过<strong>x轴横条宽度来度量时间指标</strong>，<strong>y轴代表线程栈的层次</strong>。</p>
<h5 id="2、Tprofiler"><a href="#2、Tprofiler" class="headerlink" title="2、Tprofiler"></a>2、Tprofiler</h5><ul>
<li>案例：<ul>
<li>使用JDK自身提供的工具进行JVM调优可以将TPS由2.5提升到20（提升了7倍），并准确定位系统瓶颈</li>
<li>系统的瓶颈有：应用里静态对象不是很多、有大量的业务进程在频繁创建一些生命周期很长的临时对象，代码里有问题</li>
<li>那么，如何在海量业务代码里边准确定位这些性能代码？这里使用阿里开源工具Tprofiler来定位这些性能代码，成功解决掉GC过于频繁的性能瓶颈，并最终在上次优化的基础上将TPS在提升了4倍，即提升到100。<ul>
<li>TProfiler配置部署、远程操作、日志阅读都不太复杂，操作还是很简单的。但是其却是能够起到一针见血、立竿见影的效果，帮我们解决了GC过于频繁的性能瓶颈。</li>
<li>TProfiler最重要的特性就是<strong>能够统计出你指定时间段内JVM 的top method</strong>，这些top method极有可能就是造成你JVM 性能瓶颈的元凶。这是其他大多数JVM调优工具所不具备的，包括JRockit Mission Control。JRokit 首席开发者Marcus Hirt在其私人博客《Low Overhead Method Profiling with Java Mission Control》下的评论中曾明确指出JRMC并不支持TOP方法的统计。</li>
<li>TProfiler的<a target="_blank" rel="noopener" href="https://github.com/alibaba/TProfiler">下载</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="3、Btrace"><a href="#3、Btrace" class="headerlink" title="3、Btrace"></a>3、Btrace</h5><ul>
<li><strong>Java运行时追踪工具</strong></li>
<li>常见的动态追踪工具有BTrace、HouseMD (该项目已经停止开发)、Greys-Anatomy (国人开发，个人开发者)、Byteman (JBoss出品)，注意Java运行时追踪工具并不限于这几种，但是这几个是相对比较常用的。</li>
<li>BTrace是SUN Kenai云计算开发平台下的一个开源项目，旨在为java提供安全可靠的动态跟踪分析工具。先看一下BTrace的官方定义：<ul>
<li>BTrace is a safe, dynamic tracing tool for the Java platform. BTrace can be used to dynamically trace a running Java program (similar to DTrace for OpenSolaris applications and OS). BTrace dynamically instruments the classes of the target application to inject tracing code (“bytecode tracing”)。</li>
</ul>
</li>
<li>简洁明了，大意是一个Java平台的安全的动态追踪工具。可以用来动态地追踪一个运行的Java程序。BTrace动态调整目标应用程序的类以注入跟踪代码(“字节码跟踪”)。</li>
</ul>
<h5 id="4、YourKit"><a href="#4、YourKit" class="headerlink" title="4、YourKit"></a>4、YourKit</h5><h5 id="5、JProbe"><a href="#5、JProbe" class="headerlink" title="5、JProbe"></a>5、JProbe</h5><h5 id="6、Spring-Insight"><a href="#6、Spring-Insight" class="headerlink" title="6、Spring Insight"></a>6、Spring Insight</h5><h4 id="9、学习建议"><a href="#9、学习建议" class="headerlink" title="9、学习建议"></a>9、学习建议</h4><p>Visual VM -&gt; Arthus -&gt; Jproflier（公司有能购买商业版） -&gt; MAT</p>
<h4 id="10、补充1：再谈内存泄露"><a href="#10、补充1：再谈内存泄露" class="headerlink" title="10、补充1：再谈内存泄露"></a>10、补充1：再谈内存泄露</h4><h5 id="1、内存泄露的理解与分析"><a href="#1、内存泄露的理解与分析" class="headerlink" title="1、内存泄露的理解与分析"></a>1、内存泄露的理解与分析</h5><h6 id="1、何为内存泄漏-memory-leak"><a href="#1、何为内存泄漏-memory-leak" class="headerlink" title="1、何为内存泄漏( memory leak)"></a>1、何为内存泄漏( memory leak)</h6><p><img src="/2021/04/19/JVM/image-20210427230217504.png" alt="image-20210427230217504"></p>
<p>可达性分析算法来判断对象是否是不再使用的对象，本质都是判断一个对象是否还被引用。那么对于这种情况下，由于代码的实现不同就会出现很多种内存泄漏问题(让JVM误以为此对象还在引用中，无法回收，造成内存泄漏)。</p>
<ul>
<li>是否还被使用?是</li>
<li>是否还被需要?否</li>
</ul>
<h6 id="2、内存泄漏-memory-leak-的理解"><a href="#2、内存泄漏-memory-leak-的理解" class="headerlink" title="2、内存泄漏( memory leak) 的理解"></a>2、内存泄漏( memory leak) 的理解</h6><p>严格来说，<strong>只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏</strong>。</p>
<p>但实际情况很多时候一些不太好的实践(或疏忽)会导致<strong>对象的生命周期变得很长甚至导致OOM</strong>，也可以叫做宽泛意义上的“内存泄漏”。</p>
<p><img src="/2021/04/19/JVM/image-20210717171640356.png" alt="image-20210717171640356"></p>
<p>对象X引用对象Y，X的生命周期比Y的生命周期长；那么当Y生命周期结束的时候，X依然引用着Y，这时候，垃圾回收期是不会回收对象Y的；如果对象X还引用着生命周期比较短的A、B、C，对象A又引用着对象a、b、c，这样就可能造成大量无用的对象不能被回收，进而占据了内存资源，造成内存泄漏，直到内存溢出。</p>
<h6 id="3、内存泄漏与内存溢出的关系"><a href="#3、内存泄漏与内存溢出的关系" class="headerlink" title="3、内存泄漏与内存溢出的关系"></a>3、内存泄漏与内存溢出的关系</h6><ol>
<li><p>内存泄漏(memory leak)</p>
<p>申请了内存用完了不释放，比如一共有1024M的内存，分配了512M 的内存一直不回收，那么可以用的内存只有512M了， 仿佛泄露掉了一部分；通俗点讲的话， 内存泄漏就是 [占着茅坑不拉shi] 。</p>
</li>
<li><p>内存溢出(out of memory)</p>
<p>申请内存时，没有足够的内存可以使用；通俗一点儿讲，一个厕所就三个坑，有两个站着茅坑不走的(内存泄漏)，剩下最后一个坑，厕所表示接待压力很大，这时候一下子来了两个人，坑位(内存)就不够了，内存泄漏变成内存溢出了。</p>
<p>可见，内存泄漏和内存溢出的关系：<strong>内存泄漏的增多，最终会导致内存溢出。</strong></p>
</li>
</ol>
<h6 id="4、泄漏的分类"><a href="#4、泄漏的分类" class="headerlink" title="4、泄漏的分类"></a>4、泄漏的分类</h6><ul>
<li><strong>经常发生</strong>：发生内存泄露的代码会被多次执行，每次执行，泄露一块内存;（坚决杜绝）</li>
<li><strong>偶然发生</strong>：在某些特定情况下才会发生；</li>
<li><strong>一次性</strong>：发生内存泄露的方法只会执行一次；</li>
<li><strong>隐式泄漏</strong>：一直占着内存不释放，直到执行结束；严格的说这个不算内存泄漏，因为最终释放掉了，但是如果执行时间特别长，也可能会导致内存耗尽。</li>
</ul>
<h5 id="2、Java中内存泄露的8种情况"><a href="#2、Java中内存泄露的8种情况" class="headerlink" title="2、Java中内存泄露的8种情况"></a>2、Java中内存泄露的8种情况</h5><ul>
<li><p>静态集合类</p>
<ul>
<li><p>静态集合类，如HashMap、LinkedList等等。如果这些容器为静态的，那么它们的生命周期与JVM程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，<strong>长生命周期的对象持有短生命周期对象的引用</strong>，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。</p>
</li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryLeak</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oomTests</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">        list.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>单例模式</p>
<ul>
<li>单例模式，和静态集合导致内存泄露的原因类似，因为<strong>单例的静态特性，它的生命周期和JVM的生命周期一样长</strong>，所以如果单例对象如果持有外部对象的引用，那么这个外部对象也不会被回收，那么就会造成内存泄漏。</li>
</ul>
</li>
<li><p>内部类持有外部类</p>
<ul>
<li>内部类持有外部类，如果个外部类的实例对象的方法返回了一个内部类的实例对象。<strong>这个内部类对象被长期引用了</strong>，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄漏。</li>
</ul>
</li>
<li><p>各种连接，如数据库连接、网络连接和IO连接等</p>
<ul>
<li><p>各种连接，如数据库连接、网络连接和IO连接等。在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用close方法来释放与数据库的连接。<strong>只有连接被关闭后，垃圾回收器才会回收对应的对象</strong>。否则，如果在访问数据库的过程中，对Connection、 Statement或ResultSet 不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。</p>
</li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Connection conn = <span class="keyword">null</span>;</span><br><span class="line">		Class.forName (<span class="string">&quot;com.mysq1.jdbc.Driver&quot;</span>);</span><br><span class="line">		conn = DriverManager . getConnection(<span class="string">&quot;url&quot;</span>, <span class="number">11</span>);</span><br><span class="line">		Statement stmt = conn. createStatement();</span><br><span class="line">		ResultSet rs = stmt.executeQuery(<span class="string">&quot;....&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">        <span class="comment">//异常日志</span></span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="comment">//1.关闭结果集Statement</span></span><br><span class="line">		<span class="comment">// 2.关闭声明的对象ResultSet</span></span><br><span class="line">		<span class="comment">// 3.关闭连接Connection</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>变量不合理的作用域</p>
<ul>
<li><p>变量不合理的作用域。一般而言，<strong>一个变量的定义的作用范围大于其使用范围</strong>，很有可能会造成内存泄漏。另一方面，<strong>如果没有及时地把对象设置为null，很有可能导致内存泄漏的发生</strong>。</p>
</li>
<li><p>伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingRandom</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String msg;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">		readFromNet();<span class="comment">//从网络中接受数据保存到msg中</span></span><br><span class="line">		saveDB();<span class="comment">//把msg保存到数据库中</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如上面这个伪代码，通过readFromNet方法把接受的消息保存在变量msg中，然后调用saveDB方法把msg的内容保存到数据库中，此时msg已经就没用了，由于msg的生命周期与对象的生命周期相同，此时msg还不能回收，因此造成了内存泄漏。</p>
</li>
<li><p>实际上这个msg变量可以放在receiveMsg方法内部， 当方法使用完，那么msg的生命周期也就结束，此时就可以回收了。还有一种方法，在使用完msg后，把msg设置为null，这样垃圾回收器也会回收msg的内存空间。</p>
</li>
<li><p>解决方法1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingRandom</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String msg;</span><br><span class="line">		msg = readFromNet();<span class="comment">//从网络中接受数据保存到msg中</span></span><br><span class="line">		saveDB();<span class="comment">//把msg保存到数据库中</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解决方法2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingRandom</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String msg;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">		readFromNet();<span class="comment">//从网络中接受数据保存到msg中</span></span><br><span class="line">		saveDB();<span class="comment">//把msg保存到数据库中</span></span><br><span class="line">        msg = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>改变哈希值</p>
<ul>
<li><p><strong>改变哈希值，当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了</strong>。</p>
</li>
<li><p>否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄漏。</p>
</li>
<li><p>这也是String为什么被设置成了不可变类型，我们可以放心地把String存入HashSet，或者把String当做HashMap的key值；</p>
</li>
<li><p>当我们想把自己定义的类保存到散列表的时候，需要保证对象的hashCode不可变。</p>
</li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeHashCode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet set = <span class="keyword">new</span> HashSet();</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="number">1002</span>, <span class="string">&quot;BB&quot;</span>);</span><br><span class="line"></span><br><span class="line">        set.add(p1);</span><br><span class="line">        set.add(p2);</span><br><span class="line"></span><br><span class="line">        p1.name = <span class="string">&quot;CC&quot;</span>;<span class="comment">//导致了内存的泄漏</span></span><br><span class="line">        set.remove(p1); <span class="comment">//删除失败</span></span><br><span class="line"></span><br><span class="line">        System.out.println(set);</span><br><span class="line"></span><br><span class="line">        set.add(<span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">&quot;CC&quot;</span>));</span><br><span class="line">        System.out.println(set);</span><br><span class="line"></span><br><span class="line">        set.add(<span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>));</span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Person person = (Person) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id != person.id) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> name != <span class="keyword">null</span> ? name.equals(person.name) : person.name == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = id;</span><br><span class="line">        result = <span class="number">31</span> * result + (name != <span class="keyword">null</span> ? name.hashCode() : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeHashCode1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;Point&gt; hs = <span class="keyword">new</span> HashSet&lt;Point&gt;();</span><br><span class="line">        Point cc = <span class="keyword">new</span> Point();</span><br><span class="line">        cc.setX(<span class="number">10</span>);<span class="comment">//hashCode = 41</span></span><br><span class="line">        hs.add(cc);</span><br><span class="line"></span><br><span class="line">        cc.setX(<span class="number">20</span>);<span class="comment">//hashCode = 51  此行为导致了内存的泄漏</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;hs.remove = &quot;</span> + hs.remove(cc));<span class="comment">//false</span></span><br><span class="line">        hs.add(cc);</span><br><span class="line">        System.out.println(<span class="string">&quot;hs.size = &quot;</span> + hs.size());<span class="comment">//size = 2</span></span><br><span class="line"></span><br><span class="line">        System.out.println(hs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        result = prime * result + x;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (getClass() != obj.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Point other = (Point) obj;</span><br><span class="line">        <span class="keyword">if</span> (x != other.x) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Point&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;x=&quot;</span> + x +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>缓存泄露</p>
<ul>
<li><p>内存泄漏的另一个常见来源是缓存，一旦你把对象引用放入到缓存中，他就很容易遗忘。比如：之前项目在一次上线的时候，应用启动奇慢直到夯死，就是因为代码中会加载一个表中的数据到缓存(内存)中，测试环境只有几百条数据，但是生产环境有几百万的数据。</p>
</li>
<li><p>对于这个问题，可以使用WeakHashMap代表缓存，此种Map的特点是，<strong>当除了自身有对key的引用外，此key没有其他引用，那么此map会自动丢弃此值</strong>。</p>
</li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Map wMap = <span class="keyword">new</span> WeakHashMap();</span><br><span class="line">    <span class="keyword">static</span> Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        testWeakHashMap();</span><br><span class="line">        testHashMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String ref1 = <span class="keyword">new</span> String(<span class="string">&quot;obejct1&quot;</span>);</span><br><span class="line">        String ref2 = <span class="keyword">new</span> String(<span class="string">&quot;obejct2&quot;</span>);</span><br><span class="line">        String ref3 = <span class="keyword">new</span> String(<span class="string">&quot;obejct3&quot;</span>);</span><br><span class="line">        String ref4 = <span class="keyword">new</span> String(<span class="string">&quot;obejct4&quot;</span>);</span><br><span class="line">        wMap.put(ref1, <span class="string">&quot;cacheObject1&quot;</span>);</span><br><span class="line">        wMap.put(ref2, <span class="string">&quot;cacheObject2&quot;</span>);</span><br><span class="line">        map.put(ref3, <span class="string">&quot;cacheObject3&quot;</span>);</span><br><span class="line">        map.put(ref4, <span class="string">&quot;cacheObject4&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;String引用ref1，ref2，ref3，ref4 消失&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWeakHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WeakHashMap GC之前&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : wMap.entrySet()) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.gc();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;WeakHashMap GC之后&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : wMap.entrySet()) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HashMap GC之前&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.gc();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;HashMap GC之后&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果：</p>
<ul>
<li>String引用ref1，ref2，ref3，ref4 消失</li>
<li>WeakHashMap GC之前</li>
<li>obejct2=cacheObject2</li>
</ul>
<ul>
<li>obejct1=cacheObject1</li>
<li>WeakHashMap GC之后</li>
<li>HashMap GC之前</li>
<li>obejct4=cacheObject4</li>
<li>obejct3=cacheObject3</li>
<li>Disconnected from the target VM, address: ‘127.0.0.1:51628’, transport: ‘socket’</li>
<li>HashMap GC之后</li>
<li>obejct4=cacheObject4</li>
<li>obejct3=cacheObject3</li>
</ul>
</li>
<li><p>分析：</p>
<p><img src="/2021/04/19/JVM/image-20210717180541120.png" alt="image-20210717180541120"></p>
<ul>
<li>上面代码和图示主演演示WeakHashMap如何自动释放缓存对象，当init函数执行完成后，局部变量字符串引用weakd1、weakd2、d1、d2都会消失，此时只有静态map中保存中对字符串对象的引用，可以看到，调用gc之后，HashMap的没有被回收，而WeakHashMap里面的缓存被回收了。</li>
</ul>
</li>
</ul>
</li>
<li><p>监听器和回调</p>
<ul>
<li>内存泄漏另一个常见来源是<strong>监听器和其他回调</strong>，如果客户端在你实现的API中注册回调，却没有显示的取消，那么就会积聚。</li>
<li>需要确保回调立即被当作垃圾回收的最佳方法是只保存它的弱引用，例如将他们保存成为WeakHashMap中的键。</li>
</ul>
</li>
</ul>
<h5 id="3、内存泄露案例分析"><a href="#3、内存泄露案例分析" class="headerlink" title="3、内存泄露案例分析"></a>3、内存泄露案例分析</h5><h6 id="1、案例代码"><a href="#1、案例代码" class="headerlink" title="1、案例代码"></a>1、案例代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        elements = <span class="keyword">new</span> Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object e)</span> </span>&#123; <span class="comment">//入栈</span></span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//存在内存泄漏</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123; <span class="comment">//出栈</span></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        <span class="keyword">return</span> elements[--size];<span class="comment">//只是将指针下移，没有回收内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elements.length == size)</span><br><span class="line">            elements = Arrays.copyOf(elements, <span class="number">2</span> * size + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2、分析"><a href="#2、分析" class="headerlink" title="2、分析"></a>2、分析</h6><p>上述程序并没有明显的错误，但是这段程序有一个内存泄漏，随着GC活动的增加，或者内存占用的不断增加，程序性能的降低就会表现出来，严重时可导致内存泄漏，但是这种失败情况相对较少。</p>
<p>代码的主要问题在pop函数， 下面通过这张图示展现</p>
<p>假设这个栈一直增长，增长后如下图所示：</p>
<p><img src="/2021/04/19/JVM/image-20210717181048650.png" alt="image-20210717181048650"></p>
<p>当进行大量的pop操作时，由于引用未进行置空，gc是不会释放的，如下图所示：</p>
<p><img src="/2021/04/19/JVM/image-20210717181439315.png" alt="image-20210717181439315"></p>
<p>从上图中看以看出，如果栈先增长，在收缩，那么从栈中弹出的对象将不会被当作垃圾回收，即使程序不再使用栈中的这些队象，他们也不会回收，因为栈中仍然保存这对象的引用，俗称<strong>过期引用</strong>，这个内存泄露很隐蔽。</p>
<h6 id="3、解决办法"><a href="#3、解决办法" class="headerlink" title="3、解决办法"></a>3、解决办法</h6><p>将代码中的pop()方法变成如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">    Object result = elements[--size];</span><br><span class="line">    elements[size] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>一旦引用过期，清空这些引用，将引用置空。</strong></p>
<h6 id="4、案例代码（与移动端的开发有关）"><a href="#4、案例代码（与移动端的开发有关）" class="headerlink" title="4、案例代码（与移动端的开发有关）"></a>4、案例代码（与移动端的开发有关）</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> object key = <span class="keyword">new</span> <span class="number">0</span>bject();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;<span class="comment">//匿名线程</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (key) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        key.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace( );</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="5、分析"><a href="#5、分析" class="headerlink" title="5、分析"></a>5、分析</h6><p><img src="/2021/04/19/JVM/image-20210717182307112.png" alt="image-20210717182307112"></p>
<p><img src="/2021/04/19/JVM/image-20210717182357403.png" alt="image-20210717182357403"></p>
<p>内部类持有外部类：当GC要回收TestActivity的时候，发现内部类（匿名线程）内部持有了外部类（key对象），不能将TestActivity顺利回收，导致了内存泄露。</p>
<h6 id="6、解决方法"><a href="#6、解决方法" class="headerlink" title="6、解决方法"></a>6、解决方法</h6><ol>
<li>使用线程时，一定要确保线程在周期性对象(如Activity) 销毁时能正常结束， 如能正常结束，但是Activity销毁后还需执行一段时间，也可能造成泄露，此时可采用WeakReference方法来解决，另外在使用Handler的时候，如存在Delay操作，也可以采用WeakReference；</li>
<li>使用Handler + HandlerThread时， 记住在周期性对象销毁时调用looper.quit()方法；</li>
</ol>
<h4 id="11、补充2：支持使用OQL语言查询对象信息"><a href="#11、补充2：支持使用OQL语言查询对象信息" class="headerlink" title="11、补充2：支持使用OQL语言查询对象信息"></a>11、补充2：支持使用OQL语言查询对象信息</h4><h5 id="1、介绍-1"><a href="#1、介绍-1" class="headerlink" title="1、介绍"></a>1、介绍</h5><p>MAT支持一种类似于SQL的查询语言OQL (Object Query Language) 。OQL使用类SQL语法，可以在堆中进行对象的查找和筛选。</p>
<h5 id="2、在Eclipse-MAT中如何用"><a href="#2、在Eclipse-MAT中如何用" class="headerlink" title="2、在Eclipse MAT中如何用"></a>2、在Eclipse MAT中如何用</h5><p><img src="/2021/04/19/JVM/C4BC430D-C575-40EC-81F0-44DE723F0EAD.png" alt="img"></p>
<h5 id="3、例子-1"><a href="#3、例子-1" class="headerlink" title="3、例子"></a>3、例子</h5><ol>
<li>select * from java.util.ArrayList（列出所有的ArrayList对象信息）</li>
<li>select v.elementData from java.util.ArrayList v（注意：elementData代表ArrayList底层的数组，结果最终以数组形式将结果呈现出来）</li>
<li>select objects v.elementData from java.util.ArrayList v（注意：elementData代表ArrayList底层的数组，objects代表对象类型，所以最终以对象形式将结果呈现出来，同时展示出来的还有浅堆、深堆）</li>
<li>select as retained set * from com.atguigu.mat.Student（得到对象的保留级）</li>
<li>select * from 0x6cd57c828（0x6cd57c828是Student类的地址值）</li>
<li>select * from char[] s where s.@length &gt; 10（char型数组长度大于10的数组）</li>
<li>select * from java.lang.String s where s.value != null（字符串值不为空的字符串信息）</li>
<li>select toString(f.path.value) from java.io.File f（列出文件的路径值）</li>
<li>select v.elementData.@length from java.util.ArrayList v（列出Arraylist对象中ArrayList中的数组长度）</li>
</ol>
<h5 id="4、SELECT子句"><a href="#4、SELECT子句" class="headerlink" title="4、SELECT子句"></a>4、SELECT子句</h5><p>在MAT中，Select子句的格式与SQL基本一致，用于指定要显示的列。Select子句中可以使用<code>*</code>，查看结果对象的引用实例(相当于outgoing references) 。</p>
<p>SELECT * FROM java.util.Vector v</p>
<p>使用”<code>OBJECTS</code>“关键字，可以将返回结果集中的项以对象的形式显示。</p>
<ul>
<li>SELECT objects v.elementData FROM java.util.Vector v</li>
<li>SELECT OBJECTS s.value FROM java.lang.String s</li>
</ul>
<p>在Select子句中，使用”<code>AS RETAINED SET</code>“关键字可以得到所得对象的保留集。</p>
<ul>
<li>SELECT AS RETAINED SET * FROM com.atguigu.mat.Student</li>
</ul>
<p>“DISTINCT”关键字用于在结果集中去除重复对象。</p>
<ul>
<li>SELECT DISTINCT OBJECTS classof(s) FROM java.lang.String s</li>
</ul>
<h5 id="5、FROM子句"><a href="#5、FROM子句" class="headerlink" title="5、FROM子句"></a>5、FROM子句</h5><p>From子句用于指定查询范围，它可以指定类名、正则表达式或者对象地址。</p>
<p>SELECT * FROM java.lang.StrIng s</p>
<p>下例使用正则表达式，限定搜索范围，输出所有com. atguigu包下所有类的实例</p>
<ul>
<li>SELECT * FROM “com\.atguigu\..*”</li>
</ul>
<p>也可以直接使用类的地址进行搜索。<strong>使用类的地址的好处是可以区分被不同ClassLoader加载的同一种类型</strong>。</p>
<ul>
<li>select * from 0x37a0b4d</li>
</ul>
<h5 id="6、WHERE子句"><a href="#6、WHERE子句" class="headerlink" title="6、WHERE子句"></a>6、WHERE子句</h5><p>Where子句用于指定OQL的查询条件。OQL查询将只返回满足Where子句指定条件的对象。Where子句的格式与传统SQL极为相似。</p>
<p>下例返回长度大于10的char数组。</p>
<ul>
<li>SELECT * FROM char[] s WHERE s.@length&gt;10</li>
</ul>
<p>下例返回包含”java”子字符串的所有字符串，使用”LIKE”操作符，”LIKE”操作符的操作参数为正则表达式。</p>
<ul>
<li>SELECT * FROM java.lang.String s WHERE toString(s) LIKE “. *java. *”</li>
</ul>
<p>下例返回所有value域不为null的字符串，使用”=”操作符。</p>
<ul>
<li>SELECT * FROM java.lang.String s where s. value!=null</li>
</ul>
<p>Where子句支持多个条件的AND、OR运算。下例返回数组长度大于15，并且深堆大于1000字节的所有Vector对象。</p>
<ul>
<li>SELECT * FROM java.util.Vector v WHERE v.elementData.@length&gt;15 AND v. @retainedHeapSize&gt;1000</li>
</ul>
<h5 id="7、内置对象与方法"><a href="#7、内置对象与方法" class="headerlink" title="7、内置对象与方法"></a>7、内置对象与方法</h5><p>OQL中可以访问堆内对象的属性，也可以访问堆内代理对象的属性。访问堆内对象的属性时，格式如下：</p>
<ul>
<li>[ <alias>. ] <field> . <field>. <field></field></field></field></alias></li>
<li>其中alias为对象名称。</li>
</ul>
<p>访问java.io.File对象的path属性，并进一步访问path的value属性：</p>
<ul>
<li>SELECT toString(f.path.value) FROM java.io.File f</li>
</ul>
<p>下例显示了String对象的内容、objectid和objectAddress。</p>
<ul>
<li>SELECT s.toString(), s.@objectId, s.@objectAddress FROM java.lang.String s</li>
</ul>
<p>下例显示java.util.Vector内部数组的长度。</p>
<ul>
<li>SELECT v.elementData.@length FROM java.util.Vector v</li>
</ul>
<p>下例显示了所有的java.util.Vector对象及其子类型</p>
<ul>
<li>select * from INSTANCEOF java.util.Vector</li>
</ul>
<h3 id="4、JVM运行时参数"><a href="#4、JVM运行时参数" class="headerlink" title="4、JVM运行时参数"></a>4、JVM运行时参数</h3><h4 id="1、JVM参数选项"><a href="#1、JVM参数选项" class="headerlink" title="1、JVM参数选项"></a>1、JVM参数选项</h4><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">参数来源</a></p>
<h5 id="1、类型一：标准参数选项"><a href="#1、类型一：标准参数选项" class="headerlink" title="1、类型一：标准参数选项"></a>1、类型一：标准参数选项</h5><h6 id="1、特点"><a href="#1、特点" class="headerlink" title="1、特点"></a>1、特点</h6><ul>
<li>比较稳定，后续版本基本不会变化</li>
<li><strong>以<code>-</code>开头</strong></li>
</ul>
<h6 id="2、各种选项"><a href="#2、各种选项" class="headerlink" title="2、各种选项"></a>2、各种选项</h6><p>直接在DOS窗口中运行java或者java -help可以看到所有的标准选项</p>
<p><img src="/2021/04/19/JVM/image-20210718175015752.png" alt="image-20210718175015752"></p>
<p><img src="/2021/04/19/JVM/image-20210718175046637.png" alt="image-20210718175046637"></p>
<h6 id="3、补充内容：-server与-client"><a href="#3、补充内容：-server与-client" class="headerlink" title="3、补充内容：-server与-client"></a>3、补充内容：-server与-client</h6><p>Hotspot JVM有 两种模式，分别是<code>server</code>（C2编译器）和<code>client</code>（C1编译器），分别通过-server和-client模式设置</p>
<ol>
<li><p><strong>在32位Windows系统上，默认使用Client类型的JVM</strong>。要想使用Server模式，则机器配置至少有2个以上的CPU和2G以上的物理内存。client模式适用于对内存要求较小的桌面应用程序，<strong>默认使用Serial串行垃圾收集器</strong></p>
</li>
<li><p><strong>64位机器上<code>只支持server模式</code>的JVM</strong>，适用于需要大内存的应用程序，<strong>默认使用并行垃圾收集器</strong></p>
</li>
<li><p>关于server和client的<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/server-class.html">官网介绍</a></p>
</li>
</ol>
<p>对于以上第2点，我们可以打开DOS窗口，输入java -version就可以看到64位机器上用的server模式，如下所示：</p>
<p><img src="/2021/04/19/JVM/BD46C8BE-6B93-4AE0-B6D0-C54B879E31AB.png" alt="img"></p>
<h5 id="2、类型二：-X参数选项"><a href="#2、类型二：-X参数选项" class="headerlink" title="2、类型二：-X参数选项"></a>2、类型二：-X参数选项</h5><h6 id="1、特点-1"><a href="#1、特点-1" class="headerlink" title="1、特点"></a>1、特点</h6><ul>
<li>非标准化参数</li>
<li>功能还是比较稳定的。但官方说后续版本可能会变更</li>
<li><strong>以<code>-X</code>开头</strong></li>
</ul>
<h6 id="2、各种选项-1"><a href="#2、各种选项-1" class="headerlink" title="2、各种选项"></a>2、各种选项</h6><p>直接在DOS窗口中运行java -X命令可以看到所有的X选项</p>
<p><img src="/2021/04/19/JVM/image-20210718175909651.png" alt="image-20210718175909651"></p>
<p>其中</p>
<ul>
<li>-Xmixed 混合模式执行 (默认)</li>
<li>-Xint 仅解释模式执行</li>
<li>-Xcomp 仅采用即时编译器模式</li>
</ul>
<h6 id="3、JVM的JIT编译模式相关的选项"><a href="#3、JVM的JIT编译模式相关的选项" class="headerlink" title="3、JVM的JIT编译模式相关的选项"></a>3、JVM的JIT编译模式相关的选项</h6><ul>
<li><p>-Xint</p>
<ul>
<li>只使用解释器：所有字节码都被解释执行，这个模式的速度是很慢的</li>
</ul>
</li>
<li><p>-Xcomp</p>
<ul>
<li>只使用编译器：所有字节码第一次使用就被编译成本地代码，然后在执行</li>
</ul>
</li>
<li><p>-Xmixed（默认）</p>
<ul>
<li><p>混合模式：这是默认模式，刚开始的时候使用解释器慢慢解释执行，后来让JIT即时编译器根据程序运行的情况，有选择地将某些热点代码提前编译并缓存在本地，在执行的时候效率就非常高了。</p>
</li>
<li><p>默认使用的就是这种模式，证明如下：</p>
<p><img src="/2021/04/19/JVM/D8A89BF9-18A3-4BB3-AB4F-7AD2D776F826.png" alt="img"></p>
</li>
</ul>
</li>
</ul>
<h6 id="4、特别地：-Xmx-Xms-Xss属于XX参数？"><a href="#4、特别地：-Xmx-Xms-Xss属于XX参数？" class="headerlink" title="4、特别地：-Xmx -Xms -Xss属于XX参数？"></a>4、特别地：-Xmx -Xms -Xss属于XX参数？</h6><ul>
<li><p>单位分别是：k/K、m/M、g/G</p>
</li>
<li><p>设置：-Xmx、-Xms最好设置成一样的值，避免扩容带来的损耗</p>
<ul>
<li><p>-Xms<size></size></p>
<ul>
<li><p>设置初始Java堆大小，等价于<code>-XX:InitialHeapSize</code></p>
</li>
<li><p>查看该参数值的时候，应该使用InitialHeapSize，例如jinfo flag InitialHeapSize 进程id</p>
</li>
<li><p>等价证明：</p>
<p><img src="/2021/04/19/JVM/61F43F0D-E803-40ED-8D01-3C51769DD3EE.png" alt="img"></p>
<p><img src="/2021/04/19/JVM/963D0947-69DB-4F67-B746-3E2670B13071.png" alt="img"></p>
</li>
</ul>
</li>
<li><p>-Xmx<size></size></p>
<ul>
<li><p>设置最大Java堆大小，等价于<code>-XX:MaxHeapSize</code></p>
</li>
<li><p>查看该参数值的时候，应该使用MaxHeapSize，例如jinfo flag InitialHeapSize 进程id</p>
</li>
<li><p>等价证明：</p>
<p><img src="/2021/04/19/JVM/image-20210718181620379.png" alt="image-20210718181620379"></p>
</li>
</ul>
</li>
<li><p>-Xss<size></size></p>
<ul>
<li>设置Java线程堆栈大小，等价于<code>-XX:ThreadStackSize</code></li>
<li>查看该参数值的时候，应该使用ThreadStackSize，例如jinfo flag InitialHeapSize 进程id</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="3、类型三：-XX参数选项（重要）"><a href="#3、类型三：-XX参数选项（重要）" class="headerlink" title="3、类型三：-XX参数选项（重要）"></a>3、<strong>类型三：-XX参数选项</strong>（重要）</h5><h6 id="1、特点-2"><a href="#1、特点-2" class="headerlink" title="1、特点"></a>1、特点</h6><ul>
<li>非标准化参数</li>
<li><strong>使用的最多的参数类型</strong></li>
<li>这类选项属于实验性，不稳定</li>
<li><strong>以<code>-XX</code>开头</strong></li>
</ul>
<h6 id="2、作用"><a href="#2、作用" class="headerlink" title="2、作用"></a>2、作用</h6><p>用于开发和调试JVM</p>
<h6 id="3、分类"><a href="#3、分类" class="headerlink" title="3、分类"></a>3、<strong>分类</strong></h6><ul>
<li>Boolean类型格式<ul>
<li>-XX:+<option>  表示启用option属性</option></li>
<li>-XX:-<option>   表示禁用option属性</option></li>
<li>举例：<ul>
<li><code>-XX:+UseParallelGC</code>：选择垃圾收集器为并行收集器</li>
<li><code>-XX:+UseG1GC</code>：表示启用G1收集器</li>
<li><code>-XX:+UseAdaptiveSizePolicy</code>：自动选择年轻代区大小和相应的Survivor区比例</li>
</ul>
</li>
<li>说明：因为有的指令默认是开启的，所以可以使用<code>-</code>关闭</li>
</ul>
</li>
<li>非Boolean类型格式（key-value类型）<ul>
<li>子类型1：数值型格式-XX:<option>=<number><ul>
<li>number表示数值，number可以带上单位，比如：’m’、’M’ 表示兆，’k’、’K’表示Kb, ‘g’、’G’表示g (例如32k跟32768是一样的效果)</li>
<li>例如：<ul>
<li><code>-XX:NewSize=1024m</code>：表示设置新生代初始大小为1024兆</li>
<li><code>-XX:MaxGCPauseMillis=500</code>：表示设置GC停顿时间: 500毫秒</li>
<li><code>-XX: GCTimeRatio=19</code>：表示设置吞吐量</li>
<li><code>-XX:NewRatio=2</code>：表示新生代与老年代的比例</li>
</ul>
</li>
</ul>
</number></option></li>
<li>子类型2：非数值型格式-XX:<name>=<string><ul>
<li>例如：<ul>
<li><code>-XX:HeapDumpPath=/usr/local/heapdump.hprof</code>：用来指定heap转存文件的存储路径。</li>
</ul>
</li>
</ul>
</string></name></li>
</ul>
</li>
</ul>
<h6 id="4、特别地：-XX-PrintFlagsFinal"><a href="#4、特别地：-XX-PrintFlagsFinal" class="headerlink" title="4、特别地：-XX:+PrintFlagsFinal"></a>4、特别地：<code>-XX:+PrintFlagsFinal</code></h6><ul>
<li>输出所有参数的名称和默认值</li>
<li>默认不包括Diagnostic和Experimental的参数</li>
<li>可以配合<code>-XX:+UnlockDiagnosticVMOptions</code>和<code>-XX:UnlockExperimentalVMOptions</code>使用</li>
</ul>
<h4 id="2、添加JVM参数选项"><a href="#2、添加JVM参数选项" class="headerlink" title="2、添加JVM参数选项"></a>2、添加JVM参数选项</h4><h5 id="1、Eclipse"><a href="#1、Eclipse" class="headerlink" title="1、Eclipse"></a>1、Eclipse</h5><ol>
<li><p>在空白处单击右键，选择Run As，在选择Run Configurations……</p>
<p><img src="/2021/04/19/JVM/098406BB-FB1F-4DC0-AE87-81C6ECBE6B00.png" alt="img"></p>
</li>
<li><p>设置虚拟机参数</p>
<p><img src="/2021/04/19/JVM/EA52A159-CB0B-4104-9C2C-86579C2B2F3A.png" alt="img"></p>
</li>
</ol>
<h5 id="2、IDEA"><a href="#2、IDEA" class="headerlink" title="2、IDEA"></a>2、IDEA</h5><ol>
<li><p>Edit Configurations…</p>
<p><img src="/2021/04/19/JVM/8432A5D7-B42B-4DD9-AADD-AC996FD9BE0B.png" alt="img"></p>
</li>
<li><p>设置虚拟机参数</p>
<p><img src="/2021/04/19/JVM/0C60AA58-6366-4085-BA1D-FF92EA6AF335.png" alt="img"></p>
</li>
</ol>
<h5 id="3、运行jar包"><a href="#3、运行jar包" class="headerlink" title="3、运行jar包"></a>3、运行jar包</h5><ul>
<li>这是在java -jar demo.jar中的java -jar之间添加了虚拟机配置信息<ul>
<li>java -Xms50m -Xmx50m -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -jar demo.jar</li>
</ul>
</li>
</ul>
<h5 id="4、通过Tomcat运行war包"><a href="#4、通过Tomcat运行war包" class="headerlink" title="4、通过Tomcat运行war包"></a>4、通过Tomcat运行war包</h5><ul>
<li>Linux系统下可以在tomcat/bin/catalina.sh中添加类似如下配置：<ul>
<li>JAVA_OPTS=”-Xms512M -Xmx1024M”</li>
</ul>
</li>
<li>Windows系统下载catalina.bat中添加类似如下配置：<ul>
<li>set “JAVA_OPTS=-Xms512M -Xmx1024M”</li>
</ul>
</li>
</ul>
<h5 id="5、程序运行过程中"><a href="#5、程序运行过程中" class="headerlink" title="5、程序运行过程中"></a>5、程序运行过程中</h5><p>jinfo不仅可以查看运行时某一个Java虛拟机参数的实际取值，甚至可以在运行时修改部分参数，并使之立即生效。</p>
<p>但是，并非所有参数都支持动态修改。参数只有被标记为manageable的flag可以被实时修改。其实，这个修改能力是极其有限的。</p>
<p>#可以查看被标记为manageable的参数：java -XX:+PrintFlagsFinal -version | grep manageable</p>
<p><img src="/2021/04/19/JVM/image-20210713001449847.png" alt="image-20210713001449847"></p>
<ul>
<li>使用jinfo -flag <name>=<value> <pid>设置非Boolean类型参数</pid></value></name></li>
<li>使用jinfo -flag [+|-]<name> <pid>设置Boolean类型参数</pid></name></li>
</ul>
<h4 id="3、常用的JVM参数选项"><a href="#3、常用的JVM参数选项" class="headerlink" title="3、常用的JVM参数选项"></a>3、常用的JVM参数选项</h4><h5 id="1、打印设置的XX选项及值"><a href="#1、打印设置的XX选项及值" class="headerlink" title="1、打印设置的XX选项及值"></a>1、打印设置的XX选项及值</h5><ul>
<li><p><code>-XX:+PrintCommandLineFlags</code>：可以让程序运行前打印出用户手动设置或者JVM自动设置的XX选项</p>
</li>
<li><p><code>-XX:+PrintFlagsInitial</code>：</p>
</li>
<li><p>**<code>-XX:+PrintFlagsFinal</code>**：表示打印出XX选项在运行程序时生效的值</p>
<ul>
<li><p>如果值的前面加上了:=，说明该值不是初始值，该值可能被jvm自动改变了，也可能被我们设置的参数改变了，如下所示：</p>
<p><img src="/2021/04/19/JVM/10326F84-0DAE-4D29-867E-C38676FC36D5.png" alt="img"></p>
</li>
<li><p>有一些被改变的值是项目在启动过程中，系统帮我们修改的</p>
</li>
<li><p>注意区别：</p>
<ul>
<li><p>-XX:+PrintFlagsFinal是打印出<strong>所有</strong>XX选项在运行程序时生效的值</p>
</li>
<li><p><strong><code>jinfo -flag 参数名称 进程id</code>**：查看某个java进程的</strong>具体**参数信息</p>
<ul>
<li><p>进程id可以通过jps命令查看具体操作如下：（其中3540代表进程id）</p>
<p><img src="/2021/04/19/JVM/image-20210713001051530.png" alt="image-20210713001051530"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>-XX:+PrintVMOptions</code>：打印JVM的参数</p>
</li>
</ul>
<h5 id="2、堆、栈、方法区等内存大小设置"><a href="#2、堆、栈、方法区等内存大小设置" class="headerlink" title="2、堆、栈、方法区等内存大小设置"></a>2、堆、栈、方法区等内存大小设置</h5><h6 id="1、栈"><a href="#1、栈" class="headerlink" title="1、栈"></a>1、栈</h6><ul>
<li><code>-Xss128k</code><ul>
<li>设置每个线程的栈大小为128k</li>
<li>等价于<code>-XX:ThreadStackSize</code></li>
</ul>
</li>
</ul>
<h6 id="2、堆内存"><a href="#2、堆内存" class="headerlink" title="2、堆内存"></a>2、堆内存</h6><ul>
<li><code>-Xms3550m</code><ul>
<li>等价于<code>-XX:InitialHeapSize</code>，设置JVM初始堆内存为3500M</li>
</ul>
</li>
<li><code>-Xmx3550m</code><ul>
<li>等价于<code>-XX:MaxHeapSize</code>，设置JVM最大堆内存为3500M</li>
</ul>
</li>
<li><code>-Xmn2g</code><ul>
<li>设置年轻代大小为2G，即等价于<code>-XX:NewSize=2g</code> <code>-XX:MaxNewSize=2g</code>，也就是设置年轻代初始值和年轻代最大值都是2G</li>
<li>官方推荐配置为<strong>整个堆大小的3/8</strong></li>
</ul>
</li>
<li><code>-XX:NewSize=1024m</code><ul>
<li>设置年轻代初始值为1024M</li>
</ul>
</li>
<li><code>-XX:MaxNewSize=1024m</code><ul>
<li>设置年轻代最大值为1024M</li>
</ul>
</li>
<li><code>-XX:SurvivorRatio=8</code><ul>
<li>设置年轻代中Eden区与一个Survivor区的比值，默认为8</li>
<li>只有显示使用Eden区和Survivor区的比例，才会让比例生效，否则比例都会自动设置，至于其中的原因，请看下面的-XX:+UseAdaptiveSizePolicy中的解释，最后推荐使用默认打开的-XX:+UseAdaptiveSizePolicy设置，并且不显示设置-XX:SurvivorRatio</li>
</ul>
</li>
<li><code>-XX:+UseAdaptiveSizePolicy</code><ul>
<li>自动选择各区大小比例，默认开启</li>
<li>分析<ul>
<li>默认开启，将会导致Eden区和Survivor区的比例自动分配，因此也会引起我们默认值-XX:SurvivorRatio=8失效，所以真实比例可能不是8，比如可能是6等</li>
</ul>
</li>
<li>如何设置Eden区和Survivor区的比例：-XX:SurvivorRatio=8<ol>
<li>显示使用显示使用Eden区和Survivor区的比例，那就使用我自己的</li>
<li>没有显示使用Eden区和Survivor区的比例，无论打开或者关闭-XX:+UseAdaptiveSizePolicy，都会自动设置Eden区和Survivor区的比例</li>
</ol>
</li>
<li>结论：<ul>
<li>只有显示使用Eden区和Survivor区的比例，才会让比例生效，否则比例都会自动设置，最后推荐使用默认打开的-XX:+UseAdaptiveSizePolicy设置，并且不显示设置-XX:SurvivorRatio</li>
</ul>
</li>
</ul>
</li>
<li><code>-XX:NewRatio=2</code><ul>
<li>设置老年代与年轻代（包括1个Eden区和2个Survivor区）的比值，默认为2</li>
<li>根据实际情况进行设置，主要根据对象生命周期来进行分配，如果对象生命周期很长，那么让老年代大一点，否则让新生代大一点</li>
</ul>
</li>
<li><code>-XX:PretenureSizeThreadshold=1024</code><ul>
<li>设置让大于此阈值的对象直接分配在老年代，单位为字节</li>
<li>只对Serial、ParNew收集器有效</li>
<li>不好控制</li>
</ul>
</li>
<li><code>-XX:MaxTenuringThreshold=15</code><ul>
<li>默认值为15</li>
<li>新生代每次MinorGC后，还存活的对象年龄+1，当对象的年龄大于设置的这个值时就进入老年代</li>
</ul>
</li>
<li><code>-XX:+PrintTenuringDistribution</code><ul>
<li>让JVM在每次MinorGC后打印出当前使用的Survivor中对象的年龄分布</li>
</ul>
</li>
<li><code>-XX:TargetSurvivorRatio</code><ul>
<li>表示MinorGC结束后Survivor区域中占用空间的期望比例</li>
</ul>
</li>
</ul>
<h6 id="3、方法区"><a href="#3、方法区" class="headerlink" title="3、方法区"></a>3、方法区</h6><ul>
<li>永久代<ul>
<li><code>-XX:PermSize=256m</code><ul>
<li>设置永久代初始值为256M</li>
</ul>
</li>
<li><code>-XX:MaxPermSize=256m</code><ul>
<li>设置永久代最大值为256M</li>
</ul>
</li>
</ul>
</li>
<li>元空间<ul>
<li><code>-XX:MetaspaceSize</code><ul>
<li>初始空间大小</li>
</ul>
</li>
<li><code>-XX:MaxMetaspaceSize</code><ul>
<li>最大空间，默认没有限制</li>
</ul>
</li>
<li><code>-XX:+UseCompressedOops</code><ul>
<li>使用压缩对象指针</li>
</ul>
</li>
<li><code>-XX:+UseCompressedClassPointers</code><ul>
<li>使用压缩类指针</li>
</ul>
</li>
<li><code>-XX:CompressedClassSpaceSize</code><ul>
<li>设置Klass Metaspace的大小，默认1G</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="4、直接内存"><a href="#4、直接内存" class="headerlink" title="4、直接内存"></a>4、直接内存</h6><ul>
<li><code>-XX:MaxDirectMemorySize</code><ul>
<li>指定DirectMemory容量，若未指定，则默认与Java堆最大值一样</li>
</ul>
</li>
</ul>
<h5 id="3、OutOfMemory相关的选项"><a href="#3、OutOfMemory相关的选项" class="headerlink" title="3、OutOfMemory相关的选项"></a>3、OutOfMemory相关的选项</h5><ul>
<li><p><code>-XX:+HeapDumpOnOutMemoryError</code></p>
<ul>
<li>表示<strong>在内存出现OOM的时候，生成Heap转储文件，以便后续分析</strong></li>
<li>-<code>XX:+HeapDumpBeforeFullGC</code>和<code>-XX:+HeapDumpOnOutMemoryError</code>只能设置1个</li>
</ul>
</li>
<li><p><code>-XX:+HeapDumpBeforeFullGC</code></p>
<ul>
<li>表示<strong>在出现FullGC之前，生成Heap转储文件，以便后续分析</strong></li>
<li><code>-XX:+HeapDumpBeforeFullGC</code>和<code>-XX:+HeapDumpOnOutMemoryError</code>只能设置1个</li>
<li>请注意<strong>FullGC可能出现多次</strong>，那么dump文件也会生成多个，而OOM只能有一次，所以<code>-XX:+HeapDumpOnOutMemoryError</code>生成的dump文件只有一个</li>
</ul>
</li>
<li><p><code>-XX:HeapDumpPath=&lt;path&gt;</code></p>
<ul>
<li>指定heap转存文件的存储路径，如果不指定，就会将dump文件放在当前目录中</li>
</ul>
</li>
<li><p><code>-XX:OnOutOfMemoryError</code></p>
<ul>
<li><p>指定一个可行性程序或者脚本的路径，当发生OOM的时候，去执行这个脚本</p>
</li>
<li><p>对OnOutOfMemoryError的运维处理：</p>
<ul>
<li><p>以部署在linux系统/opt/Server目录下的Server.jar为例：</p>
<ol>
<li><p>在run. sh启动脚本中添加jvm参数：<code>-XX:OnOutOfMemoryError=/opt/Server/restart.sh</code></p>
</li>
<li><p>restart.sh脚本：</p>
<ul>
<li><p>linux环境：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">pid=$(ps -eflgrep Server.jar|awk &#x27;&#123;if($8==&quot;java&quot;) &#123;print $2&#125;&#125;&#x27;)</span><br><span class="line">kill -9 $pid</span><br><span class="line">cd /opt/Server/;sh run.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>Windows环境：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo off</span><br><span class="line">wmic process where Name=&#x27;java.exe&#x27; delete</span><br><span class="line">cd D:\Server</span><br><span class="line">start run.bat</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="4、垃圾收集器相关选项"><a href="#4、垃圾收集器相关选项" class="headerlink" title="4、垃圾收集器相关选项"></a>4、垃圾收集器相关选项</h5><p>7款经典收集器与垃圾分代之间的关系：</p>
<p><img src="/2021/04/19/JVM/image-20210429024547757.png" alt="image-20210429024547757"></p>
<p>垃圾收集器的组合关系：</p>
<p><img src="/2021/04/19/JVM/image-20210429023609239.png" alt="image-20210429023609239"></p>
<ol>
<li><p>两个收集器间有连线，表明它们可以搭配使用：</p>
<p>Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1;</p>
</li>
<li><p>其中Serial Old作为CMS出现”Concurrent Mode Failure” 失败的后备预案。</p>
</li>
<li><p>(红色虚线)由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃(JEP 173)，并在JDK 9中完全取消了这些组合的支持(JEP214) ，即：移除。</p>
</li>
<li><p>(绿色虚线)JDK 14中：弃用Parallel Scavenge和Serial Old GC组合(JEP366)</p>
</li>
<li><p>(青色虚线)JDK 14中：删除CMS垃圾回收器 (JEP 363)</p>
</li>
</ol>
<h6 id="1、查看默认的垃圾回收器"><a href="#1、查看默认的垃圾回收器" class="headerlink" title="1、查看默认的垃圾回收器"></a>1、查看默认的垃圾回收器</h6><ul>
<li><code>-XX:+PrintCommandLineFlags</code>：查看命令行相关参数(包含使用的垃圾收集器)</li>
<li>使用命令行指令: <code>jinfo - flag 相关垃圾回收器参数进程ID</code></li>
</ul>
<p>以上两种方式都可以查看默认使用的垃圾回收器，第一种方式更加准备，但是需要程序的支持；第二种方式需要去尝试，如果使用了，返回的值中有<code>+</code>号（使用），否则就是<code>-</code>号（没使用）。</p>
<h6 id="2、Serial回收器"><a href="#2、Serial回收器" class="headerlink" title="2、Serial回收器"></a>2、Serial回收器</h6><ul>
<li>Serial收集器作为HotSpot中Client模式下的默认新生代垃圾收集器。</li>
<li>Serial Old是运行在Client模式下默认的老年代的垃圾回收器。</li>
<li><code>-XX:+UseSerialGC</code>：<ul>
<li>指定年轻代和老年代都使用串行收集器。等价于新生代用Serial GC，且老年代用Serial Old GC。 可以获得最高的单线程收集效率。</li>
</ul>
</li>
</ul>
<h6 id="3、Parnew回收器"><a href="#3、Parnew回收器" class="headerlink" title="3、Parnew回收器"></a>3、Parnew回收器</h6><ul>
<li><code>-XX: +UseParNewGC</code>：<ul>
<li>手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</li>
</ul>
</li>
<li><code>-XX:ParallelGCThreads</code>：<ul>
<li>设置年轻代并行收集器的线程数。一般地， 最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</li>
<li>在默认情况下，<strong>当CPU数量小于8个， ParallelGCThreads 的值等于CPU数量。</strong></li>
<li><strong>当CPU数量大于8个，ParallelGCThreads的值等于<code>3 + [5 * CPU_Count] / 8]</code> 。</strong></li>
</ul>
</li>
</ul>
<p>注意：根据下图可知，该回收器最终将会没有搭档，那就相当于被遗弃了（JDK14以后）</p>
<p><img src="/2021/04/19/JVM/image-20210429023609239.png" alt="image-20210429023609239"></p>
<h6 id="4、Parallel回收器"><a href="#4、Parallel回收器" class="headerlink" title="4、Parallel回收器"></a>4、Parallel回收器</h6><ul>
<li><code>-XX:+UseParallelGC</code><ul>
<li>手动指定年轻代使用Parallel并行收集器执行内存回收任务。</li>
</ul>
</li>
<li><code>-XX: +UseParallelOldGC</code>：<ul>
<li>手动指定 =老年代都是使用并行回收收集器。<ul>
<li>分别适用于新生代和老年代。默认jdk8是开启的。</li>
<li>上面两个参数，默认开启一个， 另一个也会被开启。(<strong>互相激活</strong>)</li>
</ul>
</li>
</ul>
</li>
<li><code>-XX:ParallelGCThreads</code>：<ul>
<li>设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</li>
<li>在默认情况下，<strong>当CPU 数量小于8个，ParallelGCThreads 的值等于CPU数量</strong>。</li>
<li><strong>当CPU数量大于8个，ParallelGCThreads的值等于<code>3 + [5 * CPU_Count] / 8]</code> 。</strong></li>
</ul>
</li>
<li><code>-XX:MaxGCPauseMillis</code>：<ul>
<li>设置垃圾收集器最大停顿时间(即STW的时间)。单位是毫秒。</li>
<li>为了尽可能地把停顿时间控制在MaxGCPauseMills以内，收集器在工作时会调整Java堆大小或者其他一些参数。</li>
<li>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。</li>
<li><strong>该参数使用需谨慎。</strong></li>
</ul>
</li>
<li><code>-XX:GCTimeRatio</code>：<ul>
<li>垃圾收集时间占总时间的比例(= 1 / (N + 1))。用于衡量吞吐量的大小。</li>
<li>取值范围(0,100) 。默认值99，也就是垃圾回收时间不超过1%。</li>
<li>与前一个<code>-XX:MaxGCPauseMillis</code>参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。</li>
</ul>
</li>
<li><code>-XX: +UseAdaptiveSizePolicy</code>：<ul>
<li>设置Parallel Scavenge收集器具有自适应调节策略</li>
<li>在这种模式下，年轻代的大小、Eden 和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</li>
<li>在手动调优比较困难的场合，可以直接使用这种自适应的方式，<strong>仅指定虚拟机的最大堆、目标的吞吐量(GCTimeRatio) 和停顿时间(MaxGCPauseMills)</strong> ，让虚拟机自已完成调优工作。</li>
</ul>
</li>
</ul>
<p>注意：</p>
<ol>
<li><strong>Parallel回收器主打吞吐量</strong>，而<strong>CMS和G1主打低延迟</strong>，<strong>如果主打吞吐量，那么就不应该限制最大停顿时间，所以-XX:MaxGCPauseMills不应该设置</strong></li>
<li>-XX:MaxGCPauseMills中的调整堆大小通过默认开启的-XX:+UseAdaptiveSizePolicy来实现</li>
<li>-XX:GCTimeRatio用来衡量吞吐量，并且和-XX:MaxGCPauseMills矛盾，因此不会同时使用</li>
</ol>
<h6 id="5、CMS回收器"><a href="#5、CMS回收器" class="headerlink" title="5、CMS回收器"></a>5、CMS回收器</h6><ul>
<li><code>-XX:+UseConcMarkSweepGC</code>：<ul>
<li>手动指定使用CMS收集器执行内存回收任务。</li>
<li>开启该参数后会自动将<code>-XX:+UseParNewGC</code>打开。</li>
<li>即：ParNew(Young区用)+CMS(Old区用)+Serial Old的组合。</li>
</ul>
</li>
<li><code>-XX:CMS1nitiatingOccupanyFraction</code>：<ul>
<li>设置堆内存使用率的阅值，一旦达到该阈值，便开始进行回收。</li>
<li>JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次CMS回收。**JDK6及以上版本默认值为92%**。</li>
<li>如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阅值，以避免频繁触发老年代串行收集器。因此<strong>通过该选项便可以有效降低Full GC的执行次数</strong>。</li>
</ul>
</li>
<li><code>-XX:+UseCMSCompactAtFullCollection</code>：<ul>
<li>用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时<br>间变得更长了。</li>
</ul>
</li>
<li><code>-XX:CMSFullGCsBeforeCompaction</code>：<ul>
<li>设置在执行多少次Full GC后对内存空间进行压缩整理。</li>
</ul>
</li>
<li><code>-XX:ParallelCMSThreads</code>：<ul>
<li>设置CMS的线程数量。</li>
<li>CMS默认启动的线程数是**(ParallelGCThreads + 3) / 4**，ParallelGCThreads 是年轻代并行收集器的线程数。当CPU 资源比较紧涨时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</li>
</ul>
</li>
</ul>
<p>-XX:ParallelCMSThreads和ParallelGCThreads有关系，ParallelGCThreads在上面Parnew回收器中有提到</p>
<p>另外，CMS收集器还有如下常用参数：</p>
<ul>
<li><code>-XX:ConcGCThreads</code>：<ul>
<li>设置并发垃圾收集的线程数，默认该值是基于ParallelGCThreads计算出来的；</li>
</ul>
</li>
<li><code>-XX:+UseCMSInitiatingOccupancyOnly</code>：<ul>
<li>是否动态可调，用这个参数可以使CMS直按CMSInitiatingOccupancyFraction设定的值启动</li>
</ul>
</li>
<li><code>-XX:+CMSScavengeBeforeRemark</code>：<ul>
<li>强制hotspot 虚拟机在cms remark阶段之前做一次minor gc，用于提高remark阶段的速度</li>
</ul>
</li>
<li><code>-XX:+CMSClassUnloadingEnable</code>：<ul>
<li>如果有的话，启用回收Perm区(JDK8之前)</li>
</ul>
</li>
<li><code>-XX:+CMSParallelInitialEnabled</code>：<ul>
<li>用于开启CMS initial-mark阶段采用多线程的方式进行标记，用于提高标记速度，在Java8开始已经默认开启；</li>
</ul>
</li>
<li><code>-XX:+CMSParallelRemarkEnbled</code>：<ul>
<li>用户开启CMS remark阶段采用多线程的方式进行重新标记。默认开启；</li>
</ul>
</li>
<li><code>-XX:+ExplicitGCInvokesConcurrent</code>、<code>-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses</code>：<ul>
<li>这两个参数用户指定hotspot虚拟在执行System.gc()时使用CMS周期；</li>
</ul>
</li>
<li><code>-XX:+CMSPrecleaningEnabled</code>：<ul>
<li>指定CMS是否需要进行Pre cleaning这个阶段</li>
</ul>
</li>
</ul>
<p>特别说明：</p>
<ul>
<li>JDK9新特性：CMS被标记为Deprecate 了(JEP291)<ul>
<li>如果对JDK 9及以上版本的HotSpot虚拟机使用参数<code>-XX:+UseConcMarkSweepGC</code>来开启CMS收集器的话，用户会收到一个警告信息，提示<br>CMS未来将会被废弃。</li>
</ul>
</li>
<li>JDK14新特性：删除CMS垃圾回收器(JEP363)<ul>
<li>移除了CMS垃圾收集器，如果在JDK14中使用<code>-XX:+UseConcMarkSweepGC</code>的话JVM不会报错，只是给出一个warning信息，但是不会exit。JVM会自动回退以默认GC方式启动JVM</li>
<li>OpenJDK 64-Bit Server VM warning: Ignoring option UseConcMarkSweepGc；support was removed in 14.0 and the VM will continue execution using the default collector.</li>
</ul>
</li>
</ul>
<h6 id="6、G1回收器"><a href="#6、G1回收器" class="headerlink" title="6、G1回收器"></a>6、G1回收器</h6><ul>
<li><code>-XX:+UseG1GC</code>：<ul>
<li>手动指定使用G1收集器执行内存回收任务。</li>
</ul>
</li>
<li><code>-XX:G1HeapRegionSize</code>：<ul>
<li>设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。<strong>默认是堆内存的1/2000</strong>。</li>
</ul>
</li>
<li><code>-XX: MaxGCPauseMillis</code>：<ul>
<li>设置期望达到的最大GC停顿时间指标(JVM会尽力实现，但不保证达到)。<strong>默认值是200ms</strong></li>
<li><code>-XX: ParallelGCThread</code>：<ul>
<li>设置STW时GC线程数的值。<strong>最多设置为8</strong></li>
</ul>
</li>
</ul>
</li>
<li><code>-XX:ConcGCThreads</code>：<ul>
<li>设置并发标记的线程数。<strong>将n设置为并行垃圾回收线程数(ParallelGCThreads)的1/4左右</strong>。</li>
</ul>
</li>
<li><code>-XX:InitiatingHeapoccupancyPercent</code>：<ul>
<li>设置触发并发GC周期的Java堆占用率阙值。超过此值，就触发GC。<strong>默认值是45</strong>。</li>
</ul>
</li>
<li><code>-XX: G1NewSizePercent</code>、 <code>-XX:G1MaxNewSizePercent</code>：<ul>
<li>新生代占用整个堆内存的最小百分比(默认5%)、最大百分比( 默认60%)</li>
</ul>
</li>
<li><code>-XX:G1ReservePercent=10</code><ul>
<li>保留内存区域，防止to space (Survivor中的to区)溢出</li>
</ul>
</li>
</ul>
<p>注意：</p>
<ul>
<li>如果使用G1垃圾收集器，<strong>不建议设置<code>-Xmn</code>和<code>-XX:NewRatio</code>，毕竟可能影响G1的自动调节</strong></li>
</ul>
<p>Mixed GC调优参数：</p>
<ul>
<li>注意：<ul>
<li>G1收集器主要涉及到Mixed GC，<strong>Mixed GC 会回收young区和部分old区</strong>。</li>
</ul>
</li>
<li>G1关于MixedGC调优常用参数：<ul>
<li><code>-XX:InitiatingHeapOccupancyPercent</code>：<ul>
<li>设置堆占用率的百分比(0到100)达到这个数值的时候触发global concurrent marking (全局并发标记)，<strong>默认为45%**。</strong>值为0表示间断进行全局并发标记**。</li>
</ul>
</li>
<li><code>-XX:G1MixedGCLiveThresholdPercent</code>：<ul>
<li>设置Old区的region被回收时候的对象占比，**默认占用率为85%**。只有Old区的region中存活的对象占用达到了这个百分比才会在Mixed GC中被回收。</li>
</ul>
</li>
<li><code>-XX:G1HeapWastePercent</code>：<ul>
<li>在global concurrent marking (全局并发标记)结束之后，可以知道所有的区有多少空间要被回收，在每次young GC之后和再次发生Mixed GC之前，会检查垃圾占比是否达到此参数，只有达到了，下次才会发生Mixed GC。</li>
</ul>
</li>
<li><code>-XX:G1MixedGCCountTarget</code>：<ul>
<li>一次global concurrent marking (全局并发标记)之后，最多执行Mixed GC的次数，<strong>默认是8</strong>。</li>
</ul>
</li>
<li><code>-XX:G1OldCSetRegionThresholdPercent</code>：<ul>
<li>设置Mixed GC收集周期中要收集的Old region数的 上限。<strong>默认值是Java堆的10%</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="7、怎么选择垃圾收集器"><a href="#7、怎么选择垃圾收集器" class="headerlink" title="7、怎么选择垃圾收集器"></a>7、怎么选择垃圾收集器</h6><ul>
<li>优先调整堆的大小让JVM自适应完成。</li>
<li>如果内存小于100M，使用串行收集器</li>
<li>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</li>
<li>如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择</li>
<li>如果是多CPU、追求低停顿时间，需快速响应(比如延迟不能超过1秒，如互联网应用)，使用并发收集器。官方推荐G1，性能高。<strong>现在互联网的项目，基本都是使用G1</strong>。</li>
</ul>
<p>特别说明：</p>
<ol>
<li>没有最好的收集器，更没有万能的收集；</li>
<li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li>
</ol>
<h5 id="5、GC日志相关选项"><a href="#5、GC日志相关选项" class="headerlink" title="5、GC日志相关选项"></a>5、GC日志相关选项</h5><h6 id="1、常用参数"><a href="#1、常用参数" class="headerlink" title="1、常用参数"></a>1、常用参数</h6><ul>
<li><p><code>-verbose:gc</code>：</p>
<ul>
<li><p>输出日志信息，默认输出的标准输出</p>
</li>
<li><p>可以独立使用</p>
<p><img src="/2021/04/19/JVM/image-20210719003357660.png" alt="image-20210719003357660"></p>
</li>
</ul>
</li>
<li><p><code>-XX:+PrintGC</code>：</p>
<ul>
<li><p>等同于<code>-verbose:gc</code>表示打开简化的日志</p>
</li>
<li><p>可以独立使用</p>
<p><img src="/2021/04/19/JVM/image-20210719003357660.png" alt="image-20210719003357660"></p>
</li>
</ul>
</li>
<li><p>**<code>-XX:+PrintGCDetails</code>**：</p>
<ul>
<li><p>在发生垃圾回收时打印内存回收详细的日志，并在进程退出时输出当前内存各区域的分配情况</p>
</li>
<li><p>可以独立使用</p>
<p><img src="/2021/04/19/JVM/image-20210719003601948.png" alt="image-20210719003601948"></p>
</li>
</ul>
</li>
<li><p>**<code>-XX:+PrintGCTimeStamps</code>**：</p>
<ul>
<li><p>程序启动到GC发生的时间秒数</p>
</li>
<li><p>不可以独立使用，需要配合-XX:+PrintGCDetails使用</p>
<p><img src="/2021/04/19/JVM/2B360717-915B-414F-8897-127B432CD616.png" alt="img"></p>
</li>
</ul>
</li>
<li><p><code>-XX:+PrintGCDateStamps</code>：</p>
<ul>
<li><p>输出GC发生时的时间戳（以日期的形式，例如：2013-05-04T21:53:59.234+0800）</p>
</li>
<li><p>不可以独立使用，可以配合-XX:+PrintGCDetails使用</p>
<p><img src="/2021/04/19/JVM/96A76B65-8305-4A60-A695-F7079E5BAE03.png" alt="img"></p>
</li>
</ul>
</li>
<li><p><code>-XX:+PrintHeapAtGC</code>：</p>
<ul>
<li><p>每一次GC前和GC后，都打印堆信息</p>
</li>
<li><p>可以独立使用</p>
</li>
<li><p>若配合**<code>-XX:+PrintGCDetails</code>**一起使用的话，可以将两个命令的结果结合在一起：每一次GC前和GC后，都打印堆信息+在进程退出时输出当前内存各区域的分配情况</p>
<p><img src="/2021/04/19/JVM/2C4F1339-2902-48E6-B298-B5F19C8C93D7.png" alt="img"></p>
</li>
</ul>
</li>
<li><p>**<code>-XIoggc:&lt;file&gt;</code>**：</p>
<ul>
<li><p>把GC日志写入到一个文件中去，而不是打印到标准输出中</p>
<p><img src="/2021/04/19/JVM/DCEA1B70-2B04-4F80-9425-9F037465D0BB.png" alt="img"></p>
</li>
</ul>
</li>
</ul>
<h6 id="2、其他参数"><a href="#2、其他参数" class="headerlink" title="2、其他参数"></a>2、其他参数</h6><ul>
<li><p><code>-XX:TraceClassLoading</code>：</p>
<ul>
<li>监控类的加载</li>
</ul>
</li>
<li><p><code>-XX:PrintGCApplicationStoppedTime</code>：</p>
<ul>
<li><p>打印GC时线程的停顿时间</p>
<p><img src="/2021/04/19/JVM/image-20210719004842828.png" alt="image-20210719004842828"></p>
</li>
</ul>
</li>
<li><p><code>-XX:+PrintGCApplicationConcurrentTime</code>：</p>
<ul>
<li>垃圾收集之前打印出应用未中断的执行时间</li>
</ul>
</li>
<li><p><code>-XX:+PrintReferenceGC</code>：</p>
<ul>
<li>记录回收了多少种不同引用类型的引用</li>
</ul>
</li>
<li><p><code>-XX:+PrintTenuringDistribution</code>：</p>
<ul>
<li>让JVM在每次MinorGC后打印出当前使用的Survivor中对象的年龄分布</li>
</ul>
</li>
<li><p><code>-XX:+UseGCLogFileRotation</code>：</p>
<ul>
<li>启用GC日志文件的自动转储</li>
</ul>
</li>
<li><p><code>-XX:NumberOfGCLogFiles=1</code>：</p>
<ul>
<li>GC日志文件的循环数目</li>
</ul>
</li>
<li><p><code>-XX:GCLogFileSize=1M</code>：</p>
<ul>
<li>控制GC日志文件的大小</li>
</ul>
</li>
</ul>
<h5 id="6、其他参数"><a href="#6、其他参数" class="headerlink" title="6、其他参数"></a>6、其他参数</h5><ul>
<li><code>-XX:+DisableExplicitGC</code>：<ul>
<li>禁用hotspot执行System.gc()，默认禁用</li>
</ul>
</li>
<li><code>-XX:ReservedCodeCacheSize=&lt;n&gt;[g|m|k]</code>、<code>-XX:InitialCodeCacheSize=&lt;n&gt;[g|m|k]</code>：<ul>
<li>指定代码缓存的大小</li>
</ul>
</li>
<li><code>-XX:+UseCodeCacheFlushing</code>：<ul>
<li>使用该参数让jvm放弃一些被编译的代码，避免代码缓存被占满时JVM切换到interpreted-only的情况</li>
</ul>
</li>
<li><code>-XX:+DoEscapeAnalysis</code>：<ul>
<li>开启逃逸分析</li>
</ul>
</li>
<li><code>-XX:+UseBiasedLocking</code>：<ul>
<li>开启偏向锁</li>
</ul>
</li>
<li><code>-XX:+UseLargePages</code>：<ul>
<li>开启使用大页面</li>
</ul>
</li>
<li><code>-XX:+PrintTLAB</code>：<ul>
<li>打印TLAB的使用情况</li>
</ul>
</li>
<li><code>-XX:TLABSize</code>：<ul>
<li>设置TLAB大小</li>
</ul>
</li>
</ul>
<h4 id="4、通过Java代码获取JVM参数"><a href="#4、通过Java代码获取JVM参数" class="headerlink" title="4、通过Java代码获取JVM参数"></a>4、通过Java代码获取JVM参数</h4><p>Java提供了java.lang.management包用于监视和管理Java虚拟机和Java运行时中的其他组件，它允许本地和远程监控和管理运行的Java虛拟机。其中ManagementFactory这个类还是挺常用的。另外还有Runtime类也可以获取一些内存、CPU核数等相关的数据。</p>
<p>通过这些api可以监控我们的应用服务器的堆内存使用情况，设置一些阈值进行报警等处理。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 监控我们的应用服务器的堆内存使用情况，设置一些阈值进行报警等处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryMonitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MemoryMXBean memorymbean = ManagementFactory.getMemoryMXBean();</span><br><span class="line">        MemoryUsage usage = memorymbean.getHeapMemoryUsage();</span><br><span class="line">        System.out.println(<span class="string">&quot;INIT HEAP: &quot;</span> + usage.getInit() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;MAX HEAP: &quot;</span> + usage.getMax() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;USE HEAP: &quot;</span> + usage.getUsed() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;\nFull Information:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Heap Memory Usage: &quot;</span> + memorymbean.getHeapMemoryUsage());</span><br><span class="line">        System.out.println(<span class="string">&quot;Non-Heap Memory Usage: &quot;</span> + memorymbean.getNonHeapMemoryUsage());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=======================通过java来获取相关系统状态============================ &quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前堆内存大小totalMemory &quot;</span> + (<span class="keyword">int</span>) Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);<span class="comment">// 当前堆内存大小</span></span><br><span class="line">        System.out.println(<span class="string">&quot;空闲堆内存大小freeMemory &quot;</span> + (<span class="keyword">int</span>) Runtime.getRuntime().freeMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);<span class="comment">// 空闲堆内存大小</span></span><br><span class="line">        System.out.println(<span class="string">&quot;最大可用总堆内存maxMemory &quot;</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);<span class="comment">// 最大可用总堆内存大小</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上篇可以通过Runtime获取：</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSpaceInitial</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//返回Java虚拟机中的堆内存总量</span></span><br><span class="line">        <span class="keyword">long</span> initialMemory = Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">        <span class="comment">//返间Java虚拟机试图使用的最大堆内存量</span></span><br><span class="line">        <span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        System.out.print1n(<span class="string">&quot;-Xms :&quot;</span> + initialMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-Xmx :&quot;</span> + maxMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;系统内存大小为:&quot;</span> + maxMemory * <span class="number">4.0</span> / <span class="number">1024</span> + <span class="string">&quot;G&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;系统内存大小为:&quot;</span> + initialMemory * <span class="number">64.0</span> / <span class="number">1024</span> + <span class="string">&quot;G&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5、分析GC日志"><a href="#5、分析GC日志" class="headerlink" title="5、分析GC日志"></a>5、分析GC日志</h3><h4 id="1、GC日志参数"><a href="#1、GC日志参数" class="headerlink" title="1、GC日志参数"></a>1、GC日志参数</h4><p>同上面第4、JVM运行时参数中的第5点、GC日志相关选项一致</p>
<h4 id="2、GC日志格式"><a href="#2、GC日志格式" class="headerlink" title="2、GC日志格式"></a>2、GC日志格式</h4><h5 id="1、复习：GC分类"><a href="#1、复习：GC分类" class="headerlink" title="1、复习：GC分类"></a>1、复习：GC分类</h5><p>针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大种类型：一种是<strong>部分收集（Partial GC）</strong>，一种是<strong>整堆收集（Full GC）</strong></p>
<ul>
<li>部分收集（Partial GC）：不是完整收集整个 Java 堆的垃圾收集。其中又分为：<ul>
<li><strong>新生代收集（Minor GC / Young GC）</strong>：只是新生代（Eden / S0, S1）的垃圾收集</li>
<li><strong>老年代收集（Major GC / Old GC）</strong>：只是老年代的垃圾收集。<ul>
<li>目前，只有 CMS GC 会有单独收集老年代的行为。</li>
<li>注意：<ul>
<li><strong>在进行Major GC之前，系统会先进行一次Minor GC</strong></li>
<li><strong>很多时候 Major GC 会和 Full GC 混淆使用，需要具体分辨是老年代回收还是整堆回收。</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>混合收集（Mixed GC）</strong>：收集整个新生代以及部分老年代的垃圾收集。<ul>
<li>目前，只有 G1 GC 会有这种行为</li>
</ul>
</li>
</ul>
</li>
<li>整堆收集（Full GC）：收集整个 java 堆和方法区的垃圾收集。</li>
</ul>
<p>那些情况会触发Full GC呢？</p>
<ul>
<li>老年代空间不足</li>
<li>方法区空间不足</li>
<li>显式调用System.gc()</li>
<li>Minor GC进入老年代的数据的平均大小 大于 老年代的可用内存</li>
<li>大对象直接进入老年代，而老年代的可用空间不足</li>
</ul>
<h5 id="2、GC日志分类"><a href="#2、GC日志分类" class="headerlink" title="2、GC日志分类"></a>2、GC日志分类</h5><h6 id="1、Minor-GC"><a href="#1、Minor-GC" class="headerlink" title="1、Minor GC"></a>1、Minor GC</h6><p>MinorGC（或 young GC 或 YGC）日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 31744K-&gt;2192K (36864K) ] 31744K-&gt;2200K (121856K), 0.0139308 secs] [Times: user=0.05 sys=0.01, real=0.01 secs]</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/19/JVM/image-20210719011748465.png" alt="image-20210719011748465"></p>
<p><img src="/2021/04/19/JVM/image-20210719011823127.png" alt="image-20210719011823127"></p>
<h6 id="2、Full-GC"><a href="#2、Full-GC" class="headerlink" title="2、Full GC"></a>2、Full GC</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Full GC (Metadata GC Threshold) [PSYoungGen: 5104K-&gt;0K (132096K) ] [Par01dGen: 416K-&gt;5453K (50176K) ]5520K-&gt;5453K (182272K), [Metaspace: 20637K-&gt;20637K (1067008K) ], 0.0245883 secs] [Times: user=0.06 sys=0.00, real=0.02 secs]</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/19/JVM/image-20210719011929852.png" alt="image-20210719011929852"></p>
<p><img src="/2021/04/19/JVM/image-20210719012024393.png" alt="image-20210719012024393"></p>
<h5 id="3、GC日志结构剖析"><a href="#3、GC日志结构剖析" class="headerlink" title="3、GC日志结构剖析"></a>3、GC日志结构剖析</h5><h6 id="1、透过日志看垃圾收集器"><a href="#1、透过日志看垃圾收集器" class="headerlink" title="1、透过日志看垃圾收集器"></a>1、透过日志看垃圾收集器</h6><ul>
<li>使用<code>Serial收集器</code>在<strong>新生代</strong>的名字是Default New Generation，因此显示的是”<code>[DefNew</code>“</li>
<li>使用<code>ParNew收集器</code>在<strong>新生代</strong>的名字会变成”<code>[ParNew</code>“，意思是”Parallel New Generation’</li>
<li>使用<code>Parallel Scavenge收集器</code>在<strong>新生代</strong>的名字是”<code>[PSYoungGen</code>“，这里的JDK1.7使用的就是PSYoungGen</li>
<li>使用<code>Parallel Old Generation收集器</code>在<strong>老年代</strong>的名字是”<code>[ParOldGen</code>“</li>
<li>使用<code>G1收集器</code>的话，会显示为”<code>garbage-first heap</code>“</li>
</ul>
<h6 id="2、透过日志看-GC-原因"><a href="#2、透过日志看-GC-原因" class="headerlink" title="2、透过日志看 GC 原因"></a>2、透过日志看 GC 原因</h6><ul>
<li><code>Allocation Failure</code>：表明本次引起GC的原因是因为在<strong>年轻代</strong>中没有足够的空间能够存储新的数据了</li>
<li><code>Metadata GCThreshold</code>：Metaspace 区不够用了</li>
<li><code>FErgonomics</code>：JVM 自适应调整导致的 GC</li>
<li><code>System</code>：调用了 System.gc()方法</li>
</ul>
<h6 id="3、透过日志看-GC-前后情况"><a href="#3、透过日志看-GC-前后情况" class="headerlink" title="3、透过日志看 GC 前后情况"></a>3、透过日志看 GC 前后情况</h6><p>通过图示，我们可以发现 GC 日志格式的规律一般都是：<strong>GC 前内存占用 -＞ GC 后内存占用（该区域内存总大小）</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[PSYoungGen: 5986K-&gt;696K (8704K) ] 5986K-&gt;704K (9216K)</span><br></pre></td></tr></table></figure>

<ul>
<li>中括号内：GC 回收前年轻代堆大小，回收后大小，（年轻代堆总大小）</li>
<li>括号外：GC 回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</li>
</ul>
<p>注意：</p>
<ul>
<li>Minor GC 堆内存总容量 = 9/10 年轻代 + 老年代。<ul>
<li>原因是 Survivor 区只计算 from 部分，而 JVM 默认年轻代中 Eden 区和 Survivor 区的比例关系，Eden:S0:S1=8:1:1。</li>
</ul>
</li>
</ul>
<h6 id="4、透过日志看-GC-时间"><a href="#4、透过日志看-GC-时间" class="headerlink" title="4、透过日志看 GC 时间"></a>4、透过日志看 GC 时间</h6><p>GC 日志中有三个时间：<strong>user</strong>，<strong>sys</strong> 和 <strong>real</strong>（结果采用四舍五入的形式）</p>
<ul>
<li><code>user</code>：进程执行用户态代码（核心之外）所使用的时间。这是<strong>执行此进程所使用的实际 CPU 时间</strong>，其他进程和此进程阻塞的时间并不包括在内。<strong>在垃圾收集的情况下，表示 GC 线程执行所使用的 CPU 总时间</strong>。</li>
<li><code>sys</code>：进程在内核态消耗的 CPU 时间，即<strong>在内核执行系统调用或等待系统事件所使用的 CPU 时间</strong></li>
<li><code>real</code>：<strong>程序从开始到结束所用的时钟时间</strong>。这个时间包括其他进程使用的时间片和进程阻塞的时间（比如等待 I/O 完成）。<strong>对于并行 gc，这个数字应该接近（用户时间＋系统时间）除以垃圾收集器使用的线程数</strong>。</li>
</ul>
<p>由于多核的原因，一般的 GC 事件中，real time 是小于 sys time ＋ user time 的，因为一般是多个线程并发的去做 GC，所以 real time 是要小于 sys ＋ user time 的。<strong>如果 real ＞ sys ＋ user 的话，则你的应用可能存在下列问题：IO 负载非常重或 CPU 不够用。</strong></p>
<h5 id="4、Minor-GC日志解析"><a href="#4、Minor-GC日志解析" class="headerlink" title="4、Minor GC日志解析"></a>4、Minor GC日志解析</h5><p><code>-XX:+PrintGCTimeStamps</code> + <code>-XX:+PrintGCDateStamps</code> + <code>-XX:+PrintGCDetails</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-11-20T17:19:43.265-0800:0.822: [GC (ALLOCATION FAILURE) [PSYOUNGGEN:76800K-&gt;8433K(89600K)] 76800K -&gt; 8449K(294400K), 0.0088371 SECS] [TIMES:USER=0.02 SYS=0.01, REAL=0.01 SECS]</span><br></pre></td></tr></table></figure>

<ul>
<li>2020-11-20T17:19:43.265-0800<ul>
<li>日志打印时间日期格式如：2013-05-04T21:53:59.234+0800</li>
</ul>
</li>
<li>0.822<ul>
<li>gc发生时，Java虛拟机启动以来经过的秒数</li>
</ul>
</li>
<li>[GC (Allocation Failure)<ul>
<li>发生了一次垃圾回收，这是一次Minor GC。它不区分新生代GC还是老年代GC，括号里的内容是gc发生的原因，这里的Allocation Failure的原因是<strong>新生代中没有足够区域能够存放需要分配的数据而失败</strong>。</li>
<li>除此之外还有：<ul>
<li><code>Metadata GCThreshold</code>：Metaspace 区不够用了</li>
<li><code>FErgonomics</code>：JVM 自适应调整导致的 GC</li>
<li><code>System</code>：调用了 System.gc()方法</li>
</ul>
</li>
</ul>
</li>
<li>[PSYoungGen:76800K-&gt;8433K(89600K)]<ul>
<li>PSYoungGen：表示GC发生的区域，区域名称与使用的GC收集器是密切相关的<ul>
<li><strong>Serial收集器</strong>：Default New Generation显示<strong>DefNew</strong></li>
<li><strong>ParNew</strong>收集器：<strong>ParNew</strong></li>
<li><strong>Parallel Scanvenge</strong>收集器：<strong>PSYoungGen</strong></li>
<li>老年代和新生代同理，也是和收集器名称相关</li>
</ul>
</li>
<li>76800K-&gt;8433K(89600K)：GC前该内存区域已使用容量 -&gt; GC后该区域容量(该区域总容量)<ul>
<li>如果是新生代，总容量则会显示整个新生代内存的9/10，即eden + from区（默认SurvivorRatio = 8）</li>
<li>如果是老年代，总容量则是全部内存大小，无变化</li>
</ul>
</li>
</ul>
</li>
<li>76800K -&gt; 8449K(294400K)<ul>
<li>在显示完区域容量GC的情况之后，会接着显示整个堆内存区域的GC情况：GC前堆内存已使用容量 -&gt; GC堆内存容量(堆内存总容量)</li>
<li>堆内存总容量 = 9/10新生代+老年代 &lt; 初始化的内存大小.</li>
</ul>
</li>
<li>0.0088371 secs]<ul>
<li>整个GC所花费的时间，单位是秒</li>
</ul>
</li>
<li>[Times:user=0.02 sys=0.01, real=0.01 secs]<ul>
<li>user：指的是CPU工作在用户态所花费的时间</li>
<li>sys：指的是CPU工作在内核态所花费的时间</li>
<li>real：指的是在此次GC事件中所花费的总时间</li>
</ul>
</li>
</ul>
<h5 id="5、Full-GC日志解析"><a href="#5、Full-GC日志解析" class="headerlink" title="5、Full GC日志解析"></a>5、Full GC日志解析</h5><p><code>-XX:+PrintGCTimeStamps</code> + <code>-XX:+PrintGCDateStamps</code> + <code>-XX:+PrintGCDetails</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2020-11-20T17:19:43.794-0800:1.351:[FULL GC (METADATA GC THRESHOLD)[PSYOUNGGEN:10082K -&gt; 0K(89600K)][PAROLDGEN:32K -&gt; 9638K(204800K)] </span><br><span class="line">10114K -&gt; 9638K(294400K),[METASPACE:20158K -&gt; 20156K(1067008K)], 0.0285388 SECS] </span><br><span class="line">[TIMES: USER=0.11 SYS=0.00, REAL=0.03 SECS]</span><br></pre></td></tr></table></figure>

<ul>
<li>2020-11-20T17:19:43.794-0800<ul>
<li>日志打印时间日期格式如：2013-05-04T21:53:59.234+0800</li>
</ul>
</li>
<li>1.351<ul>
<li>gc发生时，Java虛拟机启动以来经过的秒数</li>
</ul>
</li>
<li>[Full GC (Metadata GC Threshold)<ul>
<li>发生了一次垃圾回收，这是一次FULL GC。它不区分新生代GC还是老年代GC</li>
<li>括号里的内容是gc发生的原因，这里的MetadataGC Threshold的原因是Metaspace区不够用了。<ul>
<li>Full GC (Ergonomics)：JVM自适应调整导致的GC</li>
<li>Full GC (System)：调用了System.gc()方法</li>
</ul>
</li>
</ul>
</li>
<li>[PSYoungGen:10082K -&gt; 0K(89600K)]<ul>
<li>PSYoungGen：表示GC发生的区域，区域名称与使用的GC收集器是密切相关的<ul>
<li><strong>Serial收集器</strong>：Default New Generation显示<strong>DefNew</strong></li>
<li><strong>ParNew</strong>收集器：<strong>ParNew</strong></li>
<li><strong>Parallel Scanvenge</strong>收集器：<strong>PSYoungGen</strong></li>
<li>老年代和新生代同理，也是和收集器名称相关</li>
</ul>
</li>
<li>10082K -&gt; 0K(89600K)：GC前该内存区域已使用容量 -&gt; GC后该区域容量(该区域总容量)<ul>
<li>如果是新生代，总容量则会显示整个新生代内存的9/10，即eden + from区（默认SurvivorRatio = 8）</li>
<li>如果是老年代，总容量则是全部内存大小，无变化</li>
</ul>
</li>
</ul>
</li>
<li>[ParOldGen:32K -&gt; 9638K(204800K)]<ul>
<li>老年代区域没有发生GC，因为本次GC是metaspace引起的</li>
</ul>
</li>
<li>10114K -&gt; 9638K(294400K)<ul>
<li>在显示完区域容量GC的情况之后，会接着显示整个堆内存区域的GC情况：GC前堆内存已使用容量 -&gt; GC堆内存容量(堆内存总容量)</li>
<li>堆内存总容量 = 9/10新生代+老年代 &lt; 初始化的内存大小.</li>
</ul>
</li>
<li>[Metaspace:20158K -&gt; 20156K(1067008K)]<ul>
<li>metaspace GC回收2K空间</li>
</ul>
</li>
<li>0.0285388 secs]<ul>
<li>整个GC所花费的时间，单位是秒</li>
</ul>
</li>
<li>[Times:user=0.11 sys=0.00, real=0.03 secs]<ul>
<li>user：指的是CPU工作在用户态所花费的时间</li>
<li>sys：指的是CPU工作在内核态所花费的时间</li>
<li>real：指的是在此次GC事件中所花费的总时间</li>
</ul>
</li>
</ul>
<h5 id="6、G1-GC的日志分析"><a href="#6、G1-GC的日志分析" class="headerlink" title="6、G1 GC的日志分析"></a>6、G1 GC的日志分析</h5><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ab37844d0e9e">参考博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/convict_eva/article/details/80623215">参考博客</a></p>
<h4 id="3、GC日志分析工具"><a href="#3、GC日志分析工具" class="headerlink" title="3、GC日志分析工具"></a>3、GC日志分析工具</h4><h5 id="1、GCEasy"><a href="#1、GCEasy" class="headerlink" title="1、GCEasy"></a>1、GCEasy</h5><ul>
<li>基本概述：<ul>
<li>GCEasy 是一款在线的 GC 日志分析器，可以通过 GC 日志分析进行内存泄露检测、GC 暂停原因分析、JVM 配置建议优化等功能，大多数功能是免费的。（当然有一些服务还是收费的）</li>
</ul>
</li>
<li>下载安装：<a target="_blank" rel="noopener" href="https://gceasy.io/">官网地址</a></li>
</ul>
<p>选择需要分析的log文件 -&gt; 点击Analyze -&gt; 可以点击Download将分析结果下载下来进行离线分析</p>
<p><img src="/2021/04/19/JVM/image-20210719024156110.png" alt="image-20210719024156110"></p>
<p>相关分析：</p>
<ul>
<li><p>案例1：MetaspaceOOM</p>
<p><img src="/2021/04/19/JVM/image-20210719025413453.png" alt="image-20210719025413453"></p>
</li>
<li><p>案例2：老年代满了导致堆OOM</p>
<p><img src="/2021/04/19/JVM/image-20210719025515161.png" alt="image-20210719025515161"></p>
</li>
</ul>
<h5 id="2、GCViewer"><a href="#2、GCViewer" class="headerlink" title="2、GCViewer"></a>2、GCViewer</h5><ul>
<li>基本概述<ul>
<li>GCViewer是一个免费的、开源的分析小工具，用于可视化查看由SUN/Oracle、IBM、HP和BEA Java虚拟机产生的垃圾收集器的日志。</li>
<li>GCViewer 是一款<strong>离线</strong>的 GC 日志分析器，用于可视化 Java VM 选项 -verbose:gc 和 .NET 生成的数据 -Xloggc:<file>。还可以计算与垃圾回收相关的性能指标（吞吐量、累积的暂停、最长的暂停等）。</file></li>
<li><strong>当通过更改世代大小或设置初始堆大小来调整特定应用程序的垃圾回收时，此功能非常有用</strong>。</li>
</ul>
</li>
<li>下载安装：<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/chewiebug/GCViewer">源码下载</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/chewiebug/GCViewer/wiki/Changelog">运行版本下载</a></li>
<li>下载之后只需双击gcviewer-1.3x. jar或运行java -jar gcviewer-1.3x.jar (它需要运行java1.8 vm)，即可启动GCViewer (gui) </li>
</ul>
</li>
</ul>
<h5 id="3、其他工具"><a href="#3、其他工具" class="headerlink" title="3、其他工具"></a>3、其他工具</h5><ul>
<li>GChisto<ul>
<li>基本概述：GChisto是一款专业分析gc日志的工具，可以通过gc日志来分析：MinorGC、Full GC的次数、频率、持续时间等，通过列表、报表、图表等不同形式来反应gc的情况。</li>
<li>虽然界面略显粗糙，但是功能还是不错的。</li>
<li>官网上没有下载的地方，需要自己从 SVN 上拉下来编译</li>
<li>不过这个工具似乎没怎么维护了，存在不少 bug</li>
</ul>
</li>
<li>HPjmeter<ul>
<li>工具很强大，但是只能打开由以下参数生成的 GC log，-verbose:gc -Xloggc:gc.log。添加其他参数生成的 gc.log 无法打开</li>
<li>HPjmeter 集成了以前的 HPjtune 功能，可以分析在 HP 机器上产生的垃圾回收日志文件</li>
</ul>
</li>
</ul>
<h3 id="6、OOM常见各种场景及解决方案"><a href="#6、OOM常见各种场景及解决方案" class="headerlink" title="6、OOM常见各种场景及解决方案"></a>6、OOM常见各种场景及解决方案</h3><h4 id="1、案例1：堆溢出"><a href="#1、案例1：堆溢出" class="headerlink" title="1、案例1：堆溢出"></a>1、案例1：堆溢出</h4><h4 id="2、案例2：元空间溢出"><a href="#2、案例2：元空间溢出" class="headerlink" title="2、案例2：元空间溢出"></a>2、案例2：元空间溢出</h4><h4 id="3、案例3：GC-overhead-limit-exceeded"><a href="#3、案例3：GC-overhead-limit-exceeded" class="headerlink" title="3、案例3：GC overhead limit exceeded"></a>3、案例3：GC overhead limit exceeded</h4><h4 id="4、案例4：线程溢出"><a href="#4、案例4：线程溢出" class="headerlink" title="4、案例4：线程溢出"></a>4、案例4：线程溢出</h4><h3 id="7、性能优化案例"><a href="#7、性能优化案例" class="headerlink" title="7、性能优化案例"></a>7、性能优化案例</h3><h4 id="1、性能测试工具：Jmeter"><a href="#1、性能测试工具：Jmeter" class="headerlink" title="1、性能测试工具：Jmeter"></a>1、性能测试工具：Jmeter</h4><h4 id="2、案例1：调整堆大小提高服务的吞吐量"><a href="#2、案例1：调整堆大小提高服务的吞吐量" class="headerlink" title="2、案例1：调整堆大小提高服务的吞吐量"></a>2、案例1：调整堆大小提高服务的吞吐量</h4><h4 id="3、案例2：调整垃圾回收器提高服务的吞吐量"><a href="#3、案例2：调整垃圾回收器提高服务的吞吐量" class="headerlink" title="3、案例2：调整垃圾回收器提高服务的吞吐量"></a>3、案例2：调整垃圾回收器提高服务的吞吐量</h4><h4 id="4、案例3：JVM优化之JIT优化"><a href="#4、案例3：JVM优化之JIT优化" class="headerlink" title="4、案例3：JVM优化之JIT优化"></a>4、案例3：JVM优化之JIT优化</h4><h4 id="5、案例4：G1并发执行的线程数对性能的影响"><a href="#5、案例4：G1并发执行的线程数对性能的影响" class="headerlink" title="5、案例4：G1并发执行的线程数对性能的影响"></a>5、案例4：G1并发执行的线程数对性能的影响</h4><h4 id="6、案例5：合理配置堆内存"><a href="#6、案例5：合理配置堆内存" class="headerlink" title="6、案例5：合理配置堆内存"></a>6、案例5：合理配置堆内存</h4><h4 id="7、特殊问题：新生代与老年代的比例"><a href="#7、特殊问题：新生代与老年代的比例" class="headerlink" title="7、特殊问题：新生代与老年代的比例"></a>7、特殊问题：新生代与老年代的比例</h4><h5 id="1、参数设置"><a href="#1、参数设置" class="headerlink" title="1、参数设置"></a>1、参数设置</h5><h5 id="2、参数AdaptiveSizePolicy"><a href="#2、参数AdaptiveSizePolicy" class="headerlink" title="2、参数AdaptiveSizePolicy"></a>2、参数AdaptiveSizePolicy</h5><ul>
<li>补充</li>
</ul>
<h4 id="8、案例6：CPU占用很高排查方案"><a href="#8、案例6：CPU占用很高排查方案" class="headerlink" title="8、案例6：CPU占用很高排查方案"></a>8、案例6：CPU占用很高排查方案</h4><h4 id="9、日均百万级订单交易系统如何设置JVM参数"><a href="#9、日均百万级订单交易系统如何设置JVM参数" class="headerlink" title="9、日均百万级订单交易系统如何设置JVM参数"></a>9、日均百万级订单交易系统如何设置JVM参数</h4><h5 id="1、现状"><a href="#1、现状" class="headerlink" title="1、现状"></a>1、现状</h5><h5 id="2、解决思路"><a href="#2、解决思路" class="headerlink" title="2、解决思路"></a>2、解决思路</h5><h5 id="3、参数配置"><a href="#3、参数配置" class="headerlink" title="3、参数配置"></a>3、参数配置</h5><h3 id="8、Java代码层及其它层面调优"><a href="#8、Java代码层及其它层面调优" class="headerlink" title="8、Java代码层及其它层面调优"></a>8、Java代码层及其它层面调优</h3><h3 id="9、大厂面试题-1"><a href="#9、大厂面试题-1" class="headerlink" title="9、大厂面试题"></a>9、大厂面试题</h3><ul>
<li>支付宝：<ul>
<li>支付宝三面：JVM性能调优都做了什么?</li>
</ul>
</li>
<li>小米：<ul>
<li>有做过JVM内存优化吗?</li>
<li>从SQL、JVM、 架构、数据库四个方面讲讲优化思路</li>
</ul>
</li>
<li>蚂蚁金服：<ul>
<li>JVM的编译优化</li>
<li>JVM性能调优都做了什么</li>
<li>JVM诊断调优工具用过哪些?</li>
<li>二面：jvm怎样调优，堆内存、栈空间设置多少合适</li>
<li>三面：JVM相关的分析工具使用过的有哪些?具体的性能调优步骤如何</li>
</ul>
</li>
<li>阿里：<ul>
<li>如何进行JVM调优?有哪些方法?</li>
<li>如何理解内存泄漏问题?有哪些情况会导致内存泄漏?如何解决?</li>
</ul>
</li>
<li>字节跳动：<ul>
<li>三面: JVM如何调优、参数怎么调?</li>
</ul>
</li>
<li>拼多多：<ul>
<li>从SQL、JVM、架构、数据库四个方面讲讲优化思路</li>
</ul>
</li>
<li>京东：<ul>
<li>JVM诊断调优工具用过哪些?</li>
<li>每秒几十万并发的秒杀系统为什么会频繁发生GC?</li>
<li>日均百万级交易系统如何优化JVM?</li>
<li>线上生产系统00M如何监控及定位与解决?</li>
<li>高并发系统如何基于G1垃圾回收器优化性能?</li>
</ul>
</li>
</ul>
<p>参考资料：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/su20145104009/article/details/83095871">Java引用类型：强引用，软引用，弱引用，虚引用</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/185612299">浅谈双亲委派机制的缺陷及打破双亲委派机制</a></p>
<p><a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1662654539572628762&wfr=spider&for=pc">谈谈双亲委派模型的第四次破坏——模块化</a></p>
<p>相关网站：</p>
<p><a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">参数查找</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xgh-user.github.io/2021/03/15/springcloud/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_little-star_">
      <meta itemprop="description" content="记录个人在平时学习的过程中的一些笔记、感受与遇到的坑,例如：java、计算机考研四件套等等。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_little-star_">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/15/springcloud/" class="post-title-link" itemprop="url">SpringCloud</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-15 00:30:19" itemprop="dateCreated datePublished" datetime="2021-03-15T00:30:19+08:00">2021-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-24 21:14:00" itemprop="dateModified" datetime="2021-05-24T21:14:00+08:00">2021-05-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%90%8E%E5%8F%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">java后台学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%90%8E%E5%8F%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/springcloud/" itemprop="url" rel="index"><span itemprop="name">springcloud</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><h3 id="1、微服务架构概述"><a href="#1、微服务架构概述" class="headerlink" title="1、微服务架构概述"></a>1、微服务架构概述</h3><p>微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务。服务之间互相协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相协作(通常是基于HTTP协议的RESTful API)。每个服务都围绕着具体业务进行构建，并且能够被独立的部署到生产环境、类生产环境等。另外，应当尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建。</p>
<h3 id="2、微服务架构编码构建"><a href="#2、微服务架构编码构建" class="headerlink" title="2、微服务架构编码构建"></a>2、微服务架构编码构建</h3><p>Rest微服务工程搭建：</p>
<ol>
<li><p>约定&gt;配置&gt;编码</p>
</li>
<li><p>IDEA新建project工作空间</p>
<ul>
<li>微服务cloud整体聚合工程<ul>
<li>父工程步骤<ul>
<li>New Project</li>
<li>聚合总父工程名字</li>
<li>Maven选版本</li>
<li>工程名字</li>
<li>字符编码</li>
<li>注解生效激活</li>
<li>java编译版本选8</li>
<li>File Type过滤</li>
</ul>
</li>
<li>父工程POM<ul>
<li>DependencyManagement(版本统一管理)</li>
<li>maven中跳过单元测试</li>
</ul>
</li>
<li>父工程创建完成执行mvn:insall将父工程发布到仓库方便子工程继承</li>
</ul>
</li>
</ul>
</li>
<li><p>Rest微服务工程搭建</p>
<ul>
<li><p>创建公共的模块</p>
<ul>
<li>实体类emtities<ul>
<li>主实体</li>
<li>Json封装体</li>
</ul>
</li>
<li>常量类</li>
<li>枚举类</li>
<li>创建步骤<ul>
<li>建module</li>
<li>改pom</li>
<li>编写</li>
<li>执行mvn:insall将公共工程发布到仓库方便需要的工程继承</li>
</ul>
</li>
</ul>
</li>
<li><p>微服务提供者Module模块</p>
<ul>
<li>建module</li>
<li>改POM</li>
<li>写YML</li>
<li>主启动</li>
<li>业务类<ul>
<li>建表sql</li>
<li>dao<ul>
<li>接口</li>
<li>mybatis的映射文件(src\main\resources\mapper\XxxxxMapper.xml)</li>
</ul>
</li>
<li>service<ul>
<li>接口</li>
<li>实现类</li>
</ul>
</li>
<li>controller</li>
</ul>
</li>
<li>测试（postman）</li>
</ul>
</li>
<li><p>热部署Devtools</p>
</li>
<li><p>微服务消费者订单Module模块</p>
<ul>
<li>建module</li>
<li>改POM</li>
<li>写YML</li>
<li>主启动</li>
<li>业务类<ul>
<li>config配置类</li>
<li>controller</li>
</ul>
</li>
<li>测试</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="3、SpringCloud简介"><a href="#3、SpringCloud简介" class="headerlink" title="3、SpringCloud简介"></a>3、SpringCloud简介</h3><p>SpringCloud：分布式微服务架构的一站式解决方案，是多种微服务架构落</p>
<p>地技术的集合体，俗称微服务全家桶。</p>
<p><img src="/2021/03/15/springcloud/1.jpg" alt="1"></p>
<p><img src="/2021/03/15/springcloud/2.jpg" alt="2"></p>
<h3 id="4、SpringCloud技术栈"><a href="#4、SpringCloud技术栈" class="headerlink" title="4、SpringCloud技术栈"></a>4、SpringCloud技术栈</h3><p><img src="/2021/03/15/springcloud/206.png" alt="image-20210305205540848"></p>
<p><img src="/2021/03/15/springcloud/207.png" alt="image-20210305205647548"></p>
<p><img src="/2021/03/15/springcloud/3.jpg" alt="3"></p>
<h3 id="5、版本选择"><a href="#5、版本选择" class="headerlink" title="5、版本选择"></a>5、版本选择</h3><p>springboot：2.2.RELEASE</p>
<p>springcloud：Hoxton.SR1</p>
<p>springcloud Alibaba：2.1.0.RELEASE</p>
<p>java：8</p>
<p>Maven：3.5及以上</p>
<p>Mysql：5.7及以上</p>
<h3 id="6、访问方式"><a href="#6、访问方式" class="headerlink" title="6、访问方式"></a>6、访问方式</h3><ul>
<li>网页</li>
<li>postman</li>
<li>dos窗口 + crul<ul>
<li>加入curl返回中文乱码（<a target="_blank" rel="noopener" href="https://blog.csdn.net/leedee/article/details/82685636%EF%BC%89">https://blog.csdn.net/leedee/article/details/82685636）</a></li>
</ul>
</li>
</ul>
<h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h2><h3 id="7、Eureka注册中心"><a href="#7、Eureka注册中心" class="headerlink" title="7、Eureka注册中心"></a>7、Eureka注册中心</h3><h4 id="7-1、Eureka基础知识："><a href="#7-1、Eureka基础知识：" class="headerlink" title="7.1、Eureka基础知识："></a>7.1、Eureka基础知识：</h4><ul>
<li><p>服务治理：SpringCloud封装了Netflix公司开发的Eureka模块来实现服</p>
<p>务治理。</p>
<p>在传统的rpc远程调用框架中，管理每个服务与服务之间的依赖关系比</p>
<p>较复杂，管理比较复杂，所以需要使用服务治理，管理服务与服务之间</p>
<p>的依赖关系，可以实现服务调用、负载均衡、容错等，实现服务的发现</p>
<p>与注册。</p>
</li>
<li><p>服务发现与注册：Eureka采用了CS的设计架构，Eureka Server作为服</p>
<p>务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使</p>
<p>用Eureka的客户端连接到Eureka Server并维持心跳连接。这样系统的</p>
<p>维护人员就可以通过Eureka Server来监控系统中各个微服务是否正常</p>
<p>运行。</p>
<p>在服务注册与发现中，有一个注册中心。但服务器启动的时候，会把当</p>
<p>前自己的服务的信息。比如：服务地址、通讯地址等以别名方式注册到</p>
<p>注册中心上。另一方（消费者|服务提供者），以该别名的方式去注册</p>
<p>中心上获取到实际的服务通讯地址，然后在实现本地的RPC调用。远程</p>
<p>RPC调用的框架核心设计思想：在于注册中心，因为使用注册中心管理</p>
<p>每个服务与服务之间的一个依赖关系（服务治理概念）。在任何远程</p>
<p>RPC框架中，都会有一个注册中心（存放服务地址相关信息（接口地</p>
<p>址））</p>
</li>
<li><p>Eureka系统架构与Dubbo架构的对比</p>
<p><img src="/2021/03/15/springcloud/4.png" alt="image-20210309193119872"></p>
<p><img src="/2021/03/15/springcloud/5.png" alt="image-20210309193236970"></p>
</li>
<li><p>Eureka的两大组件</p>
<ul>
<li><p>Eureka Server：提供服务注册服务</p>
<p>各个微服务结点通过配置启动后，会在Eureka Server中进行注</p>
<p>册，这样Eureka Server中的服务注册表中将会存储所有可用服务</p>
<p>注册节点的信息，服务节点的信息可以在界面中直观看到。</p>
<p>主启动加注解：@EnableEurekaServer</p>
<p>pom:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Eureka Client：通过注册中心进行访问</p>
<p>是一个java客户端，用于简化Eureka Server的交互，客户端同时也</p>
<p>具备一个内置的，使用轮询（round-robin）负载算法的负载均衡</p>
<p>器。在启动应用后，将会向Eureka Server发送心跳（默认周期</p>
<p>30s）。如果Eureka Server在多个心跳周期内没有接收到某个节点</p>
<p>的心跳，Eureka Server将会从访问注册表中把这个服务节点移除</p>
<p>（默认90s）</p>
<p>主启动加注解：@EnableEurekaClient</p>
<p>pom：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="7-2、工作流程："><a href="#7-2、工作流程：" class="headerlink" title="7.2、工作流程："></a>7.2、工作流程：</h4><p><img src="/2021/03/15/springcloud/springcloud%5C6.png" alt="img"></p>
<p> 解决办法: 搭建Eureka注册中心集群,实现负载均衡+故障容错</p>
<h4 id="7-3、集群搭建"><a href="#7-3、集群搭建" class="headerlink" title="7.3、集群搭建"></a>7.3、集群搭建</h4><p>相互依赖，相互守望（在application.yml中配置文件互相配置）</p>
<h4 id="7-4、eureka自我保护"><a href="#7-4、eureka自我保护" class="headerlink" title="7.4、eureka自我保护"></a>7.4、eureka自我保护</h4><p>概述：保护模式主要用于一组客户端和Eureka Server之间存在网络分区场</p>
<p>景下的保护。一旦进入保护模式，Eureka Server将会尝试保护其服务注册</p>
<p>表中的信息，不在删除服务注册表中的数据，也就是不会注销任何微服务。</p>
<p><img src="/2021/03/15/springcloud/7.png" alt="image-20210309203401792"></p>
<p>导致原因：</p>
<p><img src="/2021/03/15/springcloud/8.png" alt="img"> </p>
<p><img src="/2021/03/15/springcloud/9.png" alt="img"> </p>
<p><img src="/2021/03/15/springcloud/10.png" alt="img"> </p>
<p><img src="/2021/03/15/springcloud/11.png" alt="img"> </p>
<p>一句话总结:某时刻 一个微服务不可用了,Eureka不会立刻清理,依旧会对该</p>
<p>服务的信息进行保存。属于CAP里面的AP分支</p>
<p>如何禁用Eureka的保护模式：</p>
<p>在Eureka服务端（Eureka Server）：</p>
<p>使用eureka.server.enable-self-preservation=false 可以禁用自我保护模式</p>
<p>在Eureka客户端（Eureka Client）（修改时间）：</p>
<ul>
<li><p>eureka.instance.lease-renewal-interval-in-seconds=1</p>
<p>Eureka客户端向服务端发送心跳的时间间隔,单位为秒。默认是30秒</p>
</li>
<li><p>eureka.instance.lease-expiration-duration-in-seconds=90</p>
<p>Eureka服务端在收到最后一次心跳后等待时间上限 ,单位为秒(默认是90</p>
<p>秒),超时删除服务</p>
</li>
</ul>
<h3 id="8、Zookeeper注册中心"><a href="#8、Zookeeper注册中心" class="headerlink" title="8、Zookeeper注册中心"></a>8、Zookeeper注册中心</h3><p>Zookeeper是一个分布式协调工具,可以实现注册中心功能。</p>
<p>依赖导入：</p>
<p>pom：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zookeeper-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>思考：</p>
<p>服务节点是临时节点还是持久节点？</p>
<p>临时节点。所以Zookeeper属于CAP中里的CP分支。</p>
<p><img src="/2021/03/15/springcloud/springcloud%5C12.png" alt="img"> </p>
<h3 id="9、Consul注册中心"><a href="#9、Consul注册中心" class="headerlink" title="9、Consul注册中心"></a>9、Consul注册中心</h3><h4 id="9-1、什么是consul"><a href="#9-1、什么是consul" class="headerlink" title="9.1、什么是consul"></a>9.1、什么是consul</h4><p>Consul是一套开源的分布式服务发现和配置管理系统，由HashiCorp公司用</p>
<p>Go语言开发。Consul提供了微服务系统中的服务治理、配置中心、控制总</p>
<p>线等功能。这些功能中的每一个都可以根据需要单独使用，也可以一起使用</p>
<p>以构建全方位的服务网络，总之Consul提供了一种完整服务网络解决方</p>
<p>案。</p>
<p>优点：</p>
<ul>
<li>基于raft协议，比较简洁</li>
<li>支持健康检查，同时支持HTTP和DNS协议支持跨数据中心的WAN集群</li>
<li>提供图形界面</li>
<li>跨平台</li>
<li>支持Linux、Mac、Windows</li>
</ul>
<p><img src="/2021/03/15/springcloud/13.png" alt="image-20210309210438031">  </p>
<h4 id="9-2、功能"><a href="#9-2、功能" class="headerlink" title="9.2、功能"></a>9.2、功能</h4><ul>
<li>服务发现：提供HTTP/DNS两种发现方式</li>
<li>健康检测：支持多种方式,HTTP、TCP、Docker、shell脚本定制化</li>
<li>KV存储：Key、Value的存储方式</li>
<li>多数据中心：Consul支持多数据中心</li>
<li>可视化界面</li>
</ul>
<h4 id="9-3、依赖导入"><a href="#9-3、依赖导入" class="headerlink" title="9.3、依赖导入"></a>9.3、依赖导入</h4><p>pom：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="10、三个注册中心异同点"><a href="#10、三个注册中心异同点" class="headerlink" title="10、三个注册中心异同点"></a>10、三个注册中心异同点</h3><p><img src="/2021/03/15/springcloud/14.png" alt="img"> </p>
<p><img src="/2021/03/15/springcloud/15.png" alt="img"> </p>
<p>CP(Zookeeper/Consul)：</p>
<p>当网络分区出现后,为了保证一致性,就必须拒绝请求,否则无法保证一致性</p>
<p>结论:违背了可用性A的要求,只满足一致性和分区容错,即CP。</p>
<p><img src="/2021/03/15/springcloud/16.png" alt="image-20210307031636572"></p>
<p>AP(Eureka):</p>
<p><img src="/2021/03/15/springcloud/19.png" alt="img"> </p>
<p>CAP（分区容错性要保证,所以要么是CP,要么是AP）：</p>
<ul>
<li>C: Consistency(强一致性)</li>
<li>A: Availability(可用性)</li>
<li>P: Parttition tolerance(分区容错性)</li>
</ul>
<p>CAP理论关注粒度是否是数据,而不是整体系统设计的策略</p>
<p>经典CAP图：</p>
<p><img src="/2021/03/15/springcloud/17.png" alt="img"> </p>
<p><img src="/2021/03/15/springcloud/18.png" alt="img"> </p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><h3 id="11、Ribbon负载均衡调用"><a href="#11、Ribbon负载均衡调用" class="headerlink" title="11、Ribbon负载均衡调用"></a>11、Ribbon负载均衡调用</h3><h4 id="11-1、是什么"><a href="#11-1、是什么" class="headerlink" title="11.1、是什么"></a>11.1、是什么</h4><p>Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端负载均衡的</p>
<p>工具。</p>
<p>简单的说，Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软</p>
<p>件负载均衡算法和服务调用。Ribbon客户端组件提供一系列完善的配置项</p>
<p>如连接超时，重试等。简单的说，就是在配置文件中列出Load </p>
<p>Balancer（LB）后面所有机器，Ribbon会自动的帮助你基于某种规则(如简</p>
<p>单轮询，随机连接等)去连接这些机器。我们很容易使用Ribbon实现自定义</p>
<p>的负载均衡算法。 </p>
<p>总结: Ribbon其实就是一个软负载均衡的客户端组件,  他可以和其他所需请</p>
<p>求的客户端结合使用,和eureka结合只是其中一个实例.</p>
<h4 id="11-2、作用（负载均衡-RestTemplate调用）"><a href="#11-2、作用（负载均衡-RestTemplate调用）" class="headerlink" title="11.2、作用（负载均衡+RestTemplate调用）"></a>11.2、作用（负载均衡+RestTemplate调用）</h4><p>LB(负载均衡)：</p>
<p>简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的</p>
<p>HA（高可用）。</p>
<p>常见的负载均衡有软件Nginx，LVS，硬件F5等。</p>
<p>Ribbon本地负载均衡客户端 VS Nginx服务端负载均衡的区别：</p>
<ul>
<li><p>Nginx是服务器负载均衡，客户端所有请求都会交给nginx，然后由</p>
<p>nginx实现转发请求。即负载均衡是由服务端实的。</p>
</li>
<li><p>Ribbon本地负载均衡，在调用微服务接口的时候，会在注册中心上获</p>
<p>取注册信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用技术。 </p>
</li>
</ul>
<p>LB(负载均衡)可分为：</p>
<ul>
<li><p>集中式LB</p>
<p>即在服务的消费方和提供方之间提供独立的LB设施(可以是硬件如F5，</p>
<p>也可以是软件，如nginx)，由该设施负责把访问请求通过某种策略转发</p>
<p>至服务的提供方。</p>
</li>
<li><p>进程内LB</p>
<p>将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，</p>
<p>然后自己再从这些地址中选择出一台合适的服务器。Ribbon就属于进</p>
<p>程内LB，它只是一个类库，集成与消费方进程，消费方通过它来获取服</p>
<p>务提供方的地址。 </p>
</li>
</ul>
<h4 id="11-3、框架说明"><a href="#11-3、框架说明" class="headerlink" title="11.3、框架说明"></a>11.3、框架说明</h4><p><img src="/2021/03/15/springcloud/20.png" alt="img"> </p>
<p>Ribbon在工作时分成两步：</p>
<ul>
<li><p>第一步：</p>
<p>先选择Eureka Server，它优先选择在同一区域内负载较少的server</p>
</li>
<li><p>第二步：</p>
<p>再根据用户指定的策略，再从server取到的服务注册列表中选择一个地</p>
<p>址。其中Ribbon提供了多种策略:比如轮询、随机和根据响应时间加</p>
<p>权。</p>
</li>
</ul>
<p>RestTemplate的使用：</p>
<ul>
<li><p>getForObject(String url,class)方法:返回对象为响应体中数据转化成的</p>
<p>对象，基本上可以理解成Json</p>
</li>
<li><p>getForEntity(String url,class)方法：返回对象为ResponseEntity对象，</p>
<p>包含响应中的一些重要信息，比如响应头、响应状态码、响应体等。  </p>
</li>
</ul>
<h4 id="11-4、Ribbon核心组件IRule"><a href="#11-4、Ribbon核心组件IRule" class="headerlink" title="11.4、Ribbon核心组件IRule"></a>11.4、Ribbon核心组件IRule</h4><h5 id="11-4-1、IRule是什么"><a href="#11-4-1、IRule是什么" class="headerlink" title="11.4.1、IRule是什么"></a>11.4.1、IRule是什么</h5><p>IRule:根据特定算法从服务列表中选取一个要访问的服务</p>
<p><img src="/2021/03/15/springcloud/21.png" alt="img"> </p>
<ul>
<li><p>com.netflix.loadbalancer.RoundRobinRule：轮询（默认）</p>
</li>
<li><p>com.netflix.loadbalancer.RandomRule：随机</p>
</li>
<li><p>com.netflix.loadbalancer.RetryRule：先按照RoundRobinRule的策略</p>
<p>获取服务,如果获取服务失败则在指定时间内进行重试,获取可用的服务</p>
</li>
<li><p>WeightedResponseTimeRule：对RoundRobinRule的扩展,响应速度</p>
<p>越快的实例选择权重越多大,越容易被选择</p>
</li>
<li><p>BestAvailableRule：会先过滤掉由于多次访问故障而处于断路器跳闸</p>
<p>状态的服务,然后选择一个并发量最小的服务</p>
</li>
<li><p>AvailabilityFilteringRule：先过滤掉故障实例,再选择并发较小的实例</p>
</li>
<li><p>ZoneAvoidanceRule：默认规则,复合判断server所在区域的性能和</p>
<p>server的可用性选择服务器</p>
</li>
</ul>
<h5 id="11-4-2、替换："><a href="#11-4-2、替换：" class="headerlink" title="11.4.2、替换："></a>11.4.2、替换：</h5><p>注意配置细节</p>
<p>官方文档明确给出了警告：</p>
<p>这个自定义配置类不能放在@ComponentScan所扫描的当前包以及子包</p>
<p>下，否则我们自定义的这个配置类就会被所有的Ribbon客户端所共享，达</p>
<p>不到特殊化定制的目的了。 </p>
<p><img src="/2021/03/15/springcloud/22.png" alt="img"> </p>
<p><img src="/2021/03/15/springcloud/23.png" alt="img"> </p>
<p>@ComponentScan所扫描的当前包以及子包：因为</p>
<p>@SpringBootApplication注解包含了@ComponentScan注解，所以该自定</p>
<p>义配置类不能放在当前包（springcloud）下。</p>
<p>新建package：com.atguigu.myrule</p>
<p>上面包下新建MySelfRule规则类</p>
<p>主启动类添加@RibbonClient</p>
<h5 id="11-4-3、Ribbon负载均衡算法"><a href="#11-4-3、Ribbon负载均衡算法" class="headerlink" title="11.4.3、Ribbon负载均衡算法"></a>11.4.3、Ribbon负载均衡算法</h5><p>RoundRobinRule：轮询的算法思想</p>
<p><img src="/2021/03/15/springcloud/24.png" alt="img"> </p>
<h3 id="12、OenFeign"><a href="#12、OenFeign" class="headerlink" title="12、OenFeign"></a>12、OenFeign</h3><h4 id="12-1、是什么？"><a href="#12-1、是什么？" class="headerlink" title="12.1、是什么？"></a>12.1、是什么？</h4><p>官方解释：<a target="_blank" rel="noopener" href="https://cloud.spring.io/spring-cloud-static/Hoxton.SR1/reference/htmlsingle/#spring-cloud-openfeign">https://cloud.spring.io/spring-cloud-static/Hoxton.SR1/reference/htmlsingle/#spring-cloud-openfeign</a></p>
<p>Feign是一个声明式WebService客户端。使用Feign能让编写Web Service客</p>
<p>户端更加简单。它的使用方法是<strong>定义一个服务接口然后在上面添加注解</strong>。</p>
<p>Feign也支持可拔插式的编码器和解码器。Spring Cloud对Feign进行了封</p>
<p>装，使其支持了Spring MVC标准注解和HTTPMessageConverters。Feign</p>
<p>可以与Eureka和Ribbon组合使用以支持负载均衡。</p>
<h4 id="12-2、作用："><a href="#12-2、作用：" class="headerlink" title="12.2、作用："></a>12.2、作用：</h4><p>Feign旨在使编写Java Http客户端变得更容易。</p>
<p>前面在使用Ribbon+RestTemplate时，利用RestTemplate对http请求的封装处</p>
<p>理，形成了一套模版化的调用方法。但是在实际开发中，由于对服务依赖的调用</p>
<p>可能不止一处，<strong>往往一个接口会被多处调用，所以通常都会针对每个微服务自行</strong></p>
<p><strong>封装一些客户端类来包装这些依赖服务的调用</strong>。所以，Feign在此基础上做了进</p>
<p>一步封装，由他来帮助我们定义和实现依赖服务接口的定义。在Feign的实现下</p>
<p><strong>我们只需创建一个接口并使用注解的方式来配置它(以前是Dao接口上面标</strong></p>
<p><strong>注Mapper注解，现在是一个微服务接口上面标注一个Feign注解即可)，即可完</strong></p>
<p>成对服务提供方的接口绑定，简化了使用Spring cloud Ribbon时，自动封装服</p>
<p>务调用客户端的开发量。</p>
<p>Feign集成了Ribbon</p>
<p>利用Ribbon维护了Payment的服务列表信息，并且通过轮询实现了客户端的负</p>
<p>载均衡。而与Ribbon不同的是，<strong>通过feign只需要定义服务绑定接口且以声明式</strong></p>
<p><strong>的方法</strong>，优雅而简单的实现了服务调用。</p>
<h4 id="12-3、Feign和OpenFeign两者区别"><a href="#12-3、Feign和OpenFeign两者区别" class="headerlink" title="12.3、Feign和OpenFeign两者区别"></a>12.3、Feign和OpenFeign两者区别</h4><p><img src="/2021/03/15/springcloud/25.png" alt="img"> </p>
<h4 id="12-4、使用步骤"><a href="#12-4、使用步骤" class="headerlink" title="12.4、使用步骤"></a>12.4、使用步骤</h4><ul>
<li><p>接口+注解：微服务调用接口+@FeignClient</p>
</li>
<li><p>Feign在消费端使用</p>
</li>
<li><p>pom：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>主启动加上@EnableFeignClients注解开启Feign</p>
</li>
<li><p>业务逻辑接口+@FeignClient配置调用provider服务</p>
<p>@FeignClient(value = “xxx-xxx-xxx”)value的值要写服务提供方在Eureka注册的名称</p>
</li>
<li><p>控制层Controller</p>
</li>
</ul>
<p><img src="/2021/03/15/springcloud/26.png" alt="img"> </p>
<h4 id="12-5、OpenFeign超时控制"><a href="#12-5、OpenFeign超时控制" class="headerlink" title="12.5、OpenFeign超时控制"></a>12.5、OpenFeign超时控制</h4><h5 id="12-5-1、是什么？"><a href="#12-5-1、是什么？" class="headerlink" title="12.5.1、是什么？"></a>12.5.1、是什么？</h5><p>默认Feign客户端<strong>只等待1秒钟</strong>，但是服务端处理需要超过1秒钟，导致Feign客</p>
<p>户端不想等待了，直接返回报错。</p>
<h5 id="12-5-2、解决方法-OpenFeign默认支持Ribbon"><a href="#12-5-2、解决方法-OpenFeign默认支持Ribbon" class="headerlink" title="12.5.2、解决方法(OpenFeign默认支持Ribbon)"></a>12.5.2、解决方法(OpenFeign默认支持Ribbon)</h5><p>为了避免这样的情况，有时候我们需要设置Feign客户端的超时控制。</p>
<p>yml文件中开启配置</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置feign客户端超时时间(OpenFeign默认支持ribbon)</span></span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line"><span class="comment">#指的是建立连接所用的时间，适用于网络状况正常的情况下,两端连接所用的时间</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">5000</span></span><br><span class="line"><span class="comment">#指的是建立连接后从服务器读取到可用资源所用的时间</span></span><br><span class="line">  <span class="attr">ConnectTimeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure>

<h4 id="12-6、OpenFeign日志打印功能"><a href="#12-6、OpenFeign日志打印功能" class="headerlink" title="12.6、OpenFeign日志打印功能"></a>12.6、OpenFeign日志打印功能</h4><h5 id="12-6-1、是什么？"><a href="#12-6-1、是什么？" class="headerlink" title="12.6.1、是什么？"></a>12.6.1、是什么？</h5><p>Feign提供了日志打印功能，我们可以通过配置来调整日志级别，从而了解</p>
<p>Feign中Http请求的细节。说白了就是<strong>对Feign接口的调用情况进行监控和</strong></p>
<p><strong>输出。</strong></p>
<h2 id="熔断器"><a href="#熔断器" class="headerlink" title="熔断器"></a>熔断器</h2><h3 id="13、Hystrix熔断器（豪猪哥）"><a href="#13、Hystrix熔断器（豪猪哥）" class="headerlink" title="13、Hystrix熔断器（豪猪哥）"></a>13、Hystrix熔断器（豪猪哥）</h3><h4 id="13-1、分布式系统面临的问题"><a href="#13-1、分布式系统面临的问题" class="headerlink" title="13.1、分布式系统面临的问题"></a>13.1、分布式系统面临的问题</h4><p><strong>复杂分布式体系结构中的应用程序 ，有数10个依赖关系，每个依赖关系在某些时候将不可避免地失败。</strong></p>
<p><img src="/2021/03/15/springcloud/27.png" alt="img"></p>
<p>服务雪崩：</p>
<p>多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和</p>
<p>微服务C又调用其它的微服务，这就是所谓的“<strong>扇出</strong>”。如果扇出的链路上某个微</p>
<p>服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系</p>
<p>统资源，进而引起系统崩溃，所谓的“雪崩效应”。</p>
<p>对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都</p>
<p>在几秒钟内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟</p>
<p>增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故</p>
<p>障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，</p>
<p>不能取消整个应用程序或系统。所以，通常当你发现一个模块下的某个实例失败</p>
<p>后，这时候这个模块依然还会接收流量，然后这个有问题的模块还调用了其他的</p>
<p>模块，这样就会发生级联故障，或者叫雪崩。</p>
<h4 id="13-2、Hystrix是什么"><a href="#13-2、Hystrix是什么" class="headerlink" title="13.2、Hystrix是什么"></a>13.2、Hystrix是什么</h4><p>Hystrix是一个用于处理分布式系统的<strong>延迟</strong>和<strong>容错</strong>的开源库，在分布式系统里，</p>
<p>许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个</p>
<p>依赖出问题的情况下，<strong>不会导致整体服务失败，避免级联故障，以提高分布式系</strong></p>
<p><strong>统的弹性</strong>。</p>
<p>“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故</p>
<p>障监控(类似熔断保险丝)，<strong>向调用方返回一个符合预期的、可处理的备选响应</strong></p>
<p><strong>(FallBack)，而不是长时间的等待或者抛出调用方无法处理的异常</strong>，这样就保证</p>
<p>了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系</p>
<p>统中的蔓延，乃至雪崩。</p>
<p>官网：<a target="_blank" rel="noopener" href="https://github.com/Netflix/hystrix/wiki">https://github.com/Netflix/hystrix/wiki</a></p>
<h4 id="13-3、作用"><a href="#13-3、作用" class="headerlink" title="13.3、作用"></a>13.3、作用</h4><ul>
<li>服务降级</li>
<li>服务熔断</li>
<li>接近实时的监控</li>
</ul>
<h4 id="13-4、HyStrix重要概念"><a href="#13-4、HyStrix重要概念" class="headerlink" title="13.4、HyStrix重要概念"></a>13.4、HyStrix重要概念</h4><h5 id="13-4-1、服务降级"><a href="#13-4-1、服务降级" class="headerlink" title="13.4.1、服务降级"></a>13.4.1、服务降级</h5><p>服务器忙,请稍后再试,不让客户端等待并立刻返回一个友好提示,fallback</p>
<p>哪些情况会发出降级：</p>
<ul>
<li>程序运行异常</li>
<li>超时</li>
<li>服务熔断触发服务降级</li>
<li>线程池/信号量也会导致服务降级</li>
</ul>
<h5 id="13-4-2、服务熔断"><a href="#13-4-2、服务熔断" class="headerlink" title="13.4.2、服务熔断"></a>13.4.2、服务熔断</h5><p>类比保险丝达到最大服务访问后,直接拒绝访问,拉闸限电,然后调用服务降级的方</p>
<p>法并返回友好提示</p>
<p>服务熔断的过程：</p>
<p>服务的降级-&gt;进而熔断-&gt;恢复调用链路</p>
<h5 id="12-4-3、服务限流"><a href="#12-4-3、服务限流" class="headerlink" title="12.4.3、服务限流"></a>12.4.3、服务限流</h5><p>秒杀高并发等操作,严禁一窝蜂的过来拥挤,大家排队,一秒钟N个,有序进行</p>
<h4 id="13-5、依赖"><a href="#13-5、依赖" class="headerlink" title="13.5、依赖"></a>13.5、依赖</h4><p>pom：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="13-6、高压访问的解决方法"><a href="#13-6、高压访问的解决方法" class="headerlink" title="13.6、高压访问的解决方法"></a>13.6、高压访问的解决方法</h4><p>超时导致服务器变慢(转圈)：超时不再等待</p>
<p>出错(宕机或程序运行出错)：出错要有兜底</p>
<h4 id="13-7、访问降级"><a href="#13-7、访问降级" class="headerlink" title="13.7、访问降级"></a>13.7、访问降级</h4><p>降级配置@HystrixCommand</p>
<h5 id="13-7-1、对于服务提供方："><a href="#13-7-1、对于服务提供方：" class="headerlink" title="13.7.1、对于服务提供方："></a>13.7.1、对于服务提供方：</h5><p>设置自身调用超时时间的峰值,峰值内可以正常运行,  超过了需要有兜底的方法处</p>
<p>理,做服务降级fallback</p>
<p>一旦调用服务方法失败并抛出了错误信息后,会自动调用@HystrixCommand标‘</p>
<p>注好的fallbckMethod调用类中的指定方法</p>
<p>主启动类激活@EnableCircuitBreaker</p>
<p>下图故意制造两个异常：</p>
<ul>
<li>int age = 10/0;计算异常</li>
<li>我们能接受3秒钟，它运行5秒钟，超时异常。</li>
</ul>
<p>当前服务不可用了，做服务降级，兜底的方案都是paymentInfo_TimeOutHandler</p>
<p><img src="/2021/03/15/springcloud/28.png" alt="img"></p>
<h5 id="13-7-2、对于服务消费方："><a href="#13-7-2、对于服务消费方：" class="headerlink" title="13.7.2、对于服务消费方："></a>13.7.2、对于服务消费方：</h5><p>主启动类激活@EnableHystrix</p>
<p>业务类</p>
<p><img src="/2021/03/15/springcloud/29.png" alt="img"></p>
<h5 id="13-7-3、目前问题"><a href="#13-7-3、目前问题" class="headerlink" title="13.7.3、目前问题"></a>13.7.3、目前问题</h5><ul>
<li>每个业务方法对应一个兜底的方法,代码膨胀</li>
<li>统一和自定义的分开</li>
</ul>
<p>解决方法：</p>
<ul>
<li><p>解决第一个问题：代码膨胀</p>
<p>feign接口系列</p>
<p>@DefaultProperties(defaultFallback=””)</p>
<p>每个方法配置一个服务降级方法，技术上可以，实际上导致代码膨胀。</p>
<p>除了个别重要核心业务有专属，其它普通的可以通过</p>
<p>@DefaultProperties(defaultFallback =”)统一跳转到统一处理结果页面</p>
<p><strong>通用的和独享的各自分开，避免了代码膨胀，合理减少了代码量</strong>。</p>
<p><img src="/2021/03/15/springcloud/30.png" alt="img"> </p>
<p><img src="/2021/03/15/springcloud/31.png" alt="img"> </p>
</li>
<li><p>解决第二个问题：和业务逻辑混在一起</p>
<p>服务降级,客户端去调用服务端,碰上服务端宕机或关闭。只需要为Feign客户</p>
<p>端定义的接口添加一个服务降级处理的实现类即可实现解耦。</p>
<p>我们可能面临的异常：</p>
<ul>
<li>运行</li>
<li>超时</li>
<li>宕机</li>
</ul>
<p>重新新建一个类(PaymentFallbackService)实现PaymentHystrixService接</p>
<p>口（OpenFeign的服务接口）,<strong>统一为接口里面的方法进行异常处理</strong></p>
<p><img src="/2021/03/15/springcloud/32.png" alt="img"> </p>
<p>PaymentHystrixService接口:</p>
<p><img src="/2021/03/15/springcloud/springcloud%5C211.png" alt="image-20210315011150047"></p>
</li>
</ul>
<h4 id="13-8、服务熔断"><a href="#13-8、服务熔断" class="headerlink" title="13.8、服务熔断"></a>13.8、服务熔断</h4><h5 id="13-8-1、是什么？"><a href="#13-8-1、是什么？" class="headerlink" title="13.8.1、是什么？"></a>13.8.1、是什么？</h5><p><a target="_blank" rel="noopener" href="https://martinfowler.com/bliki/CircuitBreaker.html">https://martinfowler.com/bliki/CircuitBreaker.html</a></p>
<p>熔断机制概述</p>
<p>熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务</p>
<p>出错不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的</p>
<p>调用，快速返回错误的响应信息。</p>
<p>当<strong>检测到该节点微服务调用响应正常后，恢复调用链路</strong>。</p>
<p>在Spring Cloud框架里，熔断机制通过Hystrix实现。Hystrix会监控微服务间调</p>
<p>用的状况，当失败的调用到一定國值，缺省是5秒内20次调用失败，就会启动熔</p>
<p>断机制。熔断机制的注解是@HystrixCommand。</p>
<h5 id="12-8-2、服务熔断的注解-HystrixCommand-Service层"><a href="#12-8-2、服务熔断的注解-HystrixCommand-Service层" class="headerlink" title="12.8.2、服务熔断的注解@HystrixCommand(Service层)"></a>12.8.2、服务熔断的注解@HystrixCommand(Service层)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;paymentCircuitBreaker_fallback&quot;,commandProperties = &#123;</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;circuitBreaker.enabled&quot;,value = &quot;true&quot;),// 是否开启断路器</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;,value = &quot;10&quot;),// 请求次数</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;,value = &quot;10000&quot;), // 时间窗口期</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;,value = &quot;60&quot;),// 失败率达到多少后跳闸</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br></pre></td></tr></table></figure>

<h5 id="12-8-3、大神结论"><a href="#12-8-3、大神结论" class="headerlink" title="12.8.3、大神结论"></a>12.8.3、大神结论</h5><p><img src="/2021/03/15/springcloud/33.png" alt="img"> </p>
<p>熔断类型：</p>
<ul>
<li><p>熔断打开（Open）：</p>
<p>请求不再调用当前服务,内部设置一般为MTTR(平均故障处理时间),当打开长达导所设时钟则进入半熔断状态</p>
</li>
<li><p>熔断关闭（Closed）：</p>
<p>熔断关闭后不会对服务进行熔断</p>
</li>
<li><p>熔断半开（Half Open）：</p>
<p>部分请求根据规则调用当前服务,如果请求成功且符合规则则认为当前服务恢复正常,关闭熔断</p>
</li>
</ul>
<h5 id="12-8-4、断路流程图"><a href="#12-8-4、断路流程图" class="headerlink" title="12.8.4、断路流程图"></a>12.8.4、断路流程图</h5><p><img src="/2021/03/15/springcloud/34.png" alt="img"> </p>
<p>步骤：</p>
<p><img src="/2021/03/15/springcloud/35.png" alt="img"> </p>
<p>断路器在什么情况下开始起作用 </p>
<p><img src="/2021/03/15/springcloud/36.png" alt="image-20210310003224243"></p>
<p>涉及到断路器的三个重要参数：<strong>快照时间窗、请求总数阀值、错误百分比</strong></p>
<p><strong>阀值</strong></p>
<ul>
<li><p>快照时间窗：断路器确定是否打开需要统计一些请求和错误数据，而统</p>
<p>计的时间范围就是快照时间窗，默认为最近的10秒。</p>
</li>
<li><p>请求总数阀值：在快照时间窗内，必须满足请求总数阀值才有资格熔</p>
<p>断。默认为20，意味着在10秒内，如果该hystrix命令的调用次数不足</p>
<p>20次，即使所有的请求都超时或其他原因失败，断路器都不会打开。</p>
</li>
<li><p>错误百分比阀值：当请求总数在快照时间窗内超过了阀值，比如发生了</p>
<p>30次调用，如果在这30次调用中，有15次发生了超时异常，也就是超</p>
<p>过50%的错误百分比，在默认设定50%阀值情况下，这时候就会将断路</p>
<p>器打开。</p>
</li>
</ul>
<p>断路器开启或者关闭的条件:</p>
<ol>
<li><p>当满足一定的阈值的时候(默认10秒钟超过20个请求次数)</p>
</li>
<li><p>当失败率达到一定的时候(默认10秒内超过50%的请求次数)</p>
</li>
<li><p>到达以上阈值,断路器将会开启</p>
</li>
<li><p>当开启的时候,所有请求都不会进行转发</p>
</li>
<li><p>一段时间之后(默认5秒),这个时候断路器是半开状态,会让其他一个请求</p>
<p>进行转发. 如果成功,断路器会关闭,若失败,继续开启.重复4和5</p>
</li>
</ol>
<p>断路器打开之后:</p>
<ol>
<li><p>再有请求调用的时候，将不会调用主逻辑，而是直接调用降级</p>
<p>fallback。通过断路器，实现了自动地发现错误并将降级逻辑切换为主</p>
<p>逻辑，减少响应延迟的效果。</p>
</li>
<li><p>原来的主逻辑要如何恢复呢？</p>
<p>对于这一问题，hystrix也为我们实现了自动恢复功能。</p>
<p>当断路器打开，对主逻辑进行熔断之后，hystrix会启动一个休眠时间</p>
<p>窗，在这个时间窗内，降级逻辑是临时的成为主逻辑，当休眠时间窗到</p>
<p>期，断路器将进入半开状态，释放一次请求到原来的主逻辑上，如果此</p>
<p>次请求正常返回，那么断路器将继续闭合，主逻辑恢复，如果这次请求</p>
<p>依然有问题，断路器继续进入打开状态，休眠时间窗重新计时。 </p>
</li>
</ol>
<p>ALL配置：</p>
<p><img src="/2021/03/15/springcloud/37.png" alt="img"> </p>
<p><img src="/2021/03/15/springcloud/38.png" alt="img"> </p>
<p><img src="/2021/03/15/springcloud/39.png" alt="img"> </p>
<p><img src="/2021/03/15/springcloud/40.png" alt="img"> </p>
<h4 id="13-9、服务限流"><a href="#13-9、服务限流" class="headerlink" title="13.9、服务限流"></a>13.9、服务限流</h4><p>alibaba的Sentinel说明</p>
<h4 id="13-10、Hystrix的工作流程"><a href="#13-10、Hystrix的工作流程" class="headerlink" title="13.10、Hystrix的工作流程"></a>13.10、Hystrix的工作流程</h4><p><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/How-it-Works">https://github.com/Netflix/Hystrix/wiki/How-it-Works</a></p>
<p>官网图例</p>
<p><img src="/2021/03/15/springcloud/41.png" alt="img"> </p>
<p>步骤说明</p>
<p><img src="/2021/03/15/springcloud/42.png" alt="img"> </p>
<h4 id="13-11、服务监控hystrixDashboard"><a href="#13-11、服务监控hystrixDashboard" class="headerlink" title="13.11、服务监控hystrixDashboard"></a>13.11、服务监控hystrixDashboard</h4><h5 id="13-11-1、概述"><a href="#13-11-1、概述" class="headerlink" title="13.11.1、概述"></a>13.11.1、概述</h5><p> 除了隔离依赖服务的调用以外，Hystrix还提供了<strong>准实时的调用监控</strong></p>
<p>**(Hystrix Dashboard)**，Hystrix会持续地记录所有通过Hystrix发起的请求</p>
<p>的执行信息，并以统计报表和图形的形式展示给用户，包括每秒执行多少</p>
<p>请求多少成功，多少失败等。Netflix通过hystrix-metrics-event-stream项</p>
<p>目实现了对以上指标的监控。Spring Cloud也提供了Hystrix Dashboard的</p>
<p>整合，对监控内容转化成可视化界面。</p>
<h5 id="13-11-2、依赖"><a href="#13-11-2、依赖" class="headerlink" title="13.11.2、依赖"></a>13.11.2、依赖</h5><p>pom：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="13-11-3、步骤"><a href="#13-11-3、步骤" class="headerlink" title="13.11.3、步骤"></a>13.11.3、步骤</h5><ol>
<li><p>主启动类加注解激活@EnableHystrixDashboard</p>
</li>
<li><p>所有Provider微服务提供类都需要监控依赖部署</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br></pre></td></tr></table></figure>
</li>
<li><p>访问网址<a target="_blank" rel="noopener" href="http://localhost:9001/hystrix%EF%BC%889001%E4%B8%BA%E7%AB%AF%E5%8F%A3%E5%90%8D%EF%BC%89">http://localhost:9001/hystrix（9001为端口名）</a></p>
</li>
</ol>
<h5 id="13-11-4、断路器演示-服务监控hystrixDashboard"><a href="#13-11-4、断路器演示-服务监控hystrixDashboard" class="headerlink" title="13.11.4、断路器演示(服务监控hystrixDashboard)"></a>13.11.4、断路器演示(服务监控hystrixDashboard)</h5><p>新版本Hystrix需要在主启动MainAppHystrix8001（微服务提供方）中指</p>
<p>定监控路径</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentHystrixMain8001</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            SpringApplication.run(PaymentHystrixMain8001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *此配置是为了服务监控而配置，与服务容错本身无关，springcloud升级后的坑</span></span><br><span class="line"><span class="comment">     *ServletRegistrationBean因为springboot的默认路径不是&quot;/hystrix.stream&quot;，</span></span><br><span class="line"><span class="comment">     *只要在自己的项目里配置上下面的servlet就可以了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">getServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HystrixMetricsStreamServlet streamServlet = <span class="keyword">new</span> HystrixMetricsStreamServlet();</span><br><span class="line">        ServletRegistrationBean registrationBean = <span class="keyword">new</span> ServletRegistrationBean(streamServlet);</span><br><span class="line">        registrationBean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        registrationBean.addUrlMappings(<span class="string">&quot;/hystrix.stream&quot;</span>);</span><br><span class="line">        registrationBean.setName(<span class="string">&quot;HystrixMetricsStreamServlet&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动一个eureka或者3个eureka集群进行监控测试</p>
<p>填写监控地址<a target="_blank" rel="noopener" href="http://localhost:8001/hystrix.stream">http://localhost:8001/hystrix.stream</a></p>
<p><img src="/2021/03/15/springcloud/43.png" alt="img"> </p>
<h5 id="13-11-5、如何看hystrixDashboard服务监控图"><a href="#13-11-5、如何看hystrixDashboard服务监控图" class="headerlink" title="13.11.5、如何看hystrixDashboard服务监控图"></a>13.11.5、如何看hystrixDashboard服务监控图</h5><ul>
<li><p>七色</p>
<p><img src="/2021/03/15/springcloud/44.png" alt="img"> </p>
</li>
<li><p>一圈：</p>
<p>实心圆：共有两种含义。它通过颜色的变化代表了实例的健康程度，它</p>
<p>的健康度从绿色&lt;黄色&lt;橙色&lt;红色递减。</p>
<p>该实心圆除了颜色的变化之外，它的大小也会根据实例的请求流量发生</p>
<p>变化，流量越大该实心圆就越大。所以通过该实心圆的展示，就可以在</p>
<p>大量的实例中快速的发现<strong>故障实例和高压力实例</strong>。 </p>
</li>
<li><p>一线：</p>
<p>曲线：用来记录2分钟内流量的相对变化，可以通过它来观察到流量的上升与下降趋势 </p>
</li>
<li><p>整图说明：</p>
<p><img src="/2021/03/15/springcloud/45.png" alt="img"> </p>
<p><img src="/2021/03/15/springcloud/Users/风间&琉璃/AppData/Local/Temp/mindmaster/1223393c341/bin/DF646587-C4E1-40BF-9FFD-7D10773D9637.png" alt="img"> </p>
<p><img src="/2021/03/15/springcloud/46.png" alt="img"> </p>
</li>
<li><p>搞懂一个才能看懂复杂的</p>
<p><img src="/2021/03/15/springcloud/47.png" alt="img"> </p>
</li>
</ul>
<h2 id="路由网关"><a href="#路由网关" class="headerlink" title="路由网关"></a>路由网关</h2><h3 id="14、Gateway新一代网关"><a href="#14、Gateway新一代网关" class="headerlink" title="14、Gateway新一代网关"></a>14、Gateway新一代网关</h3><h4 id="14-1、是什么？"><a href="#14-1、是什么？" class="headerlink" title="14.1、是什么？"></a>14.1、是什么？</h4><p>一句话：</p>
<p>SpringCloud Gateway使用的是Webflux中的reactor-netty响应式编程组</p>
<p>件,底层使用了Netty通讯框架。</p>
<p><a target="_blank" rel="noopener" href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/">https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/</a></p>
<p>Cloud全家桶中有个很重要的组件就是网关，在1.x版本中都是采用的Zuul</p>
<p>网关；但在2.x版本中，zuul的升级一直跳票，SpringCloud最后自己研发</p>
<p>了一个网关替代Zuul，那就是SpringCloud Gateway一句话：</p>
<p><strong>gateway是原zuul1.x版的替代</strong> </p>
<p><img src="/2021/03/15/springcloud/48.png" alt="img"> </p>
<p>Gateway是在Spring生态系统之上构建的API网关服务，基于Spring </p>
<p>5,Spring Boot 2和Project Reactor等技术。</p>
<p>Gateway旨在提供一种简单而有效的方式来对API进行路由，以及提供一些</p>
<p>强大的过滤器功能，例如：熔断、限流、重试等</p>
<p><img src="/2021/03/15/springcloud/49.png" alt="image-20210310010754927"></p>
<p>SpringCloud Gateway 是 Spring Cloud 的一个全新项目，基于 Spring </p>
<p>5.0+Spring Boot 2.0 和 Project Reactor 等技术开发的网关，它旨在为微</p>
<p>服务架构提供一种简单有效的统一的API路由管理方式。 </p>
<p>SpringCloud Gateway 作为 Spring Cloud 生态系统中的网关，目标是替代 </p>
<p>Zuul，在Spring Cloud 2.0以上版本中，没有对新版本的Zuul 2.0以上最新</p>
<p>高性能版本进行集成，仍然还是使用的Zuul 1.x非Reactor模式的老版本。</p>
<p>而为了提升网关的性能，SpringCloud Gateway是基于WebFlux框架实现</p>
<p>的，而WebFlux框架底层则使用了高性能的Reactor模式通信框架Netty。</p>
<p>Spring Cloud Gateway的目标提供统一的路由方式且基于 Filter 链的方式</p>
<p>提供了网关基本的功能，例如：安全，监控/指标，和限流。</p>
<p> 源码架构：</p>
<p><img src="/2021/03/15/springcloud/50.png" alt="img"> </p>
<h4 id="14-2、作用"><a href="#14-2、作用" class="headerlink" title="14.2、作用"></a>14.2、作用</h4><ul>
<li>反向代理</li>
<li>鉴权</li>
<li>流量控制</li>
<li>熔断</li>
<li>日志监控</li>
<li>……</li>
</ul>
<h4 id="14-3、微服务架构中网关在哪里"><a href="#14-3、微服务架构中网关在哪里" class="headerlink" title="14.3、微服务架构中网关在哪里"></a>14.3、微服务架构中网关在哪里</h4><p><img src="/2021/03/15/springcloud/51.png" alt="img"> </p>
<h4 id="14-4、Zool与Gateway"><a href="#14-4、Zool与Gateway" class="headerlink" title="14.4、Zool与Gateway"></a>14.4、Zool与Gateway</h4><ol>
<li><p>一方面因为Zuul1.0已经进入了维护阶段，而且Gateway是</p>
<p>Spring Cloud团队研发的，是亲儿子产品，值得信赖。而且很多功能</p>
<p>Zuul都没有用起来也非常的简单便捷。</p>
</li>
</ol>
<p>   Gateway是基于异步非阻塞模型上进行开发的，性能方面不需要担</p>
<p>   心。虽然Netfix早就发布了最新的Zuul 2.x，但 Spring Cloud貌似没有</p>
<p>   整合计划。而且Netflix相关组件都宣布进入维护期；不知前景如何？</p>
<p>   多方面综合考虑Gateway是很理想的网关选择。</p>
<ol start="2">
<li><p>Spring Cloud Gateway 具有如下特性：</p>
<p><strong>基于Spring Framework 5,Project Reactor和 Spring Boot 2.0 进行构建</strong>； </p>
<ul>
<li>动态路由：能够匹配任何请求属性；</li>
<li>可以对路由指定 Predicate (断言)和 Filter (过滤器)；</li>
<li>集成Hystrix的断路器功能；</li>
<li>集成 Spring Cloud 服务发现功能；</li>
<li>易于编写的Predicate (断言)和Filter (过滤器)；</li>
<li>请求限流功能；</li>
<li>支持路径重写。</li>
</ul>
</li>
<li><p>Spring Cloud Gateway 与 Zuul的区别:</p>
<p>在SpringCloud <strong>F</strong>inchley正式版之前，Spring Cloud 推荐的网关是 </p>
<p>Netflix 提供的Zuul:</p>
<ul>
<li><p>Zuul 1.x，是一个基于阻塞I/O的API Gateway</p>
</li>
<li><p>Zuul 1.x 基于<strong>Servlet 2.5</strong>使用阻塞架构，它不支持任何长连接(如 </p>
<p>WebSocket)。 Zuul 的设计模式和Nginx较像，每次I/ O 操作都</p>
<p>是<strong>从工作线程中选择一个执行</strong>，请求线程<strong>被阻塞到工作线程完成</strong>，</p>
<p>但是差别是:Nginx 用C++ 实现，Zuul 用 Java 实现，而 JVM 本身</p>
<p>会有第一次加载较慢的情况，使得Zuul的性能相对较差。</p>
</li>
<li><p>Zuul 2.x理念更先进，想<strong>基于Netty非阻塞和支持长连接</strong>，但</p>
<p>SpringCloud目前还没有整合。Zuul 2.x的性能较 Zuul 1.x有较大提升。在性能方面，根据官方提供的基准测试，Spring Cloud Gateway的RPS(每秒请求数)是Zuul的1.6倍。</p>
</li>
<li><p>Spring Cloud Gateway 建立在 <strong>Spring Framework 5、Project</strong> </p>
<p><strong>Reactor和 Spring Boot 2</strong>之上，使用<strong>非阻塞API</strong>。</p>
</li>
<li><p>Spring Cloud Gateway 还支持WebSocket，并且与Spring紧密集</p>
<p>成拥有更好的开发体验。</p>
</li>
</ul>
</li>
<li><p>springcloud中所集成的Zuul版本，采用的是Tomcat容器，使用的是传</p>
<p>统的Servlet IO处理模型。</p>
<p>Servlet的生命周期：servlet由servlet container进行生命周期管理。</p>
<ul>
<li><p>container启动时构造servlet对象并调用servlet init()进行初始化；</p>
</li>
<li><p>container运行时接受请求，并为每个请求分配一个线程(一般从线</p>
<p>程池中获取空闲线程)然后调用service();</p>
</li>
<li><p>container关闭时调用servlet destory()销毁servlet;</p>
</li>
</ul>
<p><img src="/2021/03/15/springcloud/52.png" alt="image-20210310012934921"></p>
</li>
<li><p>上述模式的缺点：</p>
<p>servlet是一个<strong>简单的网络IO模型</strong>，当请求进入servlet container时，</p>
<p>servlet container就会为其绑定一个线程，在<strong>并发不高的场景</strong>下这种模</p>
<p>型是适用的。但是一旦高并发(比如抽风用jemeter压)，线程数量就会</p>
<p>上涨，而线程资源代价是昂贵的(<strong>上线文切换，内存消耗大</strong>)严重影响请</p>
<p>求的处理时间。在一些简单业务场景下，不希望为每个request分配一</p>
<p>个线程，只需要1个或几个线程就能应对极大并发的请求，这种业务场</p>
<p>景下servlet模型没有优势。</p>
<p>而Zuul 1.X是<strong>基于servlet之上的一个阻塞式处理模型</strong>，即spring实现</p>
<p>了处理所有request请求的一个servlet(DispatcherServlet)并由该</p>
<p>servlet阻塞式处理处理。所以Springcloud Zuul无法摆脱servlet模型</p>
<p>的弊端。</p>
</li>
<li><p>WebFlux：</p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#spring-webflux">https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#spring-webflux</a></p>
<p><img src="/2021/03/15/springcloud/53.png" alt="img"> </p>
<p><img src="/2021/03/15/springcloud/54.png" alt="img"> </p>
<p>传统的Web框架，此如说：struts2，springmvc等都是基于Servlet </p>
<p>API与Servlet容器基础之上运行的。</p>
<p>但是，<strong>在Servlet3.1之后有了异步非阻赛的支持</strong>。而WebFlux是一个典</p>
<p>型非阻塞异步的框架，它的核心是基于Reactor的相关API实现的。相</p>
<p>对于传统的web框架来说，它可以运行在诸如Netty，Undertow及支</p>
<p>持Servlet3.1的容器上。非阻塞式+函数式编程(Spring5必须让你使用</p>
<p>java8)</p>
<p>Spring WebFlux 是Spring 5.0 引入的新的响应式框架，区别于 Spring </p>
<p>MVC，它不需要依赖Servlet API，它是<strong>完全异步非阻塞的</strong>，并且<strong>基于</strong> </p>
<p><strong>Reactor 来实现响应式流规范</strong>。</p>
<h4 id="14-5、三大核心概念"><a href="#14-5、三大核心概念" class="headerlink" title="14.5、三大核心概念"></a>14.5、三大核心概念</h4></li>
</ol>
<ul>
<li><p>Route(路由)：</p>
<p>路由是构建网关的基本模块,它由ID,目标URI,一系列的断言和过滤器组</p>
<p>成,如断言为true则匹配该路由。</p>
</li>
<li><p>Predicate(断言)：</p>
<p>参考的是Java8的java.util.function.Predicate</p>
<p>开发人员可以匹配HTTP请求中的所有内容(例如请求头或请求参数),如</p>
<p>果请求与断言相匹配则进行路由。</p>
</li>
<li><p>Filter(过滤)：</p>
<p>指的是Spring框架中GatewayFilter的实例,使用过滤器,可以在请求被路</p>
<p>由前或者之后对请求进行修改。</p>
</li>
</ul>
<p>web请求，通过一些匹配条件，定位到真正的服务节点。并在这个转发过</p>
<p>程的前后，进行一些精细化控制。</p>
<p>predicate就是我们的匹配条件；而filter，就可以理解为一个无所不能的拦截器。有了这两个元素，再加上目标uri，就可以实现一个具体的路由了。</p>
<p><img src="/2021/03/15/springcloud/55.png" alt="image-20210310014051292"> </p>
<h4 id="14-6、Gateway工作流程（路由转发-执行过滤器链）"><a href="#14-6、Gateway工作流程（路由转发-执行过滤器链）" class="headerlink" title="14.6、Gateway工作流程（路由转发+执行过滤器链）"></a>14.6、Gateway工作流程（路由转发+执行过滤器链）</h4><p>官网总结</p>
<p><img src="/2021/03/15/springcloud/56.png" alt="img"> </p>
<p><img src="/2021/03/15/springcloud/Users/风间&琉璃/AppData/Local/Temp/mindmaster/1223393c341/bin/3008859F-0E2E-4542-92C5-A049333E2AC6.png" alt="img"> </p>
<p>客户端向Spring Cloud Gateway发出请求。然后在Gateway Handler </p>
<p>Mapping中找到与请求相匹配的路由，将其发送到Gateway Web </p>
<p>Handler。</p>
<p>Handler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务</p>
<p>逻辑，然后返回。</p>
<p>过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前(“pre”)或之</p>
<p>后(“post”)执行业务逻辑。</p>
<p>Filter在“pre”类型的过滤器可以做参数校验、权限校验、流量监控、日志输</p>
<p>出、协议转换等，</p>
<p>在“post”类型的过滤器中可以做响应内容、响应头的修改，日志的输出，流</p>
<p>量监控等有着非常重要的作用。</p>
<h4 id="14-7、依赖"><a href="#14-7、依赖" class="headerlink" title="14.7、依赖"></a>14.7、依赖</h4><p>pom：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>application.yml配置：</p>
<p><img src="/2021/03/15/springcloud/57.png" alt="img"></p>
<p>访问：</p>
<p>添加网关前：<a target="_blank" rel="noopener" href="http://localhost:8001/payment/get/31">http://localhost:8001/payment/get/31</a></p>
<p>添加网关后：<a target="_blank" rel="noopener" href="http://localhost:9527/payment/get/31">http://localhost:9527/payment/get/31</a></p>
<h4 id="14-8、Gateway网关路由有两种配置方式"><a href="#14-8、Gateway网关路由有两种配置方式" class="headerlink" title="14.8、Gateway网关路由有两种配置方式"></a>14.8、Gateway网关路由有两种配置方式</h4><p>1、在配置文件yml中配置</p>
<p>2、代码中注入RouteLocator的Bean</p>
<p>示例：</p>
<p>百度国内新闻网站,需要外网<a target="_blank" rel="noopener" href="https://news.baidu.com/guonei">https://news.baidu.com/guonei</a></p>
<p>业务需求：通过9527网关访问到外网的百度新闻网址</p>
<p>实现：在cloud-gateway-gateway9527编写配置类</p>
<p><img src="/2021/03/15/springcloud/58.png" alt="img"> </p>
<p><img src="/2021/03/15/springcloud/59.png" alt="img"> </p>
<h4 id="14-9、通过服务名实现动态"><a href="#14-9、通过服务名实现动态" class="headerlink" title="14.9、通过服务名实现动态"></a>14.9、通过服务名实现动态</h4><p>默认情况下Gatway会根据注册中心注册的服务列表,  以注册中心上微服务</p>
<p>名为路径<strong>创建动态路由进行转发,从而实现动态路由的功能</strong>。</p>
<p>启动：一个eureka+两个服务提供者</p>
<p>application.yml配置：</p>
<p>需要注意的是uri的协议lb,表示启用Gateway的负载均衡功能。</p>
<p>lb://serverName是spring cloud  gatway在微服务中自动为我们创建的负载均衡uri</p>
<p><img src="/2021/03/15/springcloud/209.png" alt="img"> </p>
<h4 id="14-10、Predicate（断言）"><a href="#14-10、Predicate（断言）" class="headerlink" title="14.10、Predicate（断言）"></a>14.10、Predicate（断言）</h4><p>说白了,Predicate就是为了实现一组匹配规则,  让请求过来找到对应的</p>
<p>Route进行处理。</p>
<p>Spring Cloud Gateway将路由匹配作为Spring WebFlux HandlerMapping</p>
<p>基础架构的一部分。</p>
<p>Spring Cloud Gateway包括许多内置的Route PredicateI工厂。所有这些</p>
<p>Predicate都与HTTP请求的不同属性匹配。多个RoutePredicate工厂可以</p>
<p>进行组合。</p>
<p>Spring Cloud Gateway 创建 Route 对象时，使用 RoutePredicateFactory</p>
<p>创建 Predicate 对象，Predicate 对象可以赋值给Route。Spring Cloud </p>
<p>Gateway 包含许多内置的Route Predicate Factories。</p>
<p>所有这些谓词都匹配HTTP请求的不同属性。多种谓词工厂可以组合，并通</p>
<p>过逻辑and。</p>
<p><img src="/2021/03/15/springcloud/60.png" alt="img">  </p>
<p>常用的Route Predicate</p>
<p><img src="/2021/03/15/springcloud/61.png" alt="img"> </p>
<ul>
<li><p>After Route Predicate：在设置时间之后</p>
</li>
<li><p>Before Route Predicate：在设置时间之前</p>
</li>
<li><p>Between Route Predicate：在设置时间中间</p>
</li>
<li><p>Cookie Route Predicate：请求要带有cookie</p>
</li>
<li><p>Header Route Predicate：请求要带有请求头，且请求头的值要符合要求</p>
</li>
<li><p>Host Route Predicate：要使用符合要求的主机进行访问</p>
</li>
<li><p>Method Route Predicate：请求方式要是符合要求</p>
</li>
<li><p>Path Route Predicate：路径相匹配的进行路由</p>
</li>
<li><p>Query Route Predicate：要有参数名并且值还要是符合要求的才能路由</p>
</li>
<li><p>RemoteAddr Route Predicate：通过无类别域间路由(IPv4 or IPv6)列</p>
<p>表匹配路由（- RemoteAddr=192.168.1.1/24）(不常用)</p>
</li>
<li><p>Weight Route Predicate：接收一个[组名,权重], 然后对于同一个组内</p>
<p>的路由按照权重转发（-Weight= group3, 9）（不常用）</p>
</li>
</ul>
<p>application.yml配置：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9527</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#开启从注册中心动态创建路由的功能，利用微服务名进行路由</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh</span> <span class="comment">#payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line">          <span class="comment">#uri: http://localhost:8001          #匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cloud-payment-service</span> <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/get/**</span>         <span class="comment"># 断言，路径相匹配的进行路由</span></span><br><span class="line"></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh2</span> <span class="comment">#payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line">          <span class="comment">#uri: http://localhost:8001          #匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cloud-payment-service</span> <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/lb/**</span>         <span class="comment"># 断言，路径相匹配的进行路由</span></span><br><span class="line">            <span class="comment">#- After=2021-03-09T01:19:24.226+08:00[Asia/Shanghai]</span></span><br><span class="line">            <span class="comment">#- Before=2021-03-09T01:19:24.226+08:00[Asia/Shanghai]</span></span><br><span class="line">            <span class="comment">#- Between=2021-03-09T01:19:24.226+08:00[Asia/Shanghai],2022-03-09T01:19:24.226+08:00[Asia/Shanghai]</span></span><br><span class="line">            <span class="comment">#- Cookie=username,xgh #请求要带有cookie（URL + -- cookie &quot;username=xgh&quot;）</span></span><br><span class="line">            <span class="comment">#- Header=X-Request-Id, \d+  # 请求头要有X-Request-Id属性并且值为整数的正则表达式（URL + --H &quot;X-Request-Id:123&quot;）</span></span><br><span class="line">            <span class="comment">#- Host=**.atguigu.com #主机要带有atguigu.com</span></span><br><span class="line">            <span class="comment">#- Method=GET #请求方式要是get</span></span><br><span class="line">            <span class="comment">#- Query=username,\d+ #要有参数名并且值还要是整数的才能路由</span></span><br><span class="line">          <span class="comment">#filters:</span></span><br><span class="line">            <span class="comment">#- AddRequestHeader=X-Request-Id,1024 #过滤器工厂会在匹配的请求头上加上一对请求头，名称为X-Request-Id，值为1024</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">cloud-gateway-service</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">gateway9527</span></span><br><span class="line">    <span class="comment">#访问路径可以显示IP地址</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">client:</span> <span class="comment">#服务提供者provider注册进eureka服务列表内</span></span><br><span class="line">    <span class="comment">#表示是否将自己注册进EurekaServer默认为true。</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span></span><br><span class="line">    <span class="attr">fetchRegistry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment">#单机版</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br><span class="line">      <span class="comment"># 集群版</span></span><br><span class="line">      <span class="comment">#defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="14-11、Filter（过滤器）"><a href="#14-11、Filter（过滤器）" class="headerlink" title="14.11、Filter（过滤器）"></a>14.11、Filter（过滤器）</h4><h5 id="14-11-1、是什么？"><a href="#14-11-1、是什么？" class="headerlink" title="14.11.1、是什么？"></a>14.11.1、是什么？</h5><p>路由过滤器可用于修改进入的HTTP请求和返回的HTTP响应，路由过滤器</p>
<p>只能指定路由进行使用。</p>
<p>Spring Cloud Gateway内置了多种路由过滤器，他们都由GatewayFilter的</p>
<p>工厂类来产生。</p>
<p><img src="/2021/03/15/springcloud/62.png" alt="image-20210310021404546"> </p>
<h5 id="14-11-2、生命周期"><a href="#14-11-2、生命周期" class="headerlink" title="14.11.2、生命周期"></a>14.11.2、生命周期</h5><ul>
<li>post</li>
<li>pre</li>
</ul>
<h5 id="14-11-3、种类"><a href="#14-11-3、种类" class="headerlink" title="14.11.3、种类"></a>14.11.3、种类</h5><ul>
<li>GatewayFilter（31种）：<a target="_blank" rel="noopener" href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gatewayfilter-factories">https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gatewayfilter-factories</a></li>
<li>GlobalFilter（10种）：<a target="_blank" rel="noopener" href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#global-filters">https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#global-filters</a></li>
</ul>
<p>常用的GatewayFilter：</p>
<p>在yml里面配置：</p>
<p><img src="/2021/03/15/springcloud/63.png" alt="img"> </p>
<p>自定义过滤器：</p>
<p>自定义全局GlobalFilter</p>
<p>两个主要接口</p>
<ul>
<li><p>GlobalFilter</p>
</li>
<li><p>Ordered</p>
</li>
</ul>
<p>作用：</p>
<ul>
<li>全局日志记录</li>
<li>统一网关鉴权</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGateWayFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;**************come in MylogGateWayGilter:  &quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        String uname = exchange.getRequest().getQueryParams().getFirst(<span class="string">&quot;uname&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (uname == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;********用户名为空，非法用户。&quot;</span>);</span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);</span><br><span class="line">            <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截的级别，值越小，级别越大</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="分布式配置中心"><a href="#分布式配置中心" class="headerlink" title="分布式配置中心"></a>分布式配置中心</h2><h3 id="15、SpringCloud-config"><a href="#15、SpringCloud-config" class="headerlink" title="15、SpringCloud config"></a>15、SpringCloud config</h3><h4 id="15-1、分布式系统面临的问题"><a href="#15-1、分布式系统面临的问题" class="headerlink" title="15.1、分布式系统面临的问题"></a>15.1、分布式系统面临的问题</h4><p>配置问题：</p>
<p>到目前为止，我们对 Eureka、Robbin、OpenFeign、Hystrix、Gateway</p>
<p>等有了相应的了解，每个微服务都是单独一个模块，微服务彼此还支持集群</p>
<p>环境。</p>
<p>但是在微服务项目的开发中，还面临着一个严重的配置问题。每一个微服务</p>
<p>都需要一个配置文件，如果有几个微服务需要连接数据库，name就需要进</p>
<p>行 4 次数据库的配置。当数据库发生改变，那么就需要同时修改 4 个微服</p>
<p>务的配置文件才可以。那么如果有40台呢？如果是集群模式呢？？</p>
<p>如果能够做到：一处修改、处处生效，这样就可以减轻修改配置压力，从而</p>
<p>增强配置管理方面的功能，此时就需要 Spring Cloud Config 和 Spring </p>
<p>Cloud Bus 上场了。</p>
<p>使用 Config + Bus，可以实现 ：</p>
<ul>
<li><p>一处修改、处处生效</p>
</li>
<li><p>灵活的对版本(dev/test/prod)进行切换，这样就足够方便了</p>
</li>
</ul>
<p><img src="/2021/03/15/springcloud/64.png" alt="img"></p>
<h4 id="15-2、是什么："><a href="#15-2、是什么：" class="headerlink" title="15.2、是什么："></a>15.2、是什么：</h4><p><a target="_blank" rel="noopener" href="https://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.2.1.RELEASE/reference/html/">https://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.2.1.RELEASE/reference/html/</a></p>
<p>Springcloud config为微服务架构中的微服务提供集中化的外部配置支持，</p>
<p>配置服务器为各个不同微服务应用的所有环境提供一个中心化的外部配</p>
<p>置。各个不同微服务应用 Springcloud config为微服务架构中的微服务提</p>
<p>供集中化的外部配置支持，配置服务器为各个不同微服务应用的所有环境</p>
<p>提供一个中心化的外部配置。中心化的外部配置。</p>
<h4 id="15-3、怎么用："><a href="#15-3、怎么用：" class="headerlink" title="15.3、怎么用："></a>15.3、怎么用：</h4><p>Springcloud Config分为<strong>服务端</strong>和<strong>客户端</strong>两部分。</p>
<ul>
<li><p>服务端（Config Server）：也称分布式配置中心，它是一个独立的微服</p>
<p>务应用，用来连接配置服务器并未客户端提供获取配置信息，加密、解</p>
<p>密信息等访问接口。</p>
</li>
<li><p>客户端：通过指定的 <strong>配置中心(Config Server)</strong> 来管理应用资源，以及与业务相关的配置内容，并在启动的时候从 <strong>配置中心</strong> 获取和加载配置信息。</p>
</li>
</ul>
<h4 id="15-4、作用"><a href="#15-4、作用" class="headerlink" title="15.4、作用"></a>15.4、作用</h4><ul>
<li><p>集中管理配置文件</p>
</li>
<li><p>不同环境不同配置，动态化的配置更新，分环境部署比如</p>
<p>dev/test/prod/beta/release</p>
</li>
<li><p>运行期间动态调整配置，不再需要字啊每个服务器的机器上编写配置文</p>
<p>件，服务会向配置中心同意拉去配置自己的信息</p>
</li>
<li><p>当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的</p>
<p>配置</p>
</li>
<li><p>将配置信息以REST接口的形式暴露</p>
<ul>
<li>post,curl访问刷新均可</li>
</ul>
</li>
</ul>
<h4 id="15-5、与GitHub整合配置"><a href="#15-5、与GitHub整合配置" class="headerlink" title="15.5、与GitHub整合配置"></a>15.5、与GitHub整合配置</h4><p>由于SpringCloud Config默认使用Git来存储配置文件（也有其他方式，比</p>
<p>如注册SVN和本地文件），但最推荐的还是Git，而且使用的是http/https服</p>
<p>务的形式。</p>
<p>步骤：</p>
<ol>
<li><p>创建存储 Config 的新 Repository</p>
</li>
<li><p>将新建的GitHub远程仓库克隆到本地</p>
<p>Repository 创建成功，即可获取自己的仓库地址，将项目克隆到本</p>
<p>地，方便对数据的修改。（GitHub 也支持直接修改，你也可以不克</p>
<p>隆，此处克隆只是为了更方便处理数据。）</p>
</li>
<li><p>进入克隆目录，新建三个配置文件，分别是 <strong><code>config-dev.yml</code>**、</strong><code>config-test.yml</code><strong>、</strong><code>config-prod.yml</code>**。然后通过命令将其推送到远程GitHub仓库。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add *.yml(将提交的文件加入暂存区，为git commit做准备)</span><br><span class="line">git commit -m “first commit” (完成对文件内容提交至Git版本库)</span><br><span class="line">git push -u origin master(将本地仓库内容，推送至GitHub远程仓库)</span><br></pre></td></tr></table></figure>
</li>
<li><p>对配置修改后，通过以上三个命令，便可以再次将修改后的内容推送至 GitHub。你也可以使用 IDEA 等工具进行</p>
<p><img src="/2021/03/15/springcloud/69.png" alt="在这里插入图片描述"></p>
</li>
<li><p>Github 远程仓库内容</p>
<p><img src="/2021/03/15/springcloud/70.png" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>服务端</strong>配置测试 (Config 结构图中的 <strong>Config Server</strong>)</p>
<p>pom：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入spring-cloud-config-server依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置文件 application.yml：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3344</span>   <span class="comment">#端口号</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-config-center</span>  <span class="comment">#注册进Eureka 服务器的微服务名</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://github.com/Liuzebiao/springcloud-config.git</span>  <span class="comment">#GitHub远程仓库地址</span></span><br><span class="line">          <span class="comment"># 搜索目录</span></span><br><span class="line">          <span class="attr">search-paths:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">springcloud-config</span></span><br><span class="line">      <span class="comment">#读取分支</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务注册到eureka</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span>  <span class="string">http://localhost:7001/eureka</span></span><br></pre></td></tr></table></figure>

<p>主启动类 配置**@EnableConfigServer**注解</p>
<p>启动测试：<a target="_blank" rel="noopener" href="http://localhost:3344/master/config-dev.yml">http://localhost:3344/master/config-dev.yml</a></p>
</li>
<li><p>GitHub配置文件<strong>读取规则</strong>：</p>
<p>远程 GitHub 仓库，配置文件的命名也是有具体规则的。Spring Cloud </p>
<p>Config 官方共支持 5 种方式的配置（<a target="_blank" rel="noopener" href="https://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.2.1.RELEASE/reference/html/#_quick_start">https://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.2.1.RELEASE/reference/html/#_quick_start</a></p>
<p>参数说明：</p>
<ol>
<li><code>label</code>：GitHub 分支(branch)名称</li>
<li><code>application</code>：服务名</li>
<li><code>profile</code>：环境(<code>dev/test/prod</code>)</li>
</ol>
<ul>
<li><p>/{application}/{profile}/{label}：</p>
<p>返回的是 Json 对象，需要自己解析所要的内容</p>
<p><img src="/2021/03/15/springcloud/71.png" alt="在这里插入图片描述"></p>
</li>
<li><p>/{application}-{profile}.yml：</p>
<p>(这种不带label方式，默认使用application.yml 配置)因为 </p>
<p>applicaiton.yml 文件已经有配置过 label，不带label 方式，默认走</p>
<p>的就是 yml 配置的 label，返回的是配置内容</p>
<p><img src="/2021/03/15/springcloud/72.png" alt="在这里插入图片描述"></p>
</li>
<li><p>/{label}/{application}-{profile}.yml：</p>
<p>(推荐使用第三种)这种方式简明扼要，条理清晰，返回的是配置内</p>
<p>容</p>
<p><img src="/2021/03/15/springcloud/73.png" alt="在这里插入图片描述"></p>
</li>
<li><p>/{application}-{profile}.properties：</p>
<p>同第2种</p>
</li>
<li><p>/{label}/{application}-{profile}.properties：</p>
<p>同第3种</p>
</li>
</ul>
</li>
<li><p><strong>客户端</strong>配置测试 (Config 结构图中的 Client A、Client B、Client C)</p>
<p>依赖pom：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入spring-cloud-starter-config依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置文件 bootstrap.yml：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3355</span> <span class="comment">#端口</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span> <span class="comment">#名称</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="comment">#config客户端配置</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span>  <span class="comment">#分支名称</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">config</span>  <span class="comment">#配置文件名称</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">dev</span>   <span class="comment"># 读取后缀名称   上述3个综合：master分支上config-dev.yml 的配置文件被读取(http://config-3344.com:3344/master/fongig-dev.yml)</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">http://localhost:3344</span>   <span class="comment">#配置中心地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务注册到eureka地址</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka</span></span><br></pre></td></tr></table></figure>

<p>主启动类 配置**@EnableConfigServer**注解</p>
<p>controller业务类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.info&#125;&quot;)</span> <span class="comment">//通过这种方式，可以直接读取ConfigServer中的配置信息</span></span><br><span class="line">    <span class="keyword">private</span> String configInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/configInfo&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConfigInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动测试：<a target="_blank" rel="noopener" href="http://localhost:3355/configInfo">http://localhost:3355/configInfo</a></p>
<h4 id="15-6、bootstrap-yml与application-yml"><a href="#15-6、bootstrap-yml与application-yml" class="headerlink" title="15.6、bootstrap.yml与application.yml"></a>15.6、bootstrap.yml与application.yml</h4></li>
</ol>
<p>applicaiton.yml是用户级的资源配置项</p>
<p>bootstrap.yml是系统级的，<strong>优先级更加高</strong></p>
<p>Spring Cloud会创建一个“Bootstrap Context”，作为Spring应用</p>
<p>的<code>Application Context</code>的<strong>父上下文</strong>。初始化的时候，</p>
<p><code>BootstrapContext</code>负责从<strong>外部源</strong>加载配置属性并解析配置。这两个上下</p>
<p>文共享一个从外部获取的<code>Environment</code>。</p>
<p>“Bootstrap”属性有<strong>高优先级</strong>，默认情况下，它们不会被本地配置覆</p>
<p>盖。<code>Bootstrap context</code>和<code>Application Context</code>有着不同的约定，所</p>
<p>以新增了一个bootstrap.yml’文件，保证<code>Bootstrap Context</code>和</p>
<p><code>Application Context</code>配置的分离。</p>
<p><strong>要将Client模块下的application.yml文件改为bootstrap.yml,这是很关</strong></p>
<p><strong>键的</strong>，因为bootstrap.yml是比application.yml先加载的。bootstrap.yml</p>
<p>优先级高于application.yml。 </p>
<h4 id="15-7、分布式配置的动态刷新问题"><a href="#15-7、分布式配置的动态刷新问题" class="headerlink" title="15.7、分布式配置的动态刷新问题"></a>15.7、分布式配置的动态刷新问题</h4><ol>
<li><p>POM引入actuator监控</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入actuator监控--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改YML,暴露监控接口</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span> </span><br><span class="line">	<span class="attr">endpoints:</span> </span><br><span class="line">		<span class="attr">web:</span> </span><br><span class="line">			<span class="attr">exposure:</span> </span><br><span class="line">				<span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>@RefreshScope业务类Controller修改</p>
</li>
<li><p>需要运维人员发送Post请求刷新3355客户端</p>
<ul>
<li>必须是POST请求</li>
<li>curl  -X POST “<a target="_blank" rel="noopener" href="http://localhost:3355/actuator/refresh&quot;">http://localhost:3355/actuator/refresh&quot;</a></li>
</ul>
</li>
</ol>
<h4 id="15-8、残留问题"><a href="#15-8、残留问题" class="headerlink" title="15.8、残留问题"></a>15.8、残留问题</h4><ul>
<li><p>假如有 N 多个台，就需要 N 多次的curl的手动刷新</p>
<p>解决想法：</p>
<p>大规模 <strong><code>微服务/集群模式</code>**，</strong>我们可以采用广播的方式，一次通知，处处生效。<strong>类似于 **<code>消息队列的 Topic</code></strong> ，**<code>微信公众号</code>** 的概念，一次订阅，所有订阅者都能接收到新消息。</p>
</li>
<li><p>无法实现精确通知,只通知集群中的某些服务(精确通知，比如有100台机器，只通知前98台)</p>
</li>
</ul>
<p>解决以上两个问题的方法：bus消息总线</p>
<h2 id="消息总线"><a href="#消息总线" class="headerlink" title="消息总线"></a>消息总线</h2><h3 id="16、SpringCloud-Bus"><a href="#16、SpringCloud-Bus" class="headerlink" title="16、SpringCloud Bus"></a>16、SpringCloud Bus</h3><h4 id="16-1、是什么"><a href="#16-1、是什么" class="headerlink" title="16.1、是什么"></a>16.1、是什么</h4><p><a target="_blank" rel="noopener" href="https://cloud.spring.io/spring-cloud-static/spring-cloud-bus/2.2.1.RELEASE/reference/html/">https://cloud.spring.io/spring-cloud-static/spring-cloud-bus/2.2.1.RELEASE/reference/html/</a></p>
<p>在微服务架构的系统中，通常会使用<strong>轻量级的消息代理</strong>来构建一个<strong>共用的消</strong></p>
<p><strong>息主题</strong>，并让系统中所有的微服务实例都连接上来。由于<strong>该主题中产生的消</strong></p>
<p><strong>息会被所有实例监听和消费，所以称它为消息总线</strong>在总线上的各个实例，都</p>
<p>可以方便的广播一些需要让其他链接在该主题上的实例都知道的消息。</p>
<p>Spring Cloud Bus 是用来将 <strong>分布式系统的节点</strong>与 <strong>轻量级消息系统</strong>连接起来</p>
<p>的框架，它整合了 Java 的<strong>事件处理机制</strong>和<strong>消息中间件</strong>的功能。Spring </p>
<p>Cloud Bus 目前仅支持<code>RabbitMQ</code>和<code>Kafka</code>。</p>
<h4 id="16-2、作用"><a href="#16-2、作用" class="headerlink" title="16.2、作用"></a>16.2、作用</h4><p>Spring Cloud Bus能管理和传播分布式系统间的消息，就像一个分布式执行</p>
<p>器，可用于广播状态更改，事件推送等，也可以作为微服务的通信通道。</p>
<p><img src="/2021/03/15/springcloud/65.png" alt="img"></p>
<h4 id="16-3、基本原理与执行流程"><a href="#16-3、基本原理与执行流程" class="headerlink" title="16.3、基本原理与执行流程"></a>16.3、基本原理与执行流程</h4><p>ConfigClient实例都监听MQ中的同一个topic(默认是<strong>SpringcloudBus</strong>)。</p>
<p>当一个服务刷新数据的时候，它会把这个信息放入到topic中，这样其它监</p>
<p>听同一个topic的服务就能得到通知，然后去更新自身的配置。其实就是<strong>通</strong></p>
<p><strong>过 MQ 消息队列的 Topic 机制，达到广播的效果。</strong></p>
<p><img src="/2021/03/15/springcloud/66.png" alt="img"></p>
<h4 id="16-4、Bus的两种设计思想"><a href="#16-4、Bus的两种设计思想" class="headerlink" title="16.4、Bus的两种设计思想"></a>16.4、Bus的两种设计思想</h4><ol>
<li><p>触发<strong>客户端</strong>：</p>
<p>利用消息总线触发一个<strong>客户端</strong>的<code>/bus/refresh</code>,而刷新所有客户端的配置</p>
<p><img src="/2021/03/15/springcloud/67.png" alt="img"></p>
</li>
<li><p>触发<strong>服务端</strong>：</p>
<p>利用消息总线触发一个<strong>服务端</strong>ConfigServer的<code>/bus/refresh</code>端点，而</p>
<p>刷新所有客户端的配置</p>
<p><img src="/2021/03/15/springcloud/68.png" alt="img"></p>
</li>
</ol>
<p>如何选型：</p>
<p>根据架构图显然<strong>第二种</strong>更加合适，所以推荐使用<strong>触发服务端 Config Server</strong> </p>
<p>的方式。第一种触发客户端方式 不适合的原因如下：</p>
<ol>
<li><p>利用消息总线触发客户端方式，<strong>打破了微服务的职责单一性</strong>，因为微服</p>
<p>务本身是业务模块，它本不应该承担配置刷新的职责；</p>
</li>
<li><p>触发客户端方式，<strong>破坏了微服务各个节点之间的对等性</strong>（比如说：</p>
<p>3355/3366/3377 集群方式提供服务，此时 3355 还需要消息通知，影</p>
<p>响节点的对等性）</p>
</li>
<li><p><strong>有一定的局限性</strong>。当微服务迁移时，网络地址会经常发生变化，如果此</p>
<p>时需要做到自动刷新，则会增加更多的修改。</p>
</li>
</ol>
<h4 id="16-5、Bus-动态刷新全局广播配置"><a href="#16-5、Bus-动态刷新全局广播配置" class="headerlink" title="16.5、Bus 动态刷新全局广播配置"></a>16.5、Bus 动态刷新全局广播配置</h4><ul>
<li><p>集群版客户端组建（搭建两个或多个客户端）</p>
</li>
<li><p><strong>服务端</strong>配置中心/<strong>客户端</strong> pom 引入Bus总线依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--添加消息总线支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>服务端配置中心 application.yml 修改 (添加 rabbitmq 相关配置)</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加rabbitmq相关支持（新加）</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#rabbitmq相关配置，暴露bus舒心配置的端点</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;bus-refresh&#x27;</span>  <span class="comment">#为什么配置 bus-refresh，看传染病那张图</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端 application.yml 修改 (同样添加 rabbitmq 相关配置)</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加rabbitmq相关支持</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#暴露监控端点</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span>  <span class="comment">#此处有很多选项可以配置，为了省事 ,直接配置 *</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动模块，开始测试</p>
<p>启动：服务端配置中心 Config Server (3344)、客户端集群</p>
<p>(3355/3366)、Eureka Server(7001)。修改 GitHub 参数配置，然后向 </p>
<p>服务端 发送 Post 请求，命令：<code>curl -X POST &quot;http://localhost:3344/actuator/bus-refresh&quot;</code>，</p>
<p>当向 Config Server 发送 Post 请求后，总线上的各个实例(客户端 </p>
<p>3355/3366 )都能够及时 <strong><code>监听和消费</code></strong> 配置的变更。使用广播的方式，真</p>
<p>正的实现 **<code>一处通知，处处生效</code>**。</p>
<p>使用 MQ 广播的方式，实现<code>一处通知，处处生效</code>的效果。此时我们登陆 </p>
<p>Rabbit MQ 客户端，在<code>Exchanges</code>模块，就能够看到一个叫做 </p>
<p><code>springCloudBus</code>的<code>Topic</code>。</p>
<p>与本文 2.2 Bus 原理 中介绍吻合：<strong>Config 客户端示例，都去监听 MQ</strong> </p>
<p><strong>中的同一个 topic（默认是 springCloudBus）。当一个服务刷新数据</strong></p>
<p>**的时候，它会把这个消息放入到 Topic 中，这样其他监听同一 Topic **</p>
<p><strong>的服务就能够得到通知，然后去更新自身的配置</strong>。</p>
</li>
</ul>
<h4 id="16-6、Bus-动态刷新定点通知配置"><a href="#16-6、Bus-动态刷新定点通知配置" class="headerlink" title="16.6、Bus 动态刷新定点通知配置"></a>16.6、Bus 动态刷新定点通知配置</h4><p>如果需要<strong>差异化通知</strong>，并不想进行全局广播，此时就用到了 Bus 的<strong>定点通</strong></p>
<p><strong>知</strong>功能。</p>
<p>此次我们通过客户端集群(3344/3355)演示。GitHub 远程配置修改后 ，进</p>
<p>行差异化定点通知，只通知 3355，不通知 3366。此处命令和全局广播有点</p>
<p>不同，命令为：http://配置中心IP:配置中心的端口号/actuator/bus-</p>
<p>refresh/{destination}</p>
<p>通过指定 /bus/refresh请求不再发送到具体的服务实例上，而是发给 </p>
<p>Config Server 并通过 <strong>{destination} 参数</strong>来指定需要更新配置的服务或实</p>
<p>例。</p>
<p><strong>{destination} 参数</strong> = 微服务名 ：端口号。3355 微服务名为：config-</p>
<p>client。此处最终发送的 Post 请求命令为：curl -X POST <a target="_blank" rel="noopener" href="http://localhost:3/">http://localhost:3</a></p>
<p>344/actuator/bus-refresh/config-client:3355，真正的实现<strong>精确通知</strong>功</p>
<p>能。</p>
<h2 id="消息驱动"><a href="#消息驱动" class="headerlink" title="消息驱动"></a>消息驱动</h2><h3 id="17、Spring-Cloud-Stream消息驱动"><a href="#17、Spring-Cloud-Stream消息驱动" class="headerlink" title="17、Spring Cloud Stream消息驱动"></a>17、Spring Cloud Stream消息驱动</h3><h4 id="17-1、目前微服务面临的问题"><a href="#17-1、目前微服务面临的问题" class="headerlink" title="17.1、目前微服务面临的问题"></a>17.1、目前微服务面临的问题</h4><p>在项目开发中，常用的四种消息中间件：<code>ActiveMQ</code>、<code>RabbitMQ</code>、</p>
<p><code>RocketMQ</code>、<code>Kafka</code>。由于每个项目需求的不同，在消息中间件的选型</p>
<p>上也就会不同。</p>
<p>在项目开发中，你会遇到以下一些问题：</p>
<ul>
<li><p>自己学的是 RabbitMQ，公司用的却是 Kafka 。再学 Kafka？学习成本</p>
<p>太高，负担太重；</p>
</li>
<li><p>多部门配合，MQ差异化带来的联调问题。A部门使用 RabbitMQ 进行</p>
<p>消息发送，大数据部门却用 Kafka， MQ 选型的不同，MQ 切换、维</p>
<p>护、开发等困难随之而来。</p>
</li>
</ul>
<p>有没有一种技术，可以让我们不再关注 MQ 的细节，只需要用一种<strong>适配绑</strong></p>
<p><strong>定</strong>的方式，就可以帮助我们自动的在各种 MQ 之间切换呢？答案就是</p>
<p>Spring Cloud Stream 消息驱动。</p>
<p>Spring Cloud Stream 消息驱动，它可以<strong>屏蔽底层 MQ 之间的细节差异</strong>。我</p>
<p>们只需要操作Spring Cloud Stream 就可以操作底层多种多样的MQ。从而</p>
<p>解决我们在 MQ 切换、维护、开发方面的难度问题。</p>
<h4 id="17-2、是什么"><a href="#17-2、是什么" class="headerlink" title="17.2、是什么"></a>17.2、是什么</h4><p><a target="_blank" rel="noopener" href="https://spring.io/projects/spring-cloud-stream#overview">https://spring.io/projects/spring-cloud-stream#overview</a></p>
<p>Spring Cloud Stream 是一个<strong>构建消息驱动</strong>微服务的框架。应用程序通过 </p>
<p><strong>inputs</strong>或者<strong>outputs</strong>来与 Spring Cloud Stream 中的 <strong>binder</strong> 对象交互。通</p>
<p>过我们的配置来进行 binding(绑定)， 然后 Spring Cloud Stream <strong>通过</strong> </p>
<p><strong>binder 对象与消息中间件交互</strong>。所以，我们只需要搞清楚如何与 Spring </p>
<p>Cloud Stream 交互，就可以方便使用消息驱动的方式。</p>
<p>Spring Cloud Stream 通过使用 <strong>Spring Integration</strong> 来连接消息代理中间</p>
<p>件，以实现消息时间驱动。Spring Cloud Stream 为一些供应商的消息中间</p>
<p>件产品提供了个性化的自动配置发现，引用了<code>发布-订阅</code>、<code>消费组</code>、<code>分区 </code>三</p>
<p>个核心概念。目前仅支持<code>RabbitMQ</code>、<code>Kafka</code>。</p>
<p>一句话总结： Spring Cloud Stream 屏蔽了底层消息中间件的差异，降低</p>
<p>MQ 切换成本，统一消息的编程模型。开发中使用的就是各种<strong>xxxBinder</strong></p>
<p><img src="/2021/03/15/springcloud/74.png" alt="img"></p>
<h4 id="17-3、设计思想"><a href="#17-3、设计思想" class="headerlink" title="17.3、设计思想"></a>17.3、设计思想</h4><h5 id="17-3-1、标志MQ"><a href="#17-3-1、标志MQ" class="headerlink" title="17.3.1、标志MQ"></a>17.3.1、标志MQ</h5><p><strong><code>生产者/消费者</code></strong> 之间通过 <strong><code>消息媒介</code></strong> 传递消息内容</p>
<p>生产者/消费者之间靠消息媒介传递信息内容：Message</p>
<p>消息必须走特定的通道：MessageChannel</p>
<p>消息通道MessageChannel的子接口SubscribeChannel，由</p>
<p>MessageHandler消息处理器所订阅</p>
<p>结构图：</p>
<p><img src="/2021/03/15/springcloud/75.png" alt="在这里插入图片描述"></p>
<h5 id="17-3-2、Spring-Cloud-Stream"><a href="#17-3-2、Spring-Cloud-Stream" class="headerlink" title="17.3.2、Spring Cloud Stream"></a>17.3.2、Spring Cloud Stream</h5><p>比如说我们用到了RabbitMQ和 Kafka，由于这两个消息中间件的架构上的</p>
<p>不同。像RabbitMQ 有<code>exchange</code>、Kafka有<code>Topic</code>和<code>Partions</code>分区的概念。</p>
<p>这些中间件的差异性，给我们实际项目的开发造成了一定的困扰。我们如果</p>
<p>用了两个消息队列中的其中一个，后面的业务需求如果向往另外一种消息队</p>
<p>列进行迁移，这需求简直是灾难性的。<strong>因为它们之间的耦合性过高，导致一</strong></p>
<p><strong>大堆东西都要重新推到来做</strong>，这时候 Spring Cloud Stream 无疑是一个好的</p>
<p>选择，它为我们提供了一种解耦合的方式。</p>
<p>结构图：</p>
<p><img src="/2021/03/15/springcloud/76.png" alt="在这里插入图片描述"></p>
<h4 id="17-4、Spring-Cloud-Stream如何统一底层差异"><a href="#17-4、Spring-Cloud-Stream如何统一底层差异" class="headerlink" title="17.4、Spring Cloud Stream如何统一底层差异"></a>17.4、Spring Cloud Stream如何统一底层差异</h4><p>在没有绑定器这个概念的情况下，我们的 Spring Boot 应用直接与消息中间</p>
<p>件进行信息交互时，由于个消息中间件构建的初衷不同，它们的实现细节上</p>
<p>会有较大的差异性。</p>
<p><strong>通过定义绑定器(Binder)作为中间层，就可以完美的实现应用程序与消息中</strong></p>
<p><strong>间件细节的隔离</strong>。 通过向应用程序暴露统一的 Channel 通道，使得应用程</p>
<p>序不需要在考虑各种不同的消息中间件的实现。</p>
<h4 id="17-5、Binder"><a href="#17-5、Binder" class="headerlink" title="17.5、Binder"></a>17.5、Binder</h4><p>在没有绑定器这个概念的情况下，我们的SpringBoot应用要直接与消息中</p>
<p>间件进行信息交互的时候，由于各消息中间件构建的初衷不同，它们的实现</p>
<p>细节上会有较大的差异性，<strong>通过定义绑定器作为中间层，完美地实现了应用</strong></p>
<p><strong>程序与消息中间件细节之间的隔离</strong>。Stream对消息中间件的进一步封装，</p>
<p>可以做到代码层面对中间件的无感知，甚至于动态的切换中间件(rabbitmq</p>
<p>切换为kafka)，使得微服务开发的高度解耦，服务可以关注更多自己的业务</p>
<p>流程。</p>
<p><img src="/2021/03/15/springcloud/77.png" alt="img"></p>
<ul>
<li>INPUT：适用于消费者</li>
<li>OUTPUT：适用于生产者</li>
</ul>
<p>默认情况下，RabbitMQ Binder实现<strong>将每个目标映射到TopicExchange</strong>。 </p>
<p>对于每个使用者组，队列都绑定到该 TopicExchange。 每个使用者实例在</p>
<p>其组的队列中都有一个对应的 RabbitMQ使用者实例。 对于分区的生产者</p>
<p>和使用者，队列以分区索引为后缀，并使用分区索引作为路由键。 对于匿</p>
<p>名使用者（没有组属性的使用者），将使用自动删除队列（具有随机的唯一</p>
<p>名称）。</p>
<h4 id="17-6、Spring-Cloud-Stream-执行流程"><a href="#17-6、Spring-Cloud-Stream-执行流程" class="headerlink" title="17.6、Spring Cloud Stream 执行流程"></a>17.6、Spring Cloud Stream 执行流程</h4><p><img src="/2021/03/15/springcloud/78.png" alt="在这里插入图片描述"></p>
<p>说明：</p>
<ol>
<li><code>Source/Sink</code>：Source 输入消息，Sink 输出消息</li>
<li><code>Channel</code>：通道，是队列 Queue 的一种抽象，在消息通讯系统中就是实现存储和转发的媒介，通过Channel 对队列进行配置；</li>
<li><code>Binder</code>：很方便的 **<code>连接中间件</code>**，屏蔽 MQ 之间的差异</li>
</ol>
<h4 id="17-7、编码API和常用注解"><a href="#17-7、编码API和常用注解" class="headerlink" title="17.7、编码API和常用注解"></a>17.7、编码API和常用注解</h4><p><img src="/2021/03/15/springcloud/79.png" alt="在这里插入图片描述"></p>
<h4 id="17-8、详细配置与代码"><a href="#17-8、详细配置与代码" class="headerlink" title="17.8、详细配置与代码"></a>17.8、详细配置与代码</h4><p>选用 RabbitMQ，在不需要任何 RabbitMQ 包依赖的基础上，使用 Spring </p>
<p>Cloud Stream 消息驱动来实现消息的发送&amp;接收。</p>
<p>步骤：</p>
<ol>
<li><p>生产者配置</p>
<p>依赖pom：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入stream-rabbit依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>applicaiton.yml 配置：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8801</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-stream-provider</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="attr">binders:</span> <span class="comment"># 在此处配置要绑定的rabbitmq的服务信息；</span></span><br><span class="line">        <span class="attr">defaultRabbit:</span> <span class="comment"># 表示定义的名称，用于binding整合(可以自定义名称)</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">rabbit</span> <span class="comment"># 消息组件类型</span></span><br><span class="line">          <span class="attr">environment:</span> <span class="comment"># 设置rabbitmq的相关的环境配置</span></span><br><span class="line">            <span class="attr">spring:</span></span><br><span class="line">              <span class="attr">rabbitmq:</span></span><br><span class="line">                <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">                <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">                <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">                <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">      <span class="attr">bindings:</span> <span class="comment"># 服务的整合处理</span></span><br><span class="line">        <span class="attr">output:</span> <span class="comment"># 这个名字是一个通道的名称</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">studyExchange</span> <span class="comment"># 表示要使用的Exchange名称定义</span></span><br><span class="line">          <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment"># 设置消息类型，本次为json，文本则设置“text/plain”</span></span><br><span class="line">          <span class="attr">default-binder:</span> <span class="string">defaultRabbit</span></span><br><span class="line">          <span class="attr">binder:</span> <span class="string">defaultRabbit</span>  <span class="comment"># 设置要绑定的消息服务的具体设置(需与自定义名称一致)(飘红：Settings-&gt;Editor-&gt;Inspections-&gt;Spring-&gt;Spring Boot-&gt;Spring Boot application.yml 对勾去掉)</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span> <span class="comment"># 客户端进行Eureka注册的配置</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">2</span> <span class="comment"># 设置心跳的时间间隔（默认是30秒）</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">5</span> <span class="comment"># 如果现在超过了5秒的间隔（默认是90秒）</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">send-8801.com</span>  <span class="comment"># 在信息列表时显示主机名称</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span>     <span class="comment"># 访问的路径变为IP地址</span></span><br></pre></td></tr></table></figure>

<p>业务类：</p>
<ul>
<li><p><strong>controller</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMessageController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IMessageProvider messageProvider;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/sendMessage&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sendMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> messageProvider.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>interface 接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMessageProvider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>service</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@EnableBinding 指信道channel和exchange绑定在一起</span></span><br><span class="line"><span class="comment">//@EnableBinding(Source.class) 就是将 Source(源) 放到 Channel 的意思</span></span><br><span class="line"><span class="meta">@EnableBinding(Source.class)</span>  <span class="comment">//定义消息的推送管道</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageProviderImpl</span> <span class="keyword">implements</span> <span class="title">IMessageProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MessageChannel output; <span class="comment">// 消息发送管道</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String serial = UUID.randomUUID().toString();</span><br><span class="line">        output.send(MessageBuilder.withPayload(serial).build());</span><br><span class="line">        System.out.println(<span class="string">&quot;发送消息: &quot;</span>+serial);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>测试启动：<a target="_blank" rel="noopener" href="http://localhost:8801/sendMessage">http://localhost:8801/sendMessage</a></p>
<p>可以看到后台有显示发送消息，进入 RabbitMQ 可视化界面，可以看到</p>
<p>有发送消息波峰出现。</p>
</li>
<li><p>消费者配置</p>
<p>依赖pom：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入stream-rabbit依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>applicaiton.yml 配置</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8802</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-stream-consumer</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="attr">binders:</span> <span class="comment"># 在此处配置要绑定的rabbitmq的服务信息；</span></span><br><span class="line">        <span class="attr">defaultRabbit:</span> <span class="comment"># 表示定义的名称，用于于binding整合(可以自定义名称)</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">rabbit</span> <span class="comment"># 消息组件类型</span></span><br><span class="line">          <span class="attr">environment:</span> <span class="comment"># 设置rabbitmq的相关的环境配置</span></span><br><span class="line">            <span class="attr">spring:</span></span><br><span class="line">              <span class="attr">rabbitmq:</span></span><br><span class="line">                <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">                <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">                <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">                <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">      <span class="attr">bindings:</span> <span class="comment"># 服务的整合处理</span></span><br><span class="line">        <span class="attr">input:</span> <span class="comment"># 这个名字是一个通道的名称</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">studyExchange</span> <span class="comment"># 表示要使用的Exchange名称定义</span></span><br><span class="line">          <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment"># 设置消息类型，本次为json，文本则设置“text/plain”</span></span><br><span class="line">          <span class="attr">binder:</span> <span class="string">defaultRabbit</span>  <span class="comment"># 设置要绑定的消息服务的具体设置(需与自定义名称一致)(飘红：Settings-&gt;Editor-&gt;Inspections-&gt;Spring-&gt;Spring Boot-&gt;Spring Boot application.yml 对勾去掉)</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span> <span class="comment"># 客户端进行Eureka注册的配置</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">2</span> <span class="comment"># 设置心跳的时间间隔（默认是30秒）</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">5</span> <span class="comment"># 如果现在超过了5秒的间隔（默认是90秒）</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">receive-8802.com</span>  <span class="comment"># 在信息列表时显示主机名称</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span>     <span class="comment"># 访问的路径变为IP地址</span></span><br></pre></td></tr></table></figure>

<p>业务类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@EnableBinding(Sink.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveMessageListenerController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@StreamListener(Sink.INPUT)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">(Message&lt;String&gt; message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1号消费者，接收：&quot;</span>+message.getPayload()+<span class="string">&quot;\t port:&quot;</span>+serverPort);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动测试：启动 RabbitMQ，调用<a target="_blank" rel="noopener" href="http://localhost:880/sendMessage">http://localhost:880/sendMessage</a></p>
<p>进行消息发送，可以看到消费者后台在实时接收消息。</p>
</li>
</ol>
<p>这样，我们并没有引入任何相关 RabbitMQ 包，也并不了解 Rabbit MQ。</p>
<p>便能够使用 Rabbit MQ 进行 **<code>消息发送 &amp; 接收</code>**。这就是Spring Cloud </p>
<p>Stream 消息驱动的优越之处。</p>
<h4 id="17-9、Stream-重复消费-持久化问题"><a href="#17-9、Stream-重复消费-持久化问题" class="headerlink" title="17.9、Stream 重复消费/持久化问题"></a>17.9、Stream 重复消费/持久化问题</h4><h5 id="17-9-1、重复消费问题"><a href="#17-9-1、重复消费问题" class="headerlink" title="17.9.1、重复消费问题"></a>17.9.1、重复消费问题</h5><p>当集群方式进行消息消费时，就会存在消息的重复消费问题。比如支付微服</p>
<p>务，购物支付完成后，消息重复消费就会导致支付多次的问题出现，这显然</p>
<p>是不能接受的。</p>
<p>这是因为<strong>没有进行分组的原因，不同组就会出现重复消费</strong>；<strong>同一组</strong>内会发生</p>
<p><strong>竞争关系</strong>，<strong>只有一个可以消费</strong>。 如果我们不指定(8802、8803)集群分组信</p>
<p>息，它会默认将其当做两个分组来对待。这个时候，如果发送一条消息到 </p>
<p>MQ，不同的组就都会收到消息，就会造成消息的重复消费。</p>
<p><strong>解决方法：</strong></p>
<p>只需要用到 Stream 当中 group 属性对消息进行分组即可。将8802、8803</p>
<p>分到一个组即可。<strong>（项目中，是否分组就视业务情况而定吧）</strong></p>
<p><img src="/2021/03/15/springcloud/80.png" alt="在这里插入图片描述"></p>
<h5 id="17-9-2、持久化问题"><a href="#17-9-2、持久化问题" class="headerlink" title="17.9.2、持久化问题"></a>17.9.2、持久化问题</h5><p>服务端发送消息时，此时客户端断开服务（宕机）：若客户端没有分组，此</p>
<p>时客户端不会接收到服务端发送的消息，导致<strong>消息丢失</strong>。</p>
<p>解决方法：</p>
<p>加一个 group 分组属性就行了。如果有客户端有进行分组，重启之后则可</p>
<p>以消费待消费的消息。特别的，但多个客户端都为同一组时，既使其中有一</p>
<p>个客户端宕机，其同组的<strong>一个客户端</strong>也可以接收到消息，不会导致消息丢失</p>
<p>（无需重启）。</p>
<h2 id="分布式链路追踪"><a href="#分布式链路追踪" class="headerlink" title="分布式链路追踪"></a>分布式链路追踪</h2><h3 id="18、Spring-Cloud-Sleuth-Zipkin-分布式链路追踪"><a href="#18、Spring-Cloud-Sleuth-Zipkin-分布式链路追踪" class="headerlink" title="18、Spring Cloud Sleuth + Zipkin 分布式链路追踪"></a>18、Spring Cloud Sleuth + Zipkin 分布式链路追踪</h3><h4 id="18-1、目前微服务面临的问题"><a href="#18-1、目前微服务面临的问题" class="headerlink" title="18.1、目前微服务面临的问题"></a>18.1、目前微服务面临的问题</h4><p>在微服务框架中，一个由客户端发起的请求，在后端系统中会经过多个不同</p>
<p>的微服务节点调用，协同操作产生最后的请求结果。每一个前端请求都会形</p>
<p>成一条复杂的分布式服务调用链路，链路中的任何一环出现<code>高延时</code>或者<code>错</code></p>
<p><code>误</code>，都会引起整个请求最后的失败。</p>
<h4 id="18-2、是什么？"><a href="#18-2、是什么？" class="headerlink" title="18.2、是什么？"></a>18.2、是什么？</h4><p><a target="_blank" rel="noopener" href="https://spring.io/projects/spring-cloud-sleuth#overview">https://spring.io/projects/spring-cloud-sleuth#overview</a></p>
<p>Spring Cloud Sleuth 提供了分布式系统中一套完整的服务跟踪的解决方</p>
<p>案，并且兼容支持了zipkin，完美的解决了多个微服务之间链路调用的问</p>
<p>题。</p>
<p>一句话总结： 就是用来处理服务之间调用关系的。</p>
<h4 id="18-3、调用结构图"><a href="#18-3、调用结构图" class="headerlink" title="18.3、调用结构图"></a>18.3、调用结构图</h4><p><img src="/2021/03/15/springcloud/81.png" alt="在这里插入图片描述"></p>
<h4 id="18-4、搭建链路监控步骤"><a href="#18-4、搭建链路监控步骤" class="headerlink" title="18.4、搭建链路监控步骤"></a>18.4、搭建链路监控步骤</h4><h5 id="18-4-1、环境准备"><a href="#18-4-1、环境准备" class="headerlink" title="18.4.1、环境准备"></a>18.4.1、环境准备</h5><p>Zipkin 是 Twitter 的一个开源项目，允许开发者收集 Twitter 各个服务上的</p>
<p>监控数据，并提供查询接口。</p>
<p>我们需要先准备一个 Zipkin 环境。<strong>Spring Cloud 从F版起已不需要自己构</strong></p>
<p><strong>建Zipkin server了</strong>，只需要调用jar包即可。当前使用版本为 H版。我们只</p>
<p>需要下载 Zipkin jar包，在安装目录的路径下使用 java -jar xxx的方式启动</p>
<p>即可。点击链接：<a target="_blank" rel="noopener" href="https://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server">https://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server</a> ，下载 zipkin-server-2.12.9-exec.jar 。启动就OK了，如</p>
<p>图所示。</p>
<p><img src="/2021/03/15/springcloud/82.png" alt="在这里插入图片描述"></p>
<p>通过 <a target="_blank" rel="noopener" href="http://loclahost:9411/">http://loclahost:9411</a> 就能进入到 Zipkin 为我们提供的可视化界面（中文）</p>
<p><img src="/2021/03/15/springcloud/83.png" alt="在这里插入图片描述"></p>
<p>一次请求完整的调用链路：</p>
<p><img src="/2021/03/15/springcloud/84.png" alt="img"></p>
<p>简单概述上图：</p>
<p><img src="/2021/03/15/springcloud/85.png" alt="img"></p>
<p>术词：</p>
<ul>
<li>Trace：类似于树结构的Span集合，表示一条调用链路，存在唯一标识</li>
<li>span:表示调用链路来源，通俗的理解span就是一次请求信息</li>
</ul>
<h5 id="18-4-2、Sleuth测试环境搭建"><a href="#18-4-2、Sleuth测试环境搭建" class="headerlink" title="18.4.2、Sleuth测试环境搭建"></a>18.4.2、Sleuth测试环境搭建</h5><ol>
<li><p>服务端/客户端 进行相同配置</p>
<p>引入 zipkin + sleuth pom 依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入sleuth+zipkin依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 applicaiton.yml 添加 zipkin、sleuth 相同配置：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># 应用名</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-payment-service</span></span><br><span class="line">  <span class="attr">zipkin:</span></span><br><span class="line">    <span class="attr">base-url:</span> <span class="string">http://localhost:9411</span> <span class="comment">#监控数据要打到9411zipkin上</span></span><br><span class="line">  <span class="attr">sleuth:</span></span><br><span class="line">    <span class="attr">sampler:</span></span><br><span class="line">    <span class="attr">probability:</span> <span class="number">1</span>  <span class="comment">#采样率值介于0到1，1则表示全部采集</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>调用测试：</p>
<p>通过<code>http://localhost/consumer/payment/get/31</code>进行服务调用，</p>
<p>调用成功后，我们打开 <code>http://localhost:9411</code> Zipkin 控制台就可</p>
<p>以看到具体服务调用情况。</p>
<p>点击相对应请求，还可以看到 <strong><code>模块间调用情况</code>**、</strong><code>调用耗时</code>** 等更详细的</p>
<p>信息。点击导航栏中的 <strong><code>依赖</code></strong> 项，还可以查看模块(调用、被调用)的依</p>
<p>赖关系等，<strong>链路调用关系一目了然。</strong></p>
<p><img src="/2021/03/15/springcloud/springcloud%5C86.png" alt="image-20210311024420119"></p>
<p>点进每个具体的请求：</p>
<p><img src="/2021/03/15/springcloud/87.png" alt="image-20210311024741448"></p>
<p>点进依赖：（查看微服务间的依赖关系）</p>
<p><img src="/2021/03/15/springcloud/88.png" alt="image-20210311024859419"></p>
</li>
</ol>
<h2 id="Spring-Cloud-Alibaba"><a href="#Spring-Cloud-Alibaba" class="headerlink" title="Spring Cloud Alibaba"></a>Spring Cloud Alibaba</h2><h4 id="1、什么是维护模式"><a href="#1、什么是维护模式" class="headerlink" title="1、什么是维护模式"></a>1、什么是维护模式</h4><p>随着 Spring Cloud Netflix 项目进入维护模式（Maintenance Mode），Eureka、Hystrix、Ribbon、Zuul 等项目都进入了维护模式。</p>
<p>将模块置于<code>维护模式</code>意味着 Spring Cloud 团队将不再向该模块添加新功能。我们将修复<code>block</code>级别的<code>bug</code>和安全性问题，还将考虑并审查社区中的小请求。自 Spring Cloud Greenwich 版本发行(2018.12.12)以来，Spring Cloud 打算继续为这些模块提供至少一年的支持。（摘自：官网）</p>
<p>现在针对 Spring Cloud Netflix 相关模块已经不再提供支持。我们都知道 Spring Cloud 版本迭代算是比较快的，因而出现了很多重大ISSUE都还来不及Fix就又推出另一个 Release 版本了。进入维护模式意味着：以后一段时间 Spring Cloud Netflix 提供的服务和功能就这么多了，不再开发新的组件和功能了，这显然无法满足接下来微服务的开发要求。</p>
<p>伴随着 Spring Cloud Netflix 倒下，停更的组件自然就需要寻找替代者来继续下去。Alibaba 为了能够在微服务领域占据一定的话语权，此时便趁虚而入，将其代替，于2018.10.31 Spring Cloud Alibaba 正式入驻 Spring Cloud 官方孵化器，并在 Maven Spring Cloud for Alibaba 0.2.0 released。（附：Spring Cloud Alibaba 官方介绍）</p>
<p><img src="/2021/03/15/springcloud/3.jpg" alt="3"></p>
<h4 id="2、Spring-Cloud-Alibaba"><a href="#2、Spring-Cloud-Alibaba" class="headerlink" title="2、Spring Cloud Alibaba"></a>2、Spring Cloud Alibaba</h4><p>Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。</p>
<p>依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。</p>
<h5 id="2-1、Spring-Cloud-Alibaba包含的组件"><a href="#2-1、Spring-Cloud-Alibaba包含的组件" class="headerlink" title="2.1、Spring Cloud Alibaba包含的组件"></a>2.1、Spring Cloud Alibaba包含的组件</h5><ol>
<li>**<code>Sentinel</code>**：阿里巴巴开源产品，把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</li>
<li>**<code>Nacos</code>**：阿里巴巴开源产品，一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</li>
<li>**<code>RocketMQ</code>**：Apache RocketMQ™ 基于 Java 的高性能、高吞吐量的分布式消息和流计算平台。</li>
<li>**<code>Dubbo</code>**：Apache Dubbo™ 是一款高性能 Java RPC 框架。</li>
<li>**<code>Seata</code>**：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。</li>
<li>**<code>Alibaba Cloud OSS</code>**：阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li>
<li>**<code>Alibaba Cloud SchedulerX</code>**：阿里中间件团队开发的一款分布式任务调度产品，支持周期性的任务与固定时间点触发任务。</li>
<li>**<code>Alibaba Cloud SMS</code>**：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</li>
</ol>
<h5 id="2-2、主要功能"><a href="#2-2、主要功能" class="headerlink" title="2.2、主要功能"></a>2.2、主要功能</h5><ol>
<li>**<code>服务限流降级</code>**： 默认支持 WebServlet、WebFlux, OpenFeign、RestTemplate、Spring Cloud Gateway, Zuul, Dubbo 和 RocketMQ 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。</li>
<li>**<code>服务注册与发现</code>**： 适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持。</li>
<li>**<code>分布式配置管理</code>**： 支持分布式系统中的外部化配置，配置更改时自动刷新。</li>
<li>**<code>消息驱动能力</code>**： 基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。</li>
<li>**<code>分布式事务</code>**： 使用 @GlobalTransactional 注解， 高效并且对业务零侵入地解决分布式事务问题。。</li>
<li>**<code>阿里云对象存储</code>**： 阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li>
<li>**<code>分布式任务调度</code>**： 提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有 Worker（schedulerx-client）上执行。</li>
<li>**<code>阿里云短信服务</code>**： 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</li>
</ol>
<h4 id="3、学习组件"><a href="#3、学习组件" class="headerlink" title="3、学习组件"></a>3、学习组件</h4><p><strong><code>Alibaba Cloud OSS</code>**、</strong><code>Alibaba Cloud SchedulerX</code><strong>、</strong><code>Alibaba Cloud SMS</code>** 是阿里云相关的付费业务。接下来，我们主要介绍 Nacos、Sentinel、Seata 这三个模块。</p>
<h4 id="4、官网资料"><a href="#4、官网资料" class="headerlink" title="4、官网资料"></a>4、官网资料</h4><ol>
<li><a target="_blank" rel="noopener" href="https://spring.io/projects/spring-cloud-alibaba#overview">Spring Cloud Alibaba官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/alibaba/spring-cloud-alibaba">Github英文文档</a></li>
<li><a target="_blank" rel="noopener" href="https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html">Spring英文文档</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md">Github中文文档</a></li>
</ol>
<h3 id="19、Spring-Cloud-Alibaba-Nacos服务注册中心与配置中心"><a href="#19、Spring-Cloud-Alibaba-Nacos服务注册中心与配置中心" class="headerlink" title="19、Spring Cloud Alibaba Nacos服务注册中心与配置中心"></a>19、Spring Cloud Alibaba Nacos服务注册中心与配置中心</h3><h4 id="19-1、什么是-Nacos"><a href="#19-1、什么是-Nacos" class="headerlink" title="19.1、什么是 Nacos"></a>19.1、什么是 Nacos</h4><p>Nacos（Dynamic <strong>Na</strong>ming and <strong>Co</strong>nfiguration <strong>S</strong>ervice）：一个更易于构建云原生应用的动态服务发现，配置管理和服务管理中心。</p>
<p>我们可以理解为：<strong>Nacos = 服务注册中心 + 配置中心</strong>；等价于 Nacos = Eureka + Spring Cloud Config + Spring Cloud Bus。</p>
<h4 id="19-2、能干嘛"><a href="#19-2、能干嘛" class="headerlink" title="19.2、能干嘛"></a>19.2、能干嘛</h4><p>Nacos 可以替代 Eureka 来实现<code>服务注册中心</code>、可以替代 Spring Cloud Config 来实现<code>服务配置中心</code>、可以替代 Spring Cloud Bus 来实现<code>配置的全局广播</code>。Nacos 是更强调云原生时代支持 “<strong>服务治理、服务沉淀、共享、持续发展</strong>” 理念的注册中心和配置中心。(附：<a target="_blank" rel="noopener" href="https://nacos.io/zh-cn/index.html">Nacos 官网</a>与<a target="_blank" rel="noopener" href="https://spring-cloud-alibaba-group.github.io/github-pages/hoxton/en-us/index.html">官方文档</a>)</p>
<p>与各种注册中心比较（粗劣）：</p>
<p><img src="/2021/03/15/springcloud/89.png" alt="img"></p>
<h4 id="19-3、Nacos-安装运行"><a href="#19-3、Nacos-安装运行" class="headerlink" title="19.3、Nacos 安装运行"></a>19.3、Nacos 安装运行</h4><p>本地环境：java8+maven环境</p>
<p>从<a target="_blank" rel="noopener" href="https://github.com/alibaba/nacos/releases">官网</a>下载，你也可以选择指定版本下载：<a target="_blank" rel="noopener" href="https://github.com/alibaba/nacos/tags">选择指定版本下载</a>。此处以 window 版进行演示，后续 Nacos 集群环境会在 Linux 环境配置。</p>
<p>下载完成后，解压缩，直接运行 bin 目录下的<code>startup.cmd</code>，<strong>此处需注意</strong>：若你下载的nacos为<strong>较新版本</strong>，nacos默认是集群方式开启，会出现：<code>nacos is starting with cluster</code>，无法正常启动（此时nacos并未集群）。</p>
<p><img src="/2021/03/15/springcloud/90.png" alt="img"></p>
<p>此时需以单机方式启动，执行以下命令<code>startup.cmd -m standalone</code>即可启动Nacos服务，我们可以看到它使用的是 8848 端口，启动结果如图所示：</p>
<p><img src="/2021/03/15/springcloud/91.png" alt="在这里插入图片描述"></p>
<p>运行成功后，直接访问 <a target="_blank" rel="noopener" href="http://localhost:8848/nacos">http://localhost:8848/nacos</a> 就可以进入 Nacos 的为我们提供的 web 控制台。**<code>用户名、密码默认为 nacos</code>**(1.2.0 版本不需要输入密码)，控制台还是挺清新的哈，还提供中文支持。</p>
<p><img src="/2021/03/15/springcloud/92.png" alt="在这里插入图片描述"></p>
<h4 id="19-4、Nacos与其他注册中心对比"><a href="#19-4、Nacos与其他注册中心对比" class="headerlink" title="19.4、Nacos与其他注册中心对比"></a>19.4、Nacos与其他注册中心对比</h4><p>Nacos和CAP：</p>
<p><img src="/2021/03/15/springcloud/96.png" alt="在这里插入图片描述"></p>
<p>CAP：</p>
<p><code>C</code>一致性<code>A</code>高可用<code>P</code>容错性。参考：<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/CAP%E5%8E%9F%E5%88%99/5712863?fr=aladdin">CAP原则</a>，主流选用的都是 AP 模式，保证系统的高可用。</p>
<p>何时选择使用何种模式？</p>
<p>一般来说，如果<strong>不需要存储服务级别的信息</strong>，且服务实例是通过<code>Nacos-client</code>注册，并能够<strong>保证心跳上报</strong>，那么就可以选择 AP 模式。当前主流的服务如 Spring Cloud 和 Dubbo 服务，都适用于 AP 模式，**AP模式为了服务的可用行而减弱了一致性，因此 AP 模式下只支持注册<code>临时实例</code>**。</p>
<p>如果需要在服务级别<strong>编辑或者存储配置信息</strong>，那么 CP 是必须的，<code>K8S服务</code>和<code>DNS服务</code>则适用于 CP 模式。CP模式下则支持注册**<code>持久化实例</code><strong>，此时则是以<code>Raft协议</code>为集群运行模式，</strong>该模式下注册实例之前必须先注册服务，如果服务不存在，则会返回错误。**</p>
<p>而Nacos支持AP和CP模式的切换：</p>
<p><img src="/2021/03/15/springcloud/97.png" alt="在这里插入图片描述"></p>
<p>Nacos的全景图：</p>
<p><img src="/2021/03/15/springcloud/98.png" alt="img"></p>
<p>Nacos AP/CP模式切换：</p>
<p>Nacos 集群默认支持的是CAP原则中的 AP原则，但是也可切换为CP原则，切换命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT &#x27;$NACOS_SERVER:8848/nacos/v1/ns/operator/switches?entry=serverMode&amp;value=CP&#x27;</span><br></pre></td></tr></table></figure>

<p>同时微服务的 bootstrap.yml需配置如下选项指明注册为临时/永久实例，<code>AP模式</code>不支持数据一致性，所以只支持服务注册的<code>临时实例</code>，<code>CP模式</code>支持服务注册的<code>永久实例</code>，满足配置文件的一致性。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#false为永久实例，true表示临时实例开启，注册为临时实例</span></span><br><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">cloud:</span> </span><br><span class="line">    <span class="attr">nacos:</span> </span><br><span class="line">	  <span class="attr">discovery:</span> </span><br><span class="line">		<span class="attr">ephemeral:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h4 id="19-5、Nacos用作服务注册中心"><a href="#19-5、Nacos用作服务注册中心" class="headerlink" title="19.5、Nacos用作服务注册中心"></a>19.5、Nacos用作服务注册中心</h4><p>Nacos 可以替代 Eureka 来作为 **<code>服务注册中心</code>**。附：<a target="_blank" rel="noopener" href="https://spring-cloud-alibaba-group.github.io/github-pages/hoxton/en-us/index.html#_spring_cloud_alibaba_nacos_discovery">Nacos 服务注册中心官方文档</a></p>
<ul>
<li><p><strong>基于Nacos的服务提供者(provider)</strong></p>
<ol>
<li><p>父pom引入spring-cloud-alibaba 依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring cloud alibaba 2.1.0.RELEASE--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当前模块pom引入 nacos-discovery 依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!--引入 nacos-discovery 依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>applicaiton.yml 文件配置：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9021</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-payment-provider</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>主启动加上@EnableDiscoveryClient</p>
</li>
<li><p>业务类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/payment&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/nacos/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPayment</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Alibaba Nacos registry,server &quot;</span>+ serverPort+<span class="string">&quot;----- id:&quot;</span>+id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动服务模块，查看服务是否注册到 Nacos</p>
<p>启动服务模块，进入 Nacos 控制台，在 <strong><code>服务管理 → 服务列表</code></strong> 中可以看到，我们定义的服务名 <code>nacos-payment-provider</code> 已经成功注册到 Nacos 注册中心。</p>
<p><img src="/2021/03/15/springcloud/93.png" alt="在这里插入图片描述"></p>
</li>
</ol>
</li>
<li><p>可以多来个服务端，与 9021 组成集群（9022、9023等等，做法与上一致）</p>
<p><strong>提示：</strong>9022 和 9023 除端口外，其他配置都相同。在<strong>测试环境</strong>（只能在测试环境里用，可能出现未知的bug）使用时，此处还有个取巧的方法，**<code>可以通过直接拷贝虚拟端口映射，来创建 9002 模块</code>**。我们使用 9021 来创建9022/9023，（实质端口为9021）如下图所示：</p>
<p><img src="/2021/03/15/springcloud/94.png" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>基于Nacos的服务消费者（consumer）</strong></p>
<ol>
<li><p>当前模块pom引入 nacos-discovery 依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringCloud ailibaba nacos --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Nacos 默认支持负载均衡</p>
<p>spring-cloud-starter-alibaba-nacos-discovery包里就整合有ribbon</p>
<p><img src="/2021/03/15/springcloud/95.png" alt="在这里插入图片描述"></p>
<p>也就是说：我们可以使用ribbon的负载均衡与RestTemplate</p>
</li>
<li><p>applicaiton.yml 文件配置：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">83</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-nacos-order</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#消费者将要去访问的微服务名称</span></span><br><span class="line"><span class="attr">server-url:</span></span><br><span class="line">  <span class="attr">nacos-user-service:</span> <span class="string">http://nacos-payment-provider</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>主启动加注解@EnableDiscoveryClient</p>
</li>
<li><p>业务类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/consumer/payment&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderNacosController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server-url.nacos-user-service&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverURL;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/nacos/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(serverURL+<span class="string">&quot;/payment/nacos/&quot;</span>+id,String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>RestTemplate配置类（注意加上@LoadBalanced实现负载均衡）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动服务消费者，查看服务是否注册到 Nacos</p>
</li>
<li><p>服务调用测试，是否实现负载均衡。通过服务端对客户端服务进行调用：<a target="_blank" rel="noopener" href="http://localhost:83/consumer/payment/nacos/31%E3%80%82%E9%87%87%E7%94%A8%E8%BD%AE%E8%AF%A2%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%BA%86%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E3%80%82">http://localhost:83/consumer/payment/nacos/31。采用轮询的方式，实现了负载均衡。</a></p>
</li>
</ol>
</li>
<li><p><strong>也可以用OpenFeign+Nacos实现服务消费者（consumer）</strong></p>
<ol>
<li><p>引入 spring-cloud-openfeign 依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入 spring-cloud-openfeign 依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>application.yml配置同上（改端口也行）</p>
</li>
<li><p>主启动类加上@EnableDiscoveryClient与@EnableFeignClients两个注解。</p>
</li>
<li><p>编写OpenFeign的服务接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;nacos-payment-provider&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderNacosService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/payment/nacos/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPayment</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>此处注意：</strong>注解@FeignClient里的服务名”nacos-payment-provider”必须和服务提供端的yml配置一致,大小写敏感(Eureka 大小写不敏感,Nacos 不同,大小写会导致调用失败)</p>
<p>具体可参考<a target="_blank" rel="noopener" href="https://github.com/alibaba/nacos/issues/2188">ISSUE</a></p>
</li>
<li><p>业务类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/consumer/payment&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderNacosController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> OrderNacosService service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/nacos/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> service.getPayment(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动测试</p>
</li>
</ol>
</li>
</ul>
<h4 id="19-6、Nacos用作服务配置中心"><a href="#19-6、Nacos用作服务配置中心" class="headerlink" title="19.6、Nacos用作服务配置中心"></a>19.6、Nacos用作服务配置中心</h4><h5 id="19-6-1、Nacos作为配置中心–基础配置"><a href="#19-6-1、Nacos作为配置中心–基础配置" class="headerlink" title="19.6.1、Nacos作为配置中心–基础配置"></a>19.6.1、Nacos作为配置中心–基础配置</h5><ol>
<li><p>当前模块 pom 引入 nacos-config 依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入nacos-config配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注册到 Nacos，需引入nacos-discovery配置--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入nacos-discovery配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>进行yml配置：</p>
<p>此处需要配置<code>bootstrap.yml</code>和<code>application.yml</code>两个文件<code>bootstrap.yml</code>用作系统级资源配置项，<code>application.yml</code>用作用户级的资源配置项。在项目中两者配合共同生效，<code>bootstrap.yml</code>优先级更高。<br>bootstrap.yml：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nacos配置</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3377</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos作为配置中心地址</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment">#指定yaml格式的配置</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># $&#123;spring.application.name&#125;-$&#123;spring.profile.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span></span><br><span class="line"><span class="comment"># nacos-config-client-dev.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># nacos-config-client-test.yaml   ----&gt; config.info</span></span><br></pre></td></tr></table></figure>

<p>application.yml：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment"># 表示开发环境</span></span><br><span class="line">    <span class="comment">#active: test # 表示测试环境</span></span><br><span class="line">    <span class="comment">#active: info</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>主启动类添加 @EnableDiscoveryClient 注解</p>
</li>
<li><p>业务类：(添加 @RefreshScope 实现配置自动更新)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span><span class="comment">//支持Nacos的动态刷新功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.info&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/config/info&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConfigInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Nacos中添加配置项：</p>
<p>进入 <strong><code>Nacos → 配置管理 → 配置列表 → + 号</code></strong> 添加配置项。Data ID 按规则编写，Group 在接下来的 <strong><code>分类配置</code></strong> 会有介绍。</p>
<p><img src="/2021/03/15/springcloud/99.png" alt="在这里插入图片描述"></p>
<p><img src="/2021/03/15/springcloud/100.png" alt="在这里插入图片描述"></p>
</li>
<li><p>启动测试，是否能够获取Nacos配置：</p>
<p>通过 <a target="_blank" rel="noopener" href="http://localhost:3377/config/info">http://localhost:3377/config/info</a> 测试，发现可以正确获取 Nacos 配置中心的配置信息</p>
<p><img src="/2021/03/15/springcloud/101.png" alt="在这里插入图片描述"></p>
</li>
<li><p>Nacos 自带动态刷新：</p>
<p>在使用 Spring Cloud Config 时，需要配合 Spring Cloud Bus + RabbitMQ 中间件，用<code>curl</code>进行广播方式才能 <strong><code>实现动态刷新</code>**。</strong><code>Nacos则自带动态刷新,修改下Nacos中的yaml配置文件，再次调用查看配置的接口，就会发现配置已经刷新。</code>**</p>
</li>
</ol>
<h5 id="19-6-2、dataId-命名规则"><a href="#19-6-2、dataId-命名规则" class="headerlink" title="19.6.2、dataId 命名规则"></a>19.6.2、dataId 命名规则</h5><p>在 Nacos Spring Cloud 中， <code>dataId</code> 有明确的配置规则，官方也有说明。进入链接查看：<a target="_blank" rel="noopener" href="https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html">官网链接</a>。</p>
<p><code>dataId</code> 的完整格式如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;prefix&#125;-$&#123;spring.profile.active&#125;.$&#123;file-extension&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>prefix 默认为 spring.application.name 的值，也可以通过配置项 spring.cloud.nacos.config.prefix来配置。</li>
<li>spring.profile.active 即为当前环境对应的 profile。注意：当 spring.profile.active 为空时，对应的连接符 - 也将不存在，dataId 的拼接格式变成 ${prefix}.${file-extension}（建议：不要让 spring.profile.active 为空，或许会有一些意外的问题,未知的bug）</li>
<li>file-exetension 为配置内容的数据格式，可以通过配置项 spring.cloud.nacos.config.file-extension 来配置。目前只支持 properties 和 yaml 类型。</li>
</ul>
<p><img src="/2021/03/15/springcloud/102.png" alt="img"></p>
<p><img src="/2021/03/15/springcloud/103.png" alt="img"></p>
<p><strong>此处注意：</strong>在Nacos网页中进行添加配置项时，在填写<code>Data ID</code>需要注意,若你采用的是yaml格式的话，如<code>nacos-config-dev.yaml</code>中的yaml不能省略成yml，即<code>nacos-config-dev.yml</code>。若省略，程序启动会报错（找不到配置项config.info）。这是Nacos的一个小坑（bug）。</p>
<h5 id="19-6-3、Nacos作为配置中心–分类配置"><a href="#19-6-3、Nacos作为配置中心–分类配置" class="headerlink" title="19.6.3、Nacos作为配置中心–分类配置"></a>19.6.3、Nacos作为配置中心–分类配置</h5><p>项目开发中，一定会遇到<code>多环境</code>、<code>多项目管理</code>问题。遇到下面问题时，Nacos 基础配置显然无法解决这些问题，接下来就对<code>Nacos 命名空间</code>及<code>Group</code>相关概念的了解。</p>
<ul>
<li>问题1： 实际开发中，通常一个系统会准备<code>dev开发环境</code>、<code>test测试环境</code>、<code>prod生产环境</code>，如何保证指定环境启动时服务能够正确读取到 Nacos 上相应环境的配置文件？</li>
<li>问题2： 一个大型的分布式微服务系统会有很多个微服务<code>子项目</code>，每个微服务项目又都会有相应的<code>dev开发环境</code>、<code>test测试环境</code>、<code>prod生产环境 </code>等，那怎么对这些微服务配置进行管理呢？</li>
</ul>
<p>这是就可以用到Nacos的分类功能了。</p>
<h6 id="19-6-3-1、Nacos的命名规则说明"><a href="#19-6-3-1、Nacos的命名规则说明" class="headerlink" title="19.6.3.1、Nacos的命名规则说明"></a>19.6.3.1、Nacos的命名规则说明</h6><p>Nacos 命名由<code>Namespace(命名空间) </code>+ <code>Group(分组)</code> + <code>Data ID(实例ID)</code> 三部分组成，类似于 Java 中的 package(报名) + class(类名) 方式。最外层 <strong>Namespace 用于区分部署环境</strong>；<strong>Group 和 Data ID 逻辑上用于区分两个目标对象</strong>。</p>
<p><img src="/2021/03/15/springcloud/104.png" alt="在这里插入图片描述"></p>
<p>默认情况下：</p>
<p><strong>Namespace = public，Group = DEFAULT_GROUP，Cluster=DEFAULT</strong></p>
<p><strong><code>Namespace</code>**主要用来实现</strong>隔离**，Nacos 默认的命名空间是<code>public</code>。比方说我们现在有三个环境：开发、测试、生产环境，我们就可以创建三个 Namespace，不同的 Namespace 之间是隔离的；</p>
<p><strong><code>Group</code>**是一组</strong>配置集<strong>，是组织配置的维度之一。默认是<code>DEFAULT_GROUP</code>。通过一个有意义的<code>名称</code>对配置集进行分组，从而区分 Data ID 相同的配置集。</strong>配置分组的常见场景：不同的应用或组件使用了相同的配置类型，就可以把不同的微服务划分到同一个分组里面去，从而解决问题2；如 database_url 配置和 MQ_topic 配置。**</p>
<p><strong><code>Service</code>**微服务；一个 Service 可以包含多个<code>Cluster(集群)</code>，Nacos 默认 Cluster 是<code>DEFAULT</code>，Cluster 是对指定微服务的一个</strong>虚拟划分<strong>。</strong>比方说为了容灾，将 Service 微服务分别部署在了杭州机房和广州机房，这是就可以给杭州机房的 Service 微服务起一个集群名称(HZ)，给广州机房的 Service 微服务起一个集群名称(GZ)，还可以尽量让同一个机房的微服务互相调用，以提升性能。**</p>
<p><strong><code>Instance</code>**，就是一个个</strong>微服务实例**。</p>
<p><img src="/2021/03/15/springcloud/105.png" alt="img"></p>
<p>保留空间public是不能被删除的。。</p>
<p><img src="/2021/03/15/springcloud/106.png" alt="img"></p>
<h6 id="19-6-3-2、新建Namespace"><a href="#19-6-3-2、新建Namespace" class="headerlink" title="19.6.3.2、新建Namespace"></a>19.6.3.2、新建Namespace</h6><p>选择 <strong><code>命名空间 → 新建命名空间</code>**，进行命名空间的设置。在 Nacos 1.1.4 版本，还<code>不支持自定义命名空间ID</code>，Nacos 1.2.0 版本后开始支持自定义命名空间ID 了。</strong>更推荐你使用自定义命名空间**。</p>
<p><img src="/2021/03/15/springcloud/107.png" alt="在这里插入图片描述"></p>
<p><img src="/2021/03/15/springcloud/108.png" alt="在这里插入图片描述"></p>
<h6 id="19-6-3-3、新建-Group"><a href="#19-6-3-3、新建-Group" class="headerlink" title="19.6.3.3、新建 Group"></a>19.6.3.3、新建 Group</h6><p>新建配置自定义Group名称。<strong>Group 就是根据需求的不同，将微服务划分到同一个分组里面去，来解决问题2</strong></p>
<p><img src="/2021/03/15/springcloud/109.png" alt="在这里插入图片描述"></p>
<h6 id="19-6-3-4、将-namespace-和-Group-应用到项目中"><a href="#19-6-3-4、将-namespace-和-Group-应用到项目中" class="headerlink" title="19.6.3.4、将 namespace 和 Group 应用到项目中"></a>19.6.3.4、将 namespace 和 Group 应用到项目中</h6><p>只需要在<code>bootstrap.yml</code>中添加 <code>namespace</code> 和 <code>group</code> 两个属性即可。**<code>namespace</code>** 属性：此处配置为 namespace **<code>命名空间 ID</code>**，自定义namespace时，推荐还是自定义名称，否则就是一串很长的字符串流水号，而且还语意不明。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3377</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos服务配置中心地址</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment">#指定yaml格式的配置</span></span><br><span class="line">        <span class="comment"># 指定 namespace 和 group </span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">dev-nsid</span> <span class="comment">#指定Namespace命名空间</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">Group_A</span> <span class="comment">#指定Group分组</span></span><br></pre></td></tr></table></figure>

<h6 id="19-6-3-5、指定-namespace-和-group-后，读取的便是对应配置内容"><a href="#19-6-3-5、指定-namespace-和-group-后，读取的便是对应配置内容" class="headerlink" title="19.6.3.5、指定 namespace 和 group 后，读取的便是对应配置内容"></a>19.6.3.5、指定 namespace 和 group 后，读取的便是对应配置内容</h6><p><img src="/2021/03/15/springcloud/110.png" alt="在这里插入图片描述"></p>
<h4 id="19-7、Nacos-集群搭建和持久化配置-Linux-Mysql"><a href="#19-7、Nacos-集群搭建和持久化配置-Linux-Mysql" class="headerlink" title="19.7、Nacos 集群搭建和持久化配置(Linux + Mysql)"></a>19.7、Nacos 集群搭建和持久化配置(Linux + Mysql)</h4><h5 id="19-7-1、Nacos集群官方架构图"><a href="#19-7-1、Nacos集群官方架构图" class="headerlink" title="19.7.1、Nacos集群官方架构图"></a>19.7.1、Nacos集群官方架构图</h5><p><img src="/2021/03/15/springcloud/111.png" alt="在这里插入图片描述"></p>
<p><strong>VIP</strong>：此处的 VIP 指代的是 <code>Virtual IP</code>（虚拟IP）的意思，通常情况下指代的是<code>Nginx</code>。</p>
<p>说明： 开源时，推荐用户把所有服务列表放到一个vip下面，然后挂到一个域名下面：</p>
<p><a href="http://ip1:port/openAPI">http://ip1:port/openAPI</a> 直连ip模式，机器挂则需要修改ip才可以使用。<br><a href="http://VIP:port/openAPI">http://VIP:port/openAPI</a> 挂载VIP模式，直连vip即可，下面挂server真实ip，可读性不好。<br><strong><a href="http://nacos.com:port/openAPI">http://nacos.com:port/openAPI</a> 域名 + VIP模式，可读性好，而且换ip方便，推荐模式。</strong></p>
<h5 id="19-7-2、Nacos集群真实架构图"><a href="#19-7-2、Nacos集群真实架构图" class="headerlink" title="19.7.2、Nacos集群真实架构图"></a>19.7.2、Nacos集群真实架构图</h5><p><img src="/2021/03/15/springcloud/112.png" alt="在这里插入图片描述"></p>
<h5 id="19-7-3、Nacos在linux下安装下载"><a href="#19-7-3、Nacos在linux下安装下载" class="headerlink" title="19.7.3、Nacos在linux下安装下载"></a>19.7.3、Nacos在linux下安装下载</h5><p>1、在<a target="_blank" rel="noopener" href="https://github.com/alibaba/nacos/releases">官网</a>下载xxx.tar.gz文件，并转移进Linux服务器。</p>
<p>2、<strong>nacos 安装目录：<code>/usr/local/nacos/</code></strong></p>
<p>3、使用tar -zxvf 命令解压</p>
<h5 id="19-7-4、Nacos数据库支持（derby-）"><a href="#19-7-4、Nacos数据库支持（derby-）" class="headerlink" title="19.7.4、Nacos数据库支持（derby ）"></a>19.7.4、Nacos数据库支持（derby ）</h5><p>手动将Nacos服务关闭再启动。存储在Nacos中的配置信息并不会丢失。这是因为 Nacos 默认内置<code>DerBy</code>数据库。 嵌入式数据库，nacos pom.xml 有引入<code>derby</code>依赖。以下摘自Nacos的<a target="_blank" rel="noopener" href="https://github.com/alibaba/nacos/blob/develop/config/pom.xml">github源码</a></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.derby<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>derby<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Nacos的derby数据库记录的数据放在nacos安装目录下的/conf/nacos-mysql.sql的sql文件里。</p>
<p>在<code>Nacos 0.7</code>版本之前，在单机模式时nacos使用嵌入式数据库(<code>derby</code>)实现数据的存储，不方便观察数据存储的基本情况。<strong>0.7 版本增加了支持 mysql 数据源能力</strong>。 具体的操作步骤：</p>
<ol>
<li>安装数据库，版本要求：5.6.5+</li>
<li>初始化mysql数据库，数据库初始化文件：<code>nacos-mysql.sql</code></li>
<li>修改<code>conf/application.properties</code>文件，增加支持mysql数据源配置（<strong>目前只支持mysql</strong>），添加mysql数据源的url、用户名和密码。</li>
<li>再启动nacos，nacos所有写嵌入式数据库的数据都写到了mysql。</li>
</ol>
<h5 id="19-7-5、Nacos-集群部署搭建"><a href="#19-7-5、Nacos-集群部署搭建" class="headerlink" title="19.7.5、Nacos 集群部署搭建"></a>19.7.5、Nacos 集群部署搭建</h5><p>Nacos支持三种部署模式</p>
<ul>
<li>单机模式 - 用于测试和单机试用。</li>
<li><strong><code>集群模式 - 用于生产环境，确保高可用。</code></strong></li>
<li>多集群模式 - 用于多数据中心场景。</li>
</ul>
<p>  此处附：<a target="_blank" rel="noopener" href="https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html">Nacos集群模式部署官方文档</a></p>
<p>若单机要集群Nacos的话要删除其中的<code>data</code>文件夹。<a target="_blank" rel="noopener" href="https://www.cnblogs.com/to-make-life-better/p/14534539.html">资料</a></p>
<h6 id="19-7-5-1、节点部署情况"><a href="#19-7-5-1、节点部署情况" class="headerlink" title="19.7.5.1、节点部署情况"></a>19.7.5.1、节点部署情况</h6><table>
<thead>
<tr>
<th align="center">服务器IP</th>
<th align="center">部署服务</th>
<th align="center">端口</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">192.168.204.202</td>
<td align="center">MySQL 5.7.28</td>
<td align="center">3306</td>
<td align="center">测试，使用单机 MySQL，高可用参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/lzb348110175/article/details/103081631">MySQL 5.7.28 主从复制实现</a></td>
</tr>
<tr>
<td align="center">192.168.204.202</td>
<td align="center">Nginx 1.4.1</td>
<td align="center">8807</td>
<td align="center">测试，使用单机 Nginx，Nginx集群搭建请自行了解(Nginx默认端口为80，此处负载均衡使用8087端口)</td>
</tr>
<tr>
<td align="center">192.168.204.202</td>
<td align="center">nacos</td>
<td align="center">8848</td>
<td align="center">集群节点01：nacos 01</td>
</tr>
<tr>
<td align="center">192.168.204.203</td>
<td align="center">nacos</td>
<td align="center">8848</td>
<td align="center">集群节点02：nacos 02</td>
</tr>
<tr>
<td align="center">192.168.204.204</td>
<td align="center">nacos</td>
<td align="center">8848</td>
<td align="center">集群节点03：nacos 03</td>
</tr>
</tbody></table>
<p>提示： 三台机器配置相同，此处对一台进行配置。使用命令 scp 发送到其他两台机器即可，此处以<code>192.168.204.202</code>为例说明。</p>
<h6 id="19-7-5-2、derby-切换-mysql-数据库配置"><a href="#19-7-5-2、derby-切换-mysql-数据库配置" class="headerlink" title="19.7.5.2、derby 切换 mysql 数据库配置"></a>19.7.5.2、derby 切换 mysql 数据库配置</h6><ol>
<li><p>执行nacos-mysql.sql脚本：</p>
<p>进入 nacos 安装目录 conf 文件下，找到 <code>nacos-mysql.sql 脚本</code>。</p>
<p>创建 nacos_config 数据库，并执行 nacos-mysql.sql 脚本。</p>
<p><img src="/2021/03/15/springcloud/113.png" alt="在这里插入图片描述"></p>
<p><img src="/2021/03/15/springcloud/114.png" alt="在这里插入图片描述"></p>
</li>
<li><p>修改application.properties，添加mysql支持：</p>
<p>进入nacos安装目录 conf 文件下，<code>application.properties</code> 配置文件添加 mysql 支持。</p>
<p>其中：</p>
<ul>
<li><p>在修改所有文件之前建议保存副本</p>
<p><img src="/2021/03/15/springcloud/115.png" alt="img"></p>
</li>
<li><p>db.user与db.password填写本机的用户名与密码</p>
</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.platform</span>=<span class="string">mysql</span></span><br><span class="line"></span><br><span class="line"><span class="meta">db.num</span>=<span class="string">1</span></span><br><span class="line"><span class="meta">db.url.0</span>=<span class="string">jdbc:mysql://192.168.204.202:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true</span></span><br><span class="line"><span class="meta">db.user</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">db.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/03/15/springcloud/116.png" alt="img"></p>
</li>
<li><p>cluster.conf 配置:</p>
<p>进入 conf 目录，使用命令：<code>cp cluster.conf.example cluster.conf</code>拷贝一份，重命名为<code>cluster.conf</code>，在 cluster.conf 中进行配置，说明哪几台机器组成集群（填写的是 nacos 集群3个节点所在 IP:端口号，不要写<code>127.0.0.1</code>，必须是Linux的<strong>真实IP</strong>）,可以通过命令<code>hostname -i</code>查看Linux的真实IP。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.204.202:8848</span><br><span class="line">192.168.204.203:8848</span><br><span class="line">192.168.204.204:8848</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 nacos 启动堆栈大小：</p>
<p>（nacos 启动时，默认 <code>-Xms2g -Xmx2g</code>。如果你是在多台虚拟机测试，配置紧张，这一步就比较重要了。如果服务器配置很优秀，这一步可以绕过。）</p>
<p><strong>配置紧张会导致以下情况的出现：</strong></p>
<ol>
<li><strong>nacos 服务启动很慢很慢的情况；</strong></li>
<li><strong>nacos 服务注册中心，有3个提供服务，你可能只能看到 2个、1个、0个服务节点，还会来回跳动的问题。</strong></li>
<li><strong>反正还是会出现一些意想不到的问题，视情况而配置。</strong></li>
</ol>
<blockquote>
<p><code>Xms 是指设定程序启动时占用内存大小。</code>一般来讲，大点，程序会启动的快一点，但是也可能会导致机器暂时间变慢。<br><code>Xmx 是指设定程序运行期间最大可占用的内存大小。</code>如果程序运行需要占用更多的内存，超出了这个设置值，就会抛出OutOfMemory异常。</p>
</blockquote>
<p>我们进入 bin 目录，使用 <code>vim startup.sh</code> 对其进行修改，将其按照配置修改到指定大小即可。（好像可以通过启动时添加 Xms 参数方式修改，我忘了怎么搞了，此处就直接修改 <code>.sh</code> 启动脚本了）（建议修改之前进行备份）</p>
<p><img src="/2021/03/15/springcloud/117.png" alt="在这里插入图片描述"></p>
</li>
<li><p>使用scp命令，进行nacos配置分发：</p>
<p>192.168.204.202 一台 nacos 集群环境配置完成，使用 scp 命令，将 nacos 目录分发到 203/204两台机器。scp 命令的使用如下：(scp命令使用介绍，请参考：Linux命令—scp)，不使用 scp 命令，你也可以 rz、sz 以打包的方式进行上传。</p>
<blockquote>
<p>scp -r /usr/local/env/nacos <a href="mailto:&#114;&#111;&#111;&#116;&#x40;&#x31;&#x39;&#50;&#x2e;&#49;&#54;&#x38;&#46;&#50;&#x30;&#x34;&#46;&#50;&#x30;&#x33;">&#114;&#111;&#111;&#116;&#x40;&#x31;&#x39;&#50;&#x2e;&#49;&#54;&#x38;&#46;&#50;&#x30;&#x34;&#46;&#50;&#x30;&#x33;</a>:/usr/local/nacos/<br>scp -r /usr/local/env/nacos <a href="mailto:&#x72;&#x6f;&#111;&#116;&#x40;&#49;&#x39;&#50;&#x2e;&#x31;&#54;&#56;&#46;&#x32;&#48;&#52;&#x2e;&#50;&#x30;&#52;">&#x72;&#x6f;&#111;&#116;&#x40;&#49;&#x39;&#50;&#x2e;&#x31;&#54;&#56;&#46;&#x32;&#48;&#52;&#x2e;&#50;&#x30;&#52;</a>:/usr/local/nacos/</p>
</blockquote>
</li>
<li><p>以上第5步也可以通过编辑Nacos的启动脚本<code>startup.sh</code>,使他能够接受不同的启动端口（建议备份）：</p>
<p><img src="/2021/03/15/springcloud/118.png" alt="img"></p>
<p><img src="/2021/03/15/springcloud/119.png" alt="img"></p>
<p><img src="/2021/03/15/springcloud/120.png" alt="img"></p>
<p><img src="/2021/03/15/springcloud/121.png" alt="img"></p>
<p>之后就可以通过<code>./startup.sh -p 端口号</code>执行：</p>
<p><img src="/2021/03/15/springcloud/122.png" alt="img"></p>
</li>
</ol>
<h6 id="19-7-5-2、Nginx的配置，由他作为负载均衡器"><a href="#19-7-5-2、Nginx的配置，由他作为负载均衡器" class="headerlink" title="19.7.5.2、Nginx的配置，由他作为负载均衡器"></a>19.7.5.2、Nginx的配置，由他作为负载均衡器</h6><p>在此处，已经默认 Nginx 服务已经OK，Nginx 服务跑在<code>192.168.204.202</code>。如需 Nginx 的搭建过程，请自行。</p>
<p>进入<code>nginx/conf</code> 目录，对 <code>nginx.conf</code>添加 nacos 集群配置，配置如下图所示：</p>
<p><img src="/2021/03/15/springcloud/123.png" alt="在这里插入图片描述"></p>
<p>配置完成，进入 sbin 目录，使用<code>./nginx -c /usr/local/nginx/nginx-1.16.0/conf/nginx.conf</code>启动 nginx，使用<code>-c</code>加载指定配置文件，路径为 nginx.conf 所在路径。启动完成，通过命令：<code>ps aux | grep nginx</code>查看 nginx 是否启动。如图已经启动成功。</p>
<p><img src="/2021/03/15/springcloud/124.png" alt="在这里插入图片描述"></p>
<h6 id="19-7-5-3、启动nacos集群"><a href="#19-7-5-3、启动nacos集群" class="headerlink" title="19.7.5.3、启动nacos集群"></a>19.7.5.3、启动nacos集群</h6><p>启动集群中的3台nacos。可以通过命令<code>ps -ef|grep nacos|grep -v grep grep |wc -l</code>查看nacos集群启用的端口数量，也可以通过nacos安装路径logs目录，使用 <code>tail -f nacos.log</code> 查看日志。</p>
<p><strong>启动成功提示：</strong></p>
<p><strong><code>如果虚拟机资源紧张，此处会一直很长时间在 nacos is starting... 状态,一定注意自己服务器的配置。</code></strong></p>
<p><img src="/2021/03/15/springcloud/126.png" alt="在这里插入图片描述"></p>
<h6 id="19-7-5-4、进入Nacos控制台"><a href="#19-7-5-4、进入Nacos控制台" class="headerlink" title="19.7.5.4、进入Nacos控制台"></a>19.7.5.4、进入Nacos控制台</h6><p>已经配置 Nginx 负载均衡，所以我们使用 Nginx 8087 端口进入Nacos 控制台：**<code>http://192.168.204.202:8087/nacos/</code>**</p>
<p><img src="/2021/03/15/springcloud/127.png" alt="在这里插入图片描述"></p>
<h6 id="19-7-5-5、查看集群节点启动情况"><a href="#19-7-5-5、查看集群节点启动情况" class="headerlink" title="19.7.5.5、查看集群节点启动情况"></a>19.7.5.5、查看集群节点启动情况</h6><p><img src="/2021/03/15/springcloud/128.png" alt="在这里插入图片描述"></p>
<h6 id="19-7-5-6、Nacos集群环境，项目application-yml中nacos地址需写-Nginx-地址"><a href="#19-7-5-6、Nacos集群环境，项目application-yml中nacos地址需写-Nginx-地址" class="headerlink" title="19.7.5.6、Nacos集群环境，项目application.yml中nacos地址需写 Nginx 地址"></a>19.7.5.6、Nacos集群环境，项目application.yml中nacos地址需写 Nginx 地址</h6><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-payment-provider</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.204</span><span class="number">.202</span><span class="string">:8087</span> <span class="comment">#配置Nacos地址(集群使用Nginx，此处需配置Nginx地址)</span></span><br></pre></td></tr></table></figure>

<p>通过访问8087端口（Ngnix）来实际访问三个nacos端口。</p>
<p><img src="/2021/03/15/springcloud/129.png" alt="在这里插入图片描述"></p>
<h3 id="20、Sentinel实现服务降级、服务熔断、服务限流"><a href="#20、Sentinel实现服务降级、服务熔断、服务限流" class="headerlink" title="20、Sentinel实现服务降级、服务熔断、服务限流"></a>20、Sentinel实现服务降级、服务熔断、服务限流</h3><p>资料查询：</p>
<p>  附官网：<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel">Sentinel GitHub 官网</a></p>
<p>  中文介绍文档：<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D">Sentinel Wiki中文介绍文档</a></p>
<p>  Sentinel 使用介绍：<a target="_blank" rel="noopener" href="https://spring-cloud-alibaba-group.github.io/github-pages/hoxton/en-us/index.html#_spring_cloud_alibaba_sentinel">Spring Cloud 关于 Sentinel 使用文档</a></p>
<h4 id="20-1、是什么"><a href="#20-1、是什么" class="headerlink" title="20.1、是什么"></a>20.1、是什么</h4><p>(本段内容摘自：Sentinel Wiki 中文文档，一句话解释Sentinel，就是之前介绍过的：Hystrix 实现服务降级、服务熔断、服务限流，Sentinel 后起之秀，更优秀)</p>
<p>随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 以流量为切入点，从<strong>流量控制</strong>、<strong>熔断降级</strong>、<strong>系统负载保护</strong>等多个维度保护服务的稳定性。</p>
<p><img src="/2021/03/15/springcloud/130.png" alt="img"></p>
<h4 id="20-2、Sentinel的特征"><a href="#20-2、Sentinel的特征" class="headerlink" title="20.2、Sentinel的特征"></a>20.2、Sentinel的特征</h4><ul>
<li><strong>丰富的应用场景</strong>：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</li>
<li><strong>完备的实时监控</strong>：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</li>
<li><strong>广泛的开源生态</strong>：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。</li>
<li><strong>完善的 SPI 扩展点</strong>：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</li>
</ul>
<h4 id="20-3、Sentinel的作用"><a href="#20-3、Sentinel的作用" class="headerlink" title="20.3、Sentinel的作用"></a>20.3、Sentinel的作用</h4><p><img src="/2021/03/15/springcloud/131.png" alt="在这里插入图片描述"></p>
<p><strong>Sentinel 的开源生态：</strong></p>
<p><img src="/2021/03/15/springcloud/132.png" alt="在这里插入图片描述"></p>
<p>Sentinel 分为两个部分:</p>
<ul>
<li>核心库（Java 客户端）：不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。</li>
<li>控制台（Dashboard）：基于 Spring Boot 开发，打包后使用 java -jar xxx.jar 方式可以直接运行，不需要额外的 Tomcat 等应用容器。</li>
</ul>
<h4 id="20-4、安装Sentinel控制台-Dashboard"><a href="#20-4、安装Sentinel控制台-Dashboard" class="headerlink" title="20.4、安装Sentinel控制台(Dashboard)"></a>20.4、安装Sentinel控制台(Dashboard)</h4><ol>
<li><p>Sentinel Dashboard 下载地址：<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/releases">Sentinel Dashboard 下载地址</a></p>
</li>
<li><p>环境：JDK 8，端口：<strong>8080 不被占用。</strong></p>
</li>
<li><p>在安装目录进入 cmd 控制台，使用 <strong><code>java -jar sentinel-dashboard-1.7.2.jar</code></strong> 方式直接运行。</p>
<p><img src="/2021/03/15/springcloud/133.png" alt="image-20210313024314111"></p>
</li>
<li><p>使用 <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080</a> 访问 Sentinel 图形管理界面。</p>
<p>登陆账号、密码均为：**<code>sentinel</code>**</p>
<p><img src="/2021/03/15/springcloud/134.png" alt="image-20210313024508488"></p>
</li>
<li><p>至此，Sentinel控制台(Dashboard)安装成功。</p>
</li>
</ol>
<h4 id="20-5、微服务项目整合Sentinel"><a href="#20-5、微服务项目整合Sentinel" class="headerlink" title="20.5、微服务项目整合Sentinel"></a>20.5、微服务项目整合Sentinel</h4><p>使用 <code>Sentinel</code> 最好配好 <code>Nacos</code> 一起使用。</p>
<p>启动Sentinel与Nacos的微服务，并通过<a href="http://localhost:8080与http://localhost:8848/nacos/#/login进行访问。">http://localhost:8080与http://localhost:8848/nacos/#/login进行访问。</a></p>
<p>新建微服务模块：</p>
<ol>
<li><p>添加pom依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入 sentinel 依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--nacos服务注册依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--sentinel持久化需要的依赖(后续持久化会用到,此处可有可无)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>application.yml 配置：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8401</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloudalibaba-sentinel-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">    <span class="comment"># 添加sentinel相关配置</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span> <span class="comment">#配置sentinel dashboard地址</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span> <span class="comment">#sentinel默认8719，假如被占用了会自动从8719开始依次+1扫描。直至找到未被占用的端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#暴露，用于监控等</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>主启动类添加 <strong>@EnableDiscoveryClient</strong> 注解</p>
</li>
<li><p>业务类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowLimitController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testA&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;-----testA&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testB&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;-----testB&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动项目，查看Sentinel是否成功监控：</p>
<p>此时进入 Sentinel 图形管理界面，并没有看到关于微服务任何信息。这是因为 <strong>Sentinel 采用的<code>懒加载机制</code>，只有执行一次方法调用，才能被Sentinel监控到</strong>。 然后多次调用 /testA 接口，在实时监控便能够看到接口 调用时间、QPS、响应时间 等内容。 说明：<strong>Sentinel 8080 已经在监控微服务 8401，监控会有一丁点的延迟。服务一段时间不调用，实时监控会消失。</strong></p>
</li>
</ol>
<h4 id="20-6、Spring-Cloud-Alibaba-Sentinel-流控、降级、热点、系统规则"><a href="#20-6、Spring-Cloud-Alibaba-Sentinel-流控、降级、热点、系统规则" class="headerlink" title="20.6、Spring Cloud Alibaba Sentinel 流控、降级、热点、系统规则"></a>20.6、Spring Cloud Alibaba Sentinel 流控、降级、热点、系统规则</h4><p><img src="/2021/03/15/springcloud/135.png" alt="image-20210313190605946"></p>
<h5 id="20-6-1、流控规则"><a href="#20-6-1、流控规则" class="headerlink" title="20.6.1、流控规则"></a>20.6.1、流控规则</h5><p>流控规则，即：流量控制规则。可自行参考官网介绍：<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">GitHub 流量控制</a>。具体配置有 <strong><code>资源名</code>**、</strong><code>针对来源</code><strong>、</strong><code>阈值类型</code><strong>、</strong><code>是否集群</code><strong>、</strong><code>流控模式</code><strong>、</strong><code>单机阈值</code><strong>、</strong><code>流控效果</code>** 这几项，它们配合进行使用。</p>
<p>可以通过<code>簇点链路</code>的方式添加，也可以通过<code>流控规则</code>方式添加。</p>
<p><img src="/2021/03/15/springcloud/136.png" alt="image-20210313190901838"></p>
<blockquote>
<p>**<code>资源名</code>**：唯一路径，默认为请求路径（也可以是后续介绍的 @SentinelResource 注解的 value 属性值）<br>**<code>针对来源</code>**：Sentinel 可以针对调用者进行限流，填写微服务名。默认为 default（不区分来源）<br>**<code>是否集群</code>**：本文为单机测试，是否集群不选</p>
</blockquote>
<h6 id="20-6-1-1、阈值类型：QPS"><a href="#20-6-1-1、阈值类型：QPS" class="headerlink" title="20.6.1.1、阈值类型：QPS"></a>20.6.1.1、阈值类型：QPS</h6><p><strong>QPS（每秒钟的请求数量）</strong>：当调用该 API 的 <strong><code>QPS</code></strong> 达到阈值的时候，进行限流。</p>
<p><strong>配置(默认流控模式为<code>直接</code>，流控效果为<code>快速失败</code>)：</strong></p>
<p><img src="/2021/03/15/springcloud/137.png" alt="在这里插入图片描述"></p>
<p><strong>效果</strong>：/testA 服务，每秒只允许调用 1 次，超出阈值后，直接失败（流控 Sentinel 默认提示：**<code>Blocked by Sentinel(flow limiting)</code>**）</p>
<h6 id="20-6-1-2、阈值类型：线程数"><a href="#20-6-1-2、阈值类型：线程数" class="headerlink" title="20.6.1.2、阈值类型：线程数"></a>20.6.1.2、阈值类型：线程数</h6><p><strong>线程数</strong>：当调用该 API 的 <strong><code>线程数</code></strong> 达到阈值的时候，进行限流。</p>
<p><strong>配置：</strong></p>
<p><img src="/2021/03/15/springcloud/138.png" alt="在这里插入图片描述"></p>
<p><strong>效果</strong>：</p>
<p>/testA 服务，单个线程只允许调用 1 次，超出阈值后，直接失败（流控 Sentinel 默认提示：**<code>Blocked by Sentinel(flow limiting)</code>**）</p>
<h6 id="20-6-1-3、流控模式：直接"><a href="#20-6-1-3、流控模式：直接" class="headerlink" title="20.6.1.3、流控模式：直接"></a>20.6.1.3、流控模式：直接</h6><p><strong>效果</strong>：超出阈值后，直接失败。</p>
<h6 id="20-6-1-4、流控模式：关联"><a href="#20-6-1-4、流控模式：关联" class="headerlink" title="20.6.1.4、流控模式：关联"></a>20.6.1.4、流控模式：关联</h6><p><strong>关联</strong>：当关联的资源达到阈值时，就限流自己。**<code>当与 A 资源关联的 B 资源达到阈值时，就限流自己(A)</code>**，即：B惹事，A挂了</p>
<p><strong>应用场景：</strong></p>
<p>双十一，<code>支付接口</code>和<code>下单接口</code>关联。当支付接口达到阈值，就限流下单接口。</p>
<p><strong>配置：</strong></p>
<p><img src="/2021/03/15/springcloud/139.png" alt="在这里插入图片描述"></p>
<p><strong>效果</strong>：</p>
<p><code>/testA</code> 服务关联<code>/testB</code> 服务，1s 调用 1次，服务正常。当狂点刷新调用 <code>/testB</code> 服务，超出阈值 QPS = 1 后，此时 /testA 被限流了，这就是 **<code>B惹事，A挂了</code>**。</p>
<h6 id="20-6-1-5、流控模式：链路"><a href="#20-6-1-5、流控模式：链路" class="headerlink" title="20.6.1.5、流控模式：链路"></a>20.6.1.5、流控模式：链路</h6><p>链路：当链路中的资源达到阈值时，就会对使用到该资源的链路进行流控。当A01 资源达到设定阈值时，所有调用该服务的链路，都会被限流，即：A01 挂了，用到我的链路都得挂。</p>
<p>此处会用到 @SentinelResource 注解 value 属性值 作为资源名。此处只是使用一下。</p>
<p>模拟两条请求链路：</p>
<p>A链路： A → A01 → A04 → A05<br>B链路： B → A01 → A02 → A03</p>
<p><img src="/2021/03/15/springcloud/140.png" alt="在这里插入图片描述"></p>
<p><strong>配置：</strong></p>
<p><img src="/2021/03/15/springcloud/141.png" alt="在这里插入图片描述"></p>
<p><strong>效果</strong>：</p>
<p>对 <strong><code>testA01</code></strong> 服务进行 <strong><code>链路</code></strong> 流控，该服务关联有 A 和 B 两条链路。当 A 链路1s 调用 1次，服务正常。当该链路调用 **<code>超出阈值 QPS = 1 后，此时A链路都会被限流，同时因为B链路也调用 testA01，所以B链路也会同时被限流调用</code>**。</p>
<h6 id="20-6-1-6、用postman进行循环访问"><a href="#20-6-1-6、用postman进行循环访问" class="headerlink" title="20.6.1.6、用postman进行循环访问"></a>20.6.1.6、用postman进行循环访问</h6><ol>
<li><p>postman里新建多线程集合组：</p>
<p><img src="/2021/03/15/springcloud/springcloud%5C142.png" alt="img"></p>
</li>
<li><p>访问地址添加进新线程组：</p>
<p><img src="/2021/03/15/springcloud/143.png" alt="img"></p>
</li>
<li><p>run：</p>
<p><img src="/2021/03/15/springcloud/144.png" alt="img"></p>
</li>
</ol>
<h6 id="20-6-1-7、流控效果：快速失败"><a href="#20-6-1-7、流控效果：快速失败" class="headerlink" title="20.6.1.7、流控效果：快速失败"></a>20.6.1.7、流控效果：快速失败</h6><p>效果：</p>
<p>直接失败。（流控 Sentinel 默认提示：**<code>Blocked by Sentinel(flow limiting)</code>**）</p>
<h6 id="20-6-1-8、流控效果：Warm-Up"><a href="#20-6-1-8、流控效果：Warm-Up" class="headerlink" title="20.6.1.8、流控效果：Warm Up"></a>20.6.1.8、流控效果：Warm Up</h6><p><strong>Warm Up</strong>：某个服务，日常访问量很少，基本为 0，突然1s访问量 10w，这种极端情况，会直接将服务击垮。所以通过配置 <strong><code>流控效果：Warm Up</code>**，允许系统慢慢呼呼的进行</strong>预热**，经<code>预热时长</code>逐渐升至设定的QPS阈值。以下图片来自<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">官网</a>。</p>
<p><img src="/2021/03/15/springcloud/145.png" alt="image">限限流 冷启动：（以下来自<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E9%99%90%E6%B5%81---%E5%86%B7%E5%90%AF%E5%8A%A8">官网</a>）</p>
<p>当流量突然增大的时候，我们常常会希望系统从空闲状态到繁忙状态的切换的时间长一些。即如果系统在此之前长期处于空闲的状态，我们希望处理请求的数量是缓步的增多，经过预期的时间以后，到达系统处理请求个数的最大值。Warm Up（冷启动，预热）模式就是为了实现这个目的的。</p>
<p>这个场景主要用于启动需要额外开销的场景，例如建立数据库连接等。</p>
<p>它的实现是在 <a target="_blank" rel="noopener" href="https://github.com/google/guava/blob/master/guava/src/com/google/common/util/concurrent/SmoothRateLimiter.java">Guava</a> 的算法的基础上实现的。然而，和 Guava 的场景不同，Guava 的场景主要用于调节请求的间隔，即 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Leaky_bucket">Leaky Bucket</a>，而 Sentinel 则主要用于控制每秒的 QPS，即我们满足每秒通过的 QPS 即可，我们不需要关注每个请求的间隔，换言之，我们更像一个 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Token_bucket">Token Bucket</a>。</p>
<p>默认 <code>coldFactor</code> 为 3，即请求 QPS 从 <code>threshold / 3</code> 开始，经预热时长逐渐升至设定的 QPS 阈值。</p>
<blockquote>
<p><strong>公式：</strong>阈值/coldFactor（默认值为3）</p>
</blockquote>
<p>源码：</p>
<p><img src="/2021/03/15/springcloud/147.png" alt="img"></p>
<p><strong>应用场景：</strong></p>
<p>秒杀系统。秒杀系统在开启的瞬间，会有很多的流量上来，很有可能将系统打死。预热方式就是为了保护系统，可以慢慢的将流量放进来，最终将阈值增长到指定的数值。</p>
<p><strong>配置：</strong></p>
<p><img src="/2021/03/15/springcloud/146.png" alt="在这里插入图片描述"></p>
<p>效果：</p>
<p><code>/testA</code> 服务，设置 QPS 单机阈值为 10，采用 Warm Up 预热的方式，预热时长为 5s。根据计算公式 **<code>10 / 3 = 3</code>**，前 5s 的阈值为 3，预热 5s 后阈值增长到 10。</p>
<p>即：前5s内，<strong>访问超过 3 次便会被限流；5s 后，阈值增长到 10，此时访问超过 3 次也不会被限流</strong>，<strong>这就是 Warm Up 预热效果。</strong></p>
<h6 id="20-6-1-9、流控效果：排队等待"><a href="#20-6-1-9、流控效果：排队等待" class="headerlink" title="20.6.1.9、流控效果：排队等待"></a>20.6.1.9、流控效果：排队等待</h6><p><strong>排队等待</strong>：让请求以均匀的速度通过，对应的是<code>漏桶算法</code>。这种方式主要用于处理间隔性突发的流量，例如消息队列。</p>
<p><strong>应用场景：</strong></p>
<p>在某一秒有大量的请求到来，而接下来的几秒则处于空闲状态。我们希望系统能够在接下来的空闲期间逐渐处理这些请求，而不是在第一秒直接拒绝多余的请求。**<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">官网</a>**</p>
<blockquote>
<p>注意：匀速排队模式暂时不支持 QPS &gt; 1000 的场景。</p>
</blockquote>
<p><img src="/2021/03/15/springcloud/210.png" alt="image"></p>
<p><strong>配置：</strong></p>
<p><img src="/2021/03/15/springcloud/148.png" alt="在这里插入图片描述"></p>
<p><strong>效果</strong>：</p>
<p><code>/testA</code> 服务，设置 QPS 单机阈值为 2，每秒只接收 2 个请求。设置超时时间 5s。采用漏斗算法，让后台匀速的处理请求，而不是直接拒绝更多的请求。超时的请求则被抛弃，返回错误信息。（流控 Sentinel 默认提示：**<code>Blocked by Sentinel(flow limiting)</code>**）</p>
<h5 id="20-6-2、降级规则"><a href="#20-6-2、降级规则" class="headerlink" title="20.6.2、降级规则"></a>20.6.2、降级规则</h5><p>降级规则。可自行参考官网介绍：<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7">GitHub 熔断降级</a>。降级策略有 <strong><code>慢调用比例</code>**、</strong><code>异常比例</code><strong>、</strong><code>异常数</code>** 三种。</p>
<p>熔断状态:</p>
<p>熔断有三种状态，分别为<code>OPEN</code>、<code>HALF_OPEN</code>、<code>CLOSED</code></p>
<p><img src="/2021/03/15/springcloud/150.png" alt="img"></p>
<p><img src="/2021/03/15/springcloud/149.png" alt="image-20210313202500145"></p>
<blockquote>
<p>**<code>资源名</code>**：唯一路径，默认为请求路径（也可以是后续介绍的 @SentinelResource 注解的 value 属性值）</p>
</blockquote>
<h6 id="20-6-2-1、慢调用比例"><a href="#20-6-2-1、慢调用比例" class="headerlink" title="20.6.2.1、慢调用比例"></a>20.6.2.1、慢调用比例</h6><p>慢调用比例 (<code>SLOW_REQUEST_RATIO</code>)：选择以<code>慢调用比例作为阈值</code>，需要设置允许的慢调用<code>RT（即最大的响应时间）</code>，请求的响应时间<code>大于</code>该值则统计为慢调用。当单位<code>统计时长</code>（<code>statIntervalMs</code>）内请求数目<code>大于</code>设置的<code>最小请求数目</code>，<strong>并且</strong>慢调用的比例<code>大于</code>阈值，则接下来的熔断时长内请求会<strong>自动被熔断</strong>。经过熔断时长后熔断器会进入<strong>探测恢复状态</strong>（<code>HALF-OPEN</code>状态），若接下来的一个请求响应时间小于设置的慢调用 RT 则结束熔断，若大于设置的慢调用 RT 则会再次被熔断。（以上来自<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7">官网</a>）</p>
<p><img src="/2021/03/15/springcloud/springcloud%5C151.png" alt="img"></p>
<p><strong>执行逻辑</strong>：</p>
<ul>
<li><p><strong>熔断（OPEN）：请求数大于最小请求数并且慢调用的比率大于比例阈值则发生熔断</strong>，熔断时长为用户自定义设置。</p>
</li>
<li><p><strong>探测（HALFOPEN）</strong>：当熔断过了定义的熔断时长，状态由熔断（OPEN）变为探测（HALFOPEN）。</p>
</li>
<li><p>如果接下来的一个请求小于最大RT，说明慢调用已经恢复，结束熔断，状态由探测（HALF_OPEN）变更为关闭（CLOSED）</p>
</li>
<li><p>如果接下来的一个请求大于最大RT，说明慢调用未恢复，继续熔断，熔断时长保持一致</p>
</li>
</ul>
<p>注意Sentinel默认统计的RT上限是<code>4900ms</code>，超出此阈值的都会算作4900ms，若需要变更此上限可以通过启动配置项<code>-Dcsp.sentinel.statistic.max.rt=xxx</code>来配置。</p>
<h6 id="20-6-2-2、异常比例"><a href="#20-6-2-2、异常比例" class="headerlink" title="20.6.2.2、异常比例"></a>20.6.2.2、异常比例</h6><p><strong>异常比例</strong>：<code>QPS &gt;= 5</code> &amp;&amp; <code>异常比例超过设定的阈值</code>，便会发生服务降级 。</p>
<p>异常比例为 0.0~1.0 范围内值。**<code>时间窗口就是断路器开启时间长短(降级时间)</code>** 。要看官网介绍来这里：<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7#%E9%99%8D%E7%BA%A7%E7%AD%96%E7%95%A5">异常比例介绍</a></p>
<p><strong>图示：</strong></p>
<p><img src="/2021/03/15/springcloud/152.png" alt="在这里插入图片描述"></p>
<p><strong>配置：</strong></p>
<p><img src="/2021/03/15/springcloud/153.png" alt="在这里插入图片描述"></p>
<p><strong>效果：</strong></p>
<p><code>/testA</code> 服务，设置 降级策略为 **<code>异常比例</code>**，异常比例设为 **<code>0.5</code>**，时间窗口为 **<code>5s</code>**。即：1s 发送6个请求，异常比例超过 50%，就会被熔断，断路器打开5s，5s后自动关闭，继续提供服务。</p>
<p>如果1s发送6次请求，前3次网页报错，因为第4次访问后，异常比例 &gt; 50%，第4次便会被熔断，报 **<code>Blocked by Sentinel(flow limiting)</code>**。5s后继续提供服务哦。</p>
<h6 id="20-6-2-3、异常数"><a href="#20-6-2-3、异常数" class="headerlink" title="20.6.2.3、异常数"></a>20.6.2.3、异常数</h6><p><strong>异常数</strong>：指的是资源 <strong><code>近1分钟</code></strong> 的异常数目，超过阈值之后会进行熔断。<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7#%E9%99%8D%E7%BA%A7%E7%AD%96%E7%95%A5">官网</a></p>
<p><strong>重点注意：</strong>异常数，统计时间窗口是分钟级别，若 timeWindow 小于 60s，则结束熔断状态后仍可能再次进入熔断状态。推荐 <strong><code>时间窗口一定要&gt;=60s</code></strong></p>
<p><strong>图示：</strong></p>
<p><img src="/2021/03/15/springcloud/154.png" alt="在这里插入图片描述"></p>
<p><strong>配置：</strong></p>
<p><img src="/2021/03/15/springcloud/155.png" alt="在这里插入图片描述"></p>
<p><strong>效果：</strong></p>
<p><code>/testA</code> 服务，设置 降级策略为 **<code>异常数</code>**，异常数设为 **<code>5</code>**，时间窗口为 **<code>60s</code>**。即：调用服务，当异常数超过5个时，开启断路器，执行熔断操作。60s 后，断路器关闭，服务恢复正常。</p>
<p>执行 /testA 服务请求，因为每个请求都是异常，前5次调用正常返回，只是报异常到前台(错误页面)；第6次服务调用时，便会被降级熔断。报 **<code>Blocked by Sentinel(flow limiting)</code>**。60s后继续提供服务哦。</p>
<h5 id="20-6-3、热点规则"><a href="#20-6-3、热点规则" class="headerlink" title="20.6.3、热点规则"></a>20.6.3、热点规则</h5><p>(本段内容摘自：<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81">Github 热点规则官方介绍</a>)</p>
<h6 id="20-6-3-1、何为热点？"><a href="#20-6-3-1、何为热点？" class="headerlink" title="20.6.3.1、何为热点？"></a>20.6.3.1、何为热点？</h6><p>热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行限制。比如：</p>
<blockquote>
<p>商品 ID 为参数，统计一段时间内最常购买的商品 ID 并进行限制<br>用户 ID 为参数，针对一段时间内频繁访问的用户 ID 进行限制</p>
</blockquote>
<p><code>热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流</code>。 <strong>热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效。</strong></p>
<p>Sentinel 利用<code>LRU 策略</code>统计最近最常访问的热点参数，结合<code>令牌桶算法</code>来进行参数级别的流控。热点参数限流支持集群模式。</p>
<p><img src="/2021/03/15/springcloud/156.png" alt="在这里插入图片描述"></p>
<h6 id="20-6-3-2、何为热点限流"><a href="#20-6-3-2、何为热点限流" class="headerlink" title="20.6.3.2、何为热点限流"></a>20.6.3.2、何为热点限流</h6><p>一句话解释：根据 url 传递进来的参数进行限流。<strong>带这个参数就限流，不带就不限流</strong>。</p>
<h6 id="20-6-3-3、热点规则"><a href="#20-6-3-3、热点规则" class="headerlink" title="20.6.3.3、热点规则"></a>20.6.3.3、热点规则</h6><p>共有 <strong><code>资源名</code>**、</strong><code>限流模式(只支持QPS模式)</code><strong>、</strong><code>参数索引</code><strong>、</strong><code>单机阈值</code><strong>、</strong><code>统计窗口时长</code><strong>、</strong><code>是否集群</code>** 六种参数；高级选项还有额外一些参数。</p>
<p><img src="/2021/03/15/springcloud/157.png" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong><code>资源名</code>**：唯一路径，默认为请求路径。</strong>此处必须是 @SentinelResource 注解的 value 属性值，配置@GetMapping 的请求路径无效）**<br><strong><code>参数索引</code>**：参数索引（从</strong><code>0</code>**开始，0表示第一个参数、1表示第二个参数）</p>
</blockquote>
<p><strong>配置：</strong></p>
<p><img src="/2021/03/15/springcloud/158.png" alt="在这里插入图片描述"></p>
<p><strong>效果：</strong></p>
<p>对 <code>/testC</code> 服务，配置热点key限流。当 1.第<code>二</code>个参数存在   2.一秒内调用 <code>/testC</code> 服务 &gt; 5次，满足限流规则。服务将被熔断。断路器打开，5s 后服务恢复正常。</p>
<p><strong>参数例外项配置：</strong></p>
<p><strong>需求</strong>(当请求参数name的值为Wade时，改变其限流阈值)：</p>
<p>当 name 参数值为 Wade 时，限流阈值变更为 100。此时就需要对 参数例外项 进行配置了。</p>
<p><code>参数类型</code>支持：int、double、String、long、float、char、byte 7种类型，参数值 指 name 参数的值，<code>限流阈值</code>指该参数值允许的阈值。</p>
<p><strong>配置：</strong></p>
<p><img src="/2021/03/15/springcloud/159.png" alt="在这里插入图片描述"></p>
<p><strong>测试：</strong></p>
<p>调用 URL：</p>
<p><code>http://localhost:8401/testC?id=1&amp;name=Wade</code>，阈值为200；</p>
<p><code>http://localhost:8401/testC?id=1&amp;name=Jhon</code>，阈值为200；</p>
<h5 id="20-6-4、系统规则（不常用）"><a href="#20-6-4、系统规则（不常用）" class="headerlink" title="20.6.4、系统规则（不常用）"></a>20.6.4、系统规则（不常用）</h5><h6 id="20-6-4-1、是什么"><a href="#20-6-4-1、是什么" class="headerlink" title="20.6.4.1、是什么"></a>20.6.4.1、是什么</h6><p>系统保护规则是从应用级别的入口流量进行控制，从单台机器的<code>load</code>、<code>CPU 使用率</code>、<code>平均 RT</code>、<code>入口 QPS</code>和<code>并发线程数</code>等几个维度监控应用指标，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。</p>
<p>系统保护规则是应用整体维度的，而不是资源维度的，并且仅对入口流量生效。入口流量指的是进入应用的流量（EntryType.IN），比如 Web 服务或 Dubbo 服务端接收的请求，都属于入口流量。</p>
<p>Sentinel 系统自适应限流从整体维度对应用入口流量进行控制，结合应用的 Load、CPU 使用率、总体平均 RT、入口 QPS 和并发线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达到一个平衡，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81">官网</a></p>
<h6 id="20-6-4-2、系统规则支持的模式"><a href="#20-6-4-2、系统规则支持的模式" class="headerlink" title="20.6.4.2、系统规则支持的模式"></a>20.6.4.2、系统规则支持的模式</h6><ul>
<li>Load 自适应（仅对 Linux/Unix-like 机器生效）：系统的 load1 作为启发指标，进行自适应系统保护。当系统 load1 超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的 maxQps * minRt 估算得出。设定参考值一般是 CPU cores * 2.5。</li>
<li>CPU usage（1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0），比较灵敏。</li>
<li>平均 RT：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。</li>
<li>并发线程数：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。</li>
<li>入口 QPS：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。</li>
</ul>
<h6 id="20-6-4-3、入口QPS配置"><a href="#20-6-4-3、入口QPS配置" class="headerlink" title="20.6.4.3、入口QPS配置"></a>20.6.4.3、入口QPS配置</h6><p>入口QPS，实用性还是比较危险的。 如果 sentinel 密码被修改，将你的整个系统 <strong><code>入口QPS</code></strong> 配置很小，那么整个系统就瘫痪了。</p>
<p>但是 入口QPS 有总控的功能。最终选择是否使用，还是视情况而定吧</p>
<p><strong>配置：</strong></p>
<p><img src="/2021/03/15/springcloud/160.png" alt="在这里插入图片描述"></p>
<p><strong>效果：</strong></p>
<p>整个系统，每个请求 QPS = 1 正常访问，当该请求 QPS &gt;1 就会被限流。</p>
<h5 id="20-6-5、-SentinelResource"><a href="#20-6-5、-SentinelResource" class="headerlink" title="20.6.5、@SentinelResource"></a>20.6.5、@SentinelResource</h5><p><code>@SentinelResource</code>可以说是 Sentinel 学习的突破口，搞懂了这个注解的应用，基本上就搞清楚了 Sentinel 的大部分应用场景。Sentinel 提供了 <strong>@SentinelResource 注解用于定义资源，并提供了AspectJ的扩展用于自动定义资源、处理BlockException等。</strong></p>
<h6 id="20-6-5-1、-SentinelResource-属性介绍"><a href="#20-6-5-1、-SentinelResource-属性介绍" class="headerlink" title="20.6.5.1、@SentinelResource 属性介绍"></a>20.6.5.1、@SentinelResource 属性介绍</h6><table>
<thead>
<tr>
<th align="center">属性名</th>
<th align="center">是否必填</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>value</strong></td>
<td align="center">是</td>
<td align="left">资源名称（必填项，需要通过 <code>value</code> 值找到对应的规则进行配置）</td>
</tr>
<tr>
<td align="center">entryType</td>
<td align="center">否</td>
<td align="left">entry类型，标记流量的方向，取值IN/OUT，默认是OUT</td>
</tr>
<tr>
<td align="center"><strong>blockHandler</strong></td>
<td align="center">否</td>
<td align="left">**处理<code>BlockException</code>的函数名称(可以理解为对Sentinel的配置进行方法兜底)**。函数要求：<br>1.必须是<code>public</code>修饰<br>2.<code>返回类型</code>与<code>原方法</code>一致<br>3. <code>参数类型</code>需要和<code>原方法</code>相匹配，并在最后加 <code>BlockException</code>类型的参数。<br>4. 默认需和原方法在同一个类中(耦合度高)。若希望使用其他类的函数，可配置<code>blockHandlerClass</code>，并<code>指定</code>blockHandlerClass里面的方法。<br></td>
</tr>
<tr>
<td align="center"><strong>blockHandlerClass</strong></td>
<td align="center">否</td>
<td align="left"><strong>存放blockHandler的类</strong>。<br>对应的处理函数必须<code>public static</code>修饰，否则无法解析，其他要求：同blockHandler。</td>
</tr>
<tr>
<td align="center"><strong>fallback</strong></td>
<td align="center">否</td>
<td align="left">**用于在抛出异常的时候提供fallback处理逻辑(可以理解为对<code>java异常</code>情况方法兜底)**。<br>fallback函数可以针对所有类型的异常（除了 <code>exceptionsToIgnore</code>里面排除掉的异常类型）进行处理。函数要求：<br>1.<code>返回类型</code>与<code>原方法</code>一致<br>2.<code>参数类型</code>需要和<code>原方法</code>相匹配，Sentinel 1.6开始，也可在方法最后加<code>Throwable</code>类型的参数。<br>3.默认需和原方法在同一个类中(耦合度高)。若希望使用其他类的函数，可配置<code>fallbackClass</code> ，并<code>指定</code>fallbackClass里面的方法。<br></td>
</tr>
<tr>
<td align="center"><strong>fallbackClass</strong></td>
<td align="center">否</td>
<td align="left"><strong>存放fallback的类</strong>。<br>对应的处理函数必须<code>static</code>修饰，否则无法解析，其他要求：同fallback。</td>
</tr>
<tr>
<td align="center"><strong>defaultFallback</strong></td>
<td align="center">否</td>
<td align="left"><strong>用于通用的 fallback 逻辑</strong>。<br>默认 fallback 函数可以针对所有类型的异常（除了<code>exceptionsToIgnore</code>里面排除掉的异常类型）进行处理。<strong>若同时配置了 fallback 和 defaultFallback，以fallback为准</strong>。函数要求：<br>1.<code>返回类型</code>与<code>原方法</code>一致<br>2.方法参数列表为<code>空</code>，或者有一个<code>Throwable </code>类型的参数。<br>3.默认需要和原方法在同一个类中(耦合度高)。若希望使用其他类的函数，可配置<code>fallbackClass</code> ，并<code>指定</code>fallbackClass 里面的方法。<br></td>
</tr>
<tr>
<td align="center"><strong>exceptionsToIgnore</strong></td>
<td align="center">否</td>
<td align="left"><strong>指定排除掉哪些异常。</strong><br>排除的异常不会计入异常统计，也不会进入fallback逻辑，而是原样抛出。</td>
</tr>
<tr>
<td align="center">exceptionsToTrace</td>
<td align="center">否</td>
<td align="left">需要trace的异常</td>
</tr>
</tbody></table>
<p>（加深标注属性为常用属性）</p>
<p><img src="/2021/03/15/springcloud/164.png" alt="img"></p>
<h6 id="20-6-5-2、fallback-指定java异常兜底方法"><a href="#20-6-5-2、fallback-指定java异常兜底方法" class="headerlink" title="20.6.5.2、fallback 指定java异常兜底方法"></a>20.6.5.2、fallback 指定java异常兜底方法</h6><p>**<code>fallback只用来处理与Java逻辑异常相关的兜底</code>**。比如：NullPointerException、ArrayIndexOutOfBoundsException 等java代码中的异常，fallback 指定的兜底方法便会生效。</p>
<p><strong>兜底方法与业务方法耦合</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/testA&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;testA&quot;, fallback = &quot;fallbackMethod&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;-----testA&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">fallbackMethod</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;限流请求连接(Java类异常)的兜底方法：&quot;</span> + e.getMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用 fallbackClass 将兜底方法与业务解耦合</strong>：</p>
<p><img src="/2021/03/15/springcloud/161.png" alt="在这里插入图片描述"></p>
<h6 id="20-6-5-3、blockHandler-指定-Sentinel-配置兜底方法"><a href="#20-6-5-3、blockHandler-指定-Sentinel-配置兜底方法" class="headerlink" title="20.6.5.3、blockHandler 指定 Sentinel 配置兜底方法"></a>20.6.5.3、blockHandler 指定 Sentinel 配置兜底方法</h6><p>**<code>blockHandler 只用来处理 与 Sentinel 配置有关的兜底</code>**。比如：配置某资源 QPS =1，当 QPS &gt;1 时，blockHandler 指定的兜底方法便会生效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务逻辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/testB&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;testB&quot;,blockHandler = &quot;exceptionMethod&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;-----testB&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">exceptionMethod</span><span class="params">(BlockException exception)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;限流@SentinelResource value 属性的兜底方法:&quot;</span> + exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用 fallbackClass 将兜底方法与业务解耦合</strong></p>
<p><img src="/2021/03/15/springcloud/162.png" alt="在这里插入图片描述"></p>
<h6 id="20-6-5-4、exceptionsToIgnore-用于指定异常不走兜底方法"><a href="#20-6-5-4、exceptionsToIgnore-用于指定异常不走兜底方法" class="headerlink" title="20.6.5.4、exceptionsToIgnore 用于指定异常不走兜底方法"></a>20.6.5.4、exceptionsToIgnore 用于指定异常不走兜底方法</h6><p>使用<code>exceptionsTolgnore</code>属性，来<code>指定某些异常不执行兜底方法，直接显示错误信息</code>。配置 ArithmeticException 异常不走兜底方法。java.lang.ArithmeticException: / by zero ，便不会再执行兜底方法，直接显示错误信息给前台页面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/testA&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;testA&quot;, </span></span><br><span class="line"><span class="meta">					fallback = &quot;fallbackMethod&quot;,</span></span><br><span class="line"><span class="meta">					fallbackClass = CustomerFallback.class, </span></span><br><span class="line"><span class="meta">					exceptionsToIgnore = ArithmeticException.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;-----testA&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="20-6-5-5、defaultFallback-用于指定通用的-fallback-兜底方法"><a href="#20-6-5-5、defaultFallback-用于指定通用的-fallback-兜底方法" class="headerlink" title="20.6.5.5、defaultFallback 用于指定通用的 fallback 兜底方法"></a>20.6.5.5、defaultFallback 用于指定通用的 fallback 兜底方法</h6><p>使用 defaultFallback 来指定通用的 fallback 兜底方法。</p>
<ul>
<li>如果当前业务配置有 defaultFallback 和 fallback 两个属性，则优先执行 fallback 指定的方法。</li>
<li>如果 fallback 指定的方法不存在，还会执行 defaultFallback 指定的方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务逻辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/testA&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;testA&quot;,</span></span><br><span class="line"><span class="meta">        fallback = &quot;fallbackMethod&quot;,</span></span><br><span class="line"><span class="meta">        fallbackClass = CustomerFallback.class,</span></span><br><span class="line"><span class="meta">        defaultFallback = &quot;defaultFallbackMethod&quot; //直接指定即可，使用比较简单</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;-----testA&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单独一个类，存放兜底方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerFallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">defaultFallbackMethod</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;通用的fallback兜底方法&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">fallbackMethod</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;限流请求连接(Java类异常)的兜底方法：&quot;</span> + e.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面兜底方案面临的问题：</p>
<ol>
<li>系统默认的，没有体现我们自己的业务要求。</li>
<li>依照现有条件，我们自定义的处理方法又和业务代码耦合在一块，不直观。</li>
<li>每个业务方法都添加一个兜底的，那代码膨胀加剧。</li>
<li>全局统一的处理方法没有体现。</li>
</ol>
<p>客户自定义限流处理逻辑：</p>
<ol>
<li><p>创建CustomerBlockHandler类用于自定义限流处理逻辑：</p>
</li>
<li><p>自定义限流处理类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerBlockHandler</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CommonResult <span class="title">handlerException</span><span class="params">(BlockException exception)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">4444</span>,<span class="string">&quot;按客戶自定义,global handlerException----1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CommonResult <span class="title">handlerException2</span><span class="params">(BlockException exception)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">4444</span>,<span class="string">&quot;按客戶自定义,global handlerException----2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>RateLimitController：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimitController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/byResource&quot;)</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;byResource&quot;,blockHandler = &quot;handleException&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">byResource</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">200</span>,<span class="string">&quot;按资源名称限流测试OK&quot;</span>,<span class="keyword">new</span> Payment(<span class="number">2020L</span>,<span class="string">&quot;serial001&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">handleException</span><span class="params">(BlockException exception)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">444</span>,exception.getClass().getCanonicalName()+<span class="string">&quot;\t 服务不可用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/rateLimit/byUrl&quot;)</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;byUrl&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">byUrl</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">200</span>,<span class="string">&quot;按url限流测试OK&quot;</span>,<span class="keyword">new</span> Payment(<span class="number">2020L</span>,<span class="string">&quot;serial002&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/rateLimit/customerBlockHandler&quot;)</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;customerBlockHandler&quot;,</span></span><br><span class="line"><span class="meta">            blockHandlerClass = CustomerBlockHandler.class,</span></span><br><span class="line"><span class="meta">            blockHandler = &quot;handlerException2&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">customerBlockHandler</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">200</span>,<span class="string">&quot;按客戶自定义&quot;</span>,<span class="keyword">new</span> Payment(<span class="number">2020L</span>,<span class="string">&quot;serial003&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/03/15/springcloud/163.png" alt="img"></p>
</li>
</ol>
<p>Sentinel的三个核心API：</p>
<p><img src="/2021/03/15/springcloud/文件/java/我/java后台学习笔记/springcloud/springcloud/165.png" alt="image-20210314010417987"></p>
<p>注意异常降级<strong>仅针对业务异常</strong>，对 Sentinel 限流降级本身的异常（<code>BlockException</code>）不生效。为了统计异常比例或异常数，需要通过 <code>Tracer.trace(ex)</code> 记录业务异常。示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Entry entry = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  entry = SphU.entry(key, EntryType.IN, key);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write your biz code here.</span></span><br><span class="line">  <span class="comment">// &lt;&lt;BIZ CODE&gt;&gt;</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!BlockException.isBlockException(t)) &#123;</span><br><span class="line">    Tracer.trace(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">    entry.exit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="20-7、服务熔断"><a href="#20-7、服务熔断" class="headerlink" title="20.7、服务熔断"></a>20.7、服务熔断</h4><p>sentinel整合ribbon+openFeign+fallback</p>
<p>公共：</p>
<ol>
<li><p>启动nacos和启动sentinel服务</p>
</li>
<li><p>新建两个服务提供端（实现负载均衡）（详情看上面微服务项目整合Sentinel）</p>
</li>
<li><p>服务提供端的业务类PaymentController：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Long,Payment&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 模拟数据库</span></span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        hashMap.put(<span class="number">1L</span>,<span class="keyword">new</span> Payment(<span class="number">1L</span>,<span class="string">&quot;28a8c1e3bc2742d8848569891fb42181&quot;</span>));</span><br><span class="line">        hashMap.put(<span class="number">2L</span>,<span class="keyword">new</span> Payment(<span class="number">2L</span>,<span class="string">&quot;bba8c1e3bc2742d8848569891ac32182&quot;</span>));</span><br><span class="line">        hashMap.put(<span class="number">3L</span>,<span class="keyword">new</span> Payment(<span class="number">3L</span>,<span class="string">&quot;6ua8c1e3bc2742d8848569891xt92183&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入1、2、3得到数据，输入4报空指针异常</span></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/paymentSQL/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">paymentSQL</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Payment payment = hashMap.get(id);</span><br><span class="line">        CommonResult&lt;Payment&gt; result = <span class="keyword">new</span> CommonResult(<span class="number">200</span>,<span class="string">&quot;from mysql,serverPort:  &quot;</span>+serverPort,payment);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建服务消费端</p>
</li>
<li><p>业务类CircleBreakerController</p>
</li>
</ol>
<h5 id="20-7-1、Ribbon系列"><a href="#20-7-1、Ribbon系列" class="headerlink" title="20.7.1、Ribbon系列"></a>20.7.1、Ribbon系列</h5><ol>
<li><p>添加sentinel依赖pom：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringCloud ailibaba nacos --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--SpringCloud ailibaba sentinel --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>application.yml配置文件：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">84</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-order-consumer</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="comment">#配置Sentinel dashboard地址</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span></span><br><span class="line">        <span class="comment">#默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者)</span></span><br><span class="line"><span class="attr">service-url:</span></span><br><span class="line">  <span class="attr">nacos-user-service:</span> <span class="string">http://nacos-payment-provider</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>主启动添加@EnableDiscoveryClient</p>
</li>
<li><p>添加RestTemplate配置类ApplicationContextConfig(<strong>添加@LoadBalanced</strong>)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextConfig</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="20-7-2、OpenFeign系列（Feign组件一般是在消费者侧）"><a href="#20-7-2、OpenFeign系列（Feign组件一般是在消费者侧）" class="headerlink" title="20.7.2、OpenFeign系列（Feign组件一般是在消费者侧）"></a>20.7.2、OpenFeign系列（Feign组件一般是在消费者侧）</h5><ol>
<li><p>添加OpenFeign依赖pom：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringCloud openfeign --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>application.yml配置文件（激活Sentinel对Feign的支持）：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">84</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-order-consumer</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="comment">#配置Sentinel dashboard地址</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span></span><br><span class="line">        <span class="comment">#默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者)</span></span><br><span class="line"><span class="attr">service-url:</span></span><br><span class="line">  <span class="attr">nacos-user-service:</span> <span class="string">http://nacos-payment-provider</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活Sentinel对Feign的支持</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>主启动类添加注解：@EnableFeignClients</p>
</li>
<li><p>service接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;nacos-payment-provider&quot;,fallback = PaymentFallbackService.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/paymentSQL/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">paymentSQL</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全局fallback实现service接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentFallbackService</span> <span class="keyword">implements</span> <span class="title">PaymentService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">paymentSQL</span><span class="params">(Long id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult&lt;&gt;(<span class="number">44444</span>,<span class="string">&quot;服务降级返回,---PaymentFallbackService&quot;</span>,<span class="keyword">new</span> Payment(id,<span class="string">&quot;errorSerial&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>业务类CircleBreakerController：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleBreakerController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVICE_URL = <span class="string">&quot;http://nacos-payment-provider&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/consumer/fallback/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="comment">//@SentinelResource(value = &quot;fallback&quot;) //没有配置</span></span><br><span class="line">    <span class="comment">//@SentinelResource(value = &quot;fallback&quot;,fallback = &quot;handlerFallback&quot;) //fallback只负责业务异常</span></span><br><span class="line">    <span class="comment">//@SentinelResource(value = &quot;fallback&quot;,blockHandler = &quot;blockHandler&quot;) //blockHandler只负责sentinel控制台配置违规</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;fallback&quot;,fallback = &quot;handlerFallback&quot;,blockHandler = &quot;blockHandler&quot;,</span></span><br><span class="line"><span class="meta">            exceptionsToIgnore = &#123;IllegalArgumentException.class&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">fallback</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        CommonResult&lt;Payment&gt; result = restTemplate.getForObject(SERVICE_URL + <span class="string">&quot;/paymentSQL/&quot;</span>+id,CommonResult.class,id);</span><br><span class="line">空指针异常</span><br><span class="line">        <span class="comment">// 输入4报非法参数异常，输入其他报空指针异常</span></span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException (<span class="string">&quot;IllegalArgumentException,非法参数异常，输入其他报....&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (result.getData() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException (<span class="string">&quot;NullPointerException,该ID没有对应记录,空指针异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//本例是fallback</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">handlerFallback</span><span class="params">(<span class="meta">@PathVariable</span>  Long id,Throwable e)</span> </span>&#123;</span><br><span class="line">        Payment payment = <span class="keyword">new</span> Payment(id,<span class="string">&quot;null&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult&lt;&gt;(<span class="number">444</span>,<span class="string">&quot;兜底异常handlerFallback,exception内容  &quot;</span>+e.getMessage(),payment);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//本例是blockHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">blockHandler</span><span class="params">(<span class="meta">@PathVariable</span>  Long id,BlockException blockException)</span> </span>&#123;</span><br><span class="line">        Payment payment = <span class="keyword">new</span> Payment(id,<span class="string">&quot;null&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult&lt;&gt;(<span class="number">445</span>,<span class="string">&quot;blockHandler-sentinel限流,无此流水: blockException  &quot;</span>+blockException.getMessage(),payment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//==================OpenFeign</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/consumer/paymentSQL/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">paymentSQL</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> paymentService.paymentSQL(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>没有配置：@SentinelResource(value = “fallback”) （不友好）</p>
<ul>
<li><p>测试：<a target="_blank" rel="noopener" href="http://lcaolhost:84/consumer/fallback/2">http://lcaolhost:84/consumer/fallback/2</a></p>
<p><img src="/2021/03/15/springcloud/167.png" alt="image-20210314020226329"></p>
</li>
<li><p>测试：<a target="_blank" rel="noopener" href="http://lcaolhost:84/consumer/fallback/4">http://lcaolhost:84/consumer/fallback/4</a></p>
<p><img src="/2021/03/15/springcloud/168.png" alt="image-20210314020528745"></p>
</li>
<li><p>测试：<a target="_blank" rel="noopener" href="http://lcaolhost:84/consumer/fallback/5">http://lcaolhost:84/consumer/fallback/5</a></p>
<p><img src="/2021/03/15/springcloud/169.png" alt="image-20210314020917296"></p>
</li>
</ul>
</li>
<li><p>只配置fallback（只负责运行异常）：@SentinelResource(value = “fallback”,fallback = “handlerFallback”)</p>
<ul>
<li><p>测试：<a target="_blank" rel="noopener" href="http://lcaolhost:84/consumer/fallback/4">http://lcaolhost:84/consumer/fallback/4</a></p>
<p><img src="/2021/03/15/springcloud/170.png" alt="image-20210314021545779"></p>
</li>
<li><p>测试：<a target="_blank" rel="noopener" href="http://lcaolhost:84/consumer/fallback/5">http://lcaolhost:84/consumer/fallback/5</a></p>
<p><img src="/2021/03/15/springcloud/171.png" alt="image-20210314021737234"></p>
</li>
</ul>
</li>
<li><p>只配置blockHandler（只负责sentinel控制台配置违规）：@SentinelResource(value = “fallback”,blockHandler = “blockHandler”)</p>
<p>配置sentinel控制台：</p>
<p><img src="/2021/03/15/springcloud/172.png" alt="image-20210314022142172"></p>
<ul>
<li><p>测试：<a target="_blank" rel="noopener" href="http://lcaolhost:84/consumer/fallback/4%E7%82%B9%E5%87%BB%E4%B8%80%E6%AC%A1">http://lcaolhost:84/consumer/fallback/4点击一次</a></p>
<p><img src="/2021/03/15/springcloud/168.png" alt="image-20210314020528745"></p>
<p>连续点击：</p>
<p><img src="/2021/03/15/springcloud/173.png" alt="image-20210314022337780"></p>
</li>
</ul>
</li>
<li><p>fallback和blockHandler都配置：</p>
<p>若blockHandler和fallback都进行了配置，则被限流降级而抛出BlockException时<strong>只会进入blockHandler处理逻辑</strong>。</p>
</li>
</ul>
<h5 id="20-7-3、熔断框架比较"><a href="#20-7-3、熔断框架比较" class="headerlink" title="20.7.3、熔断框架比较"></a>20.7.3、熔断框架比较</h5><p><img src="/2021/03/15/springcloud/174.png" alt="img"></p>
<p><img src="/2021/03/15/springcloud/175.png" alt="img"></p>
<h4 id="20-8、Sentinel-控制台规则持久化（持久化到Nacos比较鸡肋）"><a href="#20-8、Sentinel-控制台规则持久化（持久化到Nacos比较鸡肋）" class="headerlink" title="20.8、Sentinel 控制台规则持久化（持久化到Nacos比较鸡肋）"></a>20.8、Sentinel 控制台规则持久化（持久化到Nacos比较鸡肋）</h4><p>Sentinel 控制台规则持久化问题：</p>
<p>在 Sentinel 中，我们会为多个服务进行 流控、限流、热点 等规则 的配置，但是当服务重启后再进入 Sentinel 后，发现之前配置过的规则都不在了，这样子的体验显然不友好，此时就需要我们对 Sentinel 中配置的规则规则进行持久化操作。</p>
<p>目前控制台的规则推送也是通过<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8#%E6%9F%A5%E8%AF%A2%E6%9B%B4%E6%94%B9%E8%A7%84%E5%88%99">规则查询更改 HTTP API</a>来更改规则。这也意味着这些规则 仅在内存态生效，应用重启之后，该规则会丢失。</p>
<p>以上是原始模式。当了解了原始模式之后，我们非常鼓励您通过<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%99%E6%89%A9%E5%B1%95">动态规则</a> 并结合各种外部存储来定制自己的规则源。我们推荐通过动态配置源的控制台来进行规则写入和推送，而不是通过 Sentinel 客户端直接写入到动态配置源中。在生产环境中，我们推荐 push 模式，具体可以参考：<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8-Sentinel">在生产环境使用 Sentinel</a>。也可以参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42437633/article/details/106443342">博客</a></p>
<p>规则管理及推送：</p>
<p><img src="/2021/03/15/springcloud/166.png" alt="在这里插入图片描述"></p>
<h5 id="20-8-1、持久化配置（鸡肋）"><a href="#20-8-1、持久化配置（鸡肋）" class="headerlink" title="20.8.1、持久化配置（鸡肋）"></a>20.8.1、持久化配置（鸡肋）</h5><p><strong>将限流配置规则持久化进Nacos保存</strong>，只要刷新8401某个rest地址，sentinel控制台的流控规则就能看到，只要Nacos里面的配置不删除，针对8401上sentinel上的流控规则持续有效。</p>
<p>步骤：</p>
<ol>
<li><p>添加依赖pom：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringCloud ailibaba sentinel-datasource-nacos 后续做持久化用到--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改添加application.yml（主要是datasource）：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8401</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloudalibaba-sentinel-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span> <span class="comment">#配置Sentinel dashboard地址</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span></span><br><span class="line">      <span class="comment">#添加nacos数据源配置</span></span><br><span class="line">      <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">ds1:</span></span><br><span class="line">          <span class="attr">nacos:</span></span><br><span class="line">            <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">            <span class="attr">dataId:</span> <span class="string">cloudalibaba-sentinel-service</span></span><br><span class="line">            <span class="attr">groupId:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line">            <span class="attr">data-type:</span> <span class="string">json</span></span><br><span class="line">            <span class="attr">rule-type:</span> <span class="string">flow</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 激活Sentinel对Feign的支持</span></span><br></pre></td></tr></table></figure>

<p>其中dataId的值为${spring.application.name}。</p>
</li>
<li><p>添加nacos业务配置规则</p>
<p><img src="/2021/03/15/springcloud/176.png" alt="img"></p>
<p>其中Data ID的值为${spring.application.name}的值。</p>
</li>
<li><p>在配置中的选择json，并添加内容：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;resource&quot;</span>:<span class="string">&quot;/rateLimit/byUrl&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;limitApp&quot;</span>:<span class="string">&quot;default&quot;</span>,</span><br><span class="line">		<span class="attr">&quot;grade&quot;</span>:<span class="number">1</span>,</span><br><span class="line">		<span class="attr">&quot;count&quot;</span>: <span class="number">1</span>,</span><br><span class="line">		<span class="attr">&quot;strategy&quot;</span>:<span class="number">0</span>,</span><br><span class="line">		<span class="attr">&quot;controlBehavior&quot;</span>:<span class="number">0</span>,</span><br><span class="line">		&quot;clusterMode&quot;; false</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>resource：资源名称；</li>
<li>limitApp：来源应用；</li>
<li>grade：國值类型，0表示线程数，1表示QPS；</li>
<li>count：单机國值；</li>
<li>strategy：流控模式，0表示直接，1表示关联，2表示链路；</li>
<li>controlBehavior：流控效果，0表示快速失败，1表示Warm Up，2表示排队等待；</li>
<li>clusterMode：是否集群。</li>
</ul>
</li>
<li><p>重启微服务，刷新sentinel。</p>
<p>发现业务规则有了</p>
<p><img src="/2021/03/15/springcloud/177.png" alt="img"></p>
</li>
<li><p>快速访问测试接口：配置成功。</p>
<p><img src="/2021/03/15/springcloud/178.png" alt="image-20210314025406567"></p>
</li>
<li><p>关闭微服务再看sentinel：</p>
<p><img src="/2021/03/15/springcloud/179.png" alt="img"></p>
</li>
<li><p>重启微服务再看sentinel：（鸡肋）</p>
<p><img src="/2021/03/15/springcloud/180.png" alt="image-20210314025455716"></p>
</li>
</ol>
<h5 id="20-8-2、Alibaba-AHAS-与-Alibaba-Sentinel"><a href="#20-8-2、Alibaba-AHAS-与-Alibaba-Sentinel" class="headerlink" title="20.8.2、Alibaba AHAS 与 Alibaba Sentinel"></a>20.8.2、Alibaba AHAS 与 Alibaba Sentinel</h5><h6 id="20-8-2-1、AHAS是什么："><a href="#20-8-2-1、AHAS是什么：" class="headerlink" title="20.8.2.1、AHAS是什么："></a>20.8.2.1、AHAS是什么：</h6><p>应用高可用服务AHAS是一款专注于提高应用高可用能力的SaaS产品，提供应用架构自动探测、故障注入式高可用能力演练、一键应用防护和增加功能开关等功能，可以快速低成本地提升应用可用性。</p>
<p><a target="_blank" rel="noopener" href="https://help.aliyun.com/product/87450.html">官网</a></p>
<p>Alibaba AHAS是<code>商业化</code>的（说白了就是要用钱买）</p>
<p>Alibaba Sentinel是<code>开源</code>的，任何人都能用</p>
<p>Alibaba AHAS完成了对配置信息持久化的更深一层的包装。</p>
<p>更多资料：</p>
<p><a target="_blank" rel="noopener" href="https://help.aliyun.com/knowledge_detail/167568.html">Alibaba AHAS 与 Alibaba Sentinel的对比</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lettuce_/article/details/102799028">springcloud（11）Alibaba-AHAS 限流方式</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hosaos/article/details/91413895">Sentinel-集成阿里云AHAS控制台实现集群流控</a></p>
<h3 id="21、SpringCloud-Alibaba-Seata处理分布式事务"><a href="#21、SpringCloud-Alibaba-Seata处理分布式事务" class="headerlink" title="21、SpringCloud Alibaba Seata处理分布式事务"></a>21、SpringCloud Alibaba Seata处理分布式事务</h3><h4 id="21-1、目前微服务面临的问题"><a href="#21-1、目前微服务面临的问题" class="headerlink" title="21.1、目前微服务面临的问题"></a>21.1、目前微服务面临的问题</h4><p>在之前 <strong><code>单机单库</code></strong> 环境下，针对事务的处理还是比较简单的。尤其是结合 Spring 框架，可以说是一个@Transaction 注解走天下。事务 &amp; Spring 事务相关内容，点击链接去了解吧：<a target="_blank" rel="noopener" href="https://blog.csdn.net/lzb348110175/article/details/104854696">事务 &amp; Spring 事务内容介绍</a></p>
<p>在如今 Spring Cloud 分布式微服务架构体系中，按业务模块划分，一个模块使用一个数据库。多个模块配合来完成一个业务，我们就从 <a target="_blank" rel="noopener" href="http://seata.io/zh-cn/docs/user/quickstart.html">官网</a> 的一个微服务实例开始吧。</p>
<h5 id="21-1-1、-用例"><a href="#21-1-1、-用例" class="headerlink" title="21.1.1、 用例"></a>21.1.1、 用例</h5><p><strong>用户购买商品的业务逻辑。整个业务逻辑由3个微服务提供支持：</strong></p>
<ul>
<li>仓储服务：对给定的商品扣除仓储数量。</li>
<li>订单服务：根据采购需求创建订单。</li>
<li>帐户服务：从用户帐户中扣除余额。</li>
</ul>
<h5 id="21-1-2、架构图"><a href="#21-1-2、架构图" class="headerlink" title="21.1.2、架构图"></a>21.1.2、架构图</h5><p><img src="/2021/03/15/springcloud/181.png" alt="在这里插入图片描述"></p>
<h5 id="21-1-3、分布式事务解决方案"><a href="#21-1-3、分布式事务解决方案" class="headerlink" title="21.1.3、分布式事务解决方案"></a>21.1.3、分布式事务解决方案</h5><p>单体应用被拆分成微服务应用，原来的三个模块被拆分成三个独立的应用，分别使用三个<code>独立的数据源</code>，业务操作需要调用三个服务来完成。此时<strong>每个服务内部的数据一致性由<code>本地事务</code>来保证</strong>，但是<strong>全局数据一致性问题是无法保证的</strong>。所以，Alibaba Seata来处理分布式事务</p>
<h4 id="21-2、是什么"><a href="#21-2、是什么" class="headerlink" title="21.2、是什么"></a>21.2、是什么</h4><p>Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。 Seata 将为用户提供了**<code>AT</code>**、<code>TCC</code>、<code>SAGA</code>和<code>XA</code>事务模式，为用户打造一站式的分布式解决方案。</p>
<p>在 Seata 开源之前，Seata 对应的内部版本在阿里经济体内部一直扮演着<code>分布式一致性中间件</code>的角色，帮助经济体平稳的度过历年的双11，对各部门业务进行了有力的支撑。经过多年沉淀与积累，商业化产品先后在阿里云、金融云进行售卖。2019.1 为了打造更加完善的技术生态和普惠技术成果，Seata 正式宣布对外开源，未来 Seata 将以社区共建的形式帮助其技术更加可靠与完备。</p>
<p>此处重点介绍 **<code>AT模式</code>**，在工作中也最常用，用起来也比较简单。</p>
<p>Seata的四个模式<a target="_blank" rel="noopener" href="https://seata.io/zh-cn/docs/dev/mode/at-mode.html">官网</a>、<a target="_blank" rel="noopener" href="https://my.oschina.net/sofastack/blog/3092880">资料</a>：</p>
<ul>
<li><p><strong>AT 模式：</strong></p>
<p>提供无侵入自动补偿的事务模式，目前已支持 MySQL、 Oracle 、PostgreSQL和 TiDB的AT模式，H2 开发中</p>
</li>
<li><p>TCC 模式<a target="_blank" rel="noopener" href="https://blog.csdn.net/huaishu/article/details/89880971">资料</a>：</p>
<p>支持 TCC 模式并可与 AT 混用，灵活度更高</p>
</li>
<li><p>SAGA 模式<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38308374/article/details/108907413">资料</a>：</p>
<p>为长事务提供有效的解决方案</p>
</li>
<li><p>XA 模式<a target="_blank" rel="noopener" href="https://blog.csdn.net/yyl2733291216/article/details/106149336/">资料</a>：</p>
<p>支持已实现 XA 接口的数据库的 XA 模式</p>
</li>
</ul>
<h4 id="21-3、Seata-术语表"><a href="#21-3、Seata-术语表" class="headerlink" title="21.3、Seata 术语表"></a>21.3、Seata 术语表</h4><p>（术语即：名词介绍，以下内容摘自：Seata 官方文档 <a target="_blank" rel="noopener" href="http://seata.io/zh-cn/docs/overview/terminology.html%EF%BC%89">http://seata.io/zh-cn/docs/overview/terminology.html）</a></p>
<ul>
<li><strong>TC (Transaction Coordinator) - 事务协调者</strong><br>维护全局和分支事务的状态，驱动全局事务提交或回滚。</li>
<li><strong>TM (Transaction Manager) - 事务管理器</strong><br>定义全局事务的范围：开始全局事务、提交或回滚全局事务。</li>
<li><strong>RM (Resource Manager) - 资源管理器</strong><br>管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li>
</ul>
<p>其中，TC 为单独部署的 <strong>Server</strong> 服务端，TM 和 RM 为嵌入到应用中的 <strong>Client</strong> 客户端。</p>
<p><img src="/2021/03/15/springcloud/182.png" alt="在这里插入图片描述"></p>
<p>Seata管理的分布式事务的典型生命周期（执行过程）：</p>
<ol>
<li>TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的 XID；</li>
<li>XID 在微服务调用链路的上下文中传播；</li>
<li>RM 向 TC 注册分支事务，将其纳入 XID 对应全局事务的管辖；</li>
<li>TM 向 TC 发起针对 XID 的全局提交或回滚决议；</li>
<li>TC 调度 XID 下管辖的全局分支事务，完成分支提交或回滚请求。</li>
</ol>
<h4 id="21-4、AT模式"><a href="#21-4、AT模式" class="headerlink" title="21.4、AT模式"></a>21.4、AT模式</h4><h5 id="21-4-1、AT-前提"><a href="#21-4-1、AT-前提" class="headerlink" title="21.4.1、AT 前提"></a>21.4.1、AT 前提</h5><ul>
<li>基于支持本地 ACID 事务的关系型数据库。</li>
<li>Java 应用，通过 JDBC 访问数据库。</li>
</ul>
<h5 id="21-4-2、AT-整体机制"><a href="#21-4-2、AT-整体机制" class="headerlink" title="21.4.2、AT 整体机制"></a>21.4.2、AT 整体机制</h5><p>两阶段提交协议的演变：</p>
<ul>
<li>一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。</li>
<li>二阶段：<ul>
<li>提交异步化，非常快速地完成。</li>
<li>回滚通过一阶段的回滚日志进行<code>反向补偿</code>。</li>
</ul>
</li>
</ul>
<h5 id="21-4-3、写隔离"><a href="#21-4-3、写隔离" class="headerlink" title="21.4.3、写隔离"></a>21.4.3、写隔离</h5><ul>
<li>一阶段本地事务提交前，需要确保先拿到 <strong>全局锁</strong> 。</li>
<li>拿不到 <strong>全局锁</strong> ，不能提交本地事务。</li>
<li>拿 <strong>全局锁</strong> 的尝试被限制在一定范围内，超出范围将放弃，并回滚本地事务，释放本地锁。</li>
</ul>
<p>以一个示例来说明：</p>
<p>两个全局事务 tx1 和 tx2，分别对 a 表的 m 字段进行更新操作，m 的初始值 1000。</p>
<p>tx1 先开始，开启本地事务，拿到本地锁，更新操作 m = 1000 - 100 = 900。本地事务提交前，先拿到该记录的 <strong>全局锁</strong> ，本地提交释放本地锁。 tx2 后开始，开启本地事务，拿到本地锁，更新操作 m = 900 - 100 = 800。本地事务提交前，尝试拿该记录的 <strong>全局锁</strong> ，tx1 全局提交前，该记录的全局锁被 tx1 持有，tx2 需要重试等待 <strong>全局锁</strong> 。</p>
<p><img src="/2021/03/15/springcloud/183.png" alt="img"></p>
<p>tx1 二阶段全局提交，释放 <strong>全局锁</strong> 。tx2 拿到 <strong>全局锁</strong> 提交本地事务。</p>
<p><img src="/2021/03/15/springcloud/184.png" alt="img"></p>
<p>如果 tx1 的二阶段全局回滚，则 tx1 需要重新获取该数据的本地锁，进行反向补偿的更新操作，实现分支的回滚。</p>
<p>此时，如果 tx2 仍在等待该数据的 <strong>全局锁</strong>，同时持有本地锁，则 tx1 的分支回滚会失败。分支的回滚会一直重试，直到 tx2 的 <strong>全局锁</strong> 等锁超时，放弃 <strong>全局锁</strong> 并回滚本地事务释放本地锁，tx1 的分支回滚最终成功。</p>
<p>因为整个过程 <strong>全局锁</strong> 在 tx1 结束前一直是被 tx1 持有的，所以不会发生 <strong>脏写</strong> 的问题。</p>
<h5 id="21-4-4、读隔离"><a href="#21-4-4、读隔离" class="headerlink" title="21.4.4、读隔离"></a>21.4.4、读隔离</h5><p>在数据库本地事务隔离级别 <strong>读已提交（Read Committed）</strong> 或以上的基础上，Seata（AT 模式）的默认全局隔离级别是 <strong>读未提交（Read Uncommitted）</strong> 。</p>
<p>如果应用在特定场景下，必需要求全局的 <strong>读已提交</strong> ，目前 Seata 的方式是通过 SELECT FOR UPDATE 语句的代理。</p>
<p><img src="/2021/03/15/springcloud/185.png" alt="img"></p>
<p>SELECT FOR UPDATE 语句的执行会申请 <strong>全局锁</strong> ，如果 <strong>全局锁</strong> 被其他事务持有，则释放本地锁（回滚 SELECT FOR UPDATE 语句的本地执行）并重试。这个过程中，查询是被 block 住的，直到 <strong>全局锁</strong> 拿到，即读取的相关数据是 <strong>已提交</strong> 的，才返回。</p>
<p>出于总体性能上的考虑，Seata 目前的方案<strong>并没有对所有 SELECT 语句都进行代理</strong>，仅针对 FOR UPDATE 的 SELECT 语句。</p>
<h5 id="21-4-5、工作机制"><a href="#21-4-5、工作机制" class="headerlink" title="21.4.5、工作机制"></a>21.4.5、工作机制</h5><p>以一个示例来说明整个 AT 分支的工作过程。</p>
<p>业务表：<code>product</code></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Key</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>bigint(20)</td>
<td>PRI</td>
</tr>
<tr>
<td>name</td>
<td>varchar(100)</td>
<td></td>
</tr>
<tr>
<td>since</td>
<td>varchar(100)</td>
<td></td>
</tr>
</tbody></table>
<p><strong>AT 分支事务的业务逻辑：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> product <span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">&#x27;GTS&#x27;</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">&#x27;TXC&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h6 id="21-4-5-1、一阶段"><a href="#21-4-5-1、一阶段" class="headerlink" title="21.4.5.1、一阶段"></a>21.4.5.1、一阶段</h6><p>过程：</p>
<ol>
<li>解析 SQL：得到 SQL 的类型（UPDATE），表（product），条件（where name = ‘TXC’）等相关的信息。</li>
<li>查询前镜像：根据解析得到的条件信息，生成查询语句，定位数据。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span>, since <span class="keyword">from</span> product <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">&#x27;TXC&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>得到前镜像：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>since</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>TXC</td>
<td>2021</td>
</tr>
</tbody></table>
<ol>
<li>执行业务 SQL：更新这条记录的 name 为 ‘GTS’。</li>
<li>查询后镜像：根据前镜像的结果，通过 <strong>主键</strong> 定位数据。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span>, since <span class="keyword">from</span> product <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span><span class="string">`;</span></span><br></pre></td></tr></table></figure>

<p>得到后镜像：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>since</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>GTS</td>
<td>2021</td>
</tr>
</tbody></table>
<p>插入回滚日志：把前后镜像数据以及业务 SQL 相关的信息组成一条回滚日志记录，插入到 <code>UNDO_LOG</code> 表中。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">&quot;branchId&quot;</span>: <span class="number">641789253</span>,</span><br><span class="line">	<span class="attr">&quot;undoItems&quot;</span>: [&#123;</span><br><span class="line">		<span class="attr">&quot;afterImage&quot;</span>: &#123;</span><br><span class="line">			<span class="attr">&quot;rows&quot;</span>: [&#123;</span><br><span class="line">				<span class="attr">&quot;fields&quot;</span>: [&#123;</span><br><span class="line">					<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;id&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;type&quot;</span>: <span class="number">4</span>,</span><br><span class="line">					<span class="attr">&quot;value&quot;</span>: <span class="number">1</span></span><br><span class="line">				&#125;, &#123;</span><br><span class="line">					<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;type&quot;</span>: <span class="number">12</span>,</span><br><span class="line">					<span class="attr">&quot;value&quot;</span>: <span class="string">&quot;GTS&quot;</span></span><br><span class="line">				&#125;, &#123;</span><br><span class="line">					<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;since&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;type&quot;</span>: <span class="number">12</span>,</span><br><span class="line">					<span class="attr">&quot;value&quot;</span>: <span class="string">&quot;2021&quot;</span></span><br><span class="line">				&#125;]</span><br><span class="line">			&#125;],</span><br><span class="line">			<span class="attr">&quot;tableName&quot;</span>: <span class="string">&quot;product&quot;</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">&quot;beforeImage&quot;</span>: &#123;</span><br><span class="line">			<span class="attr">&quot;rows&quot;</span>: [&#123;</span><br><span class="line">				<span class="attr">&quot;fields&quot;</span>: [&#123;</span><br><span class="line">					<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;id&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;type&quot;</span>: <span class="number">4</span>,</span><br><span class="line">					<span class="attr">&quot;value&quot;</span>: <span class="number">1</span></span><br><span class="line">				&#125;, &#123;</span><br><span class="line">					<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;type&quot;</span>: <span class="number">12</span>,</span><br><span class="line">					<span class="attr">&quot;value&quot;</span>: <span class="string">&quot;TXC&quot;</span></span><br><span class="line">				&#125;, &#123;</span><br><span class="line">					<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;since&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;type&quot;</span>: <span class="number">12</span>,</span><br><span class="line">					<span class="attr">&quot;value&quot;</span>: <span class="string">&quot;2021&quot;</span></span><br><span class="line">				&#125;]</span><br><span class="line">			&#125;],</span><br><span class="line">			<span class="attr">&quot;tableName&quot;</span>: <span class="string">&quot;product&quot;</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">&quot;sqlType&quot;</span>: <span class="string">&quot;UPDATE&quot;</span></span><br><span class="line">	&#125;],</span><br><span class="line">	<span class="attr">&quot;xid&quot;</span>: <span class="string">&quot;xid:xxx&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>提交前，向 TC注册分支：申请 <code>product</code> 表中，主键值等于 1 的记录的<strong>全局锁</strong>.</li>
<li>本地事务提交：业务数据的更新和前面步骤中生成的 UNDO LOG 一并提交。</li>
<li>将本地事务提交的结果上报给 TC。</li>
</ol>
<h6 id="21-4-5-2、二阶段-回滚"><a href="#21-4-5-2、二阶段-回滚" class="headerlink" title="21.4.5.2、二阶段-回滚"></a>21.4.5.2、二阶段-回滚</h6><ol>
<li><p>收到 TC 的分支回滚请求，开启一个本地事务，执行如下操作。</p>
</li>
<li><p>通过 XID 和 Branch ID 查找到相应的 UNDO LOG 记录。</p>
</li>
<li><p>数据校验：拿 UNDO LOG 中的后镜与当前数据进行比较，如果有不同，说明数据被当前全局事务之外的动作做了修改（脏写）。这种情况，需要根据配置策略来做处理，详细的说明在另外的文档中介绍。</p>
</li>
<li><p>根据 UNDO LOG 中的前镜像和业务 SQL 的相关信息生成并执行回滚的语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> product <span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">&#x27;TXC&#x27;</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>提交本地事务。并把本地事务的执行结果（即分支事务回滚的结果）上报给 TC。</p>
</li>
</ol>
<h6 id="21-4-5-3、二阶段-提交"><a href="#21-4-5-3、二阶段-提交" class="headerlink" title="21.4.5.3、二阶段-提交"></a>21.4.5.3、二阶段-提交</h6><ol>
<li>收到 TC 的分支提交请求，把请求放入一个异步任务的队列中，马上返回提交成功的结果给 TC。</li>
<li>异步任务阶段的分支提交请求将异步和批量地删除相应<code>UNDO LOG</code>记录。</li>
</ol>
<p>回滚事务表：</p>
<p>UNDO_LOG Table：不同数据库在类型上会略有差别。</p>
<p>以 MySQL 为例：</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
</tr>
</thead>
<tbody><tr>
<td>branch_id</td>
<td>bigint PK</td>
</tr>
<tr>
<td>xid</td>
<td>varchar(100)</td>
</tr>
<tr>
<td>context</td>
<td>varchar(128)</td>
</tr>
<tr>
<td>rollback_info</td>
<td>longblob</td>
</tr>
<tr>
<td>log_status</td>
<td>tinyint</td>
</tr>
<tr>
<td>log_created</td>
<td>datetime</td>
</tr>
<tr>
<td>log_modified</td>
<td>datetime</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 注意此处0.7.0+ 增加字段 context</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`undo_log`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`branch_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`xid`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`context`</span> <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`rollback_info`</span> longblob <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`log_status`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`log_created`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`log_modified`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`ux_undo_log`</span> (<span class="string">`xid`</span>,<span class="string">`branch_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">1</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<h6 id="21-4-5-4、总结"><a href="#21-4-5-4、总结" class="headerlink" title="21.4.5.4、总结"></a>21.4.5.4、总结</h6><ul>
<li>是什么</li>
</ul>
<p><img src="/2021/03/15/springcloud/186.png" alt="img"></p>
<ul>
<li>一阶段加载：</li>
</ul>
<p><img src="/2021/03/15/springcloud/187.png" alt="img"></p>
<p><img src="/2021/03/15/springcloud/188.png" alt="img"></p>
<ul>
<li>二阶段提交：</li>
</ul>
<p><img src="/2021/03/15/springcloud/189.png" alt="img"></p>
<ul>
<li>二阶段回滚：</li>
</ul>
<p><img src="/2021/03/15/springcloud/190.png" alt="img"></p>
<p><img src="/2021/03/15/springcloud/191.png" alt="img"></p>
<h4 id="21-5、Spring-Cloud-整合-Nacos-1-3-1-Seata-1-2-0-集群部署-Windows版"><a href="#21-5、Spring-Cloud-整合-Nacos-1-3-1-Seata-1-2-0-集群部署-Windows版" class="headerlink" title="21.5、Spring Cloud 整合 Nacos 1.3.1 + Seata 1.2.0 集群部署(Windows版)"></a>21.5、Spring Cloud 整合 Nacos 1.3.1 + Seata 1.2.0 集群部署(Windows版)</h4><h5 id="21-5-1、环境说明"><a href="#21-5-1、环境说明" class="headerlink" title="21.5.1、环境说明"></a>21.5.1、环境说明</h5><p><strong>部署环境+版本：</strong> <strong><code>MySQL 5.7.x</code></strong> + <strong><code>Nacos 1.3.1</code></strong> + <strong><code>Seata 1.2.0</code></strong> + **<code>Windows 环境演示</code>**，Linux 部署类似。</p>
<h5 id="21-5-2、Seata-1-2-0-下载"><a href="#21-5-2、Seata-1-2-0-下载" class="headerlink" title="21.5.2、Seata 1.2.0 下载"></a>21.5.2、Seata 1.2.0 下载</h5><p>进入 <a target="_blank" rel="noopener" href="http://seata.io/zh-cn/blog/download.html">Seata 官网下载地址</a> 或者 <a target="_blank" rel="noopener" href="https://github.com/seata/seata/releases/tag/v1.2.0">Seata Github下载地址</a>，选择 Seata 1.2.0 版本下载。</p>
<h5 id="21-5-3、官网新人文档中的资源目录介绍"><a href="#21-5-3、官网新人文档中的资源目录介绍" class="headerlink" title="21.5.3、官网新人文档中的资源目录介绍"></a>21.5.3、官网新人文档中的资源目录介绍</h5><p><img src="/2021/03/15/springcloud/192.png" alt="在这里插入图片描述"></p>
<p><strong>详细说明</strong></p>
<p><img src="/2021/03/15/springcloud/193.png" alt="在这里插入图片描述"></p>
<h5 id="21-5-4、Seata-Server-端配置"><a href="#21-5-4、Seata-Server-端配置" class="headerlink" title="21.5.4、Seata Server 端配置"></a>21.5.4、Seata Server 端配置</h5><h6 id="21-5-4-1、解压"><a href="#21-5-4-1、解压" class="headerlink" title="21.5.4.1、解压"></a>21.5.4.1、解压</h6><p>将下载的 <strong><code>seata-server-1.2.0.zip</code></strong> 解压到某个路径下（注意该路径不要有中文或空格）。</p>
<h6 id="21-5-4-2、MySQL-数据库配置"><a href="#21-5-4-2、MySQL-数据库配置" class="headerlink" title="21.5.4.2、MySQL 数据库配置"></a>21.5.4.2、MySQL 数据库配置</h6><p>1、执行MySQL数据库操作前，需要我们手动创建一个名称为 <strong><code>seata</code></strong> 的数据库，然后在该数据库下建表。建库命令如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> seata <span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/03/15/springcloud/194.png" alt="image-20210314232019841"></p>
<p>进入 <a target="_blank" rel="noopener" href="https://github.com/seata/seata/tree/1.2.0/script">资源目录</a> <strong><code>seata/script/server/db/mysql.sql</code></strong> ，执行SQL语句。建表语句如下，你也可以点击链接获取。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- -------------------------------- The script used when storeMode is &#x27;db&#x27; --------------------------------</span></span><br><span class="line"><span class="comment">-- the table to store GlobalSession data</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`global_table`</span></span><br><span class="line">(</span><br><span class="line">    <span class="string">`xid`</span>                       <span class="built_in">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`transaction_id`</span>            <span class="built_in">BIGINT</span>,</span><br><span class="line">    <span class="string">`status`</span>                    <span class="built_in">TINYINT</span>      <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`application_id`</span>            <span class="built_in">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="string">`transaction_service_group`</span> <span class="built_in">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="string">`transaction_name`</span>          <span class="built_in">VARCHAR</span>(<span class="number">128</span>),</span><br><span class="line">    <span class="string">`timeout`</span>                   <span class="built_in">INT</span>,</span><br><span class="line">    <span class="string">`begin_time`</span>                <span class="built_in">BIGINT</span>,</span><br><span class="line">    <span class="string">`application_data`</span>          <span class="built_in">VARCHAR</span>(<span class="number">2000</span>),</span><br><span class="line">    <span class="string">`gmt_create`</span>                DATETIME,</span><br><span class="line">    <span class="string">`gmt_modified`</span>              DATETIME,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`xid`</span>),</span><br><span class="line">    <span class="keyword">KEY</span> <span class="string">`idx_gmt_modified_status`</span> (<span class="string">`gmt_modified`</span>, <span class="string">`status`</span>),</span><br><span class="line">    <span class="keyword">KEY</span> <span class="string">`idx_transaction_id`</span> (<span class="string">`transaction_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- the table to store BranchSession data</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`branch_table`</span></span><br><span class="line">(</span><br><span class="line">    <span class="string">`branch_id`</span>         <span class="built_in">BIGINT</span>       <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`xid`</span>               <span class="built_in">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`transaction_id`</span>    <span class="built_in">BIGINT</span>,</span><br><span class="line">    <span class="string">`resource_group_id`</span> <span class="built_in">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="string">`resource_id`</span>       <span class="built_in">VARCHAR</span>(<span class="number">256</span>),</span><br><span class="line">    <span class="string">`branch_type`</span>       <span class="built_in">VARCHAR</span>(<span class="number">8</span>),</span><br><span class="line">    <span class="string">`status`</span>            <span class="built_in">TINYINT</span>,</span><br><span class="line">    <span class="string">`client_id`</span>         <span class="built_in">VARCHAR</span>(<span class="number">64</span>),</span><br><span class="line">    <span class="string">`application_data`</span>  <span class="built_in">VARCHAR</span>(<span class="number">2000</span>),</span><br><span class="line">    <span class="string">`gmt_create`</span>        DATETIME(<span class="number">6</span>),</span><br><span class="line">    <span class="string">`gmt_modified`</span>      DATETIME(<span class="number">6</span>),</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`branch_id`</span>),</span><br><span class="line">    <span class="keyword">KEY</span> <span class="string">`idx_xid`</span> (<span class="string">`xid`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- the table to store lock data</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`lock_table`</span></span><br><span class="line">(</span><br><span class="line">    <span class="string">`row_key`</span>        <span class="built_in">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`xid`</span>            <span class="built_in">VARCHAR</span>(<span class="number">96</span>),</span><br><span class="line">    <span class="string">`transaction_id`</span> <span class="built_in">BIGINT</span>,</span><br><span class="line">    <span class="string">`branch_id`</span>      <span class="built_in">BIGINT</span>       <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`resource_id`</span>    <span class="built_in">VARCHAR</span>(<span class="number">256</span>),</span><br><span class="line">    <span class="string">`table_name`</span>     <span class="built_in">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="string">`pk`</span>             <span class="built_in">VARCHAR</span>(<span class="number">36</span>),</span><br><span class="line">    <span class="string">`gmt_create`</span>     DATETIME,</span><br><span class="line">    <span class="string">`gmt_modified`</span>   DATETIME,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`row_key`</span>),</span><br><span class="line">    <span class="keyword">KEY</span> <span class="string">`idx_branch_id`</span> (<span class="string">`branch_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/03/15/springcloud/195.png" alt="在这里插入图片描述"></p>
<h6 id="21-5-4-3、Server端参数项配置"><a href="#21-5-4-3、Server端参数项配置" class="headerlink" title="21.5.4.3、Server端参数项配置"></a>21.5.4.3、Server端参数项配置</h6><p>解压后，进入 <strong><code>conf</code></strong> 目录开始参数的配置。我们修改 <strong><code>file.conf</code></strong> 和 <strong><code>registry.conf</code></strong> 这两个文件。</p>
<p><img src="/2021/03/15/springcloud/196.png" alt="在这里插入图片描述"></p>
<ol>
<li><p><strong>对 file.conf 配置：</strong></p>
<p><img src="/2021/03/15/springcloud/197.png" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>对 registry.conf 配置：</strong></p>
<p><img src="/2021/03/15/springcloud/198.png" alt="在这里插入图片描述"></p>
</li>
</ol>
<h6 id="21-5-4-4、启动Seata-Server端"><a href="#21-5-4-4、启动Seata-Server端" class="headerlink" title="21.5.4.4、启动Seata Server端"></a>21.5.4.4、启动Seata Server端</h6><p>进入 bin 目录，双击 <strong><code>seata-server.bat</code></strong> 启动。（Linux环境请选择 seata-server.sh 启动）</p>
<p><img src="/2021/03/15/springcloud/199.png" alt="在这里插入图片描述"></p>
<p>到此为止，Seata Server 端启动完成。</p>
<h4 id="21-5-5、config-center-配置中心配置"><a href="#21-5-5、config-center-配置中心配置" class="headerlink" title="21.5.5、config-center 配置中心配置"></a>21.5.5、config-center 配置中心配置</h4><p>配置中心的配置，本文使用 nacos 作为配置中心。</p>
<h6 id="21-5-5-1、获取要配置的参数信息"><a href="#21-5-5-1、获取要配置的参数信息" class="headerlink" title="21.5.5.1、获取要配置的参数信息"></a>21.5.5.1、获取要配置的参数信息</h6><p>进入 <a target="_blank" rel="noopener" href="https://github.com/seata/seata/tree/1.2.0/script">资源目录</a> <strong><code>seata/script/config-center/config.txt</code></strong> ，展示的是 Seata 1.2.0 版本所有配置中心的内容，全部配置点击链接查看。本文使用db方式，故选择db相关配置，需要用到的配置如下：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">service.vgroupMapping.my_test_tx_group=default  </span><br><span class="line">service.default.grouplist=127.0.0.1:8091</span><br><span class="line">service.enableDegrade=false</span><br><span class="line">service.disableGlobalTransaction=false</span><br><span class="line">store.mode=db  /*此处修改为db*/</span><br><span class="line">store.db.datasource=druid</span><br><span class="line">store.db.dbType=mysql</span><br><span class="line">store.db.driverClassName=com.mysql.jdbc.Driver  /*自定义修改*/</span><br><span class="line">store.db.url=jdbc:mysql://192.168.204.201:3306/seata?useUnicode=true /*自定义修改*/</span><br><span class="line">store.db.user=root  /*自定义修改*/</span><br><span class="line">store.db.password=root  /*自定义修改*/</span><br><span class="line">store.db.minConn=5</span><br><span class="line">store.db.maxConn=30</span><br><span class="line">store.db.globalTable=global_table</span><br><span class="line">store.db.branchTable=branch_table</span><br><span class="line">store.db.queryLimit=100</span><br><span class="line">store.db.lockTable=lock_table</span><br><span class="line">store.db.maxWait=5000</span><br></pre></td></tr></table></figure>

<h6 id="21-5-5-2、将参数配置到Nacos配置中心"><a href="#21-5-5-2、将参数配置到Nacos配置中心" class="headerlink" title="21.5.5.2、将参数配置到Nacos配置中心"></a>21.5.5.2、将参数配置到Nacos配置中心</h6><p>进入 资源目录 seata/script/config-center/nacos/nacos-config.sh ，该配置会将 seata 相关配置批量添加到 nacos 服务器。</p>
<p>该脚本可以随便放在某个位置，只要脚本 nacos-config.sh 能够读取到 config.txt 文件即可。本文放在如下为止</p>
<p><img src="/2021/03/15/springcloud/200.png" alt="在这里插入图片描述"></p>
<p>你自己打开<code>nacos-config.sh</code>脚本 看看它查找 config.txt 的逻辑就可以了，只要能够读取到 config.txt 文件即可。nacos-config.sh 脚本支持传入<code>四个参数</code>：</p>
<ul>
<li>-h nacos 所在服务器的IP地址，默认为 localhost</li>
<li>-p nacos 端口号，默认为 8848</li>
<li>-g nacos 配置所属 group 名称，默认为 SEATA_GROUP</li>
<li>-t 将 nacos 配置保存到指定的命名空间，默认为 “”，代表 public 命名空间（注意：-t 参数值接收的是 命名空间ID，不是 命名空间名称） </li>
</ul>
<p>使用 <strong>git 命令框</strong> 执行 <strong><code>sh nacos-config.sh</code></strong> ，就可以将配置批量保存到 nacos 服务器。如下图所示：</p>
<p><img src="/2021/03/15/springcloud/201.gif" alt="在这里插入图片描述"></p>
<p>到此为止，Config Center 配置中心参数，配置完成。</p>
<h4 id="21-5-6、client-客户端配置"><a href="#21-5-6、client-客户端配置" class="headerlink" title="21.5.6、client 客户端配置"></a>21.5.6、client 客户端配置</h4><h5 id="21-5-6-1、业务场景"><a href="#21-5-6-1、业务场景" class="headerlink" title="21.5.6.1、业务场景"></a>21.5.6.1、业务场景</h5><p>用户购买商品的业务逻辑。整个业务逻辑由3个微服务提供支持：</p>
<ul>
<li>订单服务A：根据采购需求创建订单。</li>
<li>仓储服务B：对给定的商品扣除仓储数量。</li>
<li>帐户服务C：从用户帐户中扣除余额。</li>
</ul>
<p>用户A购买商品，调用<code>A服务</code>创建订单完成，调用<code>B服务</code>扣减库存，然后调用<code>C服务</code>扣减账户余额。<strong>每个服务内部的数据一致性由本地事务来保证，多个服务调用来完成业务，全局事务数据一致性则由 Seata 来保证。</strong></p>
<h5 id="21-5-6-2、业务数据库准备"><a href="#21-5-6-2、业务数据库准备" class="headerlink" title="21.5.6.2、业务数据库准备"></a>21.5.6.2、业务数据库准备</h5><p>配置三个业务分别对应各自的数据库。</p>
<ul>
<li>A服务 对应数据库：seata_order ；表：t_order</li>
<li>B服务 对应数据库：seata_storage ；表：t_storage</li>
<li>C服务 对应数据库：seata_account ；表：t_account</li>
</ul>
<p><strong>建库，建表语句如下：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建seata_order数据库</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> seata_order;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建t_order表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> seata_order.t_order(</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">BIGINT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    <span class="string">`user_id`</span> <span class="built_in">BIGINT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">    <span class="string">`product_id`</span> <span class="built_in">BIGINT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;产品id&#x27;</span>,</span><br><span class="line">    <span class="string">`count`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;数量&#x27;</span>,</span><br><span class="line">    <span class="string">`money`</span> <span class="built_in">DECIMAL</span>(<span class="number">11</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;金额&#x27;</span>,</span><br><span class="line">    <span class="string">`status`</span> <span class="built_in">INT</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;订单状态：0：创建中; 1：已完结&#x27;</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> AUTO_INCREMENT=<span class="number">7</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建seata_storage数据库</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> seata_storage;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建t_storage表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> seata_storage.t_storage(</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">BIGINT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    <span class="string">`product_id`</span> <span class="built_in">BIGINT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;产品id&#x27;</span>,</span><br><span class="line">    <span class="string">`total`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;总库存&#x27;</span>,</span><br><span class="line">    <span class="string">`used`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;已用库存&#x27;</span>,</span><br><span class="line">    <span class="string">`residue`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;剩余库存&#x27;</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> AUTO_INCREMENT=<span class="number">2</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入一条数据 </span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> seata_storage.t_storage(<span class="string">`id`</span>,<span class="string">`product_id`</span>,<span class="string">`total`</span>,<span class="string">`used`</span>,<span class="string">`residue`</span>)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;100&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;100&#x27;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建seata_account数据库</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> seata_account;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建t_account表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> seata_account.t_account(</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">BIGINT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">    <span class="string">`user_id`</span> <span class="built_in">BIGINT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">    <span class="string">`total`</span> <span class="built_in">DECIMAL</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;总额度&#x27;</span>,</span><br><span class="line">    <span class="string">`used`</span> <span class="built_in">DECIMAL</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;已用余额&#x27;</span>,</span><br><span class="line">    <span class="string">`residue`</span> <span class="built_in">DECIMAL</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;剩余可用额度&#x27;</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> AUTO_INCREMENT=<span class="number">2</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入一条数据 </span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> seata_account.t_account(<span class="string">`id`</span>,<span class="string">`user_id`</span>,<span class="string">`total`</span>,<span class="string">`used`</span>,<span class="string">`residue`</span>) <span class="keyword">VALUES</span>(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1000&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1000&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="21-5-6-3、创建-undo-log-表"><a href="#21-5-6-3、创建-undo-log-表" class="headerlink" title="21.5.6.3、创建 undo_log 表"></a>21.5.6.3、创建 undo_log 表</h5><p>进入 <a target="_blank" rel="noopener" href="https://github.com/seata/seata/tree/1.2.0/script">资源目录</a> <strong><code>seata/script/client/at/db/mysql.sql</code></strong> ，展示的就是 undo_log 表的建表语句，该表需要在涉及到事务处理的每个库中都添加以下。undo_log 表建表语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- for AT mode you must to init this sql for you business database. the seata server not need it.</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`undo_log`</span></span><br><span class="line">(</span><br><span class="line">    <span class="string">`id`</span>            <span class="built_in">BIGINT</span>(<span class="number">20</span>)   <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">&#x27;increment id&#x27;</span>,</span><br><span class="line">    <span class="string">`branch_id`</span>     <span class="built_in">BIGINT</span>(<span class="number">20</span>)   <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;branch transaction id&#x27;</span>,</span><br><span class="line">    <span class="string">`xid`</span>           <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;global transaction id&#x27;</span>,</span><br><span class="line">    <span class="string">`context`</span>       <span class="built_in">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;undo_log context,such as serialization&#x27;</span>,</span><br><span class="line">    <span class="string">`rollback_info`</span> LONGBLOB     <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;rollback info&#x27;</span>,</span><br><span class="line">    <span class="string">`log_status`</span>    <span class="built_in">INT</span>(<span class="number">11</span>)      <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;0:normal status,1:defense status&#x27;</span>,</span><br><span class="line">    <span class="string">`log_created`</span>   DATETIME     <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;create datetime&#x27;</span>,</span><br><span class="line">    <span class="string">`log_modified`</span>  DATETIME     <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;modify datetime&#x27;</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">    <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`ux_undo_log`</span> (<span class="string">`xid`</span>, <span class="string">`branch_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line">  AUTO_INCREMENT = <span class="number">1</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8 <span class="keyword">COMMENT</span> =<span class="string">&#x27;AT transaction mode undo table&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="21-5-6-4、库表创建完成图示"><a href="#21-5-6-4、库表创建完成图示" class="headerlink" title="21.5.6.4、库表创建完成图示"></a>21.5.6.4、库表创建完成图示</h5><p><img src="/2021/03/15/springcloud/202.png" alt="在这里插入图片描述"></p>
<h5 id="21-5-6-5、添加-pom-依赖"><a href="#21-5-6-5、添加-pom-依赖" class="headerlink" title="21.5.6.5、添加 pom 依赖"></a>21.5.6.5、添加 pom 依赖</h5><p>pom.xml 部分的注意事项，可参考：<a target="_blank" rel="noopener" href="https://seata.io/zh-cn/docs/ops/deploy-guide-beginner.html">部署指南-注意事项</a></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--seata--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="21-5-6-7、application-yml-针对-seata-进行配置"><a href="#21-5-6-7、application-yml-针对-seata-进行配置" class="headerlink" title="21.5.6.7、application.yml 针对 seata 进行配置"></a>21.5.6.7、application.yml 针对 seata 进行配置</h5><p>进入<a target="_blank" rel="noopener" href="https://github.com/seata/seata/tree/1.2.0/script">资源目录</a><code>seata/script/client/spring/</code>，展示的就是 seata 整合 Spring 的全部配置内容，提供了<code>.properties</code>、<code>.yml</code>两种格式的配置。详细的配置项还挺多，此处就不粘贴了，你可以点击 资源目录 查看。此处挑选了本案例需要的部分内容进行配置，配置如下所示：（项目application.yml完整配置，请参考文末项目完整代码）</p>
<p><code>该配置在每个服务模块都需要配置一份</code>，你也可以通过 nacos 配置中心的方式配置使用。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">application-id:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br><span class="line">  <span class="attr">tx-service-group:</span> <span class="string">my_test_tx_group</span></span><br><span class="line">  <span class="attr">enable-auto-data-source-proxy:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">vgroup-mapping:</span></span><br><span class="line">      <span class="attr">my_test_tx_group:</span> <span class="string">default</span>  <span class="comment"># 此处key需要与tx-service-group的value一致，否则会报 no available service &#x27;null&#x27; found, please make sure registry config correct 异常</span></span><br><span class="line">    <span class="attr">grouplist:</span></span><br><span class="line">      <span class="attr">default:</span> <span class="number">192.168</span><span class="number">.41</span><span class="number">.113</span><span class="string">:8091</span></span><br><span class="line">    <span class="attr">enable-degrade:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">disable-global-transaction:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">namespace:</span></span><br><span class="line">      <span class="attr">serverAddr:</span> <span class="number">192.168</span><span class="number">.41</span><span class="number">.113</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">SEATA_GROUP</span></span><br><span class="line">      <span class="attr">userName:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">application:</span> <span class="string">seata-server</span>  <span class="comment"># 此处名称需和 seata server 服务端 application一致,否则会报 no available service &#x27;null&#x27; found, please make sure registry config correct 异常</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.41</span><span class="number">.113</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">namespace:</span></span><br><span class="line">      <span class="attr">userName:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>业务代码略</p>
<h4 id="21-5-7、Seata-高可用集群部署"><a href="#21-5-7、Seata-高可用集群部署" class="headerlink" title="21.5.7、Seata 高可用集群部署"></a>21.5.7、Seata 高可用集群部署</h4><h5 id="21-5-7-1、集群部署"><a href="#21-5-7-1、集群部署" class="headerlink" title="21.5.7.1、集群部署"></a>21.5.7.1、集群部署</h5><p>Seata 集群部署比较简单，只需将已配置好的 seata-server 再启动一个即可。seata 默认使用 8091 端口，此次我在 Windows 部署，所以 seata-server 第二个节点选用 8092 端口，进入 cmd 命令行，使用命令：<code>seata-server.bat -p 8092</code>启动seata-server 第二台节点。(Linux 正式环境，多机器的话，只需要 scp 到另一台机器，启动即可)</p>
<p>通过 nacos 服务列表，seata-server 实例数由 1 变为 2。端口分别为 8091、8092 。集群搭建完成，挺简单的。想要几个节点就来几个节点，so easy。<br><img src="/2021/03/15/springcloud/203.gif" alt="在这里插入图片描述"></p>
<h5 id="21-5-7-2、服务注册成功"><a href="#21-5-7-2、服务注册成功" class="headerlink" title="21.5.7.2、服务注册成功"></a>21.5.7.2、服务注册成功</h5><p>3个服务启动成功后，均会通过 RPC 的方式注册到 Seata 集群的两个节点上来，如下图所示：</p>
<p><img src="/2021/03/15/springcloud/204.png" alt="在这里插入图片描述"></p>
<h5 id="21-5-7-3、Seata集群测试"><a href="#21-5-7-3、Seata集群测试" class="headerlink" title="21.5.7.3、Seata集群测试"></a>21.5.7.3、Seata集群测试</h5><p>使用 postman 发送 50 个请求，中途关闭 8091 节点。由于集群之间通过 Nacos 通信原因，一个节点的突然宕机，会导致部分请求失败，但是服务很快便会恢复正常。</p>
<p>当再次将 8091 节点启动后，服务还是能够正常请求，8091 节点也有事务相应的日志显示，说明Seata 集群能够正常提供服务。测试如图所示：<br><img src="/2021/03/15/springcloud/205.gif" alt="在这里插入图片描述"></p>
<h4 id="21-5-8、全局事务服务-GTS-阿里云"><a href="#21-5-8、全局事务服务-GTS-阿里云" class="headerlink" title="21.5.8、全局事务服务 GTS-阿里云"></a>21.5.8、全局事务服务 GTS-阿里云</h4><h5 id="21-5-8-1、是什么"><a href="#21-5-8-1、是什么" class="headerlink" title="21.5.8.1、是什么"></a>21.5.8.1、是什么</h5><p><a target="_blank" rel="noopener" href="https://help.aliyun.com/product/48444.html">官网</a></p>
<p>全局事务服务（Global Transaction Service，简称 GTS）是一款高性能、高可靠、接入简单的分布式事务中间件，用于解决分布式环境下的事务一致性问题。 在单机数据库下很容易维持事务的 ACID（Atomicity、Consistency、Isolation、Durability）特性，但在分布式系统中并不容易，GTS 可以保证分布式系统中的分布式事务的 ACID 特性。 GTS 支持 DRDS、RDS、MySQL 等多种数据源，可以配合 EDAS 和 Dubbo 等微服务框架使用， 兼容 MQ 实现事务消息。通过各种组合，可以轻松实现分布式数据库事务、多库事务、消息事务、服务链路级事务等多种业务需求。</p>
<h5 id="21-5-8-2、GTS与Seata"><a href="#21-5-8-2、GTS与Seata" class="headerlink" title="21.5.8.2、GTS与Seata"></a>21.5.8.2、GTS与Seata</h5><ul>
<li>Seata：开源框架</li>
<li>GTS：付费的商用框架</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xgh-user.github.io/2020/11/23/springboot%E9%A1%B9%E7%9B%AE%E6%89%93%E6%88%90jar%E5%8C%85%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E5%9C%A8linux%E4%B8%8A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_little-star_">
      <meta itemprop="description" content="记录个人在平时学习的过程中的一些笔记、感受与遇到的坑,例如：java、计算机考研四件套等等。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_little-star_">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/23/springboot%E9%A1%B9%E7%9B%AE%E6%89%93%E6%88%90jar%E5%8C%85%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E5%9C%A8linux%E4%B8%8A/" class="post-title-link" itemprop="url">springboot项目打成jar包后台运行在linux上</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-11-23 03:15:47 / 修改时间：03:16:42" itemprop="dateCreated datePublished" datetime="2020-11-23T03:15:47+08:00">2020-11-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javaee/" itemprop="url" rel="index"><span itemprop="name">javaee</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javaee/springboot%E9%A1%B9%E7%9B%AE%E6%89%93%E6%88%90jar%E5%8C%85%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E5%9C%A8linux%E4%B8%8A/" itemprop="url" rel="index"><span itemprop="name">springboot项目打成jar包后台运行在linux上</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>背景：springboot2为为主体搭建的项目，直接打成jar包，上传到linux上面</p>
<p>启动项目：java -jar xx.jar 这样很方便，但是不能关闭窗口，否则项目就停了</p>
<p>后台启动： nohup java -jar xx.jar &amp; </p>
<p>这样就能后台启动了</p>
<p>有时候我们并不是部署单机版的，需要部署多个，可能部署到一台机器上，但是端口肯定得不一样吧，要是再重新打包一份就太麻烦了，我们可以在启动命令上加上启动端口参数</p>
<p>命令：nohup java -jar xx.jar –server.port=8083 &amp;</p>
<p>此时你会发现在当前目录下多了nohup.out 的文件，这个文件就是你项目的日志文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">　　　　<span class="comment">&lt;!-- 打包可执行jar包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includeSystemScope</span>&gt;</span>true<span class="tag">&lt;/<span class="name">includeSystemScope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.sanro.test.CMApplication<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xgh-user.github.io/2020/11/23/springboot%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_little-star_">
      <meta itemprop="description" content="记录个人在平时学习的过程中的一些笔记、感受与遇到的坑,例如：java、计算机考研四件套等等。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_little-star_">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/23/springboot%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/" class="post-title-link" itemprop="url">springboot项目的远程部署</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-11-23 03:11:44 / 修改时间：03:19:06" itemprop="dateCreated datePublished" datetime="2020-11-23T03:11:44+08:00">2020-11-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javaee/" itemprop="url" rel="index"><span itemprop="name">javaee</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javaee/springboot%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/" itemprop="url" rel="index"><span itemprop="name">springboot项目的远程部署</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在之前写过一篇博客关于ssm项目远程部署<br> 地址：<a href="https://xgh-user.github.io/2020/11/23/ssm-maven%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/">在这里</a></p>
<p>该教程是基于上篇，只是有部分修改而已。</p>
<p>Springboot 远程部署需要修改一下几点：</p>
<h3 id="1、POM文件"><a href="#1、POM文件" class="headerlink" title="1、POM文件"></a>1、POM文件</h3><p>（1）打包方式，这里将jar —&gt; war<br> <img src="/2020/11/23/springboot%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/1.jpg" alt="1"><br> （2）关于依赖<br> springboot由于内置了tomcat，所以在使用war包部署是需要移除内置tomcat，并添加servlet容器支持。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--移除嵌入式tomcat插件--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--添加servlet-api的依赖，使用war包部署这个必须要有--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.36<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="二、SpringbootApplication启动类"><a href="#二、SpringbootApplication启动类" class="headerlink" title="二、SpringbootApplication启动类"></a>二、SpringbootApplication启动类</h3><p>启动类需要继承 <strong>SpringBootServletInitializer</strong>  类，并且重写<strong>configure</strong> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.builder.SpringApplicationBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.support.SpringBootServletInitializer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloSpringbootApplication</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder.sources(HelloSpringbootApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SpringApplication.run(HelloSpringbootApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只需以上两部就可以完成Springboot项目远程部署。</p>
<p>转载自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/android_ztz/article/details/79262416">https://blog.csdn.net/android_ztz/article/details/79262416</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xgh-user.github.io/2020/11/23/ssm-maven%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_little-star_">
      <meta itemprop="description" content="记录个人在平时学习的过程中的一些笔记、感受与遇到的坑,例如：java、计算机考研四件套等等。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_little-star_">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/23/ssm-maven%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/" class="post-title-link" itemprop="url">ssm+maven项目的远程部署</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-11-23 02:58:56 / 修改时间：03:11:06" itemprop="dateCreated datePublished" datetime="2020-11-23T02:58:56+08:00">2020-11-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javaee/" itemprop="url" rel="index"><span itemprop="name">javaee</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javaee/ssm-maven%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/" itemprop="url" rel="index"><span itemprop="name">ssm+maven项目的远程部署</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="一、环境"><a href="#一、环境" class="headerlink" title="一、环境"></a>一、环境</h3><p>本教程使用的环境如下 </p>
<ul>
<li><p>idea 2017 </p>
</li>
<li><p>tomcat 8.5 </p>
</li>
<li><p>centos 7 </p>
</li>
<li><p>maven 3.5</p>
<p>注意：tomcat6 和 tomcat7、8、9会有一些区别，下面会详细介绍</p>
</li>
</ul>
<h3 id="二、配置【只需完成下面三步】"><a href="#二、配置【只需完成下面三步】" class="headerlink" title="二、配置【只需完成下面三步】"></a>二、配置【只需完成下面三步】</h3><h4 id="1、Tomcat-服务器配置"><a href="#1、Tomcat-服务器配置" class="headerlink" title="1、Tomcat 服务器配置"></a>1、Tomcat 服务器配置</h4><p>如果不了解 Tomcat 的安装，参考 <a target="_blank" rel="noopener" href="http://blog.csdn.net/android_ztz/article/details/79249467">http://blog.csdn.net/android_ztz/article/details/79249467</a> </p>
<p>找到[tomcat安装的根路径]/conf/tomcat-users.xml 文件，编辑如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;tomcat-users xmlns&#x3D;&quot;http:&#x2F;&#x2F;tomcat.apache.org&#x2F;xml&quot;</span><br><span class="line">              xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">              xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;tomcat.apache.org&#x2F;xml tomcat-users.xsd&quot;</span><br><span class="line">              version&#x3D;&quot;1.0&quot;&gt;</span><br><span class="line">  &lt;role rolename&#x3D;&quot;admin-gui&quot;&#x2F;&gt;</span><br><span class="line">  &lt;role rolename&#x3D;&quot;admin-script&quot;&#x2F;&gt;</span><br><span class="line">  &lt;role rolename&#x3D;&quot;manager-gui&quot;&#x2F;&gt;</span><br><span class="line">  &lt;role rolename&#x3D;&quot;manager-script&quot;&#x2F;&gt;</span><br><span class="line">  &lt;role rolename&#x3D;&quot;manager-jmx&quot;&#x2F;&gt;</span><br><span class="line">  &lt;role rolename&#x3D;&quot;manager-status&quot;&#x2F;&gt;</span><br><span class="line">  &lt;user username&#x3D;&quot;tomcat&quot; password&#x3D;&quot;tomcat&quot; roles&#x3D;&quot;manager-gui,manager-script,manager-jmx,manager-status,admin-gui,admin-script&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;tomcat-users&gt;</span><br></pre></td></tr></table></figure>

<p>role标签都是定义权限，user标签定义的是用户，usernme和password都是自定义的，roles是赋予该用户的权限。</p>
<blockquote>
<p>测试配置是否成功</p>
</blockquote>
<p>在浏览器中访问 <a href="http://yourIp:port/manager/text">http://yourIp:port/manager/text</a> (tomcat 7、8、9) ；<br> <a href="http://yourIp:port/manager/html">http://yourIp:port/manager/html</a> （tomcat 6）<br> 如果出现输入账户和密码的弹框，表示成功。</p>
<p>但是有可能会出现 <strong>【管理页面403 Access Denied】错误</strong>，详情见下面问题2：</p>
<p>【修改Tomcat端口号-默认是8080】<br> 如果需要修改，找到[tomcat安装的根路径]/conf/server.xml ，找到这一段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port&#x3D;&quot;8080&quot; protocol&#x3D;&quot;HTTP&#x2F;1.1&quot;</span><br><span class="line">               connectionTimeout&#x3D;&quot;20000&quot;</span><br><span class="line">               redirectPort&#x3D;&quot;8443&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>只需修改port的值即可。</p>
<h3 id="二、配置Maven"><a href="#二、配置Maven" class="headerlink" title="二、配置Maven"></a>二、配置Maven</h3><p>打开[Maven的安装路径]/conf/setting.xml文件 ，找到这一段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;servers&gt;</span><br><span class="line">    &lt;server&gt;</span><br><span class="line">      &lt;id&gt;tomcat8&lt;&#x2F;id&gt;</span><br><span class="line">      &lt;username&gt;tomcat&lt;&#x2F;username&gt;</span><br><span class="line">      &lt;password&gt;tomcat&lt;&#x2F;password&gt;</span><br><span class="line">    &lt;&#x2F;server&gt;</span><br><span class="line">  &lt;&#x2F;servers&gt;</span><br></pre></td></tr></table></figure>

<p>id : tomcat+版本号<br> username : 在Tomcat配置的用户名<br> password : 在Tomcat配置的密码</p>
<h3 id="三、使用idea新建一个Maven项目，打开自动生成的pom文件，配置如下："><a href="#三、使用idea新建一个Maven项目，打开自动生成的pom文件，配置如下：" class="headerlink" title="三、使用idea新建一个Maven项目，打开自动生成的pom文件，配置如下："></a>三、使用idea新建一个Maven项目，打开自动生成的pom文件，配置如下：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">  xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;maven-v4_0_0.xsd&quot;&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line">  &lt;groupId&gt;com.ztz&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;deploy-project&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;packaging&gt;war&lt;&#x2F;packaging&gt;</span><br><span class="line">  &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">  &lt;name&gt;deploy-project Maven Webapp&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;url&gt;http:&#x2F;&#x2F;maven.apache.org&lt;&#x2F;url&gt;</span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.8.1&lt;&#x2F;version&gt;</span><br><span class="line">      &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">  &lt;&#x2F;dependencies&gt;</span><br><span class="line">  &lt;build&gt;</span><br><span class="line">    &lt;defaultGoal&gt;compile&lt;&#x2F;defaultGoal&gt;</span><br><span class="line">    &lt;finalName&gt;deploy-project&lt;&#x2F;finalName&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">      &lt;!-- maven项目插件运行配置 --&gt;</span><br><span class="line">      &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.3&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;configuration&gt;</span><br><span class="line">          &lt;source&gt;1.8&lt;&#x2F;source&gt;</span><br><span class="line">          &lt;target&gt;1.8&lt;&#x2F;target&gt;</span><br><span class="line">          &lt;encoding&gt;UTF-8&lt;&#x2F;encoding&gt;</span><br><span class="line">        &lt;&#x2F;configuration&gt;</span><br><span class="line">      &lt;&#x2F;plugin&gt;</span><br><span class="line">      &lt;!-- maven远程项目部署插件 --&gt;</span><br><span class="line">      &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.tomcat.maven&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;tomcat7-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.2&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;configuration&gt;</span><br><span class="line">          &lt;!-- 填写自己服务器的IP地址和端口号,并且其他的不变,Tomcat7、8、9使用这个，Tomcat6使用另一个--&gt;</span><br><span class="line">          &lt;url&gt;http:&#x2F;&#x2F;192.168.199.133&#x2F;manager&#x2F;text&lt;&#x2F;url&gt;</span><br><span class="line">          &lt;server&gt;tomcat8&lt;&#x2F;server&gt;</span><br><span class="line">          &lt;!-- 这个账户和密码是自定义的，和Maven，Tomcat中配置要保持一致--&gt;</span><br><span class="line">          &lt;username&gt;tomcat&lt;&#x2F;username&gt;</span><br><span class="line">          &lt;password&gt;tomcat&lt;&#x2F;password&gt;</span><br><span class="line">          &lt;port&gt;80&lt;&#x2F;port&gt;</span><br><span class="line">          &lt;!-- 若tomcat项目中已存在，且使&quot;mvn tomcat7:deploy&quot;命令必须要设置下面的代码 --&gt;</span><br><span class="line">          &lt;!-- 更新项目时，仅需要执行&quot;mvn tomcat7:redeploy&quot;命令即可 --&gt;</span><br><span class="line">          &lt;!-- 上述命令无论服务器是tomcat7、8或9，均是使用&quot;mvn tomcat7:deploy&quot;或&quot;mvn tomcat7:redeploy&quot; --&gt;</span><br><span class="line">          &lt;update&gt;true&lt;&#x2F;update&gt;</span><br><span class="line">          &lt;!-- 项目路径 --&gt;</span><br><span class="line">          &lt;path&gt;&#x2F;deploy-project&lt;&#x2F;path&gt;</span><br><span class="line">        &lt;&#x2F;configuration&gt;</span><br><span class="line">      &lt;&#x2F;plugin&gt;</span><br><span class="line">    &lt;&#x2F;plugins&gt;</span><br><span class="line">  &lt;&#x2F;build&gt;</span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure>

<p>最主要的配置就是<built>标签中，关于<built>详解：<br> finalName：项目名<br> server： 服务器名和版本<br> username： 和tomcat、maven中保持一致<br> password：和tomcat、maven中保持一致<br> port：需要部署到的端口，要和服务器配置的端口一致<br> path：访问项目的路径</built></built></p>
<blockquote>
<p>其他就可以和上面保持一致。</p>
</blockquote>
<p>现在已经完成了所有的配置，那么就开始测试一下能否部署成功，在idea 中点击右栏[Maven标签]<br><img src="/2020/11/23/ssm-maven%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/1.jpg"></p>
<p> 双击【tomcat7:deploy】完成部署，查看控制台信息<br><img src="/2020/11/23/ssm-maven%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2/2.jpg" alt="2"></p>
<p>—————————————- 华丽 ——————————————–</p>
<p>遇到的问题1： </p>
<ul>
<li><p>Tomcat已启动，内网可以访问，但是外网不可以访问。 </p>
<p>答 ： 这很有可能是防火墙阻止了浏览器的访问。 </p>
</li>
<li><p>解决方式：</p>
<p>centos7使用的防火墙是 firewall 而不是 iptables 可以开要访问的端口，先查看一下防火墙状态：  firewall-cmd –state ， 结是running 或者 not running ， 建议running状态下添加开放端口。 比如需要访问的是8080端口，则可以这样 </p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=public --add-port=8080/tcp     # --permanent 表示永久添加；去掉标识临时，重启后恢复 </span><br><span class="line"> firewall-cmd --reload     # 加载配置，使得修改有效。 </span><br><span class="line"> 查看端口是否开放成功？  </span><br><span class="line">firewall-cmd --permanent --zone=public --list-ports      #查看开启的端口</span><br></pre></td></tr></table></figure>

<p>如果出现 8080/tcp 表示成功 。  </p>
<p>需要了解firewall更多，点击这里。 </p>
<hr>
<ul>
<li><p>遇到的问题2： </p>
<p>管理页面403 Access Denied </p>
<p>这说明你没有权限访问， </p>
</li>
<li><p>解决方式：</p>
<p>打开/webapps/manager/META-INF/目录下context.xml文件，将下面这段注释掉或者修改为下面这段。</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.valves.RemoteAddrValve&quot;</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">allow</span>=<span class="string">&quot;127\.\d+\.\d+\.\d+|::1|0:0:0:0:0:0:0:1|\d+\.\d+\.\d+\.\d+&quot;</span> /&gt;</span>12</span><br></pre></td></tr></table></figure>

<p>原因是： \d+.\d+.\d+.\d+ 标识任访问，如果不添加这个，则只允许前面两种类型IP访问，allow中是用正则表达式来表示的。</p>
<hr>
<ul>
<li><p>遇到的问题3 ： </p>
<p>[ERROR] Failed to execute goal  org.apache.tomcat.maven:tomcat7-maven-plugin: 2.0-SNAPSHOT:deploy  (default-cli) on project helloworld: Cannot invoke Tomcat manager:  Server returned HTTP response code: 401 for URL: <a target="_blank" rel="noopener" href="http://localhost:8080/manager/text/deploy?path=/helloworld">http://localhost:8080/manager/text/deploy?path=%2Fhelloworld</a> -&gt; [Help 1]</p>
</li>
</ul>
<p>该错误是在部署时出现的，是由于权限问题，可能是你的 tomcat-users.xml中user的权限不够，也可能是你的idea中pom文件的用户名和密码错了。</p>
<p>转载自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/android_ztz/article/details/79249335">https://blog.csdn.net/android_ztz/article/details/79249335</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xgh-user.github.io/2020/11/10/02java%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99%E5%92%8C%E8%A7%84%E8%8C%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_little-star_">
      <meta itemprop="description" content="记录个人在平时学习的过程中的一些笔记、感受与遇到的坑,例如：java、计算机考研四件套等等。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_little-star_">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/10/02java%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99%E5%92%8C%E8%A7%84%E8%8C%83/" class="post-title-link" itemprop="url">02java语法规则和规范</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-11-10 02:49:30 / 修改时间：02:51:45" itemprop="dateCreated datePublished" datetime="2020-11-10T02:49:30+08:00">2020-11-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javase/" itemprop="url" rel="index"><span itemprop="name">javase</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javase/java%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99%E5%92%8C%E8%A7%84%E8%8C%83/" itemprop="url" rel="index"><span itemprop="name">java语法规则和规范</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>需要掌握的内容：</p>
<ul>
<li><p>标识符</p>
</li>
<li><p>关键字</p>
</li>
<li><p>字面值</p>
</li>
<li><p>变量</p>
</li>
<li><p>数据类型</p>
</li>
<li><p>运算符：</p>
<ul>
<li>算术运算符</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>赋值类运算符</li>
<li>字符串连接运算符</li>
<li>三元运算符</li>
<li>赋值运算符</li>
<li>字符串连接运算符</li>
</ul>
</li>
<li><p>控制语句</p>
<ul>
<li>选择结构<ul>
<li>if,if..else</li>
<li>switch</li>
</ul>
</li>
<li>循环结构<ul>
<li>for</li>
<li>while</li>
<li>do..while()</li>
</ul>
</li>
<li>控制循环的语句<ul>
<li>break</li>
<li>continue</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1、标识符："><a href="#1、标识符：" class="headerlink" title="1、标识符："></a>1、标识符：</h3><p>1、在java程序当中，使用EditPlus工具进行代码编写的时候，</p>
<p>有一些单词是蓝色，有的是红色，有的绿色，有的是黑色，有</p>
<p>的是紫色，有的是粉色….</p>
<p>2、注意：在java源代码当中，在EditPlus工具中显示的高亮颜色为黑色时，<br>这个单词属于标识符。</p>
<p>3、标识符可以标识什么？<br>可以标识：</p>
<ul>
<li>类名</li>
<li>方法名</li>
<li>变量名</li>
<li>接口名</li>
<li>常量名</li>
<li>……</li>
</ul>
<p>4、到底什么是标识符呢？<br>一句话搞定：凡是程序员自己有权利命名的单词都是标识符。</p>
<p>5、标识符可以随意编写吗，有命名规则吗？有<br>什么是命名规则？<br>    命名规则属于语法机制，必须遵守，不遵守命名规则标识不符合语法，<br>    这样，编译器会报错。</p>
<ul>
<li><p>规则1：标识符只能由数字、字母（包括中文）、下划线_、美元符号$组成，<br>不能含有其它符号。</p>
</li>
<li><p>规则2：标识符不能以数字开头</p>
</li>
<li><p>规则3：关键字不能做标识符。例如：public class static void 这些蓝色的字体</p>
<p>都是关键字，关键字是不能做标识符的。</p>
</li>
<li><p>规则4：标识符是严格区分大小写的。大写A和小写a不一样。</p>
</li>
<li><p>规则5：标识符理论上是没有长度限制的。</p>
</li>
</ul>
<p>6、注意的点：</p>
<p>class 123ABC{<br>        }<br>    编译报错，错误信息是：<br>        错误: 需要&lt;标识符&gt;<br>    错误原因：编译器检测到class这个单词，那么编译器会从class这个<br>    单词后面找类名，而类名是标识符，编译器找了半天没有找到标识符，<br>    因为123ABC不是标识符，所以编译器提示的错误信息是：需要&lt;标识符&gt;<br>    解决办法：<br>        将123ABC修改为合法的标识符。</p>
<p>class Hello World{<br>        }<br>    <strong>类名是标识符，标识符“中”不能有空格</strong><br>    编译器错误信息是：<br>        错误: 需要’{‘<br>    编译器检测到class，然后找class后面的标识符，编译器找到了一个合法的标识符<br>    叫做“Hello”，然后编译器继续往后找“{”，结果没有找到“{”，所以报错了。<br>    解决办法：<br>        办法1：是把World删除<br>        办法2：把空格删除</p>
<p>class public {<br>        }<br>    <strong>关键字不能做标识符</strong><br>    编译器错误信息是：<br>        错误: 需要&lt;标识符&gt;</p>
<p>这个可以，因为 public1 不是关键字，可以用<br>class public1 {<br>        }</p>
<pre><code>* 虽然java中的标识符严格区分大小写
* 但是对于类名来说，如果一个java源文件中同时出现了：A类和a类
* 那么谁在前就生成谁。大家以后最好不要让类名“相同”。
* 最好类名是不同的。</code></pre>
<p>7、题目：<br>        创建一个java文件，起名 123.java可以吗？<br>        可以，完全可以，在windows操作系统中文件名叫做：123.java没毛病。<br>        123其实并不是标识符。只是一个文件名。<br>        只不过在123.java文件中无法定义public的类。<br>8、命名规范：<br>1、命名规则和命名规范有什么区别？</p>
<p>命名规则是语法，不遵守就会编译报错。</p>
<p>命名规范只是说，大家尽量按照统一的规范来进行命名，不符合规范也行，</p>
<p>代码是可以编译通过的，但是你的代码风格和大家不一样，这个通常也是不允许的。</p>
<p>规则类似于：现实世界中的法律。</p>
<p>规范类似于：现实世界中的道德。</p>
<p>统一按照规范进行的话，代码的可读性很好。代码很容易让其它开发人员理解。</p>
<p>2、具体的命名规范是哪些？</p>
<ul>
<li>规范1：见名知意（这个标识符在起名的时候，最好一看这个单词就知道啥意思。）</li>
<li>规范2：遵循驼峰命名方式，什么是驼峰（一高一低，一高一低…）<br>驼峰有利于单词与单词之间很好的进行分隔<br>BiaoShiFuTest，这个很好，一眼就能看出来是4个单词。</li>
<li>规范3：类名、接口名有特殊要求<br>类名和接口名首字母大写，后面每个单词首字母大写。<br>StudentTest、UserTest ，这是类名、接口名。</li>
<li>规范4：变量名、方法名有特殊要求<br>变量名和方法名首字母小写，后面每个单词首字母大写。<br>nianLing/age（NianLing这样就不符合了。）<br>mingZi/name（MingZi这样也不符合了。）</li>
<li>规范5：所有“常量”名：全部大写，并且单词和单词之间采用下划线衔接。<br>USER_AGE ：用户年龄<br>MATH_PI：固定不变的常量3.1415926…..</li>
</ul>
<h3 id="2、关键字："><a href="#2、关键字：" class="headerlink" title="2、关键字："></a>2、关键字：</h3><p>关键字:</p>
<p>在SUN公司开发Java语言的时候，提前定义好了一些具有特殊含义的单词，这些单词全部小写，具有特殊含义，不能用作标识符。凡是在EditPlus中以蓝色字体形式存在的都是关键字，具有特殊含义。</p>
<p>切记：</p>
<ul>
<li><p>java语言中的所有关键字都是全部小写。</p>
</li>
<li><p>注意：java语言中是严格区分大小写的。</p>
<p>public和Public不一样。</p>
<p>Class和class不一样。</p>
<p>static和Static也不一样。</p>
</li>
<li><p><strong>重点</strong>：string不是java关键字！！！</p>
</li>
</ul>
<p>Java关键字(50个)的大致含义(运用记忆)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">关键字			含义</span><br><span class="line">	<span class="keyword">abstract</span>		表明类或者成员方法具有抽象属性</span><br><span class="line">	<span class="keyword">assert</span>			用来进行程序调试</span><br><span class="line">	<span class="keyword">boolean</span>			基本数据类型之一，布尔类型</span><br><span class="line">	<span class="keyword">break</span>			提前跳出一个块</span><br><span class="line">	<span class="keyword">byte</span>			基本数据类型之一，字节类型</span><br><span class="line">	<span class="keyword">case</span>			用在<span class="keyword">switch</span>语句之中，表示其中的一个分支</span><br><span class="line">	<span class="keyword">catch</span>			用在异常处理中，用来捕捉异常</span><br><span class="line">	<span class="keyword">char</span>			基本数据类型之一，字符类型</span><br><span class="line">	<span class="class"><span class="keyword">class</span>			类</span></span><br><span class="line"><span class="class">	<span class="title">const</span>			保留关键字，没有具体含义</span></span><br><span class="line"><span class="class">	<span class="title">continue</span>		回到一个块的开始处</span></span><br><span class="line"><span class="class">	<span class="title">default</span>			默认，例如，用在<span class="title">switch</span>语句中，表明一个默认的分支</span></span><br><span class="line"><span class="class">	<span class="title">do</span>				用在<span class="title">do</span>-<span class="title">while</span>循环结构中</span></span><br><span class="line"><span class="class">	<span class="title">double</span>			基本数据类型之一，双精度浮点数类型</span></span><br><span class="line"><span class="class">	<span class="title">else</span>			用在条件语句中，表明当条件不成立时的分支</span></span><br><span class="line"><span class="class">	<span class="title">enum</span>			枚举</span></span><br><span class="line"><span class="class">	<span class="keyword">extends</span>			表明一个类型是另一个类型的子类型，这里常见的类型有类和接口</span></span><br><span class="line"><span class="class">	<span class="title">final</span>			用来说明最终属性，表明一个类不能派生出子类，或者成员方法不能被覆盖，或者成员					 	    域的值不能被改变，用来定义常量</span></span><br><span class="line"><span class="class">	<span class="title">finally</span>			用于处理异常情况，用来声明一个基本肯定会被执行到的语句块</span></span><br><span class="line"><span class="class">	<span class="title">float</span>			基本数据类型之一，单精度浮点数类型</span></span><br><span class="line"><span class="class">	<span class="title">for</span>				一种循环结构的引导词</span></span><br><span class="line"><span class="class">	<span class="title">goto</span>			保留关键字，没有具体含义</span></span><br><span class="line"><span class="class">	<span class="title">if</span>				条件语句的引导词</span></span><br><span class="line"><span class="class">	<span class="keyword">implements</span>		表明一个类实现了给定的接口</span></span><br><span class="line"><span class="class">	<span class="title">import</span>			表明要访问指定的类或包</span></span><br><span class="line"><span class="class">	<span class="title">instance</span> <span class="title">of</span>		用来测试一个对象是否是指定类型的实例对象</span></span><br><span class="line"><span class="class">	<span class="title">int</span>				基本数据类型之一，整数类型</span></span><br><span class="line"><span class="class">	<span class="title">interface</span>		接口</span></span><br><span class="line"><span class="class">	<span class="title">long</span>			基本数据类型之一，长整数类型</span></span><br><span class="line"><span class="class">	<span class="title">native</span>			用来声明一个方法是由与计算机相关的语言(如<span class="title">C</span>/<span class="title">C</span>++/<span class="title">FORTRAN</span>语言)实现的</span></span><br><span class="line"><span class="class">	<span class="title">new</span>				用来创建新实例对象</span></span><br><span class="line"><span class="class">	<span class="title">package</span>			包</span></span><br><span class="line">	private			一种访问控制方式:私用模式</span><br><span class="line">	<span class="keyword">protected</span>		一种访问控制方式:保护模式</span><br><span class="line">	<span class="keyword">public</span>			一种访问控制方式:共用模式</span><br><span class="line">	<span class="keyword">return</span>			从成员方法中返回数据</span><br><span class="line">	<span class="keyword">short</span>			基本数据类型之一,短整数类型</span><br><span class="line">	<span class="keyword">static</span>			表明具有静态属性</span><br><span class="line">	<span class="keyword">strictfp</span>		用来声明FP_strict(单精度或双精度浮点数)表达式遵循IEEE <span class="number">754</span>算术规范</span><br><span class="line">	<span class="keyword">super</span>			表明当前对象的父类型的引用或者父类型的构造方法</span><br><span class="line">	<span class="keyword">switch</span>			分支语句结构的引导词</span><br><span class="line">	<span class="keyword">synchronized</span>	表明一段代码需要同步执行</span><br><span class="line">	<span class="keyword">this</span>			指向当前实例对象的引用</span><br><span class="line">	<span class="keyword">throw</span>			抛出一个异常</span><br><span class="line">	<span class="keyword">throws</span>			声明在当前定义的成员方法中所有需要抛出的异常</span><br><span class="line">	<span class="keyword">transient</span>		声明不用序列化的成员域</span><br><span class="line">	<span class="keyword">try</span>				尝试一个可能抛出异常的程序块</span><br><span class="line">	<span class="keyword">void</span>			声明当前成员方法没有返回值</span><br><span class="line">	<span class="keyword">volatile</span>		表明两个或者多个变量必须同步地发生变化</span><br><span class="line">	<span class="keyword">while</span>			用在循环结构中</span><br></pre></td></tr></table></figure>



<h3 id="3、字面量："><a href="#3、字面量：" class="headerlink" title="3、字面量："></a>3、字面量：</h3><p>关于程序当中的数据<br>        开发软件是为了解决现实世界中的问题。<br>        而现实世界当中，有很多问题都是使用数据进行描述的。<br>        所以软件执行过程中最主要就是对数据的处理。</p>
<p>软件在处理数据之前需要能够表示数据，在java代码中怎么去表示数据呢？在java中有这样的一个概念：字面量。</p>
<p>注意：在java语言中“数据”被称为“字面量”。<br>        10<br>        1.23<br>        true<br>        false<br>        ‘a’<br>        “abc”<br>        以上这些都是数据，在程序中都被叫做“字面量”。</p>
<p>字面量可以分为很多种类：<br>    整数型字面量：1 2 3 100 -100 -20 ….<br>    浮点型字面量：1.3 1.2 3.14…..<br>    布尔型字面量：true、false没有其它值了，表示真和假,true表示真，false表示假<br>    字符型字面量：’a’、’b’、’中’<br>    字符串型字面量：”abc”、”a”、”b”、”中国”<br>其中字符型和字符串型都是描述了现实世界中的文字：<br>需要注意的是：<br>    所有的字符型只能使用单引号括起来。<br>    所有的字符串型只能使用双引号括起来。<br>    字符型一定是单个字符才能成为“字符型”<br>在语法级别上区分字符型和字符串型：<br>    主要看是双引号还是单引号。<br>    单引号的一定是字符型。<br>    双引号的一定是字符串型。</p>
<h3 id="4、变量："><a href="#4、变量：" class="headerlink" title="4、变量："></a>4、变量：</h3><p>变量的定义：<br>        变量其实就是内存当中存储数据的最基本的单元。<br>        变量就是一个存储数据的盒子。</p>
<p>在java语言当中任何数据都是有数据类型的，其中整数型是：int<br>当然，在java中除了数据类型int之外，还有其它的类型，例如带小数的：double等<br>数据类型有什么用呢？<br>    重点：不同的数据类型，在内存中分配的空间大小不同。<br>    也就是说，Java虚拟机到底给这个数据分配多大的空间，主要还是看这个变量的数据类型。<br>    根据不同的类型，分配不同大小的空间。<br>    对于int这种整数类型，JVM会自动给int分配4个字节大小的空间。</p>
<p>1个字节=8个比特位<br>1个比特位就是一个1或0. 注意：比特位是二进制位。<br>int是占用多少个二进制位？1个int占有32个二进制位（bit位）<br>int i = 1; 实际上在内存中是这样表示的：<br>    00000000 00000000 00000000 00000001<br>int i = 2;<br>    00000000 00000000 00000000 00000010<br>二进制位就是：满2进1位（0 1 10 11 100 101….）<br>十进制位就是：满10进1位（1 2 3 4 5 6 7 8 9 10）</p>
<p>对于一个变量来说，包括三要素：</p>
<ul>
<li>变量的数据类型</li>
<li>变量的名字</li>
<li>变量中保存的值</li>
</ul>
<p>类型+名字+值<br>    类型决定空间的大小。<br>    起个名字是为了以后方便访问。（以后在程序中访问这个数据是通过名称来访问的。）<br>    值是变量保存的数据。</p>
<p>变量名属于标识符</p>
<ul>
<li>变量名命名规范</li>
<li>首字母小写，后面每个单词首字母大写，遵循驼峰命名方式，见名知意。</li>
</ul>
<p>变量声明/定义的语法格式<br>    数据类型 变量名;<br>    例如：<br>        int nianLing;</p>
<p>在java语言中有一个规定，变量必须先声明，再赋值才能访问。（没有值相当于这个空间没有开辟。）<br>在java语言中给一个变量赋值呢的语法格式<br>    重点：使用一个运算符，叫做“=”，这个运算符被称为赋值运算符。<br>    赋值运算符“=”的运算特点是：等号右边先执行，执行完之后赋值给左边的变量。<br>变量声明的时候可以同时进行赋值。<br>一行同时声明多个变量。<br>重点：在同一个域当中，变量名不能重名，不能重复声明（和类型没有关系。不能同名。）。<br>变量可以重新赋值，但在同一个域当中，不能重复声明。</p>
<p>关于变量的一个分类：<br>    变量根据出现的位置进行划分：<br>        在方法体当中声明的变量：局部变量。<br>        在方法体之外，类体内声明的变量：成员变量。<br>        重点依据是：声明的位置。<br>注意：局部变量只在方法体当中有效，方法体执行结束该变量的内存就释放了。</p>
<p>变量的作用域：</p>
<ul>
<li>作用域的定义:<br>变量的有效范围。</li>
<li>关于变量的作用域，可以记住一句话：<br>出了大括号就不认识了。</li>
<li>java中有一个很重要的原则：<br>就近原则。（不仅java中是这样，其它编程语言都有这个原则。）<br>哪个离我近，就访问哪个。</li>
</ul>
<h3 id="5、数据类型："><a href="#5、数据类型：" class="headerlink" title="5、数据类型："></a>5、数据类型：</h3><p>数据类型有什么用？<br>        数据类型用来声明变量，程序在运行过程中根据不同的数据类型分配不同大小的空间。<br>        int i = 10;<br>        double d = 1.23;<br>        i变量和d变量类型不同，空间大小不同。</p>
<h4 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h4><ul>
<li>数据类型在java语言中包括两种：<ul>
<li>基本数据类型<br>基本数据类型又可以划分为4大类8小种：<ul>
<li>整数型<br>byte,short,int,long （没有小数的）</li>
<li>浮点型<br>float,double （带有小数的）</li>
<li>布尔型<br>boolean：只有两个值true和false，true表示真，false表示假</li>
<li>字符型<br>char：java中规定字符型字面量必须使用单引号括起来。属于文字。</li>
<li>8小种：<ul>
<li>byte,short,int,long</li>
<li>float,double</li>
<li>boolean</li>
<li>char</li>
</ul>
</li>
</ul>
</li>
<li>引用数据类型<pre><code>字符串型String属于引用数据类型。
String字符串不属于基本数据类型范畴。
java中除了基本数据类型之外，剩下的都是引用数据类型。
引用数据类型后期面向对象的时候才会接触。</code></pre>
</li>
</ul>
</li>
</ul>
<p>8种基本数据类型中<br>    整数型：byte short int long有什么区别？<br>    浮点型：float和double有什么区别？<br>    区别：占用的空间大小不同。</p>
<p>关于计算机存储单位？<br>    计算机只能识别二进制。（1001101100…）<br>    1字节 = 8bit（8比特）–&gt; 1byte = 8bit<br>    1bit就是一个1或0.<br>    1KB = 1024byte<br>    1MB = 1024KB<br>    1GB = 1024MB<br>    1TB = 1024GB</p>
<p>?    byte b = 2; 在计算机中是这样表示的：00000010<br>?    short s = 2; 在计算机中是这样表示的：00000000 00000010<br>?    int i = 2;在计算机中是这样表示的：00000000 00000000 00000000 00000010<br>?    …</p>
<p>?    类型            占用字节数量(byte)</p>
<p>?    byte                1<br>?    short                2<br>?    int                    4<br>?    long                8<br>?    float                4<br>?    double            8<br>?    boolean        1  (1byte的1或0，00000001(true)或00000000(false))<br>?    char                2</p>
<p>关于二进制：<br>1            2                3            4                5                6            7<br>1            10                11            100            101            110        111  ….<br>十进制转换成二进制<br>125 转换成二进制：<br>    办法：除以2，然后余数逆序输出：1111101<br>二进制转换成十进制<br>    2的2次方   2的1次方 2的0次方<br>    1                1            1<br>    4                2            1<br>    1<em>4 + 1</em>2 + 1*1 = 7</p>
<p>?    2的2次方   2的1次方 2的0次方<br>?    1            0            1<br>?    4            2            1<br>?    1<em>4 + 0</em>2 + 1*1 = 5</p>
<p>byte类型的取值范围：<br>    byte是 [-128 ~ 127] 共可以标识256个不同的数字。<br>    byte类型的最大值是怎么计算出来的？<br>        byte是1个字节，是8个比特位，所以byte可以存储的最大值是：01111111<br>    注意：在计算机当中，一个二进制位最左边的是符号位，当为0时表示正数，<br>    当为1时表示负数。所以byte类型最大值是：01111111<br>    那么是不是2的7次方-1呢？<br>        是不是：10000000（前边是一个二进制） - 1<br>    byte类型最大值是：2的7次方 - 1.</p>
<p>有几个取值范围需要大家记住：<br>    (1个字节)byte: [-128 ~ 127]<br>    (2个字节)short:[-32768 ~ 32767] 可以表示65536个不同的数字<br>    (4个字节)int: [-2147483648 ~ 2147483647]<br>    (2个字节)char: [0~65535]  可以表示65536个不同的数字<br>short和char实际上容量相同，不过char可以表示更大的数字。<br>因为char表示的是文字，文件没有正负之分，所以char可以表示更大的数字。</p>
<p>对于8种基本数据类型来说：<br>其中byte,short,int,long,float,double,boolean，这7种类型计算机表示起来比较容易，因为他们都是数字。其中布尔类型只有两个值true和false，实际上true和false分别在C++中对应的是1和0，1为true，false为0。<br>对于char类型来说计算机表示起来比较麻烦，因为char对应的是文字，每一个国家的文字不一样，文字不能直接通过“自然算法”转换成二进制。这个时候怎么办？字符编码诞生了。</p>
<p>什么是字符编码？<br>    字符编码是人为的定义的一套转换表。<br>    在字符编码中规定了一系列的文字对应的二进制。<br>    字符编码其实本质上就是一本字典，该字段中描述了文字与二进制之间的对照关系。<br>    字符编码是人为规定的。（是某个计算机协会规定的。）<br>    字符编码涉及到编码和解码两个过程，编码和解码的时候必须采用同一套字符编码方式，不然就会出现乱码。</p>
<p>关于字符编码的发展过程？<br>    起初的时候计算机是不支持文字的，只支持科学计算。实际上计算机起初是为了<br>    战争而开发的，计算导弹的轨道….</p>
<p>?    后来随着计算机的发展，计算机开始支持文字，最先支持的文字是英文，英文<br>?    对应的字符编码方式是：ASCII码。</p>
<p>?    ASCII码采用1byte进行存储，因为英文字母是26个。（键盘上所有的键全部算上也<br>?    超不过256个。1byte可以表示256种不同的情况。所以英文本身在计算机方面就占有<br>?    优势。）<br>?    ‘a’ –(采用ASCII码进行编码)-&gt; 01100001<br>?    01100001 –(采用ASCII码进行解码)-&gt; ‘a’<br>?    如果编码和解码采用的不是同一个编码方式，会出现乱码。<br>?    ‘b’ —&gt; 98<br>?    ‘c’ —&gt; 99…<br>?    ‘a’ —&gt; 97</p>
<p>?    ‘A’ —&gt; 65<br>?    ‘B’ —&gt; 66<br>?    …</p>
<p>?    ‘0’ —&gt; 48  （这个’0’不是那个0，是文字’0’）<br>?    ‘1’ —&gt; 49<br>?<br>?    随着计算机语言的发展，后来国际标准组织制定了ISO-8859-1编码方式，<br>?    又称为latin-1编码方式，向上兼容ASCII码。但不支持中文。<br>?    后来发展到亚洲，才支持中文，日文，韩文….<br>?    中文这块的编码方式：GB2312&lt;GBK&lt;GB18030 （容量的关系）<br>?    以上编码方式是简体中文。<br>?    繁体中文：big5（台湾使用的是大五码。）<br>?    在java中，java语言为了支持全球所有的文字，采用了一种字符编码方式<br>?    叫做unicode编码。unicode编码统一了全球所有的文字，支持所有文字。<br>?    具体的实现包括：UTF-8 UTF-16 UTF-32….    </p>
<p>需要记住：<br>    ASCII（’a’是97 ‘A’是65 ‘0’是48…）<br>    ISO-8859-1（latin-1）<br>    GB2312<br>    GBK<br>    GB18030<br>    Big5<br>    unicode（utf8 utf16 utf32）</p>
<h4 id="布尔型bollean："><a href="#布尔型bollean：" class="headerlink" title="布尔型bollean："></a>布尔型bollean：</h4><p>1、在java语言中boolean类型只有两个值，没有其他值：<br>true和false。<br>不像C或者C++，C语言中1和0也可以表示布尔类型<br>2、boolean类型在实际开发中使用在哪里呢？<br>使用在逻辑判断当中，通常放到条件的位置上（充当条件）</p>
<h4 id="字符型char："><a href="#字符型char：" class="headerlink" title="字符型char："></a>字符型char：</h4><p>1、char占用2个字节。<br>char可以存储1个汉字吗？<br>可以的，汉字占用2个字节，java中的char类型占用2个字节，正好。<br>2、char的取值范围：[0-65535]<br>3、char采用unicode编码方式。<br>4、char类型的字面量使用单引号括起来。<br>5、char可以存储一个汉字。<br>6、转义字符：<br>java语言中“\”负责转义。<br>\t 表示制表符tab<br>\n 表示制表符回车<br>System.out.println(); 换行<br>System.out.print(); 不换行<br>&#39; 表示一个普通不能再普通的单引号字符 ‘（&#39;联合起来表示一个普通的 ‘）<br>\ 表示一个“普通的反斜杠字符 <br>// 双引号括起来的是字符串<br>System.out.println(“test”);<br>// 希望输出的结果是：”test”<br>// 错误: 需要’)’<br>//System.out.println(“”test””);<br>System.out.println(““test””); //内部的双引号我用中文的行吗？可以。<br>7、整数能否直接赋值给char<br>char x = 97;<br>这个java语句是允许的，并且输出的结果是’a’<br>经过这个测试得出两个结论：</p>
<ul>
<li>当一个整数赋值给char类型变量的时候，会自动转换成char字符型，最终的结果是一个字符。</li>
<li>当一个整数没有超出byte short char的取值范围的时候，这个整数可直接赋值给byte short char类型的变量。</li>
</ul>
<h4 id="浮点型float-double"><a href="#浮点型float-double" class="headerlink" title="浮点型float/double:"></a>浮点型float/double:</h4><p>浮点型包括：<br>float            4个字节<br>double        8个字节<br>float是单精度<br>double是双精度<br>double更精确<br>比如说：<br>10.0 / 3 如果采用float来存储的话结果可能是：3.33333<br>10.0 / 3 如果采用double来存储的话结果可能是：3.3333333333333<br>但是需要注意的是，如果用在银行方面或者说使用在财务方面，double<br>也是远远不够的，在java中提供了一种精度更高的类型，这种类型专门<br>使用在财务软件方面：java.math.BigDecimal （不是基本数据类型，属于<br>引用数据类型。）<br>float和double存储数据的时候都是存储的近似值。<br>因为现实世界中有这种无线循环的数据，例如：3.3333333333333….<br>数据实际上是无限循环，但是计算机的内存有限，用一个有限的资源<br>表示无限的数据，只能存储近似值。</p>
<p>long类型占用8个字节。<br>float类型占用4个字节。<br>注意：任意一个浮点型都比整数型空间大。<br>    float容量 &gt; long容量。<br>java中规定，任何一个浮点型数据默认被当做double来处理。<br>如果想让这个浮点型字面量被当做float类型来处理，那么<br>请在字面量后面添加F/f。<br>1.0 那么1.0默认被当做double类型处理。<br>1.0F 这才是float类型。（1.0f）</p>
<h4 id="整型byte-short-int-long："><a href="#整型byte-short-int-long：" class="headerlink" title="整型byte/short/int/long："></a>整型byte/short/int/long：</h4><p>整数型在java语言中共4种类型：<br>byte    1个字节  最大值127<br>short    2个字节  最大值32767<br>int    4个字节  2147483647是int最大值，超了这个范围可以使用long类型。<br>long    8个字节<br>1个字节 = 8个二进制位<br>1byte = 8bit<br>对于以上的四个类型来说，最常用的是int。</p>
<p>在java语言中整数型字面量有4种表示形式：<br>十进制：最常用的。<br>二进制<br>八进制<br>十六进制</p>
<p>在java中有一条非常重要的结论，必须记住：<br>在任何情况下，整数型的“字面量/数据”默认被当做int类型处理。<br>如果希望该“整数型字面量”被当做long类型来处理，需要在“字面量”后面添加L/l<br>建议使用大写L，因为小写l和1傻傻分不清。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误: 整数太大</span></span><br><span class="line"><span class="keyword">long</span> e = <span class="number">2147483648</span>;</span><br></pre></td></tr></table></figure>

<p>在java中，整数型字面量一上来编译器就会将它看做int类型<br>而2147483648已经超出了int的范围，所以在没有赋值之前就出错了。<br>记住，不是e放不下2147483648，e是long类型，完全可以容纳2147483648<br>只不过2147483648本身已经超出了int范围。<br>解决问题：<br>    long e = 2147483648L;</p>
<ul>
<li>小容量可以直接赋值给大容量，称为自动类型转换。</li>
<li>大容量不能直接赋值给小容量，需要使用强制类型转换符进行强转。</li>
</ul>
<p>但需要注意的是：<br>加强制类型转换符之后，虽然编译通过了，但是运行的时候可能会损失精度。<br>大容量转换成小容量，要想编译通过，必须加强制类型转换符，进行强制类型转换。<br>但是要记住：编译虽然过了，但是运行时可能损失精度。</p>
<p>java中有一个语法规则：<br>当这个整数型字面量没有超出byte的取值范围，那么这个整数型字面量可以直接赋值给byte类型的变量。<br>当整数型字面量没有超出short类型取值范围的时候，该字面量可以直接赋值给short。<br>这种语法机制是为了方便写代码，而存在的。<br>byte、char、short做混合运算的时候，各自先转换成int再做运算。</p>
<p>计算机的数据存储方式：</p>
<ul>
<li>计算机在任何情况下都只能识别二进制</li>
<li>计算机在底层存储数据的时候，一律存储的是“二进制的补码形式”<br>计算机采用补码形式存储数据的原因是：补码形式效率最高。</li>
<li>补码：<br>实际上是这样的，二进制有：原码 反码 补码 </li>
<li>记住：<br>对于一个正数来说：二进制原码、反码、补码是同一个，完全相同。</li>
<li>分析 byte b = (byte)150;  //-106<br>这个b是多少？<br>int类型的4个字节的150的二进制码是什么？<br>00000000 00000000 00000000 10010110<br>将以上的int类型强制类型转为1个字节的byte，最终在计算机中的二进制码是：<br>10010110</li>
</ul>
<p>千万要注意：计算机永远存储的都是二进制补码形式。也就是说上面<br>10010110 这个是一个二进制补码形式，你可以采用逆推导的方式推算出<br>这个二进制补码对应的原码是啥！！！！！！<br>10010110 —&gt; 二进制补码形式<br>10010101 —&gt; 二进制反码形式<br>11101010 —&gt; 二进制原码形式 </p>
<p>计算机数据的自动转换：<br>在类型转换的时候需要遵循规则</p>
<ul>
<li>八种基本数据类型中，除 boolean 类型不能转换，剩下七种类型之间都可以进行转换；</li>
<li>如果整数型字面量没有超出 byte,short,char 的取值范围，可以直接将其赋值给byte,short,char 类型的变    量；</li>
<li>小容量向大容量转换称为自动类型转换，容量从小到大的排序为：<br>byte &lt; short(char) &lt; int &lt; long &lt; float &lt; double，其中 short和 char<br>都占用两个字节，但是char 可以表示更大的正整数；</li>
<li>大容量转换成小容量，称为强制类型转换，编写时必须添加“强制类型转换符”，但运行时可能出现精度损失，谨慎使用；</li>
<li>byte,short,char 类型混合运算时，先各自转换成 int 类型再做运算；</li>
<li>多种数据类型混合运算，各自先转换成容量最大的那一种再做运算；</li>
</ul>
<p>多种数据类型做混合运算的时候，最终的结果类型是“最大容量”对应的类型。<br>boolean &lt; (char/short/byte)int &lt; float &lt; double<br>char+short+byte 这个除外。<br>因为char + short + byte混合运算的时候，会各自先转换成int再做运算。<br>java中规定，int类型和int类型最终的结果还是int类型(最终取整)。</p>
<p>6、java中的输入和输出：<br>    输出信息到控制台：<br>        System.out.println(…);<br>    在java中怎么接收键盘的输入呢？<br>        前提：java.util.Scanner s = new java.util.Scanner(System.in);<br>        接收一个整数：<br>            int num = s.nextInt();<br>        接收一个字符串：<br>            String str = s.next();<br>        import java.util.Scanner;<br>        Scanner s = new Scanner(System.in);</p>
<h3 id="7、运算符："><a href="#7、运算符：" class="headerlink" title="7、运算符："></a>7、运算符：</h3><p>1、算术运算符：</p>
<p><code>+</code> : 求和</p>
<p><code>-</code> : 相减</p>
<p><code>*</code> : 乘积</p>
<p><code>/</code> : 商</p>
<p><code>%</code> : 求余数（求模）</p>
<p><code>++</code> : 自加1</p>
<p><code>--</code> : 自减1</p>
<pre><code>对于++运算符来说：
可以出现在变量前，也可以出现在变量后。
不管出现在变量前还是后，总之++执行结束之后，变量的值一定会自加1。
* ++出现在变量后：
 语法：当++出现在变量后，会先做赋值运算，再自加1
* ++出现在变量前：
 语法：当++出现在变量前的时候，会先进行自加1的运算，然后再赋值。 

2、关系运算符：
    &gt;    大于
    &gt;=    大于等于
    &lt;    小于
    &lt;=    小于等于
    ==    等于
    !=    不等于

    一定要记住一个规则：
        所有的关系运算符的运算结果都是布尔类型，
        不是true就是false，不可能是其他值。

    在java语言中:
        = ： 赋值运算符
        == ：关系运算符，判断是否相等。

    注意：关系运算符中如果有两个符号的话，两个符号之间不能有空格。
        &gt;= 这是对的, &gt; = 这是不对的。
        == 这是对的，= = 这是不对的。

3、逻辑运算符：
    &amp;    逻辑与（可以翻译成并且）
    |    逻辑或（可以翻译成或者）
    !    逻辑非（取反）
    &amp;&amp;    短路与
    ||    短路或

    用普通话描述的话：100 大于 99 并且 100 大于 98 ，有道理
    用代码描述的话：100 &gt; 99 &amp; 100 &gt; 98 --&gt; true

    true &amp; true --&gt; true

    非常重要：
        逻辑运算符两边要求都是布尔类型，并且最终的运算结果也是布尔类型。
        这是逻辑运算符的特点。

    100 &amp; true 不行，语法错误。
    100 &amp; 200 不行，没有这种语法。
    true &amp; false 这样可以。

    100 &gt; 90 &amp; 100 &gt; 101 --&gt; false

    &amp; 两边都是true，结果才是true
    | 有一边是true，结果就是true

    关于短路与 &amp;&amp;，短路或 ||（以短路与为例）

        * 短路与&amp;&amp; 和 逻辑与&amp; 的区别
            首先这两个运算符的运算结果没有任何区别，完全相同。
            只不过“短路与&amp;&amp;”会发生短路现象。

        * 短路现象
            右边表达式不执行，这种现象叫做短路现象。

        * 什么时候使用&amp;&amp;，什么时候使用&amp; ？
            从效率方面来说，&amp;&amp;比&amp;的效率高一些。
            因为逻辑与&amp;不管第一个表达式结果是什么，第二个表达式一定会执行。(&amp;&amp;更智能)

            以后的开发中，短路与&amp;&amp;和逻辑与还是需要同时并存的。
                大部分情况下都建议使用短路与&amp;&amp;
                只有当既需要左边表达式执行，又需要右边表达式执行的时候，才会
                选择逻辑与&amp;。
        * 什么时候会发生短路？
            int x = 10;
            int y = 11;
            // 逻辑与&amp;什么时候结果为true（两边都是true，结果才是true）
            // 左边的 x&gt;y 表达式结果已经是false了，其实整个表达式的结
            // 果已经确定是false了，按道理来说右边的表达式不应该执行。
            System.out.println(x &gt; y &amp; x &gt; y++); 

            // 通过这个测试得出：x &gt; y++ 这个表达式执行了。
            System.out.println(y); // 12

            //测试短路与&amp;&amp;
            int m = 10;
            int n = 11;
            // 使用短路与&amp;&amp;的时候，当左边的表达式为false的时候，右边的表达式不执行
            // 这种现象被称为短路。
            System.out.println(m &gt; n &amp;&amp; m &gt; n++);
            System.out.println(n); // 11

            什么时候发生短路或现象(|| 短路或)？
            // “或”的时候只要有一边是true，结果就是true。
            // 所以，当左边的表达式结果是true的时候，右边的表达式不需要执行，此时会短路。

4、赋值运算符：
    1、赋值运算符包括“基本赋值运算符”和“扩展赋值运算符”：基本的、扩展的。
    2、基本赋值运算符
        =
    3、扩展的赋值运算符
        +=
        -=
        *=
        /=
        %=
        注意：扩展赋值运算符在编写的时候，两个符号之间不能有空格。
            + =  错误的。
            += 正确的。
    4、很重要的语法机制：
        使用扩展赋值运算符的时候，永远都不会改变运算结果类型。
        byte x = 100;
        x += 1;
        x自诞生以来是byte类型，那么x变量的类型永远都是byte。不会变。
        不管后面是多大的数字。

    5、赋值运算符“=”右边优先级比较高，先执行右边的表达式
       然后将表达式执行结束的结果放到左边的“盒子”当中。（赋值）

    6、研究：
        // i += 10 和 i = i + 10 真的是完全一样吗？
        // 答案：不一样，只能说相似，其实本质上并不是完全相同。
        byte x = 100; // 100没有超出byte类型取值范围，可以直接赋值
        System.out.println(x); // 100

        // 分析：这个代码是否能够编译通过？
        // 错误: 不兼容的类型: 从int转换到byte可能会有损失
        //x = x + 1; // 编译器检测到x + 1是int类型，int类型可以直接赋值给byte类型的变量x吗？

        // 使用扩展赋值运算符可以吗？
        // 可以的，所以得出结论：x += 1 和 x = x + 1不一样。
        // 其实 x += 1 等同于：x = (byte)(x + 1);
        x += 1;
        System.out.println(x); // 101

        // 早就超出byte的取值范围了。
        x += 199; // x = (byte)(x + 199);
        System.out.println(x); // 44 （当然会自动损失精度了。）

5、条件运算符（三目运算符）：
    语法格式：
        布尔表达式 ? 表达式1 : 表达式2

    执行原理
        布尔表达式的结果为true时，表达式1的执行结果作为整个表达式的结果。
        布尔表达式的结果为false时，表达式2的执行结果作为整个表达式的结果。

6、+ 运算符：
    1、+ 运算符在java语言中有两个作用：
        作用1：求和
        作用2：字符串拼接

    2、什么时候求和？什么时候进行字符串的拼接呢？
        当 + 运算符两边都是数字类型的时候，求和。
        当 + 运算符两边的“任意一边”是字符串类型，那么这个+会进行字符串拼接操作。

    3、一定要记住：字符串拼接完之后的结果还是一个字符串。

    4、示例：
        int a = 100;
        int b = 200;
        // 注意：当一个表达式当中有多个加号的时候
        // 遵循“自左向右”的顺序依次执行。（除非额外添加了小括号，小括号的优先级高）
        // 第一个+先运算，由于第一个+左右两边都是数字，所以会进行求和。
        // 求和之后结果是300，代码就变成了：System.out.println(300 + &quot;110&quot;);
        // 那么这个时候，由于+的右边是字符串&quot;110&quot;，所以此时的+会进行字符串拼接。
        System.out.println(a + b + &quot;110&quot;); // 最后一定是一个字符串：&quot;300110&quot;

        // 先执行小括号当中的程序：b + &quot;110&quot;，这里的+会进行字符串的拼接，
        // 拼接之后的结果是：&quot;200110&quot;，这个结果是一个字符串类型。
        // 代码就变成了：System.out.println(a + &quot;200110&quot;);
        // 这个时候的+还是进行字符串的拼接。最终结果是：&quot;100200110&quot;
        System.out.println(a + (b + &quot;110&quot;));

        // 在控制台上输出&quot;100+200=300&quot;
        System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + c);

        在java语言中定义字符串类型的变量
        // String是字符串类型，并且String类型不属于基本数据类型范畴，属于引用类型。
        // name是变量名，只要是合法的标识符就行。
        // &quot;jack&quot; 是一个字符串型字面量。
        String name = &quot;jack&quot;;
        // 口诀：加一个双引号&quot;&quot;，然后双引号之间加两个加号：&quot;++&quot;，然后两个加号中间加变量名：&quot;+name+&quot;
        System.out.println(&quot;登录成功欢迎&quot;+name+&quot;回来&quot;);</code></pre>
<h3 id="8、控制语句："><a href="#8、控制语句：" class="headerlink" title="8、控制语句："></a>8、控制语句：</h3><p>选择结构<br>        - if,if..else<br>            if语句的语法结构以及运行原理<br>            if语句是分支语句，也可以叫做条件语句。<br>            if语句的语法格式：<br>                第一种写法：<br>                    int a = 100;<br>                    int b = 200;<br>                    if(布尔表达式){<br>                        java语句;<br>                        java语句;<br>                    }<br>                    这里的一个大括号{} 叫做一个分支。<br>                    if 这个单词翻译为如果，所以又叫做条件语句。<br>                    该语法的执行原理是：<br>                        如果布尔表达式的结果是true，则执行大括<br>                        号中的程序，否则大括号中代码不执行。</p>
<pre><code>            第二种写法：
                if(布尔表达式)&#123;  // 分支1
                    java语句;     
                &#125;else&#123;            // 分支2
                    java语句;
                &#125;
                执行原理：
                如果布尔表达式的结果是true，则执行分支1，分支2不执行。
                如果布尔表达式的结果是false， 分支1不执行，执行分支2.
                以上的这个语句可以保证一定会有一个分支执行。
                else表示其它。

            第三种写法：
                if(布尔表达式1)&#123; // 分支1
                    java语句;
                &#125;else if(布尔表达式2)&#123; // 分支2
                    java语句;
                &#125;else if(布尔表达式3)&#123;
                    java语句;
                &#125;else if(布尔表达式4)&#123;
                    java语句;
                &#125;....
                以上if语句的执行原理：
                    先判断“布尔表达式1”，如果“布尔表达式1”为true，则执行分支1，
                    然后if语句结束了。
                    当“布尔表达式1”结果是false，那么会继续判断布尔表达式2的结果，
                    如果布尔表达式2的结果是true，则执行分支2，然后整个if就结束了。

                    从上往下依次判断，主要看第一个true发生在哪个分支上。
                    第一个true对应的分支执行，只要一个分支执行，整个if结束。

            第四种写法：
                if(布尔表达式1)&#123; // 分支1
                    java语句;
                &#125;else if(布尔表达式2)&#123; // 分支2
                    java语句;
                &#125;else if(布尔表达式3)&#123;
                    java语句;
                &#125;else if(布尔表达式4)&#123;
                    java语句;
                &#125;else&#123;
                    java语句; // 以上条件没有一个成立的。这个else就执行了。
                &#125;</code></pre>
<p>?<br>            注意：<br>                1、对于if语句来说，在任何情况下只能有1个分支执行，不可能<br>                    存在2个或者更多个分支执行。if语句中只要有1个分支执行了，<br>                    整个if语句就结束了。（对于1个完整的if语句来说的。）</p>
<pre><code>            2、以上4种语法机制中，凡是带有else分支的，一定可以保证会有
            一个分支执行。以上4种当中，第一种和第三种没有else分支，这样
            的语句可能会导致最后一个分支都不执行。第二种和第四种肯定会有
            1个分支执行。

            3、当分支当中“java语句;”只有1条，那么大括号&#123;&#125;可以省略，但为了
            可读性，最好不要省略。

            4、控制语句和控制语句之间是可以嵌套的，但是嵌套的时候大家最好
            一个语句一个语句进行分析，不要冗杂在一起分析。
                if(true)&#123;
                    //窍门：分析外面if语句的时候，里面的这个if语句可以看做是普通的一堆java代码。
                    if(true)&#123;
                        if(false)&#123;

                        &#125;else&#123;
                            ....最终走这里了。
                        &#125;
                    &#125;else&#123;

                    &#125;
                &#125;else&#123;

                &#125;

                if()&#123;
                    // 窍门：分析外面if时，里面的for循环当做普通java代码来看。
                    for()&#123;
                        if()&#123;
                            for()&#123;

                            &#125;
                        &#125;
                    &#125;
                &#125;else&#123;
                    while()&#123;
                        if()&#123;
                            for()&#123;

                            &#125;
                        &#125;
                    &#125;
                &#125;

        示例1：
            业务要求：
                1、从键盘上接收一个人的年龄。
                2、年龄要求为[0-150]，其它值表示非法，需要提示非法信息。
                3、根据人的年龄来动态的判断这个人属于生命的哪个阶段？
                    [0-5] 婴幼儿
                    [6-10] 少儿
                    [11-18] 少年
                    [19-35] 青年
                    [36-55] 中年
                    [56-150] 老年
                4、请使用if语句完成以上的业务逻辑。

            String str = &quot;老年&quot;; // 字符串变量默认值是“老年”
            if(age &lt; 0 || age &gt; 150)&#123;
                System.out.println(&quot;对不起，年龄值不合法&quot;);
                //return;
            &#125; else if(age &lt;= 5)&#123;
                str = &quot;婴幼儿&quot;;
            &#125; else if(age &lt;= 10)&#123;
                str = &quot;少儿&quot;;
            &#125; else if(age &lt;= 18)&#123;
                str = &quot;少年&quot;;
            &#125; else if(age &lt;= 35)&#123;
                str = &quot;青年&quot;;
            &#125; else if(age &lt;= 55)&#123;
                str = &quot;中年&quot;;
            &#125; 
            System.out.println(str);

        示例2：
            业务要求：
                1、系统接收一个学生的考试成绩，根据考试成绩输出成绩的等级。

                2、等级：
                    优：[90~100]
                    良：[80~90) 
                    中：[70-80)
                    及格：[60~70)
                    不及格：[0-60)

                3、要求成绩是一个合法的数字，成绩必须在[0-100]之间，成绩可能带有小数。

            java.util.Scanner s = new java.util.Scanner(System.in);
            System.out.print(&quot;请输入您的考试成绩：&quot;);
            // 考试成绩带有小数
            double score = s.nextDouble();
            // 判断考试成绩
            String str = &quot;优&quot;;
            if(score &lt; 0 || score &gt; 100)&#123;
                str = &quot;成绩不合法!!!&quot;;
            &#125;else if(score &lt; 60)&#123;
                str = &quot;不及格&quot;;
            &#125;else if(score &lt; 70)&#123;
                str = &quot;及格&quot;;
            &#125;else if(score &lt; 80)&#123;
                str = &quot;中&quot;;
            &#125;else if(score &lt; 90)&#123;
                str = &quot;良&quot;;
            &#125;
            System.out.println(str);

    - switch
        switch语句：
            1、switch语句也是选择语句，也可以叫做分支语句。
            2、switch语句的语法格式

                switch(值)&#123;
                case 值1:
                    java语句;
                    java语句;...
                    break;
                case 值2:
                    java语句;
                    java语句;...
                    break;
                case 值3:
                    java语句;
                    java语句;...
                    break;
                default:
                    java语句;
                &#125;

                以上是一个完整的switch语句：
                    其中：break;语句不是必须的。default分支也不是必须的。

                switch语句支持的值:
                    支持int类型以及String类型。
                    但一定要注意JDK的版本，JDK8之前不支持String类型，只支持int。
                    在JDK8之后，switch语句开始支持字符串String类型。

                    switch语句本质上是只支持int和String，但是byte,short,char也可以
                    使用在switch语句当中，因为byte short char可以进行自动类型转换。

                    switch语句中“值”与“值1”、“值2”比较的时候会使用“==”进行比较。

            3、switch语句的执行原理
                拿“值”与“值1”进行比较，如果相同，则执行该分支中的java语句，
                然后遇到&quot;break;&quot;语句，switch语句就结束了。

                如果“值”与“值1”不相等，会继续拿“值”与“值2”进行比较，如果相同，
                则执行该分支中的java语句，然后遇到break;语句，switch结束。

                注意：如果分支执行了，但是分支最后没有“break;”，此时会发生case
                穿透现象。

                所有的case都没有匹配成功，那么最后default分支会执行。

                switch中的case可以合并。

            示例：
                1、系统接收一个学生的考试成绩，根据考试成绩输出成绩的等级。

                2、等级：
                    优：[90~100]
                    良：[80~90) 
                    中：[70-80)
                    及格：[60~70)
                    不及格：[0-60)

                3、要求成绩是一个合法的数字，成绩必须在[0-100]之间，成绩可能带有小数。

                必须使用switch语句来完成。

                // 提示用户输入学生成绩
                java.util.Scanner s = new java.util.Scanner(System.in);
                System.out.print(&quot;请输入学生成绩：&quot;);
                double score = s.nextDouble();
                //System.out.println(score);
                if(score &lt; 0 || score &gt; 100)&#123;
                    System.out.println(&quot;您输入的学生成绩不合法，再见！&quot;);
                    return; 
                &#125;

                // 程序能够执行到这里说明成绩一定是合法的。
                // grade的值可能是：0 1 2 3 4 5 6 7 8 9 10
                // 0 1 2 3 4 5 不及格
                // 6 及格
                // 7 中
                // 8 良
                // 9 10 优

                int grade = (int)(score / 10); // 95.5/10结果9.55，强转为int结果是9
                String str = &quot;不及格&quot;;
                switch(grade)&#123;
                case 10: case 9:
                    str = &quot;优&quot;;
                    break;
                case 8: 
                    str = &quot;良&quot;;
                    break;
                case 7:
                    str = &quot;中&quot;;
                    break;
                case 6:
                    str = &quot;及格&quot;;
                &#125;
                System.out.println(&quot;该学生的成绩等级为：&quot; + str);

* 循环结构（循环语句的出现就是为了解决代码的复用性）
    - for
        1、for循环的语法机制以及运行原理：
            语法机制：
                for(初始化表达式; 条件表达式; 更新表达式)&#123;
                    循环体; // 循环体由java语句构成
                    java语句;
                    java语句;
                    java语句;
                    java语句;
                    ....
                &#125;
                注意：
                    第一：初始化表达式最先执行，并且在整个循环中只执行一次。
                    第二：条件表达式结果必须是一个布尔类型，也就是：true或false
                执行原理：
                    先执行初始化表达式，并且初始化表达式只执行1次。
                    然后判断条件表达式的结果，如果条件表达式结果为true，
                    则执行循环体。
                    循环体结束之后，执行更新表达式。
                    更新完之后，再判断条件表达式的结果，
                    如果还是true，继续执行循环体。

                    直到更新表达式执行结束之后，再次判断条件时，条件为false，
                    for循环终止。

                更新表达式的作用是：控制循环的次数，换句话说，更新表达式会更新
                某个变量的值，这样条件表达式的结果才有可能从true变成false，从而
                终止for循环的执行，如果确实更新表达式，很有可能会导致死循环。

            2、嵌套使用：
                * 所有合法的“控制语句”都可以嵌套使用。
                * for循环嵌套一个for循环执行原理：
                        for()&#123;
                            //在分析外层for循环的时候，把里面的for就当做一段普通的java语句/代码.
                            for()&#123;&#125;
                        &#125;

            示例：
                九九乘法表

                1*1=1
                1*2=2 2*2=4
                1*3=3 2*3=6 3*3=9
                1*4=4 2*4=8 3*4=12 4*4=16
                ....
                ......
                1*9=9 2*9=18.............................9*9=81

                以上九九乘法表的特点：
                    第一个特点：共9行。
                    第二个特点：第1行1个。第2行2个。第n行n个。

                // 9行，循环9次。
                for(int i = 1; i &lt;= 9; i++)&#123; // 纵向循环
                    //System.out.println(i); // i是行号（1~9）
                    // 负责输出一行的。（内部for循环负责将一行上的全部输出。）
                    for(int j = 1; j &lt;= i; j++)&#123; // i是行号
                        System.out.print(j + &quot;*&quot; + i + &quot;=&quot; + i * j + &quot; &quot;);
                    &#125;
                    // 换行
                    System.out.println();
                &#125;

    - while
        1、while循环的语法机制以及执行原理
            语法机制：
                while(布尔表达式)&#123;
                    循环体;
                &#125;
            执行原理：
                判断布尔表达式的结果，如果为true就执行循环体，
                循环体结束之后，再次判断布尔表达式的结果，如果
                还是true，继续执行循环体，直到布尔表达式结果
                为false，while循环结束。

        2、while循环有没有可能循环次数为0次？（与do...while区分开）
            可能。
            while循环的循环次数是：0~n次。

    - do...while()
        do..while循环语句的执行原理以及语法机制：
        语法机制：
            do &#123;
                循环体;
            &#125;while(布尔表达式);

        注意：do..while循环最后的时候别漏掉“分号”

        执行原理：
            先执行循环体当中的代码，执行一次循环体之后，
            判断布尔表达式的结果，如果为true，则继续执行
            循环体，如果为false循环结束。

        对于do..while循环来说，循环体至少执行1次。循环体的执行次数是：1~n次。
        对于while循环来说，循环体执行次数是：0~n次。

* 控制循环的语句
    - break
        1、break;语句比较特殊，特殊在：break语句是一个单词成为一个完整的java语句。
        另外：continue也是这样，他俩都是一个单词成为一条语句。

        2、break 翻译为折断、弄断。

        3、break;语句可以用在哪里呢？
            用在两个地方，其它位置不行
            第一个位置：switch语句当中，用来终止switch语句的执行。
                用在switch语句当中，防止case穿透现象，用来终止switch。

            第二个位置：break;语句用在循环语句当中，用来终止循环的执行。
                用在for当中
                用在while当中
                用在do....while..当中。

        4、break;语句的执行并不会让整个方法结束，break;语句主要是用来终止离它最近
        的那个循环语句。

        5、怎么用break;语句终止指定的循环呢？（很少用）
            第一步：你需要给循环起一个名字，例如：
                a: for()&#123;
                    b:for()&#123;

                    &#125;
                &#125;
            第二步：终止：break a;

    - continue
        1、continue翻译为：继续
        2、continue语句和break语句要对比着学习
        3、continue语句的作用是：
            终止当前&quot;本次&quot;循环，直接进入下一次循环继续执行。
            for()&#123;
                if()&#123; // 当这个条件成立时，执行continue语句
                    continue; //当这个continue语句执行时，continue下面的代码不执行，直接进入下一次循环执行。
                &#125;
                // 以上的continue一旦执行，以下代码不执行，直接执行更新表达式。
                code1;
                code2;
                code3;
                code4;
            &#125;

        4、continue语句后面也可以指定循环
            a:for(;;更新表达式1)&#123;
                b:for(;;更新表达式2)&#123;
                    if()&#123;
                        continue a;
                    &#125;
                    code1;
                    code2;
                    code3;
                &#125;
            &#125;

    break;语句和return;语句的区别：
    不是一个级别。
    break;用来终止switch和离它最近的循环。
    return;用来终止离它最近的一个方法。</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xgh-user.github.io/2020/11/09/01%E5%85%B3%E4%BA%8Ejava/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="_little-star_">
      <meta itemprop="description" content="记录个人在平时学习的过程中的一些笔记、感受与遇到的坑,例如：java、计算机考研四件套等等。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="_little-star_">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/09/01%E5%85%B3%E4%BA%8Ejava/" class="post-title-link" itemprop="url">01关于java</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-09 03:04:16" itemprop="dateCreated datePublished" datetime="2020-11-09T03:04:16+08:00">2020-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-10 01:53:24" itemprop="dateModified" datetime="2020-11-10T01:53:24+08:00">2020-11-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javase/" itemprop="url" rel="index"><span itemprop="name">javase</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javase/%E5%85%B3%E4%BA%8Ejava/" itemprop="url" rel="index"><span itemprop="name">关于java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="需要掌握的内容："><a href="#需要掌握的内容：" class="headerlink" title="需要掌握的内容："></a>需要掌握的内容：</h3><ul>
<li>理解java的加载与执行</li>
<li>能够自己搭建java的开发环境</li>
<li>能够独立编写HelloWorld程序，编译并运行</li>
<li>掌握环境变量path的原理以及如何配置</li>
<li>掌握环境变量classpath的原理以及如何配置</li>
<li>java中的注释</li>
<li>public class 和 class 的区别</li>
</ul>
<h3 id="1、计算机结构："><a href="#1、计算机结构：" class="headerlink" title="1、计算机结构："></a>1、计算机结构：</h3><p>计算机包括：</p>
<ul>
<li>硬件<ul>
<li>CPU：中央处理器，负责计算机的核心运算，它是计算机的最核心部件，指挥官。 1 + 1 = 2</li>
<li>内存：临时存储区域，程序在运行的过程当中，一些数据的临时存储区域。</li>
<li>主板：链接各个部件</li>
<li>显卡</li>
<li>声卡</li>
<li>鼠标</li>
<li>键盘</li>
<li>硬盘【外存】：永久性保存，断电之后再启动，数据仍然存在。<br>…..</li>
</ul>
</li>
</ul>
<ul>
<li><p>软件</p>
<ul>
<li><p>系统软件</p>
<ul>
<li><p>windows系列的</p>
</li>
<li><p>winxp</p>
</li>
<li><p>win7<br>….</p>
</li>
<li><p>Linux系列的</p>
</li>
<li><p>Red Hat</p>
</li>
<li><p>Fedora</p>
</li>
<li><p>SUN Solaris<br>….</p>
</li>
</ul>
</li>
<li><p>应用软件</p>
<ul>
<li><p>QQ</p>
</li>
<li><p>百度云管家</p>
</li>
<li><p>Office办公软件</p>
</li>
</ul>
<p>…..</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>总结：</p>
<ul>
<li><p>应用软件是运行在系统软件当中的，系统软件和底层硬盘交互。</p>
</li>
<li><p>Java编程语言可以：完成应用软件的开发。</p>
</li>
<li><p>可以用一个功能比记事本强大的文本编辑器进行java程序的编写。</p>
</li>
<li><p>windows操作系统默认情况下是不显示文件扩展名的，作为程序员必须将文件的扩展名显示出来：</p>
<ul>
<li>计算机 –&gt; 组织 –&gt; 文件夹和搜索选项 –&gt; 查看 –&gt; 隐藏已知文件类型的扩展名【对勾去掉】           win7</li>
<li>计算机 –&gt; 查看 –&gt; 隐藏已知文件类型的扩展名【对勾去掉】                                        win10</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2、windows操作系统当中常用的DOS命令："><a href="#2、windows操作系统当中常用的DOS命令：" class="headerlink" title="2、windows操作系统当中常用的DOS命令："></a>2、windows操作系统当中常用的DOS命令：</h3><ul>
<li><p>什么是DOS命令呢？</p>
<p>在DOS命令窗口中才可以输入并执行DOS命令。<br>在最初的windows计算机中没有图形界面的，只有DOS命令窗口<br>也就是说通过执行DOS命令窗口可以完全完成文件的新建、编辑、保存、删除等一系列操作。</p>
</li>
<li><p>不使用UI界面，使用DOS命令可以完成所有的操作。</p>
</li>
<li><p>在DOS命令窗口中可以执行DOS命令</p>
</li>
<li><p>打开DOS命令窗口：</p>
<ul>
<li>快捷键：win + r，打开运行窗口</li>
<li>输入cmd回车</li>
</ul>
</li>
<li><p>查看IP地址：</p>
<ul>
<li>ipconfig</li>
<li>ipconfig /all  可以查看更详细的IP信息，这种查看方式可以看到网卡的物理地址。<br>物理地址具有全球唯一性。是在生产网卡的时候，嵌入的编号。</li>
</ul>
</li>
<li><p>清屏：cls</p>
</li>
<li><p>DOS窗口当中也可以设置字体和屏幕以及文字的颜色。</p>
</li>
<li><p>退出DOS命令窗口：exit</p>
</li>
<li><p>怎么从DOS命令窗口当中复制文本：<br>-任意位置点击鼠标右键–&gt;标记 –&gt; 选择你要复制的文本 –&gt; 点击鼠标右键 （此时已经到剪贴板当中了）<br> 找一个位置粘贴即可。<br>-左键选择你要复制的文本 –&gt; ctrl+c进行复制 （此时已经到剪贴板当中了）–&gt; x选择一个位置ctrl+v粘贴即可。</p>
</li>
<li><p>查看两台计算机之间是否可以正常通信：</p>
<ul>
<li>ping 192.168.27.23   【发送和接收数据包4次】</li>
<li>ping 192.168.27.23 -t 【一直不停的发送和接收数据包】</li>
<li>ping <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a></li>
</ul>
<ul>
<li>登录百度：<a target="_blank" rel="noopener" href="http://119.75.218.70/">http://119.75.218.70</a></li>
</ul>
</li>
<li><p>强行终止DOS命令窗口中正在运行的程序：ctrl + c</p>
</li>
<li><p>打开DOS命令窗口默认所在的路径是：C:\Users\Administrator???</p>
</li>
<li><p>创建目录：mkdir abc【表示在当前所在目录下新建一个目录，起名abc】</p>
</li>
<li><p>关于目录切换命令：cd</p>
<ul>
<li><p>cd 命令的语法格式：</p>
<p>cd 路径</p>
</li>
<li><p>路径分为：</p>
<ul>
<li><p>绝对路径：<br>C:\Users\Administrator<br>D:\用户目录\收藏夹<br>……</p>
<p>从硬盘的根路径作为出发点。</p>
</li>
<li><p>相对路径：<br>从当前所在的位置作为起点的路径。</p>
</li>
</ul>
</li>
<li><p>自动补全：<br>cd e 【然后按tab键，当前所在的目录下所有以e开始的目录自动补全路径，当这个自动补全的路径不是自己想要的路径，可以继续使用tab键】</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>回到上级目录：cd .. 【..是一个路径，代表当前路径的上级路径】<br>  cd ../../../</p>
</li>
<li><p>直接回到根路径：cd \</p>
</li>
</ul>
<ul>
<li><p>查看当前目录下所有的子文件和子目录：dir</p>
</li>
<li><p>del：<br>删除一个或者多个文件<br>删除T1.class文件<br>C:\Users\Administrator&gt;del T1.class<br>删除所有.class结尾的文件，支持模糊匹配<br>C:\Users\Administrator&gt;del *.class</p>
<p>T1.class<br>T1.glass<br>del *ass 这个命令就会将T1.class和T1.glass都删除。<br>删除的一定是能匹配上的。</p>
<p>del *.class 这个命令中的那个“.”不要特殊化，这个“.”其实就是一个普通的字母</p>
</li>
<li><p>不要把相关重要的资料放到桌面上，因为桌面是属于C盘系统盘。</p>
</li>
<li><p>怎么切换盘符：【不需要使用cd命令】<br>c: 回车<br>d: 回车<br>e: 回车<br>f: 回车</p>
</li>
<li><p>打开注册表：regedit</p>
</li>
</ul>
<h3 id="3、关于windows操作系统当中常用的快捷键："><a href="#3、关于windows操作系统当中常用的快捷键：" class="headerlink" title="3、关于windows操作系统当中常用的快捷键："></a>3、关于windows操作系统当中常用的快捷键：</h3><ul>
<li>win + r    打开运行窗口</li>
<li>win + d    显示桌面</li>
<li>win + e    打开资源管理器</li>
<li>win + L    锁屏</li>
<li>alt + tab    应用之间的切换</li>
</ul>
<h3 id="4、“通用的”文本编辑快捷键："><a href="#4、“通用的”文本编辑快捷键：" class="headerlink" title="4、“通用的”文本编辑快捷键："></a>4、“通用的”文本编辑快捷键：</h3><ul>
<li>ctrl + a    全选</li>
<li>ctrl + c    复制</li>
<li>ctrl + v    粘贴</li>
<li>ctrl + s    保存</li>
<li>ctrl + x    剪切</li>
<li>ctrl + z    撤销</li>
<li>ctrl + y    重做</li>
<li>tab          缩进/多行缩进</li>
<li>shift + tab    取消缩进</li>
<li>HOME        回到行首</li>
<li>END        回到行尾</li>
<li>shift + home    选中一行</li>
<li>shift + end    选中一行</li>
<li>ctrl + shift + 向右或者向左的箭头  选中一个单词</li>
<li>鼠标双击：    选中一个单词</li>
<li>鼠标三击：    选中一行</li>
<li>ctrl + end    回到文件末尾</li>
<li>ctrl + home    回到文件头</li>
</ul>
<h3 id="5、什么是JDK？"><a href="#5、什么是JDK？" class="headerlink" title="5、什么是JDK？"></a>5、什么是JDK？</h3><p>Java Development Kits<br>Java开发工具包【Java开发必备】<br>可以从Oracle的官网上下载。<a target="_blank" rel="noopener" href="http://www.oracle.com/">http://www.oracle.com</a><br>下载JDK的时候需要注意：JDK的版本，不同的操作系统需要安装不同版本的JDK。</p>
<h3 id="6、Java分三大块：1999年"><a href="#6、Java分三大块：1999年" class="headerlink" title="6、Java分三大块：1999年"></a>6、Java分三大块：1999年</h3><ul>
<li><p>J2SE【Java的标准版本】：</p>
<p>基础，无论是以后走EE还是ME，SE是必须要精通的。<br>J2SE是SUN公司为java程序员准备的一套“基础类库”，这套基础类库学习之后，可以完成最基本的操作，<br>例如，文件的读写、线程的控制….</p>
</li>
<li><p>J2EE【Java的企业版本】：</p>
<p>这是SUN公司为程序员专门准备的一套“类库”，这套类库可以协助程序员完成企业级软件的开发<br>企业级软件：OA办公系统、进销存系统、超市系统…….</p>
</li>
<li><p>J2ME【Java的微型版本】</p>
<p>这是SUN公司为java程序员专门准备的另一套“类库”，这套类库可以协助程序员完成微型设备的嵌入式开发，<br>Java最初就是做微型设备嵌入式开发的。</p>
</li>
<li><p>2005年，java诞生十周年的时候，以上的三大模块改名了：</p>
<ul>
<li>JavaSE</li>
<li>JavaEE</li>
<li>JavaME</li>
</ul>
</li>
</ul>
<h3 id="7、关键术语："><a href="#7、关键术语：" class="headerlink" title="7、关键术语："></a>7、关键术语：</h3><ul>
<li>JDK【Java开发工具箱】</li>
<li>JRE【Java的运行时环境】</li>
<li>JVM【Java虚拟机】</li>
</ul>
<p>三者之间的关系：</p>
<ul>
<li>JDK 中包含JRE</li>
<li>JRE中包含JVM</li>
</ul>
<h3 id="8、Java语言特性："><a href="#8、Java语言特性：" class="headerlink" title="8、Java语言特性："></a>8、Java语言特性：</h3><ul>
<li><p>跨平台/可移植 </p>
<ul>
<li>有一种特殊的机制：JVM</li>
</ul>
<ul>
<li>Java程序并没有和底层的操作系统直接交互，java程序实际上运行在jvm当中，JVM屏蔽了操作系统之间的差异。</li>
<li>但是有一个前提：不同的操作系统中必须安装不同版本的JVM。</li>
<li>在可移植性方面表现非常好，一次编译，到处运行。</li>
<li>但是为了达到可移植，必须提前在操作系统中安装JRE，JRE有了之后才会有JVM。【JVM不能单独安装】<br>这方面体验不是特别好。</li>
<li>java语言只要编写一次，可以做到到处运行。<br>例如：java程序编写完之后，可以运行在windows操作系统上，<br>不需要做任何改动可以直接运行在Linux操作系统上，同样也<br>可以运行到MaC OS上面。<br>一次编写，到处运行。（平台改变了，程序不需要改。）</li>
</ul>
</li>
<li><p>JVM这种机制实现了跨平台，那么这种机制优点和缺点分别是什么？</p>
<ul>
<li><p>优点：一次编写到处运行，可以跨平台。</p>
</li>
<li><p>缺点：麻烦。对于运行java程序来说必须先有一个JVM。<br>就像你要想在网页上看视频，你必须先安装一个flash是一样的。</p>
</li>
<li><p>Java语言可以编写病毒吗？</p>
<p>可以，没问题。但是很难让用户中毒。<br>中毒的一般都是java程序员。所以很少有人编写java的病毒脚本。</p>
</li>
</ul>
</li>
<li><p>Java号称：开源、免费、跨平台、纯面向对象。</p>
<ul>
<li><p>开源：开发源代码，SUN公司编写的java类库的源代码普通程序员能看到。众人拾柴火焰高。<br>这样java程序会很健壮。很少的BUG【漏洞/陷阱】</p>
</li>
<li><p>免费</p>
</li>
<li><p>跨平台：依靠JVM机制【java程序不和操作系统交互，java程序运行在JVM中，JVM和操作系统交互。】<br>不同的操作系统有不同版本的JVM。</p>
</li>
<li><p>面向对象：人类在认识现实世界的时候多数是以面向对象的方式认知的。</p>
</li>
</ul>
</li>
<li><p>简单性：</p>
<ul>
<li>这里的简单说的是相对于C语言来说的。</li>
<li>例如：C语言当中有指针，C++中多继承</li>
<li>java取消了指针的概念，取消了多继承，只支持单继承。<br>…..</li>
</ul>
</li>
<li><p>java支持多线程</p>
</li>
<li><p>java中还有一种特殊的机制：自动垃圾回收机制。GC机制。<br>【java运行过程当中有一个“垃圾回收器”一直在守护着。】</p>
</li>
</ul>
<h3 id="9、Java的加载与执行：一个完整的java程序"><a href="#9、Java的加载与执行：一个完整的java程序" class="headerlink" title="9、Java的加载与执行：一个完整的java程序"></a>9、Java的加载与执行：一个完整的java程序</h3><p>1、Java开发的整个生命周期，包括两个重要的阶段，分别是：编译阶段和运行阶段</p>
<p>2、编译生成的程序被称为：字节码程序。编译生成的文件是：xxx.class文件</p>
<p>3、编译和运行可以在不同的操作系统中完成。</p>
<p>4、程序员在xxx.java文件中编写源代码，源代码必须符合java的语法，这些源代码就是高级语言。<br>存放源代码的文件被称为源文件。</p>
<p>5、过程：</p>
<ul>
<li><p>编译期：【在windows环境中完成】</p>
<p>安装JDK，配置环境</p>
<p>在硬盘的某个位置创建一个xxx.java源文件</p>
<p>打开源文件，在该文件当中编写符合java语法的源程序，然后保存。</p>
<p>使用JDK中自带的javac.exe命令对以上的java源程序进行编译。</p>
<p>编译通过：说明语法没有问题</p>
<p>在硬盘上生成一个或者多个字节码文件【xxx.class】</p>
<p>编译失败：说明源程序某个位置不符合java语法格式。</p>
<p>编译的语法格式：打开DOS命令窗口，输入：javac 源文件路径</p>
</li>
<li><p>注意：</p>
<ul>
<li>源文件路径可以是绝对路径，也可以是相对路径。</li>
<li>编译之后，其实java源文件删除不会影响程序的执行。</li>
<li>最好不要将java源文件删除，因为程序最终运行效果不是预期效果的时候，需要重新修改java源代码，然后进行重新编译生成全新的class字节码文件，再重新运行字节码程序。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>运行期：【可以不在windows中完成，可以换一个操作系统，但前提是该操作系统中已经安装java的运行时环境】</p>
<ul>
<li>打开命令窗口，在命令窗口中使用java.exe命令运行java程序，语法格式：java 类名</li>
<li>注意：java这个命令使用的时候，java命令后面不是文件的路径。必须是一个“类名”。<ul>
<li>例如：<ul>
<li>java Hello</li>
<li>java Student</li>
<li>java User</li>
<li>java Product                </li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>以下程序的执行原理：<ul>
<li>java.exe命令执行会启动：JVM</li>
<li>JVM启动之后，马上启动“类加载器-Class Loader”</li>
<li>ClassLoader负责去硬盘的“某个位置”上搜索“类名.class”字节码文件。</li>
<li>找不到这个.class文件，一定会出现程序异常现象。</li>
<li>找到了这个.class文件之后将.class文件转换成”二进制”，操作系统可以直接识别二进制，<br>操作系统执行二进制码和底层的硬件平台进行交互。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="10、什么是类名？"><a href="#10、什么是类名？" class="headerlink" title="10、什么是类名？"></a>10、什么是类名？</h3><ul>
<li>假设硬盘上有一个文件，叫做Hello.class，那么类名就叫做：Hello</li>
<li>假设硬盘上有一个文件，叫做Student.class，那么类名就叫做：Student</li>
<li>假设硬盘上有一个文件，叫做User.class，那么类名就叫做：User</li>
<li>假设硬盘上有一个文件，叫做Product.class，那么类名就叫做：Product</li>
</ul>
<h3 id="11、开始第一个java程序的开发"><a href="#11、开始第一个java程序的开发" class="headerlink" title="11、开始第一个java程序的开发"></a>11、开始第一个java程序的开发</h3><p>1、JDK下载</p>
<p>2、JDK安装</p>
<ul>
<li>只安装了JDK，独立的JRE没有安装</li>
</ul>
<p>3、在硬盘的某个位置上新建一个java源文件：HelloWorld.java</p>
<p>4、在HelloWorld.java文件中编写源代码</p>
<p>5、打开命令窗口，使用javac命令进行编译：</p>
<ul>
<li><p>javac 源文件路径</p>
</li>
<li><p>出现以下错误：</p>
<p>C:\Users\Administrator&gt;javac<br>‘javac’ 不是内部或外部命令，也不是可运行的程序<br>或批处理文件。</p>
</li>
<li><p>怎么解决？</p>
<ul>
<li>第一种方案：切换到javac.exe文件所在的目录，这个时候使用javac.exe不会出问题，但是这种方式比较麻烦。</li>
<li>第二种方案：配置环境变量path</li>
</ul>
</li>
<li><p>原理：windows操作系统在查找某个命令的时候是怎么查找的？</p>
<ul>
<li>首先会从当前目录下找这个命令</li>
<li>当前目录下不存在这个命令的话，会去环境变量path指定的路径当中查找该命令。</li>
<li>还是找不到则出现错误提示信息。</li>
<li>path环境变量隶属于windows操作系统，和java无关，这个环境变量主要用来指定命令的搜索路径。</li>
</ul>
</li>
</ul>
<p>6、配置环境变量</p>
<ul>
<li><p>计算机 –&gt; 点击右键 –&gt; 属性 –&gt; 高级系统设置 –&gt; 环境变量</p>
</li>
<li><p>环境变量配置包括用户级别和系统级别</p>
</li>
<li><p>任何一个环境变量都有变量名和变量值，例如path环境变量：<br>变量名是:path值：路径【多个路径之间必须采用分号隔开，而且要求分号必须是半角分号】</p>
<p>path=C:\Program Files (x86)\Java\jdk1.7.0_75\bin;otherpath;otherpath…..</p>
</li>
</ul>
<p>编译1【绝对路径】：D:\course\JavaProjects&gt;javac D:\course\JavaProjects\02-JavaSE\day01\HelloWorld.java<br>编译2【相对路径】：D:\course\JavaProjects&gt;javac 02-JavaSE\day01\HelloWorld.java<br>编译3【相对路径】：D:\course\JavaProjects\02-JavaSE\day01&gt;javac HelloWorld.java</p>
<p>7、运行：</p>
<ul>
<li><p>必须将路径切换到“D:\course\JavaProjects\02-JavaSE\day01”目录下</p>
</li>
<li><p>执行：java HelloWorld</p>
</li>
<li><p>D:\course\JavaProjects\02-JavaSE\day01&gt;java HelloWorld<br>Hello World!</p>
</li>
</ul>
<h3 id="12、JDK、JRE、JVM三者之间的关系？"><a href="#12、JDK、JRE、JVM三者之间的关系？" class="headerlink" title="12、JDK、JRE、JVM三者之间的关系？"></a>12、JDK、JRE、JVM三者之间的关系？</h3><ul>
<li>JDK:Java开发工具箱</li>
<li>JRE:java运行环境</li>
<li>JVM:java虚拟机</li>
</ul>
<p>JDK包括JRE，JRE包括JVM。</p>
<p>JVM是不能独立安装的。</p>
<p>JRE和JDK都是可以独立安装的。</p>
<p>有单独的JDK安装包。</p>
<p>也有单独的JRE安装包。</p>
<p>没有单独的JVM安装包。</p>
<p>安装JDK的时候：JRE就自动安装了，同时JRE内部的JVM也就自动安装了。</p>
<p>安装JRE的时候：JVM也就自动安装了。</p>
<h3 id="13、java程序从开发到最终运行经历了什么？"><a href="#13、java程序从开发到最终运行经历了什么？" class="headerlink" title="13、java程序从开发到最终运行经历了什么？"></a>13、java程序从开发到最终运行经历了什么？</h3><ul>
<li><p>编译期：（可以在windows上）</p>
<ul>
<li>第一步：在硬盘的某个位置（随意），新建一个xxx.java文件</li>
<li>第二步：使用记事本或者其它文本编辑器例如EditPlus打开xxx.java文件</li>
<li>第三步：在xxx.java文件中编写“符合java语法规则的”源代码。</li>
<li>第四步：保存（一定要将xxx.java文件保存一下）</li>
<li>第五步：使用编译器（javac【JDK安装后自带】）对xxx.java文件进行编译。</li>
<li>第六步：如果xxx.java文件中编写的源代码是符合语法规则的，编译会通过，如果xxx.java文件中编写的源代码违背了语法规则，那么编译器会报错，编译器报错之后class文件是不会生成的，只有编译通过了才会生成class字节码文件。并且一个java源文件是可以生成多个class文件的。（编译实质上是检查语法）</li>
</ul>
</li>
<li><p>运行期（JRE在起作用）：（可以在windows上，也可以在其他的OS上。）</p>
<ul>
<li>第七步：如果是在Linux上运行，需要将windows上生成的class文件拷贝过去不需要拷贝源代码，真正运行的是字节码。（但是源代码也不要删除，有用）</li>
<li>第八步：使用JDK自带的一个命令/工具：java（负责运行的命令/工具）执行字节码</li>
<li>第九步：往下的步骤就全部交给JVM了，就不需要程序员干涉了。<br>JVM会将字节码文件装载进去，然后JVM对字节码进行解释（解释器负责将字节码解释为1010101010..等的二进制）</li>
<li>第十步：JVM会将生成的二进制码交给OS操作系统，操作系统会执行二进制码和硬件进行交互。</li>
</ul>
</li>
<li><p>注意：在以上的过程中，需要使用两个非常重要的命令？</p>
<ul>
<li>javac 命令，负责编译</li>
<li>java 命令，负责运行</li>
</ul>
</li>
<li><p>以上是一个复杂的过程，那么缩减一下，程序员到底要干啥？（编写、编译、运行）</p>
<ul>
<li>新建java文件</li>
<li>打开java文件</li>
<li>写java源代码</li>
<li>保存</li>
<li>javac命令编译</li>
<li>java命令运行</li>
</ul>
</li>
</ul>
<h3 id="14、注释"><a href="#14、注释" class="headerlink" title="14、注释"></a>14、注释</h3><p>1、注释是对java源代码的解释说明。</p>
<p>注释可以帮程序员更好的理解程序。</p>
<p>2、注释信息只保存在java源文件当中，java源文件编译生成的字节码class文件，class文件中是没有这些注释信息的。</p>
<p>3、在实际的开发中，一般项目组都要求积极的编写注释。这也是一个java软件工程师的基本素养。</p>
<p>4、注释不是写的越多越好，精简，主线清晰，每个注释都应该是点睛之笔。</p>
<p>5、注释方法（3种）：</p>
<ul>
<li><p>单行注释<br>  // 这种注释属于单行注释，只注释两个斜杠后面的</p>
</li>
<li><p>多行注释<br>/*<br>在这里可以编写多行注释<br>这是第一行注释<br>这是第二行注释<br>这是第三行注释<br>…….<br>*/</p>
</li>
<li><p>javadoc注释<br>/**</p>
<p>   *javadoc注释</p>
<p>  *javadoc注释</p>
<p>  *javadoc注释</p>
<p>  *javadoc注释</p>
<p>  *javadoc注释<br>*/<br>注意：这种注释是比较专业的注释，该注释信息会被javadoc.exe工具解析提取并生成帮助文档。</p>
</li>
</ul>
<h3 id="15、HelloWorld程序的执行原理"><a href="#15、HelloWorld程序的执行原理" class="headerlink" title="15、HelloWorld程序的执行原理"></a>15、HelloWorld程序的执行原理</h3><ol>
<li>java.exe命令会启动JVM</li>
<li>JVM启动之后会启动类加载器ClassLoader</li>
<li>ClassLoader会在硬盘上的某个位置搜索HelloWorld.class字节码文件</li>
<li>找到该文件则执行</li>
<li>找不到该文件则报错</li>
</ol>
<p>ClassLoader是在哪个位置上搜索HelloWorld.class字节码文件的？</p>
<p>默认情况下，ClassLoader从当前路径下加载xxx.class字节码文件</p>
<p>当然，也可以让ClassLoader去某个指定的路径下加载字节码文件，这时需要配置环境变量classpath</p>
<p>classpath环境变量属于java语言中的环境变量，不属于windows操作系统【PATH环境变量属于操作系统】</p>
<p>classpath是给ClassLoader类加载器指路的。</p>
<p>设置这样的环境变量：classpath=D:\course\JavaProjects\02-JavaSE\day02</p>
<p>打开dos命令窗口在任意位置，都可以执行：java HelloWorld</p>
<p>classpath环境变量没有配置的话，类加载器默认从当前路径下找字节码文件，<br>当classpath环境变量配置为某个指定的路径之后，类加载器只去指定的路径当中加载字节码文件。</p>
<p>综上所述，环境变量classpath不再配置，这样类加载器会自动从当前路径下加载class字节码文件。<br>所以，每一次执行.class程序的时候，需要在DOS命令窗口中先切换到.class字节码文件所在的路径下。<br>然后运行。</p>
<p>当然，classpath也可以这样配置：classpath=.</p>
<p>注意：</p>
<ul>
<li>路径中“..”表示上级目录</li>
<li>路径中“.”表示当前目录</li>
</ul>
<p>对HelloWorld程序进行解释：<br>需要记忆：</p>
<ul>
<li>public</li>
<li>class</li>
<li>static</li>
<li>void</li>
<li>System.out.println(“”); 向控制台输出消息</li>
<li>类体</li>
<li>方法体</li>
<li>类体中不能直接编写java语句【除声明变量之外】</li>
<li>一个java语句必须以“;”结束</li>
<li>方法体中可以编写多条java语句</li>
<li>主方法是程序的入口，固定写法，SUN规定的。</li>
</ul>
<h3 id="16、关于java代码的编写"><a href="#16、关于java代码的编写" class="headerlink" title="16、关于java代码的编写"></a>16、关于java代码的编写</h3><p>在java中任何有效的代码必须写到“类体”当中，最外层必须是一个类的定义。</p>
<p>public表示公开的，class表示定义一个类，Test是一个类名。类名后面必须是一对大括号，这一对大括号被称为“类体”</p>
<p>括号和引号必须是成对的。并且建议都要成对编写，这样才不会丢掉。</p>
<p>代码缩进:</p>
<ul>
<li>我包着你，你就比我低一级。你就需要缩进。</li>
<li>没有合理的缩进，代码可读性很差。</li>
<li>或者也可以这样说，大括号里的都需要缩进。</li>
<li>缩进就是可读性问题，不缩进也不影响程序的编译和执行。</li>
</ul>
<p>类体/public static void main(String[] args){}:</p>
<ul>
<li>程序的入口，SUN公司java语言规定的</li>
<li>也就是说：JVM在执行程序的时候，会主动去找这样一个方法。没有这个规格的方法，程序是无法执行的。</li>
<li>main方法也可以叫做主方法。</li>
<li>注意：<ul>
<li>方法必须放到“类体”中，不能放到“类体”外面。</li>
<li>类体当中应该是方法，而不是直接的java语句。</li>
<li>任何一个程序都要有一个入口，没有入口进不来，无法执行。</li>
<li>程序的入口只有一个，若有一个一模一样的入口，编译器会报错。</li>
<li>一个程序如果没有入口但是没有语法错误的话，编译器不会报错，但运行会报错。</li>
</ul>
</li>
</ul>
<p>方法体/System.out.println():<br>    - 注意：<br>     - 方法体由一行一行的“java语句”构成<br>    - 并且非常重要的是：任何一条java语句必须以“;”结尾，并且这个分号还得是英文的，不能用中文分号。<br>    - “;” 代表一条语句的结束。<br>    - 非常非常重要的是：方法体中的代码遵循自上而下的顺序依次逐行执行。<br>    - System.out.println();这行代码的作用是向控制台输出一句话。就是这个作用。<br>    - 注意：如果println后面小括号里的内容是一个“字符串”的话，必须使用英文双引号括起来。<br>    - 双引号也要成对儿写。</p>
<p>注意的小点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个不加双引号行吗？</span></span><br><span class="line"><span class="comment">// 可以，因为它是数字。</span></span><br><span class="line">System.out.println(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是数字，加双引号行吗？</span></span><br><span class="line">System.out.println(<span class="string">&quot;100&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上性质一样吗？</span></span><br><span class="line"><span class="comment">// 不一样：一个是字符串，一个是数字。</span></span><br><span class="line"><span class="comment">// 但最终输出到控制台上一个样子，没啥区别。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里扩展一下：对于数字来说能进行加减乘除吗？</span></span><br><span class="line"><span class="comment">// + 能用吗？</span></span><br><span class="line"><span class="comment">// - 能用吗？</span></span><br><span class="line"><span class="comment">// / 能用吗？</span></span><br><span class="line"><span class="comment">// * 能用吗？</span></span><br><span class="line"><span class="comment">// 可以</span></span><br><span class="line">System.out.println(<span class="number">100</span> + <span class="number">200</span>); <span class="comment">// 300</span></span><br><span class="line">System.out.println(<span class="number">200</span> - <span class="number">100</span>); <span class="comment">// 100</span></span><br><span class="line">System.out.println(<span class="number">200</span> * <span class="number">100</span>); <span class="comment">// 20000</span></span><br><span class="line">System.out.println(<span class="number">200</span> / <span class="number">100</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>



<h3 id="17、public-class-和-class的区别："><a href="#17、public-class-和-class的区别：" class="headerlink" title="17、public class 和 class的区别："></a>17、public class 和 class的区别：</h3><ul>
<li><p>一个java源文件当中可以定义多个class</p>
</li>
<li><p>一个java源文件当中public的class不是必须的</p>
</li>
<li><p>一个class会定义生成一个xxx.class字节码文件</p>
</li>
<li><p>一个java源文件当中定义公开的类的话，只能有一个，并且该类名称必须和java源文件名称一致。</p>
</li>
<li><p>每一个class当中都可以编写main方法，都可以设定程序的入口，想执行B.class中的main方法：java B，<br>想执行X.class当中的main方法：java X</p>
</li>
<li><p>注意：</p>
</li>
<li><p>当在命令窗口中执行java Hello，那么要求Hello.class当中必须有主方法。没有主方法会出现运行<br>阶段的错误：</p>
<p>D:\course\JavaProjects\02-JavaSE\day02&gt;java Hello<br>错误: 在类 B 中找不到主方法, 请将主方法定义为:<br>public static void main(String[] args)</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">_little-star_</p>
  <div class="site-description" itemprop="description">记录个人在平时学习的过程中的一些笔记、感受与遇到的坑,例如：java、计算机考研四件套等等。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">_little-star_</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
